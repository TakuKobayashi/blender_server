
#ifndef __RNA_BLENDER_CPP_H__
#define __RNA_BLENDER_CPP_H__

/* Automatically generated classes for the Data API.
 * Do not edit manually, changes will be overwritten. */

#include "RNA_blender.h"
#include "RNA_types.h"
#include "RNA_access.h"

#include <stdlib.h> /* for malloc */
#include <string>
#include <string.h> /* for memcpy */

namespace BL {

#define BOOLEAN_PROPERTY(sname, identifier) \
    inline bool sname::identifier(void) { return sname##_##identifier##_get(&ptr) ? true: false; } \
    inline void sname::identifier(bool value) { sname##_##identifier##_set(&ptr, value); }

#define BOOLEAN_ARRAY_PROPERTY(sname, size, identifier) \
    inline Array<bool, size> sname::identifier(void) \
        { Array<bool, size> ar; sname##_##identifier##_get(&ptr, ar.data); return ar; } \
    inline void sname::identifier(bool values[size]) \
        { sname##_##identifier##_set(&ptr, values); } \

#define BOOLEAN_DYNAMIC_ARRAY_PROPERTY(sname, identifier) \
    inline DynamicArray<bool> sname::identifier(void) { \
        int arraylen[3]; \
        int len = sname##_##identifier##_get_length(&ptr, arraylen); \
        DynamicArray<bool> ar(len); \
        sname##_##identifier##_get(&ptr, ar.data); \
        return ar; } \
    inline void sname::identifier(bool values[]) \
        { sname##_##identifier##_set(&ptr, values); } \

#define INT_PROPERTY(sname, identifier) \
    inline int sname::identifier(void) { return sname##_##identifier##_get(&ptr); } \
    inline void sname::identifier(int value) { sname##_##identifier##_set(&ptr, value); }

#define INT_ARRAY_PROPERTY(sname, size, identifier) \
    inline Array<int, size> sname::identifier(void) \
        { Array<int, size> ar; sname##_##identifier##_get(&ptr, ar.data); return ar; } \
    inline void sname::identifier(int values[size]) \
        { sname##_##identifier##_set(&ptr, values); } \

#define INT_DYNAMIC_ARRAY_PROPERTY(sname, identifier) \
    inline DynamicArray<int> sname::identifier(void) { \
        int arraylen[3]; \
        int len = sname##_##identifier##_get_length(&ptr, arraylen); \
        DynamicArray<int> ar(len); \
        sname##_##identifier##_get(&ptr, ar.data); \
        return ar; } \
    inline void sname::identifier(int values[]) \
        { sname##_##identifier##_set(&ptr, values); } \

#define FLOAT_PROPERTY(sname, identifier) \
    inline float sname::identifier(void) { return sname##_##identifier##_get(&ptr); } \
    inline void sname::identifier(float value) { sname##_##identifier##_set(&ptr, value); }

#define FLOAT_ARRAY_PROPERTY(sname, size, identifier) \
    inline Array<float, size> sname::identifier(void) \
        { Array<float, size> ar; sname##_##identifier##_get(&ptr, ar.data); return ar; } \
    inline void sname::identifier(float values[size]) \
        { sname##_##identifier##_set(&ptr, values); } \

#define FLOAT_DYNAMIC_ARRAY_PROPERTY(sname, identifier) \
    inline DynamicArray<float> sname::identifier(void) { \
        int arraylen[3]; \
        int len = sname##_##identifier##_get_length(&ptr, arraylen); \
        DynamicArray<float> ar(len); \
        sname##_##identifier##_get(&ptr, ar.data); \
        return ar; } \
    inline void sname::identifier(float values[]) \
        { sname##_##identifier##_set(&ptr, values); } \

#define ENUM_PROPERTY(type, sname, identifier) \
    inline sname::type sname::identifier(void) { return (type)sname##_##identifier##_get(&ptr); } \
    inline void sname::identifier(sname::type value) { sname##_##identifier##_set(&ptr, value); }

#define STRING_PROPERTY(sname, identifier) \
    inline std::string sname::identifier(void) { \
        int len = sname##_##identifier##_length(&ptr); \
        std::string str; str.resize(len); \
        sname##_##identifier##_get(&ptr, &str[0]); return str; } \
    inline void sname::identifier(const std::string& value) { \
        sname##_##identifier##_set(&ptr, value.c_str()); } \

#define POINTER_PROPERTY(type, sname, identifier) \
    inline type sname::identifier(void) { return type(sname##_##identifier##_get(&ptr)); }

#define COLLECTION_PROPERTY_LENGTH_false(sname, identifier) \
    inline static int sname##_##identifier##_length_wrap(PointerRNA *ptr) \
    { \
        CollectionPropertyIterator iter; \
        int length = 0; \
        sname##_##identifier##_begin(&iter, ptr); \
        while (iter.valid) { \
            sname##_##identifier##_next(&iter); \
            ++length; \
        } \
        sname##_##identifier##_end(&iter); \
        return length; \
    } 
#define COLLECTION_PROPERTY_LENGTH_true(sname, identifier) \
    inline static int sname##_##identifier##_length_wrap(PointerRNA *ptr) \
    { return sname##_##identifier##_length(ptr); } 

#define COLLECTION_PROPERTY_LOOKUP_INT_false(sname, identifier) \
    inline static int sname##_##identifier##_lookup_int_wrap(PointerRNA *ptr, int key, PointerRNA *r_ptr) \
    { \
        CollectionPropertyIterator iter; \
        int i = 0, found = 0; \
        sname##_##identifier##_begin(&iter, ptr); \
        while (iter.valid) { \
            if (i == key) { \
                *r_ptr = iter.ptr; \
                found = 1; \
                break; \
            } \
            sname##_##identifier##_next(&iter); \
            ++i; \
        } \
        sname##_##identifier##_end(&iter); \
        if (!found) \
            memset(r_ptr, 0, sizeof(*r_ptr)); \
        return found; \
    } 
#define COLLECTION_PROPERTY_LOOKUP_INT_true(sname, identifier) \
    inline static int sname##_##identifier##_lookup_int_wrap(PointerRNA *ptr, int key, PointerRNA *r_ptr) \
    { \
        int found = sname##_##identifier##_lookup_int(ptr, key, r_ptr); \
        if (!found) \
            memset(r_ptr, 0, sizeof(*r_ptr)); \
        return found; \
    } 
#define COLLECTION_PROPERTY_LOOKUP_STRING_false(sname, identifier) \
    inline static int sname##_##identifier##_lookup_string_wrap(PointerRNA *ptr, const char *key, PointerRNA *r_ptr) \
    { \
        CollectionPropertyIterator iter; \
        int found = 0; \
        PropertyRNA *item_name_prop = RNA_struct_name_property(ptr->type); \
        sname##_##identifier##_begin(&iter, ptr); \
        while (iter.valid && !found) { \
            char name_fixed[32]; \
            const char *name; \
            int name_length; \
            name = RNA_property_string_get_alloc(&iter.ptr, item_name_prop, name_fixed, sizeof(name_fixed), &name_length); \
            if (!strncmp(name, key, name_length)) { \
                *r_ptr = iter.ptr; \
                found = 1; \
            } \
            if (name_fixed != name) \
                MEM_freeN((void *) name); \
            sname##_##identifier##_next(&iter); \
        } \
        sname##_##identifier##_end(&iter); \
        if (!found) \
            memset(r_ptr, 0, sizeof(*r_ptr)); \
        return found; \
    } 
#define COLLECTION_PROPERTY_LOOKUP_STRING_true(sname, identifier) \
    inline static int sname##_##identifier##_lookup_string_wrap(PointerRNA *ptr, const char *key, PointerRNA *r_ptr) \
    { \
        int found = sname##_##identifier##_lookup_string(ptr, key, r_ptr); \
        if (!found) \
            memset(r_ptr, 0, sizeof(*r_ptr)); \
        return found; \
    } 
#define COLLECTION_PROPERTY(collection_funcs, type, sname, identifier, has_length, has_lookup_int, has_lookup_string) \
    typedef CollectionIterator<type, sname##_##identifier##_begin, \
        sname##_##identifier##_next, sname##_##identifier##_end> identifier##_iterator; \
    COLLECTION_PROPERTY_LENGTH_##has_length(sname, identifier) \
    COLLECTION_PROPERTY_LOOKUP_INT_##has_lookup_int(sname, identifier) \
    COLLECTION_PROPERTY_LOOKUP_STRING_##has_lookup_string(sname, identifier) \
    CollectionRef<sname, type, sname##_##identifier##_begin, \
        sname##_##identifier##_next, sname##_##identifier##_end, \
        sname##_##identifier##_length_wrap, \
        sname##_##identifier##_lookup_int_wrap, sname##_##identifier##_lookup_string_wrap, collection_funcs> identifier;

class Pointer {
public:
    Pointer(const PointerRNA &p) : ptr(p) { }
    operator const PointerRNA&() { return ptr; }
    bool is_a(StructRNA *type) { return RNA_struct_is_a(ptr.type, type) ? true: false; }
    operator void*() { return ptr.data; }
    operator bool() { return ptr.data != NULL; }

    bool operator==(const Pointer &other) { return ptr.data == other.ptr.data; }
    bool operator!=(const Pointer &other) { return ptr.data != other.ptr.data; }

    PointerRNA ptr;
};


template<typename T, int Tsize>
class Array {
public:
    T data[Tsize];

    Array() {}
    Array(const Array<T, Tsize>& other) { memcpy(data, other.data, sizeof(T) * Tsize); }
    const Array<T, Tsize>& operator = (const Array<T, Tsize>& other) { memcpy(data, other.data, sizeof(T) * Tsize); return *this; }

    operator T*() { return data; }
    operator const T*() const { return data; }
};

template<typename T>
class DynamicArray {
public:
    T *data;
    int length;

    DynamicArray() : data(NULL), length(0) {}
    DynamicArray(int new_length) : data(NULL), length(new_length) { data = (T *)malloc(sizeof(T) * new_length); }
    DynamicArray(const DynamicArray<T>& other) { copy_from(other); }
    const DynamicArray<T>& operator = (const DynamicArray<T>& other) { copy_from(other); return *this; }

    ~DynamicArray() { if (data) free(data); }

    operator T*() { return data; }

protected:
    void copy_from(const DynamicArray<T>& other) {
        if (data) free(data);
        data = (T *)malloc(sizeof(T) * other.length);
        memcpy(data, other.data, sizeof(T) * other.length);
        length = other.length;
    }
};

typedef void (*TBeginFunc)(CollectionPropertyIterator *iter, PointerRNA *ptr);
typedef void (*TNextFunc)(CollectionPropertyIterator *iter);
typedef void (*TEndFunc)(CollectionPropertyIterator *iter);
typedef int (*TLengthFunc)(PointerRNA *ptr);
typedef int (*TLookupIntFunc)(PointerRNA *ptr, int key, PointerRNA *r_ptr);
typedef int (*TLookupStringFunc)(PointerRNA *ptr, const char *key, PointerRNA *r_ptr);

template<typename T, TBeginFunc Tbegin, TNextFunc Tnext, TEndFunc Tend>
class CollectionIterator {
public:
    CollectionIterator() : iter(), t(iter.ptr), init(false) { iter.valid = false; }
    ~CollectionIterator(void) { if (init) Tend(&iter); };

    operator bool(void)
    { return iter.valid != 0; }
    const CollectionIterator<T, Tbegin, Tnext, Tend>& operator++() { Tnext(&iter); t = T(iter.ptr); return *this; }

    T& operator*(void) { return t; }
    T* operator->(void) { return &t; }
    bool operator == (const CollectionIterator<T, Tbegin, Tnext, Tend>& other) { return iter.valid == other.iter.valid; }
    bool operator!=(const CollectionIterator<T, Tbegin, Tnext, Tend>& other) { return iter.valid != other.iter.valid; }

    void begin(const Pointer &ptr)
    { if (init) Tend(&iter); Tbegin(&iter, (PointerRNA *)&ptr.ptr); t = T(iter.ptr); init = true; }

private:
    const CollectionIterator<T, Tbegin, Tnext, Tend>& operator = (const CollectionIterator<T, Tbegin, Tnext, Tend>& /*copy*/) {}
    CollectionPropertyIterator iter;
    T t;
    bool init;
};

template<typename Tp, typename T, TBeginFunc Tbegin, TNextFunc Tnext, TEndFunc Tend,
         TLengthFunc Tlength, TLookupIntFunc Tlookup_int, TLookupStringFunc Tlookup_string,
         typename Tcollection_funcs>
class CollectionRef : public Tcollection_funcs {
public:
    CollectionRef(const PointerRNA &p) : Tcollection_funcs(p), ptr(p) {}

    void begin(CollectionIterator<T, Tbegin, Tnext, Tend>& iter)
    { iter.begin(ptr); }
    CollectionIterator<T, Tbegin, Tnext, Tend> end()
    { return CollectionIterator<T, Tbegin, Tnext, Tend>(); } /* test */ 
    int length()
    { return Tlength(&ptr); }
    T operator[](int key)
    { PointerRNA r_ptr; Tlookup_int(&ptr, key, &r_ptr); return T(r_ptr); }
    T operator[](const std::string &key)
    { PointerRNA r_ptr; Tlookup_string(&ptr, key.c_str(), &r_ptr); return T(r_ptr); }

private:
    PointerRNA ptr;
};

class DefaultCollectionFunctions {
public:
    DefaultCollectionFunctions(const PointerRNA & /*p*/) {}
};


/**************** Declarations ****************/

class Struct;
class Property;
class BoolProperty;
class IntProperty;
class FloatProperty;
class StringProperty;
class EnumProperty;
class EnumPropertyItem;
class PointerProperty;
class CollectionProperty;
class Function;
class BlenderRNA;
class UnknownType;
class AnyType;
class ID;
class IDOverrideStatic;
class IDOverrideStaticProperty;
class IDOverrideStaticPropertyOperation;
class ImagePreview;
class PropertyGroupItem;
class PropertyGroup;
class IDMaterials;
class Library;
class IDPropertyWrapPtr;
class Texture;
class CloudsTexture;
class WoodTexture;
class MarbleTexture;
class MagicTexture;
class BlendTexture;
class StucciTexture;
class NoiseTexture;
class ImageTexture;
class MusgraveTexture;
class VoronoiTexture;
class DistortedNoiseTexture;
class TextureSlot;
class TexMapping;
class ColorMapping;
class Action;
class ActionFCurves;
class ActionGroups;
class ActionPoseMarkers;
class ActionGroup;
class DopeSheet;
class AnimData;
class NlaTracks;
class AnimDataDrivers;
class KeyingSet;
class KeyingSetPaths;
class KeyingSetPath;
class KeyingSetInfo;
class AnimViz;
class AnimVizMotionPaths;
class MotionPath;
class MotionPathVert;
class Armature;
class ArmatureBones;
class ArmatureEditBones;
class Bone;
class EditBone;
class BoidRule;
class BoidRuleGoal;
class BoidRuleAvoid;
class BoidRuleAvoidCollision;
class BoidRuleFollowLeader;
class BoidRuleAverageSpeed;
class BoidRuleFight;
class BoidState;
class BoidSettings;
class Brush;
class BrushCapabilities;
class BrushCapabilitiesSculpt;
class BrushCapabilitiesImagePaint;
class BrushCapabilitiesVertexPaint;
class BrushCapabilitiesWeightPaint;
class BrushGpencilSettings;
class BrushTextureSlot;
class OperatorStrokeElement;
class CacheFile;
class AlembicObjectPaths;
class AlembicObjectPath;
class Camera;
class CameraBackgroundImage;
class CameraBackgroundImages;
class CameraStereoData;
class ClothSolverResult;
class ClothSettings;
class ClothCollisionSettings;
class Collection;
class CollectionObjects;
class CollectionChildren;
class CurveMapPoint;
class CurveMap;
class CurveMapPoints;
class CurveMapping;
class ColorRampElement;
class ColorRamp;
class ColorRampElements;
class Histogram;
class Scopes;
class ColorManagedDisplaySettings;
class ColorManagedViewSettings;
class ColorManagedInputColorspaceSettings;
class ColorManagedSequencerColorspaceSettings;
class Constraint;
class ConstraintTarget;
class ConstraintTargetBone;
class ChildOfConstraint;
class PythonConstraint;
class ArmatureConstraint;
class ArmatureConstraintTargets;
class StretchToConstraint;
class FollowPathConstraint;
class LockedTrackConstraint;
class ActionConstraint;
class CopyScaleConstraint;
class MaintainVolumeConstraint;
class CopyLocationConstraint;
class CopyRotationConstraint;
class CopyTransformsConstraint;
class FloorConstraint;
class TrackToConstraint;
class KinematicConstraint;
class ClampToConstraint;
class LimitDistanceConstraint;
class LimitScaleConstraint;
class LimitRotationConstraint;
class LimitLocationConstraint;
class TransformConstraint;
class ShrinkwrapConstraint;
class DampedTrackConstraint;
class SplineIKConstraint;
class PivotConstraint;
class FollowTrackConstraint;
class CameraSolverConstraint;
class ObjectSolverConstraint;
class TransformCacheConstraint;
class Context;
class Curve;
class CurveSplines;
class SurfaceCurve;
class TextCurve;
class TextBox;
class TextCharacterFormat;
class SplinePoint;
class BezierSplinePoint;
class Spline;
class SplinePoints;
class SplineBezierPoints;
class DynamicPaintCanvasSettings;
class DynamicPaintSurfaces;
class DynamicPaintBrushSettings;
class DynamicPaintSurface;
class FCurve;
class FCurveKeyframePoints;
class FCurveModifiers;
class Keyframe;
class FCurveSample;
class DriverTarget;
class DriverVariable;
class Driver;
class ChannelDriverVariables;
class FModifier;
class FModifierGenerator;
class FModifierFunctionGenerator;
class FModifierEnvelope;
class FModifierEnvelopeControlPoints;
class FModifierEnvelopeControlPoint;
class FModifierCycles;
class FModifierPython;
class FModifierLimits;
class FModifierNoise;
class FModifierStepped;
class FluidSettings;
class DomainFluidSettings;
class FluidVertexVelocity;
class FluidFluidSettings;
class ObstacleFluidSettings;
class InflowFluidSettings;
class OutflowFluidSettings;
class ParticleFluidSettings;
class ControlFluidSettings;
class GreasePencil;
class GreasePencilLayers;
class GreasePencilGrid;
class GPencilLayer;
class GPencilFrames;
class GPencilFrame;
class GPencilStrokes;
class GPencilStroke;
class GPencilStrokePoints;
class GPencilStrokePoint;
class GPencilTriangle;
class GpencilVertexGroupElement;
class RenderSlot;
class Image;
class RenderSlots;
class ImageUser;
class ImagePackedFile;
class Key;
class ShapeKey;
class ShapeKeyPoint;
class ShapeKeyCurvePoint;
class ShapeKeyBezierPoint;
class Light;
class PointLight;
class AreaLight;
class SpotLight;
class SunLight;
class Lattice;
class LatticePoint;
class ViewLayer;
class LayerObjects;
class FreestyleLineSet;
class FreestyleModuleSettings;
class FreestyleSettings;
class FreestyleModules;
class Linesets;
class LayerCollection;
class ObjectBase;
class LineStyleModifier;
class LineStyleColorModifier;
class LineStyleColorModifier_AlongStroke;
class LineStyleColorModifier_DistanceFromCamera;
class LineStyleColorModifier_DistanceFromObject;
class LineStyleColorModifier_Material;
class LineStyleColorModifier_Tangent;
class LineStyleColorModifier_Noise;
class LineStyleColorModifier_CreaseAngle;
class LineStyleColorModifier_Curvature_3D;
class LineStyleAlphaModifier;
class LineStyleAlphaModifier_AlongStroke;
class LineStyleAlphaModifier_DistanceFromCamera;
class LineStyleAlphaModifier_DistanceFromObject;
class LineStyleAlphaModifier_Material;
class LineStyleAlphaModifier_Tangent;
class LineStyleAlphaModifier_Noise;
class LineStyleAlphaModifier_CreaseAngle;
class LineStyleAlphaModifier_Curvature_3D;
class LineStyleThicknessModifier;
class LineStyleThicknessModifier_Tangent;
class LineStyleThicknessModifier_AlongStroke;
class LineStyleThicknessModifier_DistanceFromCamera;
class LineStyleThicknessModifier_DistanceFromObject;
class LineStyleThicknessModifier_Material;
class LineStyleThicknessModifier_Calligraphy;
class LineStyleThicknessModifier_Noise;
class LineStyleThicknessModifier_Curvature_3D;
class LineStyleThicknessModifier_CreaseAngle;
class LineStyleGeometryModifier;
class LineStyleGeometryModifier_Sampling;
class LineStyleGeometryModifier_BezierCurve;
class LineStyleGeometryModifier_SinusDisplacement;
class LineStyleGeometryModifier_SpatialNoise;
class LineStyleGeometryModifier_PerlinNoise1D;
class LineStyleGeometryModifier_PerlinNoise2D;
class LineStyleGeometryModifier_BackboneStretcher;
class LineStyleGeometryModifier_TipRemover;
class LineStyleGeometryModifier_Polygonalization;
class LineStyleGeometryModifier_GuidingLines;
class LineStyleGeometryModifier_Blueprint;
class LineStyleGeometryModifier_2DOffset;
class LineStyleGeometryModifier_2DTransform;
class LineStyleGeometryModifier_Simplification;
class FreestyleLineStyle;
class LineStyleTextureSlots;
class LineStyleColorModifiers;
class LineStyleAlphaModifiers;
class LineStyleThicknessModifiers;
class LineStyleGeometryModifiers;
class LineStyleTextureSlot;
class BlendData;
class BlendDataCameras;
class BlendDataScenes;
class BlendDataObjects;
class BlendDataMaterials;
class BlendDataNodeTrees;
class BlendDataMeshes;
class BlendDataLights;
class BlendDataLibraries;
class BlendDataScreens;
class BlendDataWindowManagers;
class BlendDataImages;
class BlendDataLattices;
class BlendDataCurves;
class BlendDataMetaBalls;
class BlendDataFonts;
class BlendDataTextures;
class BlendDataBrushes;
class BlendDataWorlds;
class BlendDataCollections;
class BlendDataTexts;
class BlendDataSpeakers;
class BlendDataSounds;
class BlendDataArmatures;
class BlendDataActions;
class BlendDataParticles;
class BlendDataPalettes;
class BlendDataGreasePencils;
class BlendDataMovieClips;
class BlendDataMasks;
class BlendDataLineStyles;
class BlendDataCacheFiles;
class BlendDataPaintCurves;
class BlendDataWorkSpaces;
class BlendDataProbes;
class Material;
class TexPaintSlot;
class MaterialGPencilStyle;
class Mesh;
class MeshVertices;
class MeshEdges;
class MeshLoops;
class MeshPolygons;
class MeshLoopTriangles;
class UVLoopLayers;
class LoopColors;
class VertexFloatProperties;
class VertexIntProperties;
class VertexStringProperties;
class PolygonFloatProperties;
class PolygonIntProperties;
class PolygonStringProperties;
class MeshFaceMapLayers;
class MeshSkinVertexLayer;
class MeshSkinVertex;
class MeshPaintMaskLayer;
class MeshPaintMaskProperty;
class MeshVertex;
class VertexGroupElement;
class MeshEdge;
class MeshLoopTriangle;
class MeshLoop;
class MeshPolygon;
class MeshUVLoopLayer;
class MeshUVLoop;
class MeshLoopColorLayer;
class MeshLoopColor;
class MeshVertexFloatPropertyLayer;
class MeshVertexFloatProperty;
class MeshPolygonFloatPropertyLayer;
class MeshPolygonFloatProperty;
class MeshVertexIntPropertyLayer;
class MeshVertexIntProperty;
class MeshPolygonIntPropertyLayer;
class MeshPolygonIntProperty;
class MeshVertexStringPropertyLayer;
class MeshVertexStringProperty;
class MeshPolygonStringPropertyLayer;
class MeshPolygonStringProperty;
class MeshFaceMapLayer;
class MeshFaceMap;
class MetaElement;
class MetaBall;
class MetaBallElements;
class Modifier;
class SubsurfModifier;
class LatticeModifier;
class CurveModifier;
class BuildModifier;
class MirrorModifier;
class DecimateModifier;
class WaveModifier;
class ArmatureModifier;
class HookModifier;
class SoftBodyModifier;
class BooleanModifier;
class ArrayModifier;
class EdgeSplitModifier;
class DisplaceModifier;
class UVProjectModifier;
class UVProjector;
class SmoothModifier;
class CorrectiveSmoothModifier;
class CastModifier;
class MeshDeformModifier;
class ParticleSystemModifier;
class ParticleInstanceModifier;
class ExplodeModifier;
class ClothModifier;
class CollisionModifier;
class BevelModifier;
class ShrinkwrapModifier;
class FluidSimulationModifier;
class MaskModifier;
class SimpleDeformModifier;
class WarpModifier;
class MultiresModifier;
class SurfaceModifier;
class SmokeModifier;
class SolidifyModifier;
class ScrewModifier;
class UVWarpModifier;
class VertexWeightEditModifier;
class VertexWeightMixModifier;
class VertexWeightProximityModifier;
class DynamicPaintModifier;
class OceanModifier;
class RemeshModifier;
class SkinModifier;
class LaplacianSmoothModifier;
class TriangulateModifier;
class MeshCacheModifier;
class LaplacianDeformModifier;
class WireframeModifier;
class DataTransferModifier;
class NormalEditModifier;
class MeshSequenceCacheModifier;
class SurfaceDeformModifier;
class WeightedNormalModifier;
class GpencilModifier;
class NoiseGpencilModifier;
class SmoothGpencilModifier;
class SubdivGpencilModifier;
class SimplifyGpencilModifier;
class ThickGpencilModifier;
class OffsetGpencilModifier;
class TintGpencilModifier;
class TimeGpencilModifier;
class ColorGpencilModifier;
class ArrayGpencilModifier;
class BuildGpencilModifier;
class OpacityGpencilModifier;
class LatticeGpencilModifier;
class MirrorGpencilModifier;
class HookGpencilModifier;
class ArmatureGpencilModifier;
class ShaderFx;
class ShaderFxBlur;
class ShaderFxColorize;
class ShaderFxWave;
class ShaderFxPixel;
class ShaderFxRim;
class ShaderFxShadow;
class ShaderFxGlow;
class ShaderFxSwirl;
class ShaderFxFlip;
class ShaderFxLight;
class NlaTrack;
class NlaStrips;
class NlaStrip;
class NlaStripFCurves;
class NodeSocket;
class NodeSocketInterface;
class Node;
class NodeInputs;
class NodeOutputs;
class NodeLink;
class NodeInternalSocketTemplate;
class NodeInternal;
class ShaderNode;
class CompositorNode;
class TextureNode;
class NodeTree;
class Nodes;
class NodeLinks;
class NodeTreeInputs;
class NodeTreeOutputs;
class NodeSocketStandard;
class NodeSocketInterfaceStandard;
class NodeSocketFloat;
class NodeSocketInterfaceFloat;
class NodeSocketFloatUnsigned;
class NodeSocketInterfaceFloatUnsigned;
class NodeSocketFloatPercentage;
class NodeSocketInterfaceFloatPercentage;
class NodeSocketFloatFactor;
class NodeSocketInterfaceFloatFactor;
class NodeSocketFloatAngle;
class NodeSocketInterfaceFloatAngle;
class NodeSocketFloatTime;
class NodeSocketInterfaceFloatTime;
class NodeSocketInt;
class NodeSocketInterfaceInt;
class NodeSocketIntUnsigned;
class NodeSocketInterfaceIntUnsigned;
class NodeSocketIntPercentage;
class NodeSocketInterfaceIntPercentage;
class NodeSocketIntFactor;
class NodeSocketInterfaceIntFactor;
class NodeSocketBool;
class NodeSocketInterfaceBool;
class NodeSocketVector;
class NodeSocketInterfaceVector;
class NodeSocketVectorTranslation;
class NodeSocketInterfaceVectorTranslation;
class NodeSocketVectorDirection;
class NodeSocketInterfaceVectorDirection;
class NodeSocketVectorVelocity;
class NodeSocketInterfaceVectorVelocity;
class NodeSocketVectorAcceleration;
class NodeSocketInterfaceVectorAcceleration;
class NodeSocketVectorEuler;
class NodeSocketInterfaceVectorEuler;
class NodeSocketVectorXYZ;
class NodeSocketInterfaceVectorXYZ;
class NodeSocketColor;
class NodeSocketInterfaceColor;
class NodeSocketString;
class NodeSocketInterfaceString;
class NodeSocketShader;
class NodeSocketInterfaceShader;
class NodeSocketVirtual;
class CompositorNodeTree;
class ShaderNodeTree;
class TextureNodeTree;
class NodeFrame;
class NodeGroup;
class NodeGroupInput;
class NodeGroupOutput;
class NodeReroute;
class ShaderNodeRGB;
class ShaderNodeValue;
class ShaderNodeMixRGB;
class ShaderNodeValToRGB;
class ShaderNodeRGBToBW;
class ShaderNodeShaderToRGB;
class ShaderNodeNormal;
class ShaderNodeGamma;
class ShaderNodeBrightContrast;
class ShaderNodeMapping;
class ShaderNodeVectorCurve;
class ShaderNodeRGBCurve;
class ShaderNodeCameraData;
class ShaderNodeMath;
class ShaderNodeVectorMath;
class ShaderNodeSqueeze;
class ShaderNodeInvert;
class ShaderNodeSeparateRGB;
class ShaderNodeCombineRGB;
class ShaderNodeHueSaturation;
class ShaderNodeOutputMaterial;
class ShaderNodeEeveeSpecular;
class ShaderNodeOutputLight;
class ShaderNodeOutputWorld;
class ShaderNodeOutputLineStyle;
class ShaderNodeFresnel;
class ShaderNodeLayerWeight;
class ShaderNodeMixShader;
class ShaderNodeAddShader;
class ShaderNodeAttribute;
class ShaderNodeAmbientOcclusion;
class ShaderNodeBackground;
class ShaderNodeHoldout;
class ShaderNodeBsdfAnisotropic;
class ShaderNodeBsdfDiffuse;
class ShaderNodeBsdfPrincipled;
class ShaderNodeBsdfGlossy;
class ShaderNodeBsdfGlass;
class ShaderNodeBsdfRefraction;
class ShaderNodeBsdfTranslucent;
class ShaderNodeBsdfTransparent;
class ShaderNodeBsdfVelvet;
class ShaderNodeBsdfToon;
class ShaderNodeBsdfHair;
class ShaderNodeBsdfHairPrincipled;
class ShaderNodeSubsurfaceScattering;
class ShaderNodeVolumeAbsorption;
class ShaderNodeVolumeScatter;
class ShaderNodeVolumePrincipled;
class ShaderNodeEmission;
class ShaderNodeNewGeometry;
class ShaderNodeLightPath;
class ShaderNodeLightFalloff;
class ShaderNodeObjectInfo;
class ShaderNodeParticleInfo;
class ShaderNodeHairInfo;
class ShaderNodeWireframe;
class ShaderNodeWavelength;
class ShaderNodeBlackbody;
class ShaderNodeBump;
class ShaderNodeNormalMap;
class ShaderNodeTangent;
class ShaderNodeScript;
class ShaderNodeTexImage;
class ShaderNodeTexEnvironment;
class ShaderNodeTexSky;
class ShaderNodeTexGradient;
class ShaderNodeTexNoise;
class ShaderNodeTexMagic;
class ShaderNodeTexWave;
class ShaderNodeTexMusgrave;
class ShaderNodeTexVoronoi;
class ShaderNodeTexChecker;
class ShaderNodeTexBrick;
class ShaderNodeTexPointDensity;
class ShaderNodeTexCoord;
class ShaderNodeVectorTransform;
class ShaderNodeSeparateHSV;
class ShaderNodeCombineHSV;
class ShaderNodeUVMap;
class ShaderNodeUVAlongStroke;
class ShaderNodeSeparateXYZ;
class ShaderNodeCombineXYZ;
class ShaderNodeBevel;
class ShaderNodeDisplacement;
class ShaderNodeVectorDisplacement;
class ShaderNodeTexIES;
class CompositorNodeViewer;
class CompositorNodeRGB;
class CompositorNodeValue;
class CompositorNodeMixRGB;
class CompositorNodeValToRGB;
class CompositorNodeRGBToBW;
class CompositorNodeNormal;
class CompositorNodeCurveVec;
class CompositorNodeCurveRGB;
class CompositorNodeAlphaOver;
class CompositorNodeBlur;
class CompositorNodeFilter;
class CompositorNodeMapValue;
class CompositorNodeMapRange;
class CompositorNodeTime;
class CompositorNodeVecBlur;
class CompositorNodeSepRGBA;
class CompositorNodeSepHSVA;
class CompositorNodeSetAlpha;
class CompositorNodeHueSat;
class CompositorNodeImage;
class CompositorNodeRLayers;
class CompositorNodeComposite;
class CompositorNodeOutputFile;
class CompositorNodeOutputFileFileSlots;
class CompositorNodeOutputFileLayerSlots;
class CompositorNodeTexture;
class CompositorNodeTranslate;
class CompositorNodeZcombine;
class CompositorNodeCombRGBA;
class CompositorNodeDilateErode;
class CompositorNodeInpaint;
class CompositorNodeDespeckle;
class CompositorNodeRotate;
class CompositorNodeScale;
class CompositorNodeSepYCCA;
class CompositorNodeCombYCCA;
class CompositorNodeSepYUVA;
class CompositorNodeCombYUVA;
class CompositorNodeDiffMatte;
class CompositorNodeColorSpill;
class CompositorNodeChromaMatte;
class CompositorNodeChannelMatte;
class CompositorNodeFlip;
class CompositorNodeSplitViewer;
class CompositorNodeMapUV;
class CompositorNodeIDMask;
class CompositorNodeDoubleEdgeMask;
class CompositorNodeDefocus;
class CompositorNodeDisplace;
class CompositorNodeCombHSVA;
class CompositorNodeMath;
class CompositorNodeLumaMatte;
class CompositorNodeBrightContrast;
class CompositorNodeGamma;
class CompositorNodeInvert;
class CompositorNodeNormalize;
class CompositorNodeCrop;
class CompositorNodeDBlur;
class CompositorNodeBilateralblur;
class CompositorNodePremulKey;
class CompositorNodeGlare;
class CompositorNodeTonemap;
class CompositorNodeLensdist;
class CompositorNodeLevels;
class CompositorNodeColorMatte;
class CompositorNodeDistanceMatte;
class CompositorNodeColorBalance;
class CompositorNodeHueCorrect;
class CompositorNodeMovieClip;
class CompositorNodeTransform;
class CompositorNodeStabilize;
class CompositorNodeMovieDistortion;
class CompositorNodeBoxMask;
class CompositorNodeEllipseMask;
class CompositorNodeBokehImage;
class CompositorNodeBokehBlur;
class CompositorNodeSwitch;
class CompositorNodeSwitchView;
class CompositorNodeColorCorrection;
class CompositorNodeMask;
class CompositorNodeKeyingScreen;
class CompositorNodeKeying;
class CompositorNodeTrackPos;
class CompositorNodePixelate;
class CompositorNodePlaneTrackDeform;
class CompositorNodeCornerPin;
class CompositorNodeSunBeams;
class CompositorNodeCryptomatte;
class TextureNodeOutput;
class TextureNodeChecker;
class TextureNodeTexture;
class TextureNodeBricks;
class TextureNodeMath;
class TextureNodeMixRGB;
class TextureNodeRGBToBW;
class TextureNodeValToRGB;
class TextureNodeImage;
class TextureNodeCurveRGB;
class TextureNodeInvert;
class TextureNodeHueSaturation;
class TextureNodeCurveTime;
class TextureNodeRotate;
class TextureNodeViewer;
class TextureNodeTranslate;
class TextureNodeCoordinates;
class TextureNodeDistance;
class TextureNodeCompose;
class TextureNodeDecompose;
class TextureNodeValToNor;
class TextureNodeScale;
class TextureNodeAt;
class TextureNodeTexVoronoi;
class TextureNodeTexBlend;
class TextureNodeTexMagic;
class TextureNodeTexMarble;
class TextureNodeTexClouds;
class TextureNodeTexWood;
class TextureNodeTexMusgrave;
class TextureNodeTexNoise;
class TextureNodeTexStucci;
class TextureNodeTexDistNoise;
class ShaderNodeGroup;
class CompositorNodeGroup;
class TextureNodeGroup;
class ShaderNodeCustomGroup;
class CompositorNodeCustomGroup;
class NodeCustomGroup;
class NodeOutputFileSlotFile;
class NodeOutputFileSlotLayer;
class NodeInstanceHash;
class Object;
class ObjectModifiers;
class ObjectGpencilModifiers;
class ObjectShaderFx;
class ObjectConstraints;
class VertexGroups;
class FaceMaps;
class ParticleSystems;
class VertexGroup;
class FaceMap;
class MaterialSlot;
class ObjectDisplay;
class PointCache;
class PointCaches;
class PointCacheItem;
class CollisionSettings;
class EffectorWeights;
class FieldSettings;
class SoftBodySettings;
class DepsgraphObjectInstance;
class DepsgraphUpdate;
class Depsgraph;
class PackedFile;
class PaletteColor;
class Palette;
class PaletteColors;
class ParticleTarget;
class SPHFluidSettings;
class ParticleHairKey;
class ParticleKey;
class ChildParticle;
class Particle;
class ParticleDupliWeight;
class ParticleSystem;
class ParticleSettingsTextureSlot;
class ParticleSettings;
class ParticleSettingsTextureSlots;
class Pose;
class BoneGroups;
class PoseBone;
class PoseBoneConstraints;
class IKParam;
class Itasc;
class BoneGroup;
class LightProbe;
class RenderEngine;
class RenderResult;
class RenderView;
class RenderLayer;
class RenderPasses;
class RenderPass;
class BakePixel;
class RigidBodyWorld;
class RigidBodyObject;
class RigidBodyConstraint;
class Scene;
class SceneObjects;
class KeyingSets;
class KeyingSetsAll;
class TimelineMarkers;
class ViewLayers;
class ToolSettings;
class GPencilInterpolateSettings;
class UnifiedPaintSettings;
class CurvePaintSettings;
class MeshStatVis;
class UnitSettings;
class Stereo3dFormat;
class ImageFormatSettings;
class TransformOrientation;
class TransformOrientationSlot;
class View3DCursor;
class SelectedUvElement;
class DisplaySafeAreas;
class SceneDisplay;
class SceneEEVEE;
class FFmpegSettings;
class RenderSettings;
class RenderViews;
class BakeSettings;
class GPUSSAOSettings;
class GPUDOFSettings;
class GPUFXSettings;
class SceneRenderView;
class Screen;
class Area;
class AreaSpaces;
class Region;
class View2D;
class PaintCurve;
class PaintToolSlot;
class Paint;
class Sculpt;
class UvSculpt;
class GpPaint;
class VertexPaint;
class ImagePaint;
class ParticleEdit;
class ParticleBrush;
class GPencilSculptGuide;
class GPencilSculptSettings;
class GPencilSculptBrush;
class SequenceColorBalanceData;
class SequenceElement;
class SequenceProxy;
class SequenceColorBalance;
class SequenceCrop;
class SequenceTransform;
class Sequence;
class SequenceModifiers;
class SequenceEditor;
class Sequences;
class ImageSequence;
class SequenceElements;
class MetaSequence;
class SceneSequence;
class MovieSequence;
class MovieClipSequence;
class MaskSequence;
class SoundSequence;
class EffectSequence;
class AddSequence;
class AdjustmentSequence;
class AlphaOverSequence;
class AlphaUnderSequence;
class ColorSequence;
class CrossSequence;
class GammaCrossSequence;
class GlowSequence;
class MulticamSequence;
class MultiplySequence;
class OverDropSequence;
class SpeedControlSequence;
class SubtractSequence;
class TransformSequence;
class WipeSequence;
class GaussianBlurSequence;
class TextSequence;
class ColorMixSequence;
class SequenceModifier;
class ColorBalanceModifier;
class CurvesModifier;
class HueCorrectModifier;
class BrightContrastModifier;
class WhiteBalanceModifier;
class SequencerTonemapModifierData;
class SmokeDomainSettings;
class SmokeFlowSettings;
class SmokeCollSettings;
class Space;
class SpaceImageEditor;
class SpaceUVEditor;
class SpaceSequenceEditor;
class SpaceTextEditor;
class FileSelectParams;
class FileBrowserFSMenuEntry;
class SpaceFileBrowser;
class SpaceOutliner;
class SpaceView3D;
class View3DShading;
class View3DOverlay;
class RegionView3D;
class SpaceProperties;
class SpaceDopeSheetEditor;
class SpaceGraphEditor;
class SpaceNLA;
class SpaceConsole;
class ConsoleLine;
class SpaceInfo;
class SpacePreferences;
class NodeTreePath;
class SpaceNodeEditor;
class SpaceNodeEditorPath;
class SpaceClipEditor;
class Speaker;
class TextLine;
class Text;
class TimelineMarker;
class Sound;
class UILayout;
class Panel;
class UIList;
class Header;
class Menu;
class ThemeFontStyle;
class ThemeStyle;
class ThemeWidgetColors;
class ThemeWidgetStateColors;
class ThemePanelColors;
class ThemeGradientColors;
class ThemeUserInterface;
class ThemeSpaceGeneric;
class ThemeSpaceGradient;
class ThemeSpaceListGeneric;
class ThemeView3D;
class ThemeGraphEditor;
class ThemeFileBrowser;
class ThemeNLAEditor;
class ThemeDopeSheet;
class ThemeImageEditor;
class ThemeSequenceEditor;
class ThemeProperties;
class ThemeTextEditor;
class ThemeNodeEditor;
class ThemeOutliner;
class ThemeInfo;
class ThemePreferences;
class ThemeConsole;
class ThemeClipEditor;
class ThemeTopBar;
class ThemeStatusBar;
class ThemeBoneColorSet;
class Theme;
class UserSolidLight;
class WalkNavigation;
class Preferences;
class Addons;
class PathCompareCollection;
class PreferencesView;
class PreferencesEdit;
class PreferencesInput;
class PreferencesKeymap;
class PreferencesFilePaths;
class PreferencesSystem;
class Addon;
class AddonPreferences;
class StudioLights;
class StudioLight;
class PathCompare;
class VectorFont;
class Operator;
class OperatorProperties;
class OperatorOptions;
class OperatorMousePath;
class OperatorFileListElement;
class Macro;
class OperatorMacro;
class Event;
class Timer;
class UIPopupMenu;
class UIPopover;
class UIPieMenu;
class Window;
class Stereo3dDisplay;
class WindowManager;
class KeyConfigurations;
class KeyConfigPreferences;
class KeyConfig;
class KeyMaps;
class KeyMap;
class KeyMapItems;
class KeyMapItem;
class GizmoGroup;
class Gizmo;
class GizmoProperties;
class Gizmos;
class GizmoGroupProperties;
class wmOwnerID;
class WorkSpaceTool;
class WorkSpace;
class wmOwnerIDs;
class wmTools;
class World;
class WorldLighting;
class WorldMistSettings;
class MovieClip;
class MovieClipProxy;
class MovieClipUser;
class MovieClipScopes;
class MovieTrackingSettings;
class MovieTrackingCamera;
class MovieTrackingMarker;
class MovieTrackingTrack;
class MovieTrackingMarkers;
class MovieTrackingPlaneMarker;
class MovieTrackingPlaneTrack;
class MovieTrackingPlaneMarkers;
class MovieTrackingTracks;
class MovieTrackingPlaneTracks;
class MovieTrackingObjectTracks;
class MovieTrackingObjectPlaneTracks;
class MovieTrackingStabilization;
class MovieTrackingReconstructedCameras;
class MovieReconstructedCamera;
class MovieTrackingReconstruction;
class MovieTrackingObject;
class MovieTrackingDopesheet;
class MovieTracking;
class MovieTrackingObjects;
class MaskParent;
class MaskSplinePointUW;
class MaskSplinePoint;
class MaskSpline;
class MaskSplines;
class MaskSplinePoints;
class MaskLayer;
class Mask;
class MaskLayers;

/**************** Struct Definition ****************/

class Struct : public Pointer {
public:
	Struct(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		properties(ptr_arg),
		functions(ptr_arg),
		property_tags(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string name(void);
	inline void name(const std::string& value);
	inline std::string identifier(void);
	inline void identifier(const std::string& value);
	inline std::string description(void);
	inline void description(const std::string& value);
	inline std::string translation_context(void);
	inline void translation_context(const std::string& value);
	inline Struct base(void);
	inline Struct nested(void);
	inline StringProperty name_property(void);
	COLLECTION_PROPERTY(DefaultCollectionFunctions, Property, Struct, properties, false, false, false)
	COLLECTION_PROPERTY(DefaultCollectionFunctions, Function, Struct, functions, false, false, false)
	COLLECTION_PROPERTY(DefaultCollectionFunctions, EnumPropertyItem, Struct, property_tags, false, false, false)

};

/**************** Property Definition ****************/

class Property : public Pointer {
public:
	Property(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string name(void);
	inline void name(const std::string& value);
	inline std::string identifier(void);
	inline void identifier(const std::string& value);
	inline std::string description(void);
	inline void description(const std::string& value);
	inline std::string translation_context(void);
	inline void translation_context(const std::string& value);
	enum type_enum {
		type_BOOLEAN = 0,
		type_INT = 1,
		type_FLOAT = 2,
		type_STRING = 3,
		type_ENUM = 4,
		type_POINTER = 5,
		type_COLLECTION = 6,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	enum subtype_enum {
		subtype_NONE = 0,
		subtype_FILE_PATH = 1,
		subtype_DIR_PATH = 2,
		subtype_PIXEL = 12,
		subtype_UNSIGNED = 13,
		subtype_PERCENTAGE = 14,
		subtype_FACTOR = 15,
		subtype_ANGLE = 327696,
		subtype_TIME = 393233,
		subtype_DISTANCE = 65554,
		subtype_COLOR = 20,
		subtype_TRANSLATION = 65557,
		subtype_DIRECTION = 22,
		subtype_MATRIX = 25,
		subtype_EULER = 327706,
		subtype_QUATERNION = 27,
		subtype_XYZ = 29,
		subtype_COLOR_GAMMA = 30,
		subtype_COORDINATES = 31,
		subtype_LAYER = 40,
		subtype_LAYER_MEMBERSHIP = 41,
	};
	inline subtype_enum subtype(void);
	inline void subtype(subtype_enum value);
	inline Struct srna(void);
	enum unit_enum {
		unit_NONE = 0,
		unit_LENGTH = 65536,
		unit_AREA = 131072,
		unit_VOLUME = 196608,
		unit_ROTATION = 327680,
		unit_TIME = 393216,
		unit_VELOCITY = 458752,
		unit_ACCELERATION = 524288,
		unit_MASS = 262144,
		unit_CAMERA = 589824,
		unit_POWER = 655360,
	};
	inline unit_enum unit(void);
	inline void unit(unit_enum value);
	enum icon_enum {
		icon_NONE = 0,
		icon_QUESTION = 1,
		icon_ERROR = 2,
		icon_CANCEL = 3,
		icon_TRIA_RIGHT = 4,
		icon_TRIA_DOWN = 5,
		icon_TRIA_LEFT = 6,
		icon_TRIA_UP = 7,
		icon_ARROW_LEFTRIGHT = 8,
		icon_PLUS = 9,
		icon_DISCLOSURE_TRI_RIGHT = 10,
		icon_DISCLOSURE_TRI_DOWN = 11,
		icon_RADIOBUT_OFF = 12,
		icon_RADIOBUT_ON = 13,
		icon_MENU_PANEL = 14,
		icon_BLENDER = 15,
		icon_GRIP = 16,
		icon_DOT = 17,
		icon_COLLAPSEMENU = 18,
		icon_X = 19,
		icon_DUPLICATE = 20,
		icon_TRASH = 21,
		icon_NODE = 24,
		icon_NODE_SEL = 25,
		icon_WINDOW = 26,
		icon_WORKSPACE = 27,
		icon_RIGHTARROW_THIN = 28,
		icon_BORDERMOVE = 29,
		icon_VIEWZOOM = 30,
		icon_ADD = 31,
		icon_REMOVE = 32,
		icon_PANEL_CLOSE = 33,
		icon_COPY_ID = 34,
		icon_EYEDROPPER = 35,
		icon_AUTO = 37,
		icon_CHECKBOX_DEHLT = 38,
		icon_CHECKBOX_HLT = 39,
		icon_UNLOCKED = 40,
		icon_LOCKED = 41,
		icon_UNPINNED = 42,
		icon_PINNED = 43,
		icon_SCREEN_BACK = 44,
		icon_RIGHTARROW = 45,
		icon_DOWNARROW_HLT = 46,
		icon_PLUGIN = 51,
		icon_HELP = 52,
		icon_GHOST_ENABLED = 53,
		icon_COLOR = 54,
		icon_UNLINKED = 55,
		icon_LINKED = 56,
		icon_HAND = 57,
		icon_ZOOM_ALL = 58,
		icon_ZOOM_SELECTED = 59,
		icon_ZOOM_PREVIOUS = 60,
		icon_ZOOM_IN = 61,
		icon_ZOOM_OUT = 62,
		icon_DRIVER_DISTANCE = 63,
		icon_DRIVER_ROTATIONAL_DIFFERENCE = 64,
		icon_DRIVER_TRANSFORM = 65,
		icon_FREEZE = 66,
		icon_STYLUS_PRESSURE = 67,
		icon_GHOST_DISABLED = 68,
		icon_FILE_NEW = 69,
		icon_FILE_TICK = 70,
		icon_QUIT = 71,
		icon_URL = 72,
		icon_RECOVER_LAST = 73,
		icon_THREE_DOTS = 74,
		icon_FULLSCREEN_ENTER = 75,
		icon_FULLSCREEN_EXIT = 76,
		icon_LIGHT = 78,
		icon_MATERIAL = 79,
		icon_TEXTURE = 80,
		icon_ANIM = 81,
		icon_WORLD = 82,
		icon_SCENE = 83,
		icon_OUTPUT = 84,
		icon_SCRIPT = 87,
		icon_PARTICLES = 88,
		icon_PHYSICS = 89,
		icon_SPEAKER = 90,
		icon_TOOL_SETTINGS = 92,
		icon_SHADERFX = 93,
		icon_MODIFIER = 94,
		icon_BLANK1 = 101,
		icon_FAKE_USER_OFF = 102,
		icon_FAKE_USER_ON = 103,
		icon_VIEW3D = 104,
		icon_GRAPH = 105,
		icon_OUTLINER = 106,
		icon_PROPERTIES = 107,
		icon_FILEBROWSER = 108,
		icon_IMAGE = 109,
		icon_INFO = 110,
		icon_SEQUENCE = 111,
		icon_TEXT = 112,
		icon_SOUND = 114,
		icon_ACTION = 115,
		icon_NLA = 116,
		icon_PREFERENCES = 117,
		icon_TIME = 118,
		icon_NODETREE = 119,
		icon_CONSOLE = 121,
		icon_TRACKER = 123,
		icon_ASSET_MANAGER = 124,
		icon_NODE_COMPOSITING = 125,
		icon_NODE_TEXTURE = 126,
		icon_NODE_MATERIAL = 127,
		icon_UV = 128,
		icon_OBJECT_DATAMODE = 130,
		icon_EDITMODE_HLT = 131,
		icon_UV_DATA = 132,
		icon_VPAINT_HLT = 133,
		icon_TPAINT_HLT = 134,
		icon_WPAINT_HLT = 135,
		icon_SCULPTMODE_HLT = 136,
		icon_POSE_HLT = 137,
		icon_PARTICLEMODE = 138,
		icon_TRACKING = 146,
		icon_TRACKING_BACKWARDS = 147,
		icon_TRACKING_FORWARDS = 148,
		icon_TRACKING_BACKWARDS_SINGLE = 149,
		icon_TRACKING_FORWARDS_SINGLE = 150,
		icon_TRACKING_CLEAR_BACKWARDS = 151,
		icon_TRACKING_CLEAR_FORWARDS = 152,
		icon_TRACKING_REFINE_BACKWARDS = 153,
		icon_TRACKING_REFINE_FORWARDS = 154,
		icon_SCENE_DATA = 156,
		icon_RENDERLAYERS = 157,
		icon_WORLD_DATA = 158,
		icon_OBJECT_DATA = 159,
		icon_MESH_DATA = 160,
		icon_CURVE_DATA = 161,
		icon_META_DATA = 162,
		icon_LATTICE_DATA = 163,
		icon_LIGHT_DATA = 164,
		icon_MATERIAL_DATA = 165,
		icon_TEXTURE_DATA = 166,
		icon_ANIM_DATA = 167,
		icon_CAMERA_DATA = 168,
		icon_PARTICLE_DATA = 169,
		icon_LIBRARY_DATA_DIRECT = 170,
		icon_GROUP = 171,
		icon_ARMATURE_DATA = 172,
		icon_COMMUNITY = 173,
		icon_BONE_DATA = 174,
		icon_CONSTRAINT = 175,
		icon_SHAPEKEY_DATA = 176,
		icon_CONSTRAINT_BONE = 177,
		icon_CAMERA_STEREO = 178,
		icon_PACKAGE = 179,
		icon_UGLYPACKAGE = 180,
		icon_EXPERIMENTAL = 181,
		icon_BRUSH_DATA = 182,
		icon_IMAGE_DATA = 183,
		icon_FILE = 184,
		icon_FCURVE = 185,
		icon_FONT_DATA = 186,
		icon_RENDER_RESULT = 187,
		icon_SURFACE_DATA = 188,
		icon_EMPTY_DATA = 189,
		icon_PRESET = 190,
		icon_RENDER_ANIMATION = 191,
		icon_RENDER_STILL = 192,
		icon_LIBRARY_DATA_BROKEN = 193,
		icon_BOIDS = 194,
		icon_STRANDS = 195,
		icon_LIBRARY_DATA_INDIRECT = 196,
		icon_GREASEPENCIL = 197,
		icon_LINE_DATA = 198,
		icon_LIBRARY_DATA_OVERRIDE = 199,
		icon_GROUP_BONE = 200,
		icon_GROUP_VERTEX = 201,
		icon_GROUP_VCOL = 202,
		icon_GROUP_UVS = 203,
		icon_FACE_MAPS = 204,
		icon_RNA = 206,
		icon_RNA_ADD = 207,
		icon_MOUSE_LMB = 208,
		icon_MOUSE_MMB = 209,
		icon_MOUSE_RMB = 210,
		icon_MOUSE_MOVE = 211,
		icon_MOUSE_LMB_DRAG = 212,
		icon_MOUSE_MMB_DRAG = 213,
		icon_MOUSE_RMB_DRAG = 214,
		icon_PRESET_NEW = 216,
		icon_DECORATE = 218,
		icon_DECORATE_KEYFRAME = 219,
		icon_DECORATE_ANIMATE = 220,
		icon_DECORATE_DRIVER = 221,
		icon_DECORATE_LINKED = 222,
		icon_DECORATE_LIBRARY_OVERRIDE = 223,
		icon_DECORATE_UNLOCKED = 224,
		icon_DECORATE_LOCKED = 225,
		icon_DECORATE_OVERRIDE = 226,
		icon_TRACKER_DATA = 228,
		icon_HEART = 229,
		icon_ORPHAN_DATA = 230,
		icon_USER = 231,
		icon_SYSTEM = 232,
		icon_SETTINGS = 233,
		icon_OUTLINER_OB_EMPTY = 234,
		icon_OUTLINER_OB_MESH = 235,
		icon_OUTLINER_OB_CURVE = 236,
		icon_OUTLINER_OB_LATTICE = 237,
		icon_OUTLINER_OB_META = 238,
		icon_OUTLINER_OB_LIGHT = 239,
		icon_OUTLINER_OB_CAMERA = 240,
		icon_OUTLINER_OB_ARMATURE = 241,
		icon_OUTLINER_OB_FONT = 242,
		icon_OUTLINER_OB_SURFACE = 243,
		icon_OUTLINER_OB_SPEAKER = 244,
		icon_OUTLINER_OB_FORCE_FIELD = 245,
		icon_OUTLINER_OB_GROUP_INSTANCE = 246,
		icon_OUTLINER_OB_GREASEPENCIL = 247,
		icon_OUTLINER_OB_LIGHTPROBE = 248,
		icon_OUTLINER_OB_IMAGE = 249,
		icon_RESTRICT_COLOR_OFF = 251,
		icon_RESTRICT_COLOR_ON = 252,
		icon_HIDE_ON = 253,
		icon_HIDE_OFF = 254,
		icon_RESTRICT_SELECT_ON = 255,
		icon_RESTRICT_SELECT_OFF = 256,
		icon_RESTRICT_RENDER_ON = 257,
		icon_RESTRICT_RENDER_OFF = 258,
		icon_OUTLINER_DATA_EMPTY = 260,
		icon_OUTLINER_DATA_MESH = 261,
		icon_OUTLINER_DATA_CURVE = 262,
		icon_OUTLINER_DATA_LATTICE = 263,
		icon_OUTLINER_DATA_META = 264,
		icon_OUTLINER_DATA_LIGHT = 265,
		icon_OUTLINER_DATA_CAMERA = 266,
		icon_OUTLINER_DATA_ARMATURE = 267,
		icon_OUTLINER_DATA_FONT = 268,
		icon_OUTLINER_DATA_SURFACE = 269,
		icon_OUTLINER_DATA_SPEAKER = 270,
		icon_OUTLINER_DATA_GREASEPENCIL = 273,
		icon_GP_SELECT_POINTS = 274,
		icon_GP_SELECT_STROKES = 275,
		icon_GP_MULTIFRAME_EDITING = 276,
		icon_GP_ONLY_SELECTED = 277,
		icon_GP_SELECT_BETWEEN_STROKES = 278,
		icon_MODIFIER_OFF = 279,
		icon_MODIFIER_ON = 280,
		icon_ONIONSKIN_OFF = 281,
		icon_ONIONSKIN_ON = 282,
		icon_RESTRICT_VIEW_ON = 283,
		icon_RESTRICT_VIEW_OFF = 284,
		icon_MESH_PLANE = 286,
		icon_MESH_CUBE = 287,
		icon_MESH_CIRCLE = 288,
		icon_MESH_UVSPHERE = 289,
		icon_MESH_ICOSPHERE = 290,
		icon_MESH_GRID = 291,
		icon_MESH_MONKEY = 292,
		icon_MESH_CYLINDER = 293,
		icon_MESH_TORUS = 294,
		icon_MESH_CONE = 295,
		icon_MESH_CAPSULE = 296,
		icon_EMPTY_SINGLE_ARROW = 297,
		icon_LIGHT_POINT = 298,
		icon_LIGHT_SUN = 299,
		icon_LIGHT_SPOT = 300,
		icon_LIGHT_HEMI = 301,
		icon_LIGHT_AREA = 302,
		icon_CUBE = 303,
		icon_SPHERE = 304,
		icon_CONE = 305,
		icon_META_PLANE = 306,
		icon_META_CUBE = 307,
		icon_META_BALL = 308,
		icon_META_ELLIPSOID = 309,
		icon_META_CAPSULE = 310,
		icon_SURFACE_NCURVE = 312,
		icon_SURFACE_NCIRCLE = 313,
		icon_SURFACE_NSURFACE = 314,
		icon_SURFACE_NCYLINDER = 315,
		icon_SURFACE_NSPHERE = 316,
		icon_SURFACE_NTORUS = 317,
		icon_EMPTY_AXIS = 318,
		icon_STROKE = 319,
		icon_EMPTY_ARROWS = 320,
		icon_CURVE_BEZCURVE = 321,
		icon_CURVE_BEZCIRCLE = 322,
		icon_CURVE_NCURVE = 323,
		icon_CURVE_NCIRCLE = 324,
		icon_CURVE_PATH = 325,
		icon_LIGHTPROBE_CUBEMAP = 326,
		icon_LIGHTPROBE_PLANAR = 327,
		icon_LIGHTPROBE_GRID = 328,
		icon_COLOR_RED = 331,
		icon_COLOR_GREEN = 332,
		icon_COLOR_BLUE = 333,
		icon_TRIA_RIGHT_BAR = 334,
		icon_TRIA_DOWN_BAR = 335,
		icon_TRIA_LEFT_BAR = 336,
		icon_TRIA_UP_BAR = 337,
		icon_FORCE_FORCE = 338,
		icon_FORCE_WIND = 339,
		icon_FORCE_VORTEX = 340,
		icon_FORCE_MAGNETIC = 341,
		icon_FORCE_HARMONIC = 342,
		icon_FORCE_CHARGE = 343,
		icon_FORCE_LENNARDJONES = 344,
		icon_FORCE_TEXTURE = 345,
		icon_FORCE_CURVE = 346,
		icon_FORCE_BOID = 347,
		icon_FORCE_TURBULENCE = 348,
		icon_FORCE_DRAG = 349,
		icon_FORCE_SMOKEFLOW = 350,
		icon_IMAGE_PLANE = 361,
		icon_IMAGE_BACKGROUND = 362,
		icon_IMAGE_REFERENCE = 363,
		icon_NODE_INSERT_ON = 367,
		icon_NODE_INSERT_OFF = 368,
		icon_NODE_TOP = 369,
		icon_NODE_SIDE = 370,
		icon_NODE_CORNER = 371,
		icon_ALIGN_LEFT = 390,
		icon_ALIGN_CENTER = 391,
		icon_ALIGN_RIGHT = 392,
		icon_ALIGN_JUSTIFY = 393,
		icon_ALIGN_FLUSH = 394,
		icon_ALIGN_TOP = 395,
		icon_ALIGN_MIDDLE = 396,
		icon_ALIGN_BOTTOM = 397,
		icon_BOLD = 398,
		icon_ITALIC = 399,
		icon_UNDERLINE = 400,
		icon_SMALL_CAPS = 401,
		icon_MODIFIER_DATA = 442,
		icon_MOD_WAVE = 443,
		icon_MOD_BUILD = 444,
		icon_MOD_DECIM = 445,
		icon_MOD_MIRROR = 446,
		icon_MOD_SOFT = 447,
		icon_MOD_SUBSURF = 448,
		icon_HOOK = 449,
		icon_MOD_PHYSICS = 450,
		icon_MOD_PARTICLES = 451,
		icon_MOD_BOOLEAN = 452,
		icon_MOD_EDGESPLIT = 453,
		icon_MOD_ARRAY = 454,
		icon_MOD_UVPROJECT = 455,
		icon_MOD_DISPLACE = 456,
		icon_MOD_CURVE = 457,
		icon_MOD_LATTICE = 458,
		icon_MOD_TINT = 459,
		icon_MOD_ARMATURE = 460,
		icon_MOD_SHRINKWRAP = 461,
		icon_MOD_CAST = 462,
		icon_MOD_MESHDEFORM = 463,
		icon_MOD_BEVEL = 464,
		icon_MOD_SMOOTH = 465,
		icon_MOD_SIMPLEDEFORM = 466,
		icon_MOD_MASK = 467,
		icon_MOD_CLOTH = 468,
		icon_MOD_EXPLODE = 469,
		icon_MOD_FLUIDSIM = 470,
		icon_MOD_MULTIRES = 471,
		icon_MOD_SMOKE = 472,
		icon_MOD_SOLIDIFY = 473,
		icon_MOD_SCREW = 474,
		icon_MOD_VERTEX_WEIGHT = 475,
		icon_MOD_DYNAMICPAINT = 476,
		icon_MOD_REMESH = 477,
		icon_MOD_OCEAN = 478,
		icon_MOD_WARP = 479,
		icon_MOD_SKIN = 480,
		icon_MOD_TRIANGULATE = 481,
		icon_MOD_WIREFRAME = 482,
		icon_MOD_DATA_TRANSFER = 483,
		icon_MOD_NORMALEDIT = 484,
		icon_MOD_PARTICLE_INSTANCE = 485,
		icon_MOD_HUE_SATURATION = 486,
		icon_MOD_NOISE = 487,
		icon_MOD_OFFSET = 488,
		icon_MOD_SIMPLIFY = 489,
		icon_MOD_THICKNESS = 490,
		icon_MOD_INSTANCE = 491,
		icon_MOD_TIME = 492,
		icon_MOD_OPACITY = 493,
		icon_REC = 494,
		icon_PLAY = 495,
		icon_FF = 496,
		icon_REW = 497,
		icon_PAUSE = 498,
		icon_PREV_KEYFRAME = 499,
		icon_NEXT_KEYFRAME = 500,
		icon_PLAY_SOUND = 501,
		icon_PLAY_REVERSE = 502,
		icon_PREVIEW_RANGE = 503,
		icon_ACTION_TWEAK = 504,
		icon_PMARKER_ACT = 505,
		icon_PMARKER_SEL = 506,
		icon_PMARKER = 507,
		icon_MARKER_HLT = 508,
		icon_MARKER = 509,
		icon_KEYFRAME_HLT = 510,
		icon_KEYFRAME = 511,
		icon_KEYINGSET = 512,
		icon_KEY_DEHLT = 513,
		icon_KEY_HLT = 514,
		icon_MUTE_IPO_OFF = 515,
		icon_MUTE_IPO_ON = 516,
		icon_VISIBLE_IPO_OFF = 517,
		icon_VISIBLE_IPO_ON = 518,
		icon_DRIVER = 519,
		icon_SOLO_OFF = 520,
		icon_SOLO_ON = 521,
		icon_FRAME_PREV = 522,
		icon_FRAME_NEXT = 523,
		icon_NLA_PUSHDOWN = 524,
		icon_IPO_CONSTANT = 525,
		icon_IPO_LINEAR = 526,
		icon_IPO_BEZIER = 527,
		icon_IPO_SINE = 528,
		icon_IPO_QUAD = 529,
		icon_IPO_CUBIC = 530,
		icon_IPO_QUART = 531,
		icon_IPO_QUINT = 532,
		icon_IPO_EXPO = 533,
		icon_IPO_CIRC = 534,
		icon_IPO_BOUNCE = 535,
		icon_IPO_ELASTIC = 536,
		icon_IPO_BACK = 537,
		icon_IPO_EASE_IN = 538,
		icon_IPO_EASE_OUT = 539,
		icon_IPO_EASE_IN_OUT = 540,
		icon_NORMALIZE_FCURVES = 541,
		icon_VERTEXSEL = 546,
		icon_EDGESEL = 547,
		icon_FACESEL = 548,
		icon_PIVOT_BOUNDBOX = 551,
		icon_PIVOT_CURSOR = 552,
		icon_PIVOT_INDIVIDUAL = 553,
		icon_PIVOT_MEDIAN = 554,
		icon_PIVOT_ACTIVE = 555,
		icon_CENTER_ONLY = 556,
		icon_ROOTCURVE = 557,
		icon_SMOOTHCURVE = 558,
		icon_SPHERECURVE = 559,
		icon_INVERSESQUARECURVE = 560,
		icon_SHARPCURVE = 561,
		icon_LINCURVE = 562,
		icon_NOCURVE = 563,
		icon_RNDCURVE = 564,
		icon_PROP_OFF = 565,
		icon_PROP_ON = 566,
		icon_PROP_CON = 567,
		icon_PROP_PROJECTED = 568,
		icon_PARTICLE_POINT = 569,
		icon_PARTICLE_TIP = 570,
		icon_PARTICLE_PATH = 571,
		icon_SNAP_OFF = 576,
		icon_SNAP_ON = 577,
		icon_SNAP_NORMAL = 578,
		icon_SNAP_GRID = 579,
		icon_SNAP_VERTEX = 580,
		icon_SNAP_EDGE = 581,
		icon_SNAP_FACE = 582,
		icon_SNAP_VOLUME = 583,
		icon_SNAP_INCREMENT = 584,
		icon_STICKY_UVS_LOC = 585,
		icon_STICKY_UVS_DISABLE = 586,
		icon_STICKY_UVS_VERT = 587,
		icon_CLIPUV_DEHLT = 588,
		icon_CLIPUV_HLT = 589,
		icon_SNAP_PEEL_OBJECT = 590,
		icon_GRID = 591,
		icon_OBJECT_ORIGIN = 592,
		icon_ORIENTATION_GLOBAL = 593,
		icon_ORIENTATION_GIMBAL = 594,
		icon_ORIENTATION_LOCAL = 595,
		icon_ORIENTATION_NORMAL = 596,
		icon_ORIENTATION_VIEW = 597,
		icon_COPYDOWN = 598,
		icon_PASTEDOWN = 599,
		icon_PASTEFLIPUP = 600,
		icon_PASTEFLIPDOWN = 601,
		icon_VIS_SEL_11 = 602,
		icon_VIS_SEL_10 = 603,
		icon_VIS_SEL_01 = 604,
		icon_VIS_SEL_00 = 605,
		icon_AUTOMERGE_ON = 607,
		icon_AUTOMERGE_OFF = 608,
		icon_UV_VERTEXSEL = 610,
		icon_UV_EDGESEL = 611,
		icon_UV_FACESEL = 612,
		icon_UV_ISLANDSEL = 613,
		icon_UV_SYNC_SELECT = 614,
		icon_ORIENTATION_CURSOR = 620,
		icon_NORMALS_VERTEX = 621,
		icon_NORMALS_FACE = 622,
		icon_NORMALS_VERTEX_FACE = 623,
		icon_SHADING_BBOX = 624,
		icon_SHADING_WIRE = 625,
		icon_SHADING_SOLID = 626,
		icon_SHADING_RENDERED = 627,
		icon_SHADING_TEXTURE = 628,
		icon_OVERLAY = 629,
		icon_XRAY = 630,
		icon_LOCKVIEW_OFF = 633,
		icon_LOCKVIEW_ON = 634,
		icon_AXIS_SIDE = 636,
		icon_AXIS_FRONT = 637,
		icon_AXIS_TOP = 638,
		icon_NDOF_DOM = 639,
		icon_NDOF_TURN = 640,
		icon_NDOF_FLY = 641,
		icon_NDOF_TRANS = 642,
		icon_LAYER_USED = 643,
		icon_LAYER_ACTIVE = 644,
		icon_SORTALPHA = 676,
		icon_SORTBYEXT = 677,
		icon_SORTTIME = 678,
		icon_SORTSIZE = 679,
		icon_SHORTDISPLAY = 680,
		icon_LONGDISPLAY = 681,
		icon_IMGDISPLAY = 683,
		icon_BOOKMARKS = 686,
		icon_FONTPREVIEW = 687,
		icon_FILTER = 688,
		icon_NEWFOLDER = 689,
		icon_FILE_PARENT = 691,
		icon_FILE_REFRESH = 692,
		icon_FILE_FOLDER = 693,
		icon_FILE_BLANK = 694,
		icon_FILE_BLEND = 695,
		icon_FILE_IMAGE = 696,
		icon_FILE_MOVIE = 697,
		icon_FILE_SCRIPT = 698,
		icon_FILE_SOUND = 699,
		icon_FILE_FONT = 700,
		icon_FILE_TEXT = 701,
		icon_SORT_DESC = 702,
		icon_SORT_ASC = 703,
		icon_LINK_BLEND = 704,
		icon_APPEND_BLEND = 705,
		icon_IMPORT = 706,
		icon_EXPORT = 707,
		icon_LOOP_BACK = 715,
		icon_LOOP_FORWARDS = 716,
		icon_BACK = 717,
		icon_FORWARD = 718,
		icon_FILE_VOLUME = 722,
		icon_ALEMBIC = 723,
		icon_VOLUME = 724,
		icon_FILE_HIDDEN = 725,
		icon_FILE_BACKUP = 726,
		icon_DISK_DRIVE = 727,
		icon_MATPLANE = 728,
		icon_MATSPHERE = 729,
		icon_MATCUBE = 730,
		icon_MONKEY = 731,
		icon_HAIR = 732,
		icon_ALIASED = 733,
		icon_ANTIALIASED = 734,
		icon_MAT_SPHERE_SKY = 735,
		icon_MATSHADERBALL = 736,
		icon_MATCLOTH = 737,
		icon_MATFLUID = 738,
		icon_WORDWRAP_OFF = 740,
		icon_WORDWRAP_ON = 741,
		icon_SYNTAX_OFF = 742,
		icon_SYNTAX_ON = 743,
		icon_LINENUMBERS_OFF = 744,
		icon_LINENUMBERS_ON = 745,
		icon_SCRIPTPLUGINS = 746,
		icon_SEQ_SEQUENCER = 754,
		icon_SEQ_PREVIEW = 755,
		icon_SEQ_LUMA_WAVEFORM = 756,
		icon_SEQ_CHROMA_SCOPE = 757,
		icon_SEQ_HISTOGRAM = 758,
		icon_SEQ_SPLITVIEW = 759,
		icon_IMAGE_RGB = 763,
		icon_IMAGE_RGB_ALPHA = 764,
		icon_IMAGE_ALPHA = 765,
		icon_IMAGE_ZDEPTH = 766,
		icon_VIEW_PERSPECTIVE = 775,
		icon_VIEW_ORTHO = 776,
		icon_VIEW_CAMERA = 777,
		icon_VIEW_PAN = 778,
		icon_VIEW_ZOOM = 779,
		icon_BRUSH_BLOB = 780,
		icon_BRUSH_BLUR = 781,
		icon_BRUSH_CLAY = 782,
		icon_BRUSH_CLAY_STRIPS = 783,
		icon_BRUSH_CLONE = 784,
		icon_BRUSH_CREASE = 785,
		icon_BRUSH_FILL = 786,
		icon_BRUSH_FLATTEN = 787,
		icon_BRUSH_GRAB = 788,
		icon_BRUSH_INFLATE = 789,
		icon_BRUSH_LAYER = 790,
		icon_BRUSH_MASK = 791,
		icon_BRUSH_MIX = 792,
		icon_BRUSH_NUDGE = 793,
		icon_BRUSH_PINCH = 794,
		icon_BRUSH_SCRAPE = 795,
		icon_BRUSH_SCULPT_DRAW = 796,
		icon_BRUSH_SMEAR = 797,
		icon_BRUSH_SMOOTH = 798,
		icon_BRUSH_SNAKE_HOOK = 799,
		icon_BRUSH_SOFTEN = 800,
		icon_BRUSH_TEXDRAW = 801,
		icon_BRUSH_TEXFILL = 802,
		icon_BRUSH_TEXMASK = 803,
		icon_BRUSH_THUMB = 804,
		icon_BRUSH_ROTATE = 805,
		icon_GPBRUSH_SMOOTH = 806,
		icon_GPBRUSH_THICKNESS = 807,
		icon_GPBRUSH_STRENGTH = 808,
		icon_GPBRUSH_GRAB = 809,
		icon_GPBRUSH_PUSH = 810,
		icon_GPBRUSH_TWIST = 811,
		icon_GPBRUSH_PINCH = 812,
		icon_GPBRUSH_RANDOMIZE = 813,
		icon_GPBRUSH_CLONE = 814,
		icon_GPBRUSH_WEIGHT = 815,
		icon_GPBRUSH_PENCIL = 816,
		icon_GPBRUSH_PEN = 817,
		icon_GPBRUSH_INK = 818,
		icon_GPBRUSH_INKNOISE = 819,
		icon_GPBRUSH_BLOCK = 820,
		icon_GPBRUSH_MARKER = 821,
		icon_GPBRUSH_FILL = 822,
		icon_GPBRUSH_ERASE_SOFT = 823,
		icon_GPBRUSH_ERASE_HARD = 824,
		icon_GPBRUSH_ERASE_STROKE = 825,
		icon_SMALL_TRI_RIGHT_VEC = 826,
		icon_KEYTYPE_KEYFRAME_VEC = 827,
		icon_KEYTYPE_BREAKDOWN_VEC = 828,
		icon_KEYTYPE_EXTREME_VEC = 829,
		icon_KEYTYPE_JITTER_VEC = 830,
		icon_KEYTYPE_MOVING_HOLD_VEC = 831,
		icon_HANDLETYPE_FREE_VEC = 832,
		icon_HANDLETYPE_ALIGNED_VEC = 833,
		icon_HANDLETYPE_VECTOR_VEC = 834,
		icon_HANDLETYPE_AUTO_VEC = 835,
		icon_HANDLETYPE_AUTO_CLAMP_VEC = 836,
		icon_COLORSET_01_VEC = 837,
		icon_COLORSET_02_VEC = 838,
		icon_COLORSET_03_VEC = 839,
		icon_COLORSET_04_VEC = 840,
		icon_COLORSET_05_VEC = 841,
		icon_COLORSET_06_VEC = 842,
		icon_COLORSET_07_VEC = 843,
		icon_COLORSET_08_VEC = 844,
		icon_COLORSET_09_VEC = 845,
		icon_COLORSET_10_VEC = 846,
		icon_COLORSET_11_VEC = 847,
		icon_COLORSET_12_VEC = 848,
		icon_COLORSET_13_VEC = 849,
		icon_COLORSET_14_VEC = 850,
		icon_COLORSET_15_VEC = 851,
		icon_COLORSET_16_VEC = 852,
		icon_COLORSET_17_VEC = 853,
		icon_COLORSET_18_VEC = 854,
		icon_COLORSET_19_VEC = 855,
		icon_COLORSET_20_VEC = 856,
		icon_EVENT_A = 857,
		icon_EVENT_B = 858,
		icon_EVENT_C = 859,
		icon_EVENT_D = 860,
		icon_EVENT_E = 861,
		icon_EVENT_F = 862,
		icon_EVENT_G = 863,
		icon_EVENT_H = 864,
		icon_EVENT_I = 865,
		icon_EVENT_J = 866,
		icon_EVENT_K = 867,
		icon_EVENT_L = 868,
		icon_EVENT_M = 869,
		icon_EVENT_N = 870,
		icon_EVENT_O = 871,
		icon_EVENT_P = 872,
		icon_EVENT_Q = 873,
		icon_EVENT_R = 874,
		icon_EVENT_S = 875,
		icon_EVENT_T = 876,
		icon_EVENT_U = 877,
		icon_EVENT_V = 878,
		icon_EVENT_W = 879,
		icon_EVENT_X = 880,
		icon_EVENT_Y = 881,
		icon_EVENT_Z = 882,
		icon_EVENT_SHIFT = 883,
		icon_EVENT_CTRL = 884,
		icon_EVENT_ALT = 885,
		icon_EVENT_OS = 886,
		icon_EVENT_F1 = 887,
		icon_EVENT_F2 = 888,
		icon_EVENT_F3 = 889,
		icon_EVENT_F4 = 890,
		icon_EVENT_F5 = 891,
		icon_EVENT_F6 = 892,
		icon_EVENT_F7 = 893,
		icon_EVENT_F8 = 894,
		icon_EVENT_F9 = 895,
		icon_EVENT_F10 = 896,
		icon_EVENT_F11 = 897,
		icon_EVENT_F12 = 898,
		icon_EVENT_ESC = 899,
		icon_EVENT_TAB = 900,
		icon_EVENT_PAGEUP = 901,
		icon_EVENT_PAGEDOWN = 902,
		icon_EVENT_RETURN = 903,
	};
	inline icon_enum icon(void);
	inline void icon(icon_enum value);
	inline bool is_readonly(void);
	inline void is_readonly(bool value);
	inline bool is_animatable(void);
	inline void is_animatable(bool value);
	inline bool is_overridable(void);
	inline void is_overridable(bool value);
	inline bool is_required(void);
	inline void is_required(bool value);
	inline bool is_argument_optional(void);
	inline void is_argument_optional(bool value);
	inline bool is_never_none(void);
	inline void is_never_none(bool value);
	inline bool is_hidden(void);
	inline void is_hidden(bool value);
	inline bool is_skip_save(void);
	inline void is_skip_save(bool value);
	inline bool is_output(void);
	inline void is_output(bool value);
	inline bool is_registered(void);
	inline void is_registered(bool value);
	inline bool is_registered_optional(void);
	inline void is_registered_optional(bool value);
	inline bool is_runtime(void);
	inline void is_runtime(bool value);
	inline bool is_enum_flag(void);
	inline void is_enum_flag(bool value);
	inline bool is_library_editable(void);
	inline void is_library_editable(bool value);
	enum tags_enum {
	};
	inline tags_enum tags(void);
	inline void tags(tags_enum value);

};

/**************** Boolean Definition ****************/

class BoolProperty : public Property {
public:
	BoolProperty(const PointerRNA &ptr_arg) :
		Property(ptr_arg)
		{}

	inline bool default_value(void);
	inline void default_value(bool value);
	inline Array<bool, 3> default_array(void);
	inline void default_array(bool values[3]);
	inline int array_length(void);
	inline void array_length(int value);
	inline Array<int, 3> array_dimensions(void);
	inline void array_dimensions(int values[3]);
	inline bool is_array(void);
	inline void is_array(bool value);

};

/**************** Int Definition ****************/

class IntProperty : public Property {
public:
	IntProperty(const PointerRNA &ptr_arg) :
		Property(ptr_arg)
		{}

	inline int default_value(void);
	inline void default_value(int value);
	inline Array<int, 3> default_array(void);
	inline void default_array(int values[3]);
	inline int array_length(void);
	inline void array_length(int value);
	inline Array<int, 3> array_dimensions(void);
	inline void array_dimensions(int values[3]);
	inline bool is_array(void);
	inline void is_array(bool value);
	inline int hard_min(void);
	inline void hard_min(int value);
	inline int hard_max(void);
	inline void hard_max(int value);
	inline int soft_min(void);
	inline void soft_min(int value);
	inline int soft_max(void);
	inline void soft_max(int value);
	inline int step(void);
	inline void step(int value);

};

/**************** Float Definition ****************/

class FloatProperty : public Property {
public:
	FloatProperty(const PointerRNA &ptr_arg) :
		Property(ptr_arg)
		{}

	inline float default_value(void);
	inline void default_value(float value);
	inline Array<float, 3> default_array(void);
	inline void default_array(float values[3]);
	inline int array_length(void);
	inline void array_length(int value);
	inline Array<int, 3> array_dimensions(void);
	inline void array_dimensions(int values[3]);
	inline bool is_array(void);
	inline void is_array(bool value);
	inline float hard_min(void);
	inline void hard_min(float value);
	inline float hard_max(void);
	inline void hard_max(float value);
	inline float soft_min(void);
	inline void soft_min(float value);
	inline float soft_max(void);
	inline void soft_max(float value);
	inline float step(void);
	inline void step(float value);
	inline int precision(void);
	inline void precision(int value);

};

/**************** String Definition ****************/

class StringProperty : public Property {
public:
	StringProperty(const PointerRNA &ptr_arg) :
		Property(ptr_arg)
		{}

	inline std::string default_value(void);
	inline void default_value(const std::string& value);
	inline int length_max(void);
	inline void length_max(int value);

};

/**************** Enum Definition ****************/

class EnumProperty : public Property {
public:
	EnumProperty(const PointerRNA &ptr_arg) :
		Property(ptr_arg),
		enum_items(ptr_arg),
		enum_items_static(ptr_arg)
		{}

	enum default_value_enum {
		default_value_DUMMY = 0,
	};
	inline default_value_enum default_value(void);
	inline void default_value(default_value_enum value);
	enum default_flag_enum {
		default_flag_DUMMY = 0,
	};
	inline default_flag_enum default_flag(void);
	inline void default_flag(default_flag_enum value);
	COLLECTION_PROPERTY(DefaultCollectionFunctions, EnumPropertyItem, EnumProperty, enum_items, false, false, false)
	COLLECTION_PROPERTY(DefaultCollectionFunctions, EnumPropertyItem, EnumProperty, enum_items_static, false, false, false)

};

/**************** Enum Item Definition ****************/

class EnumPropertyItem : public Pointer {
public:
	EnumPropertyItem(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string name(void);
	inline void name(const std::string& value);
	inline std::string description(void);
	inline void description(const std::string& value);
	inline std::string identifier(void);
	inline void identifier(const std::string& value);
	inline int value(void);
	inline void value(int value);
	enum icon_enum {
		icon_NONE = 0,
		icon_QUESTION = 1,
		icon_ERROR = 2,
		icon_CANCEL = 3,
		icon_TRIA_RIGHT = 4,
		icon_TRIA_DOWN = 5,
		icon_TRIA_LEFT = 6,
		icon_TRIA_UP = 7,
		icon_ARROW_LEFTRIGHT = 8,
		icon_PLUS = 9,
		icon_DISCLOSURE_TRI_RIGHT = 10,
		icon_DISCLOSURE_TRI_DOWN = 11,
		icon_RADIOBUT_OFF = 12,
		icon_RADIOBUT_ON = 13,
		icon_MENU_PANEL = 14,
		icon_BLENDER = 15,
		icon_GRIP = 16,
		icon_DOT = 17,
		icon_COLLAPSEMENU = 18,
		icon_X = 19,
		icon_DUPLICATE = 20,
		icon_TRASH = 21,
		icon_NODE = 24,
		icon_NODE_SEL = 25,
		icon_WINDOW = 26,
		icon_WORKSPACE = 27,
		icon_RIGHTARROW_THIN = 28,
		icon_BORDERMOVE = 29,
		icon_VIEWZOOM = 30,
		icon_ADD = 31,
		icon_REMOVE = 32,
		icon_PANEL_CLOSE = 33,
		icon_COPY_ID = 34,
		icon_EYEDROPPER = 35,
		icon_AUTO = 37,
		icon_CHECKBOX_DEHLT = 38,
		icon_CHECKBOX_HLT = 39,
		icon_UNLOCKED = 40,
		icon_LOCKED = 41,
		icon_UNPINNED = 42,
		icon_PINNED = 43,
		icon_SCREEN_BACK = 44,
		icon_RIGHTARROW = 45,
		icon_DOWNARROW_HLT = 46,
		icon_PLUGIN = 51,
		icon_HELP = 52,
		icon_GHOST_ENABLED = 53,
		icon_COLOR = 54,
		icon_UNLINKED = 55,
		icon_LINKED = 56,
		icon_HAND = 57,
		icon_ZOOM_ALL = 58,
		icon_ZOOM_SELECTED = 59,
		icon_ZOOM_PREVIOUS = 60,
		icon_ZOOM_IN = 61,
		icon_ZOOM_OUT = 62,
		icon_DRIVER_DISTANCE = 63,
		icon_DRIVER_ROTATIONAL_DIFFERENCE = 64,
		icon_DRIVER_TRANSFORM = 65,
		icon_FREEZE = 66,
		icon_STYLUS_PRESSURE = 67,
		icon_GHOST_DISABLED = 68,
		icon_FILE_NEW = 69,
		icon_FILE_TICK = 70,
		icon_QUIT = 71,
		icon_URL = 72,
		icon_RECOVER_LAST = 73,
		icon_THREE_DOTS = 74,
		icon_FULLSCREEN_ENTER = 75,
		icon_FULLSCREEN_EXIT = 76,
		icon_LIGHT = 78,
		icon_MATERIAL = 79,
		icon_TEXTURE = 80,
		icon_ANIM = 81,
		icon_WORLD = 82,
		icon_SCENE = 83,
		icon_OUTPUT = 84,
		icon_SCRIPT = 87,
		icon_PARTICLES = 88,
		icon_PHYSICS = 89,
		icon_SPEAKER = 90,
		icon_TOOL_SETTINGS = 92,
		icon_SHADERFX = 93,
		icon_MODIFIER = 94,
		icon_BLANK1 = 101,
		icon_FAKE_USER_OFF = 102,
		icon_FAKE_USER_ON = 103,
		icon_VIEW3D = 104,
		icon_GRAPH = 105,
		icon_OUTLINER = 106,
		icon_PROPERTIES = 107,
		icon_FILEBROWSER = 108,
		icon_IMAGE = 109,
		icon_INFO = 110,
		icon_SEQUENCE = 111,
		icon_TEXT = 112,
		icon_SOUND = 114,
		icon_ACTION = 115,
		icon_NLA = 116,
		icon_PREFERENCES = 117,
		icon_TIME = 118,
		icon_NODETREE = 119,
		icon_CONSOLE = 121,
		icon_TRACKER = 123,
		icon_ASSET_MANAGER = 124,
		icon_NODE_COMPOSITING = 125,
		icon_NODE_TEXTURE = 126,
		icon_NODE_MATERIAL = 127,
		icon_UV = 128,
		icon_OBJECT_DATAMODE = 130,
		icon_EDITMODE_HLT = 131,
		icon_UV_DATA = 132,
		icon_VPAINT_HLT = 133,
		icon_TPAINT_HLT = 134,
		icon_WPAINT_HLT = 135,
		icon_SCULPTMODE_HLT = 136,
		icon_POSE_HLT = 137,
		icon_PARTICLEMODE = 138,
		icon_TRACKING = 146,
		icon_TRACKING_BACKWARDS = 147,
		icon_TRACKING_FORWARDS = 148,
		icon_TRACKING_BACKWARDS_SINGLE = 149,
		icon_TRACKING_FORWARDS_SINGLE = 150,
		icon_TRACKING_CLEAR_BACKWARDS = 151,
		icon_TRACKING_CLEAR_FORWARDS = 152,
		icon_TRACKING_REFINE_BACKWARDS = 153,
		icon_TRACKING_REFINE_FORWARDS = 154,
		icon_SCENE_DATA = 156,
		icon_RENDERLAYERS = 157,
		icon_WORLD_DATA = 158,
		icon_OBJECT_DATA = 159,
		icon_MESH_DATA = 160,
		icon_CURVE_DATA = 161,
		icon_META_DATA = 162,
		icon_LATTICE_DATA = 163,
		icon_LIGHT_DATA = 164,
		icon_MATERIAL_DATA = 165,
		icon_TEXTURE_DATA = 166,
		icon_ANIM_DATA = 167,
		icon_CAMERA_DATA = 168,
		icon_PARTICLE_DATA = 169,
		icon_LIBRARY_DATA_DIRECT = 170,
		icon_GROUP = 171,
		icon_ARMATURE_DATA = 172,
		icon_COMMUNITY = 173,
		icon_BONE_DATA = 174,
		icon_CONSTRAINT = 175,
		icon_SHAPEKEY_DATA = 176,
		icon_CONSTRAINT_BONE = 177,
		icon_CAMERA_STEREO = 178,
		icon_PACKAGE = 179,
		icon_UGLYPACKAGE = 180,
		icon_EXPERIMENTAL = 181,
		icon_BRUSH_DATA = 182,
		icon_IMAGE_DATA = 183,
		icon_FILE = 184,
		icon_FCURVE = 185,
		icon_FONT_DATA = 186,
		icon_RENDER_RESULT = 187,
		icon_SURFACE_DATA = 188,
		icon_EMPTY_DATA = 189,
		icon_PRESET = 190,
		icon_RENDER_ANIMATION = 191,
		icon_RENDER_STILL = 192,
		icon_LIBRARY_DATA_BROKEN = 193,
		icon_BOIDS = 194,
		icon_STRANDS = 195,
		icon_LIBRARY_DATA_INDIRECT = 196,
		icon_GREASEPENCIL = 197,
		icon_LINE_DATA = 198,
		icon_LIBRARY_DATA_OVERRIDE = 199,
		icon_GROUP_BONE = 200,
		icon_GROUP_VERTEX = 201,
		icon_GROUP_VCOL = 202,
		icon_GROUP_UVS = 203,
		icon_FACE_MAPS = 204,
		icon_RNA = 206,
		icon_RNA_ADD = 207,
		icon_MOUSE_LMB = 208,
		icon_MOUSE_MMB = 209,
		icon_MOUSE_RMB = 210,
		icon_MOUSE_MOVE = 211,
		icon_MOUSE_LMB_DRAG = 212,
		icon_MOUSE_MMB_DRAG = 213,
		icon_MOUSE_RMB_DRAG = 214,
		icon_PRESET_NEW = 216,
		icon_DECORATE = 218,
		icon_DECORATE_KEYFRAME = 219,
		icon_DECORATE_ANIMATE = 220,
		icon_DECORATE_DRIVER = 221,
		icon_DECORATE_LINKED = 222,
		icon_DECORATE_LIBRARY_OVERRIDE = 223,
		icon_DECORATE_UNLOCKED = 224,
		icon_DECORATE_LOCKED = 225,
		icon_DECORATE_OVERRIDE = 226,
		icon_TRACKER_DATA = 228,
		icon_HEART = 229,
		icon_ORPHAN_DATA = 230,
		icon_USER = 231,
		icon_SYSTEM = 232,
		icon_SETTINGS = 233,
		icon_OUTLINER_OB_EMPTY = 234,
		icon_OUTLINER_OB_MESH = 235,
		icon_OUTLINER_OB_CURVE = 236,
		icon_OUTLINER_OB_LATTICE = 237,
		icon_OUTLINER_OB_META = 238,
		icon_OUTLINER_OB_LIGHT = 239,
		icon_OUTLINER_OB_CAMERA = 240,
		icon_OUTLINER_OB_ARMATURE = 241,
		icon_OUTLINER_OB_FONT = 242,
		icon_OUTLINER_OB_SURFACE = 243,
		icon_OUTLINER_OB_SPEAKER = 244,
		icon_OUTLINER_OB_FORCE_FIELD = 245,
		icon_OUTLINER_OB_GROUP_INSTANCE = 246,
		icon_OUTLINER_OB_GREASEPENCIL = 247,
		icon_OUTLINER_OB_LIGHTPROBE = 248,
		icon_OUTLINER_OB_IMAGE = 249,
		icon_RESTRICT_COLOR_OFF = 251,
		icon_RESTRICT_COLOR_ON = 252,
		icon_HIDE_ON = 253,
		icon_HIDE_OFF = 254,
		icon_RESTRICT_SELECT_ON = 255,
		icon_RESTRICT_SELECT_OFF = 256,
		icon_RESTRICT_RENDER_ON = 257,
		icon_RESTRICT_RENDER_OFF = 258,
		icon_OUTLINER_DATA_EMPTY = 260,
		icon_OUTLINER_DATA_MESH = 261,
		icon_OUTLINER_DATA_CURVE = 262,
		icon_OUTLINER_DATA_LATTICE = 263,
		icon_OUTLINER_DATA_META = 264,
		icon_OUTLINER_DATA_LIGHT = 265,
		icon_OUTLINER_DATA_CAMERA = 266,
		icon_OUTLINER_DATA_ARMATURE = 267,
		icon_OUTLINER_DATA_FONT = 268,
		icon_OUTLINER_DATA_SURFACE = 269,
		icon_OUTLINER_DATA_SPEAKER = 270,
		icon_OUTLINER_DATA_GREASEPENCIL = 273,
		icon_GP_SELECT_POINTS = 274,
		icon_GP_SELECT_STROKES = 275,
		icon_GP_MULTIFRAME_EDITING = 276,
		icon_GP_ONLY_SELECTED = 277,
		icon_GP_SELECT_BETWEEN_STROKES = 278,
		icon_MODIFIER_OFF = 279,
		icon_MODIFIER_ON = 280,
		icon_ONIONSKIN_OFF = 281,
		icon_ONIONSKIN_ON = 282,
		icon_RESTRICT_VIEW_ON = 283,
		icon_RESTRICT_VIEW_OFF = 284,
		icon_MESH_PLANE = 286,
		icon_MESH_CUBE = 287,
		icon_MESH_CIRCLE = 288,
		icon_MESH_UVSPHERE = 289,
		icon_MESH_ICOSPHERE = 290,
		icon_MESH_GRID = 291,
		icon_MESH_MONKEY = 292,
		icon_MESH_CYLINDER = 293,
		icon_MESH_TORUS = 294,
		icon_MESH_CONE = 295,
		icon_MESH_CAPSULE = 296,
		icon_EMPTY_SINGLE_ARROW = 297,
		icon_LIGHT_POINT = 298,
		icon_LIGHT_SUN = 299,
		icon_LIGHT_SPOT = 300,
		icon_LIGHT_HEMI = 301,
		icon_LIGHT_AREA = 302,
		icon_CUBE = 303,
		icon_SPHERE = 304,
		icon_CONE = 305,
		icon_META_PLANE = 306,
		icon_META_CUBE = 307,
		icon_META_BALL = 308,
		icon_META_ELLIPSOID = 309,
		icon_META_CAPSULE = 310,
		icon_SURFACE_NCURVE = 312,
		icon_SURFACE_NCIRCLE = 313,
		icon_SURFACE_NSURFACE = 314,
		icon_SURFACE_NCYLINDER = 315,
		icon_SURFACE_NSPHERE = 316,
		icon_SURFACE_NTORUS = 317,
		icon_EMPTY_AXIS = 318,
		icon_STROKE = 319,
		icon_EMPTY_ARROWS = 320,
		icon_CURVE_BEZCURVE = 321,
		icon_CURVE_BEZCIRCLE = 322,
		icon_CURVE_NCURVE = 323,
		icon_CURVE_NCIRCLE = 324,
		icon_CURVE_PATH = 325,
		icon_LIGHTPROBE_CUBEMAP = 326,
		icon_LIGHTPROBE_PLANAR = 327,
		icon_LIGHTPROBE_GRID = 328,
		icon_COLOR_RED = 331,
		icon_COLOR_GREEN = 332,
		icon_COLOR_BLUE = 333,
		icon_TRIA_RIGHT_BAR = 334,
		icon_TRIA_DOWN_BAR = 335,
		icon_TRIA_LEFT_BAR = 336,
		icon_TRIA_UP_BAR = 337,
		icon_FORCE_FORCE = 338,
		icon_FORCE_WIND = 339,
		icon_FORCE_VORTEX = 340,
		icon_FORCE_MAGNETIC = 341,
		icon_FORCE_HARMONIC = 342,
		icon_FORCE_CHARGE = 343,
		icon_FORCE_LENNARDJONES = 344,
		icon_FORCE_TEXTURE = 345,
		icon_FORCE_CURVE = 346,
		icon_FORCE_BOID = 347,
		icon_FORCE_TURBULENCE = 348,
		icon_FORCE_DRAG = 349,
		icon_FORCE_SMOKEFLOW = 350,
		icon_IMAGE_PLANE = 361,
		icon_IMAGE_BACKGROUND = 362,
		icon_IMAGE_REFERENCE = 363,
		icon_NODE_INSERT_ON = 367,
		icon_NODE_INSERT_OFF = 368,
		icon_NODE_TOP = 369,
		icon_NODE_SIDE = 370,
		icon_NODE_CORNER = 371,
		icon_ALIGN_LEFT = 390,
		icon_ALIGN_CENTER = 391,
		icon_ALIGN_RIGHT = 392,
		icon_ALIGN_JUSTIFY = 393,
		icon_ALIGN_FLUSH = 394,
		icon_ALIGN_TOP = 395,
		icon_ALIGN_MIDDLE = 396,
		icon_ALIGN_BOTTOM = 397,
		icon_BOLD = 398,
		icon_ITALIC = 399,
		icon_UNDERLINE = 400,
		icon_SMALL_CAPS = 401,
		icon_MODIFIER_DATA = 442,
		icon_MOD_WAVE = 443,
		icon_MOD_BUILD = 444,
		icon_MOD_DECIM = 445,
		icon_MOD_MIRROR = 446,
		icon_MOD_SOFT = 447,
		icon_MOD_SUBSURF = 448,
		icon_HOOK = 449,
		icon_MOD_PHYSICS = 450,
		icon_MOD_PARTICLES = 451,
		icon_MOD_BOOLEAN = 452,
		icon_MOD_EDGESPLIT = 453,
		icon_MOD_ARRAY = 454,
		icon_MOD_UVPROJECT = 455,
		icon_MOD_DISPLACE = 456,
		icon_MOD_CURVE = 457,
		icon_MOD_LATTICE = 458,
		icon_MOD_TINT = 459,
		icon_MOD_ARMATURE = 460,
		icon_MOD_SHRINKWRAP = 461,
		icon_MOD_CAST = 462,
		icon_MOD_MESHDEFORM = 463,
		icon_MOD_BEVEL = 464,
		icon_MOD_SMOOTH = 465,
		icon_MOD_SIMPLEDEFORM = 466,
		icon_MOD_MASK = 467,
		icon_MOD_CLOTH = 468,
		icon_MOD_EXPLODE = 469,
		icon_MOD_FLUIDSIM = 470,
		icon_MOD_MULTIRES = 471,
		icon_MOD_SMOKE = 472,
		icon_MOD_SOLIDIFY = 473,
		icon_MOD_SCREW = 474,
		icon_MOD_VERTEX_WEIGHT = 475,
		icon_MOD_DYNAMICPAINT = 476,
		icon_MOD_REMESH = 477,
		icon_MOD_OCEAN = 478,
		icon_MOD_WARP = 479,
		icon_MOD_SKIN = 480,
		icon_MOD_TRIANGULATE = 481,
		icon_MOD_WIREFRAME = 482,
		icon_MOD_DATA_TRANSFER = 483,
		icon_MOD_NORMALEDIT = 484,
		icon_MOD_PARTICLE_INSTANCE = 485,
		icon_MOD_HUE_SATURATION = 486,
		icon_MOD_NOISE = 487,
		icon_MOD_OFFSET = 488,
		icon_MOD_SIMPLIFY = 489,
		icon_MOD_THICKNESS = 490,
		icon_MOD_INSTANCE = 491,
		icon_MOD_TIME = 492,
		icon_MOD_OPACITY = 493,
		icon_REC = 494,
		icon_PLAY = 495,
		icon_FF = 496,
		icon_REW = 497,
		icon_PAUSE = 498,
		icon_PREV_KEYFRAME = 499,
		icon_NEXT_KEYFRAME = 500,
		icon_PLAY_SOUND = 501,
		icon_PLAY_REVERSE = 502,
		icon_PREVIEW_RANGE = 503,
		icon_ACTION_TWEAK = 504,
		icon_PMARKER_ACT = 505,
		icon_PMARKER_SEL = 506,
		icon_PMARKER = 507,
		icon_MARKER_HLT = 508,
		icon_MARKER = 509,
		icon_KEYFRAME_HLT = 510,
		icon_KEYFRAME = 511,
		icon_KEYINGSET = 512,
		icon_KEY_DEHLT = 513,
		icon_KEY_HLT = 514,
		icon_MUTE_IPO_OFF = 515,
		icon_MUTE_IPO_ON = 516,
		icon_VISIBLE_IPO_OFF = 517,
		icon_VISIBLE_IPO_ON = 518,
		icon_DRIVER = 519,
		icon_SOLO_OFF = 520,
		icon_SOLO_ON = 521,
		icon_FRAME_PREV = 522,
		icon_FRAME_NEXT = 523,
		icon_NLA_PUSHDOWN = 524,
		icon_IPO_CONSTANT = 525,
		icon_IPO_LINEAR = 526,
		icon_IPO_BEZIER = 527,
		icon_IPO_SINE = 528,
		icon_IPO_QUAD = 529,
		icon_IPO_CUBIC = 530,
		icon_IPO_QUART = 531,
		icon_IPO_QUINT = 532,
		icon_IPO_EXPO = 533,
		icon_IPO_CIRC = 534,
		icon_IPO_BOUNCE = 535,
		icon_IPO_ELASTIC = 536,
		icon_IPO_BACK = 537,
		icon_IPO_EASE_IN = 538,
		icon_IPO_EASE_OUT = 539,
		icon_IPO_EASE_IN_OUT = 540,
		icon_NORMALIZE_FCURVES = 541,
		icon_VERTEXSEL = 546,
		icon_EDGESEL = 547,
		icon_FACESEL = 548,
		icon_PIVOT_BOUNDBOX = 551,
		icon_PIVOT_CURSOR = 552,
		icon_PIVOT_INDIVIDUAL = 553,
		icon_PIVOT_MEDIAN = 554,
		icon_PIVOT_ACTIVE = 555,
		icon_CENTER_ONLY = 556,
		icon_ROOTCURVE = 557,
		icon_SMOOTHCURVE = 558,
		icon_SPHERECURVE = 559,
		icon_INVERSESQUARECURVE = 560,
		icon_SHARPCURVE = 561,
		icon_LINCURVE = 562,
		icon_NOCURVE = 563,
		icon_RNDCURVE = 564,
		icon_PROP_OFF = 565,
		icon_PROP_ON = 566,
		icon_PROP_CON = 567,
		icon_PROP_PROJECTED = 568,
		icon_PARTICLE_POINT = 569,
		icon_PARTICLE_TIP = 570,
		icon_PARTICLE_PATH = 571,
		icon_SNAP_OFF = 576,
		icon_SNAP_ON = 577,
		icon_SNAP_NORMAL = 578,
		icon_SNAP_GRID = 579,
		icon_SNAP_VERTEX = 580,
		icon_SNAP_EDGE = 581,
		icon_SNAP_FACE = 582,
		icon_SNAP_VOLUME = 583,
		icon_SNAP_INCREMENT = 584,
		icon_STICKY_UVS_LOC = 585,
		icon_STICKY_UVS_DISABLE = 586,
		icon_STICKY_UVS_VERT = 587,
		icon_CLIPUV_DEHLT = 588,
		icon_CLIPUV_HLT = 589,
		icon_SNAP_PEEL_OBJECT = 590,
		icon_GRID = 591,
		icon_OBJECT_ORIGIN = 592,
		icon_ORIENTATION_GLOBAL = 593,
		icon_ORIENTATION_GIMBAL = 594,
		icon_ORIENTATION_LOCAL = 595,
		icon_ORIENTATION_NORMAL = 596,
		icon_ORIENTATION_VIEW = 597,
		icon_COPYDOWN = 598,
		icon_PASTEDOWN = 599,
		icon_PASTEFLIPUP = 600,
		icon_PASTEFLIPDOWN = 601,
		icon_VIS_SEL_11 = 602,
		icon_VIS_SEL_10 = 603,
		icon_VIS_SEL_01 = 604,
		icon_VIS_SEL_00 = 605,
		icon_AUTOMERGE_ON = 607,
		icon_AUTOMERGE_OFF = 608,
		icon_UV_VERTEXSEL = 610,
		icon_UV_EDGESEL = 611,
		icon_UV_FACESEL = 612,
		icon_UV_ISLANDSEL = 613,
		icon_UV_SYNC_SELECT = 614,
		icon_ORIENTATION_CURSOR = 620,
		icon_NORMALS_VERTEX = 621,
		icon_NORMALS_FACE = 622,
		icon_NORMALS_VERTEX_FACE = 623,
		icon_SHADING_BBOX = 624,
		icon_SHADING_WIRE = 625,
		icon_SHADING_SOLID = 626,
		icon_SHADING_RENDERED = 627,
		icon_SHADING_TEXTURE = 628,
		icon_OVERLAY = 629,
		icon_XRAY = 630,
		icon_LOCKVIEW_OFF = 633,
		icon_LOCKVIEW_ON = 634,
		icon_AXIS_SIDE = 636,
		icon_AXIS_FRONT = 637,
		icon_AXIS_TOP = 638,
		icon_NDOF_DOM = 639,
		icon_NDOF_TURN = 640,
		icon_NDOF_FLY = 641,
		icon_NDOF_TRANS = 642,
		icon_LAYER_USED = 643,
		icon_LAYER_ACTIVE = 644,
		icon_SORTALPHA = 676,
		icon_SORTBYEXT = 677,
		icon_SORTTIME = 678,
		icon_SORTSIZE = 679,
		icon_SHORTDISPLAY = 680,
		icon_LONGDISPLAY = 681,
		icon_IMGDISPLAY = 683,
		icon_BOOKMARKS = 686,
		icon_FONTPREVIEW = 687,
		icon_FILTER = 688,
		icon_NEWFOLDER = 689,
		icon_FILE_PARENT = 691,
		icon_FILE_REFRESH = 692,
		icon_FILE_FOLDER = 693,
		icon_FILE_BLANK = 694,
		icon_FILE_BLEND = 695,
		icon_FILE_IMAGE = 696,
		icon_FILE_MOVIE = 697,
		icon_FILE_SCRIPT = 698,
		icon_FILE_SOUND = 699,
		icon_FILE_FONT = 700,
		icon_FILE_TEXT = 701,
		icon_SORT_DESC = 702,
		icon_SORT_ASC = 703,
		icon_LINK_BLEND = 704,
		icon_APPEND_BLEND = 705,
		icon_IMPORT = 706,
		icon_EXPORT = 707,
		icon_LOOP_BACK = 715,
		icon_LOOP_FORWARDS = 716,
		icon_BACK = 717,
		icon_FORWARD = 718,
		icon_FILE_VOLUME = 722,
		icon_ALEMBIC = 723,
		icon_VOLUME = 724,
		icon_FILE_HIDDEN = 725,
		icon_FILE_BACKUP = 726,
		icon_DISK_DRIVE = 727,
		icon_MATPLANE = 728,
		icon_MATSPHERE = 729,
		icon_MATCUBE = 730,
		icon_MONKEY = 731,
		icon_HAIR = 732,
		icon_ALIASED = 733,
		icon_ANTIALIASED = 734,
		icon_MAT_SPHERE_SKY = 735,
		icon_MATSHADERBALL = 736,
		icon_MATCLOTH = 737,
		icon_MATFLUID = 738,
		icon_WORDWRAP_OFF = 740,
		icon_WORDWRAP_ON = 741,
		icon_SYNTAX_OFF = 742,
		icon_SYNTAX_ON = 743,
		icon_LINENUMBERS_OFF = 744,
		icon_LINENUMBERS_ON = 745,
		icon_SCRIPTPLUGINS = 746,
		icon_SEQ_SEQUENCER = 754,
		icon_SEQ_PREVIEW = 755,
		icon_SEQ_LUMA_WAVEFORM = 756,
		icon_SEQ_CHROMA_SCOPE = 757,
		icon_SEQ_HISTOGRAM = 758,
		icon_SEQ_SPLITVIEW = 759,
		icon_IMAGE_RGB = 763,
		icon_IMAGE_RGB_ALPHA = 764,
		icon_IMAGE_ALPHA = 765,
		icon_IMAGE_ZDEPTH = 766,
		icon_VIEW_PERSPECTIVE = 775,
		icon_VIEW_ORTHO = 776,
		icon_VIEW_CAMERA = 777,
		icon_VIEW_PAN = 778,
		icon_VIEW_ZOOM = 779,
		icon_BRUSH_BLOB = 780,
		icon_BRUSH_BLUR = 781,
		icon_BRUSH_CLAY = 782,
		icon_BRUSH_CLAY_STRIPS = 783,
		icon_BRUSH_CLONE = 784,
		icon_BRUSH_CREASE = 785,
		icon_BRUSH_FILL = 786,
		icon_BRUSH_FLATTEN = 787,
		icon_BRUSH_GRAB = 788,
		icon_BRUSH_INFLATE = 789,
		icon_BRUSH_LAYER = 790,
		icon_BRUSH_MASK = 791,
		icon_BRUSH_MIX = 792,
		icon_BRUSH_NUDGE = 793,
		icon_BRUSH_PINCH = 794,
		icon_BRUSH_SCRAPE = 795,
		icon_BRUSH_SCULPT_DRAW = 796,
		icon_BRUSH_SMEAR = 797,
		icon_BRUSH_SMOOTH = 798,
		icon_BRUSH_SNAKE_HOOK = 799,
		icon_BRUSH_SOFTEN = 800,
		icon_BRUSH_TEXDRAW = 801,
		icon_BRUSH_TEXFILL = 802,
		icon_BRUSH_TEXMASK = 803,
		icon_BRUSH_THUMB = 804,
		icon_BRUSH_ROTATE = 805,
		icon_GPBRUSH_SMOOTH = 806,
		icon_GPBRUSH_THICKNESS = 807,
		icon_GPBRUSH_STRENGTH = 808,
		icon_GPBRUSH_GRAB = 809,
		icon_GPBRUSH_PUSH = 810,
		icon_GPBRUSH_TWIST = 811,
		icon_GPBRUSH_PINCH = 812,
		icon_GPBRUSH_RANDOMIZE = 813,
		icon_GPBRUSH_CLONE = 814,
		icon_GPBRUSH_WEIGHT = 815,
		icon_GPBRUSH_PENCIL = 816,
		icon_GPBRUSH_PEN = 817,
		icon_GPBRUSH_INK = 818,
		icon_GPBRUSH_INKNOISE = 819,
		icon_GPBRUSH_BLOCK = 820,
		icon_GPBRUSH_MARKER = 821,
		icon_GPBRUSH_FILL = 822,
		icon_GPBRUSH_ERASE_SOFT = 823,
		icon_GPBRUSH_ERASE_HARD = 824,
		icon_GPBRUSH_ERASE_STROKE = 825,
		icon_SMALL_TRI_RIGHT_VEC = 826,
		icon_KEYTYPE_KEYFRAME_VEC = 827,
		icon_KEYTYPE_BREAKDOWN_VEC = 828,
		icon_KEYTYPE_EXTREME_VEC = 829,
		icon_KEYTYPE_JITTER_VEC = 830,
		icon_KEYTYPE_MOVING_HOLD_VEC = 831,
		icon_HANDLETYPE_FREE_VEC = 832,
		icon_HANDLETYPE_ALIGNED_VEC = 833,
		icon_HANDLETYPE_VECTOR_VEC = 834,
		icon_HANDLETYPE_AUTO_VEC = 835,
		icon_HANDLETYPE_AUTO_CLAMP_VEC = 836,
		icon_COLORSET_01_VEC = 837,
		icon_COLORSET_02_VEC = 838,
		icon_COLORSET_03_VEC = 839,
		icon_COLORSET_04_VEC = 840,
		icon_COLORSET_05_VEC = 841,
		icon_COLORSET_06_VEC = 842,
		icon_COLORSET_07_VEC = 843,
		icon_COLORSET_08_VEC = 844,
		icon_COLORSET_09_VEC = 845,
		icon_COLORSET_10_VEC = 846,
		icon_COLORSET_11_VEC = 847,
		icon_COLORSET_12_VEC = 848,
		icon_COLORSET_13_VEC = 849,
		icon_COLORSET_14_VEC = 850,
		icon_COLORSET_15_VEC = 851,
		icon_COLORSET_16_VEC = 852,
		icon_COLORSET_17_VEC = 853,
		icon_COLORSET_18_VEC = 854,
		icon_COLORSET_19_VEC = 855,
		icon_COLORSET_20_VEC = 856,
		icon_EVENT_A = 857,
		icon_EVENT_B = 858,
		icon_EVENT_C = 859,
		icon_EVENT_D = 860,
		icon_EVENT_E = 861,
		icon_EVENT_F = 862,
		icon_EVENT_G = 863,
		icon_EVENT_H = 864,
		icon_EVENT_I = 865,
		icon_EVENT_J = 866,
		icon_EVENT_K = 867,
		icon_EVENT_L = 868,
		icon_EVENT_M = 869,
		icon_EVENT_N = 870,
		icon_EVENT_O = 871,
		icon_EVENT_P = 872,
		icon_EVENT_Q = 873,
		icon_EVENT_R = 874,
		icon_EVENT_S = 875,
		icon_EVENT_T = 876,
		icon_EVENT_U = 877,
		icon_EVENT_V = 878,
		icon_EVENT_W = 879,
		icon_EVENT_X = 880,
		icon_EVENT_Y = 881,
		icon_EVENT_Z = 882,
		icon_EVENT_SHIFT = 883,
		icon_EVENT_CTRL = 884,
		icon_EVENT_ALT = 885,
		icon_EVENT_OS = 886,
		icon_EVENT_F1 = 887,
		icon_EVENT_F2 = 888,
		icon_EVENT_F3 = 889,
		icon_EVENT_F4 = 890,
		icon_EVENT_F5 = 891,
		icon_EVENT_F6 = 892,
		icon_EVENT_F7 = 893,
		icon_EVENT_F8 = 894,
		icon_EVENT_F9 = 895,
		icon_EVENT_F10 = 896,
		icon_EVENT_F11 = 897,
		icon_EVENT_F12 = 898,
		icon_EVENT_ESC = 899,
		icon_EVENT_TAB = 900,
		icon_EVENT_PAGEUP = 901,
		icon_EVENT_PAGEDOWN = 902,
		icon_EVENT_RETURN = 903,
	};
	inline icon_enum icon(void);
	inline void icon(icon_enum value);

};

/**************** Pointer Definition ****************/

class PointerProperty : public Property {
public:
	PointerProperty(const PointerRNA &ptr_arg) :
		Property(ptr_arg)
		{}

	inline Struct fixed_type(void);

};

/**************** Collection Definition ****************/

class CollectionProperty : public Property {
public:
	CollectionProperty(const PointerRNA &ptr_arg) :
		Property(ptr_arg)
		{}

	inline Struct fixed_type(void);

};

/**************** Function Definition ****************/

class Function : public Pointer {
public:
	Function(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		parameters(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string identifier(void);
	inline void identifier(const std::string& value);
	inline std::string description(void);
	inline void description(const std::string& value);
	COLLECTION_PROPERTY(DefaultCollectionFunctions, Property, Function, parameters, false, false, false)
	inline bool is_registered(void);
	inline void is_registered(bool value);
	inline bool is_registered_optional(void);
	inline void is_registered_optional(bool value);
	inline bool use_self(void);
	inline void use_self(bool value);
	inline bool use_self_type(void);
	inline void use_self_type(bool value);

};

/**************** Blender RNA ****************/

class BlenderRNA : public Pointer {
public:
	BlenderRNA(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		structs(ptr_arg)
		{}

	inline Struct rna_type(void);
	COLLECTION_PROPERTY(DefaultCollectionFunctions, Struct, BlenderRNA, structs, true, true, true)

};

/**************** Unknown Type ****************/

class UnknownType : public Pointer {
public:
	UnknownType(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

};

/**************** Any Type ****************/

class AnyType : public Pointer {
public:
	AnyType(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

};

/**************** ID ****************/

class ID : public Pointer {
public:
	ID(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string name(void);
	inline void name(const std::string& value);
	inline std::string name_full(void);
	inline void name_full(const std::string& value);
	inline bool is_evaluated(void);
	inline void is_evaluated(bool value);
	inline ID original(void);
	inline int users(void);
	inline void users(int value);
	inline bool use_fake_user(void);
	inline void use_fake_user(bool value);
	inline bool tag(void);
	inline void tag(bool value);
	inline bool is_library_indirect(void);
	inline void is_library_indirect(bool value);
	inline Library library(void);
	inline IDOverrideStatic override_static(void);
	inline ImagePreview preview(void);

	inline ID copy(void *main);
	inline ID override_create(void *main);
	inline void user_clear();
	inline void user_remap(void *main, ID& new_id);
	inline ID make_local(void *main, bool clear_proxy);
	inline int user_of_id(ID& id);
	inline AnimData animation_data_create(void *main);
	inline void animation_data_clear(void *main);
	inline void update_tag(int refresh);
};

/**************** ID Static Override ****************/

class IDOverrideStatic : public Pointer {
public:
	IDOverrideStatic(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		properties(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline ID reference(void);
	inline bool auto_generate(void);
	inline void auto_generate(bool value);
	COLLECTION_PROPERTY(DefaultCollectionFunctions, IDOverrideStaticProperty, IDOverrideStatic, properties, false, true, false)

};

/**************** ID Static Override Property ****************/

class IDOverrideStaticProperty : public Pointer {
public:
	IDOverrideStaticProperty(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		operations(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string rna_path(void);
	inline void rna_path(const std::string& value);
	COLLECTION_PROPERTY(DefaultCollectionFunctions, IDOverrideStaticPropertyOperation, IDOverrideStaticProperty, operations, false, true, false)

};

/**************** ID Static Override Property Operation ****************/

class IDOverrideStaticPropertyOperation : public Pointer {
public:
	IDOverrideStaticPropertyOperation(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	enum operation_enum {
		operation_NOOP = 0,
		operation_REPLACE = 1,
		operation_DIFF_ADD = 101,
		operation_DIFF_SUB = 102,
		operation_FACT_MULTIPLY = 103,
		operation_INSERT_AFTER = 201,
		operation_INSERT_BEFORE = 202,
	};
	inline operation_enum operation(void);
	inline void operation(operation_enum value);
	enum flag_enum {
		flag_MANDATORY = 1,
		flag_LOCKED = 2,
	};
	inline flag_enum flag(void);
	inline void flag(flag_enum value);
	inline std::string subitem_reference_name(void);
	inline void subitem_reference_name(const std::string& value);
	inline std::string subitem_local_name(void);
	inline void subitem_local_name(const std::string& value);
	inline int subitem_reference_index(void);
	inline void subitem_reference_index(int value);
	inline int subitem_local_index(void);
	inline void subitem_local_index(int value);

};

/**************** Image Preview ****************/

class ImagePreview : public Pointer {
public:
	ImagePreview(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline bool is_image_custom(void);
	inline void is_image_custom(bool value);
	inline Array<int, 2> image_size(void);
	inline void image_size(int values[2]);
	inline DynamicArray<int> image_pixels(void);
	inline void image_pixels(int values[]);
	inline DynamicArray<float> image_pixels_float(void);
	inline void image_pixels_float(float values[]);
	inline bool is_icon_custom(void);
	inline void is_icon_custom(bool value);
	inline Array<int, 2> icon_size(void);
	inline void icon_size(int values[2]);
	inline DynamicArray<int> icon_pixels(void);
	inline void icon_pixels(int values[]);
	inline DynamicArray<float> icon_pixels_float(void);
	inline void icon_pixels_float(float values[]);
	inline int icon_id(void);
	inline void icon_id(int value);

	inline void reload();
};

/**************** ID Property ****************/

class PropertyGroupItem : public Pointer {
public:
	PropertyGroupItem(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

};

/**************** ID Property Group ****************/

class PropertyGroup : public Pointer {
public:
	PropertyGroup(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

};

/**************** Library ****************/

class Library : public ID {
public:
	Library(const PointerRNA &ptr_arg) :
		ID(ptr_arg)
		{}

	inline std::string filepath(void);
	inline void filepath(const std::string& value);
	inline Library parent(void);
	inline PackedFile packed_file(void);
	inline Array<int, 3> version(void);
	inline void version(int values[3]);

	inline void reload(Context C);
};

/**************** IDPropertyWrapPtr ****************/

class IDPropertyWrapPtr : public Pointer {
public:
	IDPropertyWrapPtr(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

};

/**************** Texture ****************/

class Texture : public ID {
public:
	Texture(const PointerRNA &ptr_arg) :
		ID(ptr_arg)
		{}

	enum type_enum {
		type_NONE = 0,
		type_BLEND = 5,
		type_CLOUDS = 1,
		type_DISTORTED_NOISE = 13,
		type_IMAGE = 8,
		type_MAGIC = 4,
		type_MARBLE = 3,
		type_MUSGRAVE = 11,
		type_NOISE = 7,
		type_STUCCI = 6,
		type_VORONOI = 12,
		type_WOOD = 2,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	inline bool use_clamp(void);
	inline void use_clamp(bool value);
	inline bool use_color_ramp(void);
	inline void use_color_ramp(bool value);
	inline ColorRamp color_ramp(void);
	inline float intensity(void);
	inline void intensity(float value);
	inline float contrast(void);
	inline void contrast(float value);
	inline float saturation(void);
	inline void saturation(float value);
	inline float factor_red(void);
	inline void factor_red(float value);
	inline float factor_green(void);
	inline void factor_green(float value);
	inline float factor_blue(void);
	inline void factor_blue(float value);
	inline bool use_preview_alpha(void);
	inline void use_preview_alpha(bool value);
	inline bool use_nodes(void);
	inline void use_nodes(bool value);
	inline NodeTree node_tree(void);
	inline AnimData animation_data(void);

	inline void evaluate(float value[3], float result[4]);
};

/**************** Clouds Texture ****************/

class CloudsTexture : public Texture {
public:
	CloudsTexture(const PointerRNA &ptr_arg) :
		Texture(ptr_arg)
		{}

	inline float noise_scale(void);
	inline void noise_scale(float value);
	inline int noise_depth(void);
	inline void noise_depth(int value);
	enum noise_basis_enum {
		noise_basis_BLENDER_ORIGINAL = 0,
		noise_basis_ORIGINAL_PERLIN = 1,
		noise_basis_IMPROVED_PERLIN = 2,
		noise_basis_VORONOI_F1 = 3,
		noise_basis_VORONOI_F2 = 4,
		noise_basis_VORONOI_F3 = 5,
		noise_basis_VORONOI_F4 = 6,
		noise_basis_VORONOI_F2_F1 = 7,
		noise_basis_VORONOI_CRACKLE = 8,
		noise_basis_CELL_NOISE = 14,
	};
	inline noise_basis_enum noise_basis(void);
	inline void noise_basis(noise_basis_enum value);
	enum noise_type_enum {
		noise_type_SOFT_NOISE = 0,
		noise_type_HARD_NOISE = 1,
	};
	inline noise_type_enum noise_type(void);
	inline void noise_type(noise_type_enum value);
	enum cloud_type_enum {
		cloud_type_GRAYSCALE = 0,
		cloud_type_COLOR = 1,
	};
	inline cloud_type_enum cloud_type(void);
	inline void cloud_type(cloud_type_enum value);
	inline float nabla(void);
	inline void nabla(float value);

};

/**************** Wood Texture ****************/

class WoodTexture : public Texture {
public:
	WoodTexture(const PointerRNA &ptr_arg) :
		Texture(ptr_arg)
		{}

	inline float noise_scale(void);
	inline void noise_scale(float value);
	inline float turbulence(void);
	inline void turbulence(float value);
	enum noise_basis_enum {
		noise_basis_BLENDER_ORIGINAL = 0,
		noise_basis_ORIGINAL_PERLIN = 1,
		noise_basis_IMPROVED_PERLIN = 2,
		noise_basis_VORONOI_F1 = 3,
		noise_basis_VORONOI_F2 = 4,
		noise_basis_VORONOI_F3 = 5,
		noise_basis_VORONOI_F4 = 6,
		noise_basis_VORONOI_F2_F1 = 7,
		noise_basis_VORONOI_CRACKLE = 8,
		noise_basis_CELL_NOISE = 14,
	};
	inline noise_basis_enum noise_basis(void);
	inline void noise_basis(noise_basis_enum value);
	enum noise_type_enum {
		noise_type_SOFT_NOISE = 0,
		noise_type_HARD_NOISE = 1,
	};
	inline noise_type_enum noise_type(void);
	inline void noise_type(noise_type_enum value);
	enum wood_type_enum {
		wood_type_BANDS = 0,
		wood_type_RINGS = 1,
		wood_type_BANDNOISE = 2,
		wood_type_RINGNOISE = 3,
	};
	inline wood_type_enum wood_type(void);
	inline void wood_type(wood_type_enum value);
	enum noise_basis_2_enum {
		noise_basis_2_SIN = 0,
		noise_basis_2_SAW = 1,
		noise_basis_2_TRI = 2,
	};
	inline noise_basis_2_enum noise_basis_2(void);
	inline void noise_basis_2(noise_basis_2_enum value);
	inline float nabla(void);
	inline void nabla(float value);

};

/**************** Marble Texture ****************/

class MarbleTexture : public Texture {
public:
	MarbleTexture(const PointerRNA &ptr_arg) :
		Texture(ptr_arg)
		{}

	inline float noise_scale(void);
	inline void noise_scale(float value);
	inline float turbulence(void);
	inline void turbulence(float value);
	inline int noise_depth(void);
	inline void noise_depth(int value);
	enum noise_type_enum {
		noise_type_SOFT_NOISE = 0,
		noise_type_HARD_NOISE = 1,
	};
	inline noise_type_enum noise_type(void);
	inline void noise_type(noise_type_enum value);
	enum marble_type_enum {
		marble_type_SOFT = 0,
		marble_type_SHARP = 1,
		marble_type_SHARPER = 2,
	};
	inline marble_type_enum marble_type(void);
	inline void marble_type(marble_type_enum value);
	enum noise_basis_enum {
		noise_basis_BLENDER_ORIGINAL = 0,
		noise_basis_ORIGINAL_PERLIN = 1,
		noise_basis_IMPROVED_PERLIN = 2,
		noise_basis_VORONOI_F1 = 3,
		noise_basis_VORONOI_F2 = 4,
		noise_basis_VORONOI_F3 = 5,
		noise_basis_VORONOI_F4 = 6,
		noise_basis_VORONOI_F2_F1 = 7,
		noise_basis_VORONOI_CRACKLE = 8,
		noise_basis_CELL_NOISE = 14,
	};
	inline noise_basis_enum noise_basis(void);
	inline void noise_basis(noise_basis_enum value);
	enum noise_basis_2_enum {
		noise_basis_2_SIN = 0,
		noise_basis_2_SAW = 1,
		noise_basis_2_TRI = 2,
	};
	inline noise_basis_2_enum noise_basis_2(void);
	inline void noise_basis_2(noise_basis_2_enum value);
	inline float nabla(void);
	inline void nabla(float value);

};

/**************** Magic Texture ****************/

class MagicTexture : public Texture {
public:
	MagicTexture(const PointerRNA &ptr_arg) :
		Texture(ptr_arg)
		{}

	inline float turbulence(void);
	inline void turbulence(float value);
	inline int noise_depth(void);
	inline void noise_depth(int value);

};

/**************** Blend Texture ****************/

class BlendTexture : public Texture {
public:
	BlendTexture(const PointerRNA &ptr_arg) :
		Texture(ptr_arg)
		{}

	enum progression_enum {
		progression_LINEAR = 0,
		progression_QUADRATIC = 1,
		progression_EASING = 2,
		progression_DIAGONAL = 3,
		progression_SPHERICAL = 4,
		progression_QUADRATIC_SPHERE = 5,
		progression_RADIAL = 6,
	};
	inline progression_enum progression(void);
	inline void progression(progression_enum value);
	enum use_flip_axis_enum {
		use_flip_axis_HORIZONTAL = 0,
		use_flip_axis_VERTICAL = 2,
	};
	inline use_flip_axis_enum use_flip_axis(void);
	inline void use_flip_axis(use_flip_axis_enum value);

};

/**************** Stucci Texture ****************/

class StucciTexture : public Texture {
public:
	StucciTexture(const PointerRNA &ptr_arg) :
		Texture(ptr_arg)
		{}

	inline float turbulence(void);
	inline void turbulence(float value);
	enum noise_basis_enum {
		noise_basis_BLENDER_ORIGINAL = 0,
		noise_basis_ORIGINAL_PERLIN = 1,
		noise_basis_IMPROVED_PERLIN = 2,
		noise_basis_VORONOI_F1 = 3,
		noise_basis_VORONOI_F2 = 4,
		noise_basis_VORONOI_F3 = 5,
		noise_basis_VORONOI_F4 = 6,
		noise_basis_VORONOI_F2_F1 = 7,
		noise_basis_VORONOI_CRACKLE = 8,
		noise_basis_CELL_NOISE = 14,
	};
	inline noise_basis_enum noise_basis(void);
	inline void noise_basis(noise_basis_enum value);
	inline float noise_scale(void);
	inline void noise_scale(float value);
	enum noise_type_enum {
		noise_type_SOFT_NOISE = 0,
		noise_type_HARD_NOISE = 1,
	};
	inline noise_type_enum noise_type(void);
	inline void noise_type(noise_type_enum value);
	enum stucci_type_enum {
		stucci_type_PLASTIC = 0,
		stucci_type_WALL_IN = 1,
		stucci_type_WALL_OUT = 2,
	};
	inline stucci_type_enum stucci_type(void);
	inline void stucci_type(stucci_type_enum value);

};

/**************** Noise Texture ****************/

class NoiseTexture : public Texture {
public:
	NoiseTexture(const PointerRNA &ptr_arg) :
		Texture(ptr_arg)
		{}


};

/**************** Image Texture ****************/

class ImageTexture : public Texture {
public:
	ImageTexture(const PointerRNA &ptr_arg) :
		Texture(ptr_arg)
		{}

	inline bool use_interpolation(void);
	inline void use_interpolation(bool value);
	inline bool use_flip_axis(void);
	inline void use_flip_axis(bool value);
	inline bool use_alpha(void);
	inline void use_alpha(bool value);
	inline bool use_calculate_alpha(void);
	inline void use_calculate_alpha(bool value);
	inline bool invert_alpha(void);
	inline void invert_alpha(bool value);
	inline bool use_mipmap(void);
	inline void use_mipmap(bool value);
	inline bool use_mipmap_gauss(void);
	inline void use_mipmap_gauss(bool value);
	enum filter_type_enum {
		filter_type_BOX = 0,
		filter_type_EWA = 1,
		filter_type_FELINE = 2,
		filter_type_AREA = 3,
	};
	inline filter_type_enum filter_type(void);
	inline void filter_type(filter_type_enum value);
	inline int filter_lightprobes(void);
	inline void filter_lightprobes(int value);
	inline int filter_eccentricity(void);
	inline void filter_eccentricity(int value);
	inline bool use_filter_size_min(void);
	inline void use_filter_size_min(bool value);
	inline float filter_size(void);
	inline void filter_size(float value);
	enum extension_enum {
		extension_EXTEND = 1,
		extension_CLIP = 2,
		extension_CLIP_CUBE = 4,
		extension_REPEAT = 3,
		extension_CHECKER = 5,
	};
	inline extension_enum extension(void);
	inline void extension(extension_enum value);
	inline int repeat_x(void);
	inline void repeat_x(int value);
	inline int repeat_y(void);
	inline void repeat_y(int value);
	inline bool use_mirror_x(void);
	inline void use_mirror_x(bool value);
	inline bool use_mirror_y(void);
	inline void use_mirror_y(bool value);
	inline bool use_checker_odd(void);
	inline void use_checker_odd(bool value);
	inline bool use_checker_even(void);
	inline void use_checker_even(bool value);
	inline float checker_distance(void);
	inline void checker_distance(float value);
	inline float crop_min_x(void);
	inline void crop_min_x(float value);
	inline float crop_min_y(void);
	inline void crop_min_y(float value);
	inline float crop_max_x(void);
	inline void crop_max_x(float value);
	inline float crop_max_y(void);
	inline void crop_max_y(float value);
	inline Image image(void);
	inline ImageUser image_user(void);
	inline bool use_normal_map(void);
	inline void use_normal_map(bool value);

};

/**************** Musgrave ****************/

class MusgraveTexture : public Texture {
public:
	MusgraveTexture(const PointerRNA &ptr_arg) :
		Texture(ptr_arg)
		{}

	enum musgrave_type_enum {
		musgrave_type_MULTIFRACTAL = 0,
		musgrave_type_RIDGED_MULTIFRACTAL = 1,
		musgrave_type_HYBRID_MULTIFRACTAL = 2,
		musgrave_type_FBM = 3,
		musgrave_type_HETERO_TERRAIN = 4,
	};
	inline musgrave_type_enum musgrave_type(void);
	inline void musgrave_type(musgrave_type_enum value);
	inline float dimension_max(void);
	inline void dimension_max(float value);
	inline float lacunarity(void);
	inline void lacunarity(float value);
	inline float octaves(void);
	inline void octaves(float value);
	inline float offset(void);
	inline void offset(float value);
	inline float gain(void);
	inline void gain(float value);
	inline float noise_intensity(void);
	inline void noise_intensity(float value);
	inline float noise_scale(void);
	inline void noise_scale(float value);
	enum noise_basis_enum {
		noise_basis_BLENDER_ORIGINAL = 0,
		noise_basis_ORIGINAL_PERLIN = 1,
		noise_basis_IMPROVED_PERLIN = 2,
		noise_basis_VORONOI_F1 = 3,
		noise_basis_VORONOI_F2 = 4,
		noise_basis_VORONOI_F3 = 5,
		noise_basis_VORONOI_F4 = 6,
		noise_basis_VORONOI_F2_F1 = 7,
		noise_basis_VORONOI_CRACKLE = 8,
		noise_basis_CELL_NOISE = 14,
	};
	inline noise_basis_enum noise_basis(void);
	inline void noise_basis(noise_basis_enum value);
	inline float nabla(void);
	inline void nabla(float value);

};

/**************** Voronoi ****************/

class VoronoiTexture : public Texture {
public:
	VoronoiTexture(const PointerRNA &ptr_arg) :
		Texture(ptr_arg)
		{}

	inline float weight_1(void);
	inline void weight_1(float value);
	inline float weight_2(void);
	inline void weight_2(float value);
	inline float weight_3(void);
	inline void weight_3(float value);
	inline float weight_4(void);
	inline void weight_4(float value);
	inline float minkovsky_exponent(void);
	inline void minkovsky_exponent(float value);
	enum distance_metric_enum {
		distance_metric_DISTANCE = 0,
		distance_metric_DISTANCE_SQUARED = 1,
		distance_metric_MANHATTAN = 2,
		distance_metric_CHEBYCHEV = 3,
		distance_metric_MINKOVSKY_HALF = 4,
		distance_metric_MINKOVSKY_FOUR = 5,
		distance_metric_MINKOVSKY = 6,
	};
	inline distance_metric_enum distance_metric(void);
	inline void distance_metric(distance_metric_enum value);
	enum color_mode_enum {
		color_mode_INTENSITY = 0,
		color_mode_POSITION = 1,
		color_mode_POSITION_OUTLINE = 2,
		color_mode_POSITION_OUTLINE_INTENSITY = 3,
	};
	inline color_mode_enum color_mode(void);
	inline void color_mode(color_mode_enum value);
	inline float noise_intensity(void);
	inline void noise_intensity(float value);
	inline float noise_scale(void);
	inline void noise_scale(float value);
	inline float nabla(void);
	inline void nabla(float value);

};

/**************** Distorted Noise ****************/

class DistortedNoiseTexture : public Texture {
public:
	DistortedNoiseTexture(const PointerRNA &ptr_arg) :
		Texture(ptr_arg)
		{}

	inline float distortion(void);
	inline void distortion(float value);
	inline float noise_scale(void);
	inline void noise_scale(float value);
	enum noise_basis_enum {
		noise_basis_BLENDER_ORIGINAL = 0,
		noise_basis_ORIGINAL_PERLIN = 1,
		noise_basis_IMPROVED_PERLIN = 2,
		noise_basis_VORONOI_F1 = 3,
		noise_basis_VORONOI_F2 = 4,
		noise_basis_VORONOI_F3 = 5,
		noise_basis_VORONOI_F4 = 6,
		noise_basis_VORONOI_F2_F1 = 7,
		noise_basis_VORONOI_CRACKLE = 8,
		noise_basis_CELL_NOISE = 14,
	};
	inline noise_basis_enum noise_basis(void);
	inline void noise_basis(noise_basis_enum value);
	enum noise_distortion_enum {
		noise_distortion_BLENDER_ORIGINAL = 0,
		noise_distortion_ORIGINAL_PERLIN = 1,
		noise_distortion_IMPROVED_PERLIN = 2,
		noise_distortion_VORONOI_F1 = 3,
		noise_distortion_VORONOI_F2 = 4,
		noise_distortion_VORONOI_F3 = 5,
		noise_distortion_VORONOI_F4 = 6,
		noise_distortion_VORONOI_F2_F1 = 7,
		noise_distortion_VORONOI_CRACKLE = 8,
		noise_distortion_CELL_NOISE = 14,
	};
	inline noise_distortion_enum noise_distortion(void);
	inline void noise_distortion(noise_distortion_enum value);
	inline float nabla(void);
	inline void nabla(float value);

};

/**************** Texture Slot ****************/

class TextureSlot : public Pointer {
public:
	TextureSlot(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline Texture texture(void);
	inline std::string name(void);
	inline void name(const std::string& value);
	inline Array<float, 3> offset(void);
	inline void offset(float values[3]);
	inline Array<float, 3> scale(void);
	inline void scale(float values[3]);
	inline Array<float, 3> color(void);
	inline void color(float values[3]);
	enum blend_type_enum {
		blend_type_MIX = 0,
		blend_type_DARKEN = 5,
		blend_type_MULTIPLY = 1,
		blend_type_LIGHTEN = 7,
		blend_type_SCREEN = 8,
		blend_type_ADD = 2,
		blend_type_OVERLAY = 9,
		blend_type_SOFT_LIGHT = 15,
		blend_type_LINEAR_LIGHT = 16,
		blend_type_DIFFERENCE = 6,
		blend_type_SUBTRACT = 3,
		blend_type_DIVIDE = 4,
		blend_type_HUE = 10,
		blend_type_SATURATION = 11,
		blend_type_COLOR = 13,
		blend_type_VALUE = 12,
	};
	inline blend_type_enum blend_type(void);
	inline void blend_type(blend_type_enum value);
	inline float default_value(void);
	inline void default_value(float value);
	enum output_node_enum {
		output_node_DUMMY = 0,
	};
	inline output_node_enum output_node(void);
	inline void output_node(output_node_enum value);

};

/**************** Texture Mapping ****************/

class TexMapping : public Pointer {
public:
	TexMapping(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	enum vector_type_enum {
		vector_type_TEXTURE = 1,
		vector_type_POINT = 0,
		vector_type_VECTOR = 2,
		vector_type_NORMAL = 3,
	};
	inline vector_type_enum vector_type(void);
	inline void vector_type(vector_type_enum value);
	inline Array<float, 3> translation(void);
	inline void translation(float values[3]);
	inline Array<float, 3> rotation(void);
	inline void rotation(float values[3]);
	inline Array<float, 3> scale(void);
	inline void scale(float values[3]);
	inline Array<float, 3> min(void);
	inline void min(float values[3]);
	inline Array<float, 3> max(void);
	inline void max(float values[3]);
	inline bool use_min(void);
	inline void use_min(bool value);
	inline bool use_max(void);
	inline void use_max(bool value);
	enum mapping_x_enum {
		mapping_x_NONE = 0,
		mapping_x_X = 1,
		mapping_x_Y = 2,
		mapping_x_Z = 3,
	};
	inline mapping_x_enum mapping_x(void);
	inline void mapping_x(mapping_x_enum value);
	enum mapping_y_enum {
		mapping_y_NONE = 0,
		mapping_y_X = 1,
		mapping_y_Y = 2,
		mapping_y_Z = 3,
	};
	inline mapping_y_enum mapping_y(void);
	inline void mapping_y(mapping_y_enum value);
	enum mapping_z_enum {
		mapping_z_NONE = 0,
		mapping_z_X = 1,
		mapping_z_Y = 2,
		mapping_z_Z = 3,
	};
	inline mapping_z_enum mapping_z(void);
	inline void mapping_z(mapping_z_enum value);
	enum mapping_enum {
		mapping_FLAT = 0,
		mapping_CUBE = 1,
		mapping_TUBE = 2,
		mapping_SPHERE = 3,
	};
	inline mapping_enum mapping(void);
	inline void mapping(mapping_enum value);

};

/**************** Color Mapping ****************/

class ColorMapping : public Pointer {
public:
	ColorMapping(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline bool use_color_ramp(void);
	inline void use_color_ramp(bool value);
	inline ColorRamp color_ramp(void);
	inline float brightness(void);
	inline void brightness(float value);
	inline float contrast(void);
	inline void contrast(float value);
	inline float saturation(void);
	inline void saturation(float value);
	enum blend_type_enum {
		blend_type_MIX = 0,
		blend_type_DARKEN = 5,
		blend_type_MULTIPLY = 1,
		blend_type_LIGHTEN = 7,
		blend_type_SCREEN = 8,
		blend_type_ADD = 2,
		blend_type_OVERLAY = 9,
		blend_type_SOFT_LIGHT = 15,
		blend_type_LINEAR_LIGHT = 16,
		blend_type_DIFFERENCE = 6,
		blend_type_SUBTRACT = 3,
		blend_type_DIVIDE = 4,
		blend_type_HUE = 10,
		blend_type_SATURATION = 11,
		blend_type_COLOR = 13,
		blend_type_VALUE = 12,
	};
	inline blend_type_enum blend_type(void);
	inline void blend_type(blend_type_enum value);
	inline Array<float, 3> blend_color(void);
	inline void blend_color(float values[3]);
	inline float blend_factor(void);
	inline void blend_factor(float value);

};

/**************** ID Materials ****************/

class IDMaterials : public Pointer {
public:
	IDMaterials(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline void append(void *main, Material& material);
	inline Material pop(void *main, int index, bool update_data);
	inline void clear(void *main, bool update_data);
};

/**************** Action F-Curves ****************/

class ActionFCurves : public Pointer {
public:
	ActionFCurves(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline FCurve create(void *main, const char * data_path, int index, const char * action_group);
	inline FCurve find(const char * data_path, int index);
	inline void remove(FCurve& fcurve);
};

/**************** Action Groups ****************/

class ActionGroups : public Pointer {
public:
	ActionGroups(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline ActionGroup create(const char * name);
	inline void remove(ActionGroup& action_group);
};

/**************** Action Pose Markers ****************/

class ActionPoseMarkers : public Pointer {
public:
	ActionPoseMarkers(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline TimelineMarker active(void);
	inline int active_index(void);
	inline void active_index(int value);

	inline TimelineMarker create(const char * name);
	inline void remove(TimelineMarker& marker);
};

/**************** NLA Tracks ****************/

class NlaTracks : public Pointer {
public:
	NlaTracks(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline NlaTrack active(void);

	inline NlaTrack create(void *main, Context C, NlaTrack& prev);
	inline void remove(void *main, Context C, NlaTrack& track);
};

/**************** Drivers ****************/

class AnimDataDrivers : public Pointer {
public:
	AnimDataDrivers(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline FCurve create(const char * data_path, int index);
	inline void remove(FCurve& driver);
	inline FCurve from_existing(Context C, FCurve& src_driver);
	inline FCurve find(const char * data_path, int index);
};

/**************** Keying set paths ****************/

class KeyingSetPaths : public Pointer {
public:
	KeyingSetPaths(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline KeyingSetPath active(void);
	inline int active_index(void);
	inline void active_index(int value);

	inline KeyingSetPath add(ID& target_id, const char * data_path, int index, int group_method, const char * group_name);
	inline void remove(KeyingSetPath& path);
	inline void clear();
};

/**************** Armature Bones ****************/

class ArmatureBones : public Pointer {
public:
	ArmatureBones(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline Bone active(void);

};

/**************** Armature EditBones ****************/

class ArmatureEditBones : public Pointer {
public:
	ArmatureEditBones(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline EditBone active(void);

	inline EditBone create(const char * name);
	inline void remove(EditBone& bone);
};

/**************** Object Paths ****************/

class AlembicObjectPaths : public Pointer {
public:
	AlembicObjectPaths(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

};

/**************** Background Images ****************/

class CameraBackgroundImages : public Pointer {
public:
	CameraBackgroundImages(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline CameraBackgroundImage create();
	inline void remove(CameraBackgroundImage& image);
	inline void clear();
};

/**************** Collection Objects ****************/

class CollectionObjects : public Pointer {
public:
	CollectionObjects(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline void link(void *main, Object& object);
	inline void unlink(void *main, Object& object);
};

/**************** Collection Children ****************/

class CollectionChildren : public Pointer {
public:
	CollectionChildren(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline void link(void *main, Collection& child);
	inline void unlink(void *main, Collection& child);
};

/**************** Curve Map Point ****************/

class CurveMapPoints : public Pointer {
public:
	CurveMapPoints(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline CurveMapPoint create(float position, float value);
	inline void remove(CurveMapPoint& point);
};

/**************** Color Ramp Elements ****************/

class ColorRampElements : public Pointer {
public:
	ColorRampElements(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline ColorRampElement create(float position);
	inline void remove(ColorRampElement& element);
};

/**************** Armature Deform Constraint Targets ****************/

class ArmatureConstraintTargets : public Pointer {
public:
	ArmatureConstraintTargets(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline ConstraintTargetBone create(void *main);
	inline void remove(void *main, ConstraintTargetBone& target);
	inline void clear(void *main);
};

/**************** Curve Splines ****************/

class CurveSplines : public Pointer {
public:
	CurveSplines(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline Spline active(void);

	inline Spline create(int type);
	inline void remove(Spline& spline);
	inline void clear();
};

/**************** Spline Points ****************/

class SplinePoints : public Pointer {
public:
	SplinePoints(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline void add(int count);
};

/**************** Spline Bezier Points ****************/

class SplineBezierPoints : public Pointer {
public:
	SplineBezierPoints(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline void add(int count);
};

/**************** Canvas Surfaces ****************/

class DynamicPaintSurfaces : public Pointer {
public:
	DynamicPaintSurfaces(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline int active_index(void);
	inline void active_index(int value);
	inline DynamicPaintSurface active(void);

};

/**************** Keyframe Points ****************/

class FCurveKeyframePoints : public Pointer {
public:
	FCurveKeyframePoints(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline Keyframe insert(float frame, float value, int options, int keyframe_type);
	inline void add(int count);
	inline void remove(Keyframe& keyframe, bool fast);
};

/**************** F-Curve Modifiers ****************/

class FCurveModifiers : public Pointer {
public:
	FCurveModifiers(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline FModifier active(void);

	inline FModifier create(int type);
	inline void remove(FModifier& modifier);
};

/**************** ChannelDriver Variables ****************/

class ChannelDriverVariables : public Pointer {
public:
	ChannelDriverVariables(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline DriverVariable create();
	inline void remove(DriverVariable& variable);
};

/**************** Control Points ****************/

class FModifierEnvelopeControlPoints : public Pointer {
public:
	FModifierEnvelopeControlPoints(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline FModifierEnvelopeControlPoint add(float frame);
	inline void remove(FModifierEnvelopeControlPoint& point);
};

/**************** Grease Pencil Layers ****************/

class GreasePencilLayers : public Pointer {
public:
	GreasePencilLayers(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline GPencilLayer active(void);
	inline int active_index(void);
	inline void active_index(int value);
	enum active_note_enum {
		active_note_DEFAULT = 0,
	};
	inline active_note_enum active_note(void);
	inline void active_note(active_note_enum value);

	inline GPencilLayer create(const char * name, bool set_active);
	inline void remove(GPencilLayer& layer);
	inline void move(GPencilLayer& layer, int type);
};

/**************** Grease Pencil Frames ****************/

class GPencilFrames : public Pointer {
public:
	GPencilFrames(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline GPencilFrame create(int frame_number);
	inline void remove(GPencilFrame& frame);
	inline GPencilFrame copy(GPencilFrame& source);
};

/**************** Grease Pencil Frames ****************/

class GPencilStrokes : public Pointer {
public:
	GPencilStrokes(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline GPencilStroke create();
	inline void remove(GPencilStroke& stroke);
};

/**************** Grease Pencil Stroke Points ****************/

class GPencilStrokePoints : public Pointer {
public:
	GPencilStrokePoints(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline void add(int count, float pressure, float strength);
	inline void pop(int index);
};

/**************** Render Layers ****************/

class RenderSlots : public Pointer {
public:
	RenderSlots(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline int active_index(void);
	inline void active_index(int value);
	inline RenderSlot active(void);

	inline RenderSlot create(const char * name);
};

/**************** Layer Objects ****************/

class LayerObjects : public Pointer {
public:
	LayerObjects(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		selected(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline Object active(void);
	COLLECTION_PROPERTY(DefaultCollectionFunctions, Object, LayerObjects, selected, false, true, true)

};

/**************** Style Modules ****************/

class FreestyleModules : public Pointer {
public:
	FreestyleModules(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline FreestyleModuleSettings create();
	inline void remove(FreestyleModuleSettings& module);
};

/**************** Line Sets ****************/

class Linesets : public Pointer {
public:
	Linesets(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline FreestyleLineSet active(void);
	inline int active_index(void);
	inline void active_index(int value);

	inline FreestyleLineSet create(void *main, const char * name);
	inline void remove(FreestyleLineSet& lineset);
};

/**************** Texture Slots ****************/

class LineStyleTextureSlots : public Pointer {
public:
	LineStyleTextureSlots(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline LineStyleTextureSlot add(Context C);
	inline LineStyleTextureSlot create(Context C, int index);
	inline void clear(Context C, int index);
};

/**************** Color Modifiers ****************/

class LineStyleColorModifiers : public Pointer {
public:
	LineStyleColorModifiers(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline LineStyleColorModifier create(const char * name, int type);
	inline void remove(LineStyleColorModifier& modifier);
};

/**************** Alpha Modifiers ****************/

class LineStyleAlphaModifiers : public Pointer {
public:
	LineStyleAlphaModifiers(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline LineStyleAlphaModifier create(const char * name, int type);
	inline void remove(LineStyleAlphaModifier& modifier);
};

/**************** Thickness Modifiers ****************/

class LineStyleThicknessModifiers : public Pointer {
public:
	LineStyleThicknessModifiers(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline LineStyleThicknessModifier create(const char * name, int type);
	inline void remove(LineStyleThicknessModifier& modifier);
};

/**************** Geometry Modifiers ****************/

class LineStyleGeometryModifiers : public Pointer {
public:
	LineStyleGeometryModifiers(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline LineStyleGeometryModifier create(const char * name, int type);
	inline void remove(LineStyleGeometryModifier& modifier);
};

/**************** Main Cameras ****************/

class BlendDataCameras : public Pointer {
public:
	BlendDataCameras(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline Camera create(const char * name);
	inline void remove(Camera& camera, bool do_unlink, bool do_id_user, bool do_ui_user);
	inline void tag(bool value);
};

/**************** Main Scenes ****************/

class BlendDataScenes : public Pointer {
public:
	BlendDataScenes(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline Scene create(const char * name);
	inline void remove(Context C, Scene& scene, bool do_unlink);
	inline void tag(bool value);
};

/**************** Main Objects ****************/

class BlendDataObjects : public Pointer {
public:
	BlendDataObjects(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline Object create(const char * name, ID& object_data);
	inline void remove(Object& object, bool do_unlink, bool do_id_user, bool do_ui_user);
	inline void tag(bool value);
};

/**************** Main Materials ****************/

class BlendDataMaterials : public Pointer {
public:
	BlendDataMaterials(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline Material create(const char * name);
	inline void create_gpencil_data(Material& material);
	inline void remove(Material& material, bool do_unlink, bool do_id_user, bool do_ui_user);
	inline void tag(bool value);
};

/**************** Main Node Trees ****************/

class BlendDataNodeTrees : public Pointer {
public:
	BlendDataNodeTrees(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline NodeTree create(const char * name, int type);
	inline void remove(NodeTree& tree, bool do_unlink, bool do_id_user, bool do_ui_user);
	inline void tag(bool value);
};

/**************** Main Meshes ****************/

class BlendDataMeshes : public Pointer {
public:
	BlendDataMeshes(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline Mesh create(const char * name);
	inline Mesh new_from_object(Depsgraph& depsgraph, Object& object, bool apply_modifiers, bool calc_undeformed);
	inline void remove(Mesh& mesh, bool do_unlink, bool do_id_user, bool do_ui_user);
	inline void tag(bool value);
};

/**************** Main Lights ****************/

class BlendDataLights : public Pointer {
public:
	BlendDataLights(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline Light create(const char * name, int type);
	inline void remove(Light& light, bool do_unlink, bool do_id_user, bool do_ui_user);
	inline void tag(bool value);
};

/**************** Main Libraries ****************/

class BlendDataLibraries : public Pointer {
public:
	BlendDataLibraries(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline void tag(bool value);
};

/**************** Main Screens ****************/

class BlendDataScreens : public Pointer {
public:
	BlendDataScreens(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline void tag(bool value);
};

/**************** Main Window Managers ****************/

class BlendDataWindowManagers : public Pointer {
public:
	BlendDataWindowManagers(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline void tag(bool value);
};

/**************** Main Images ****************/

class BlendDataImages : public Pointer {
public:
	BlendDataImages(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline Image create(const char * name, int width, int height, bool alpha, bool float_buffer, bool stereo3d);
	inline Image load(const char * filepath, bool check_existing);
	inline void remove(Image& image, bool do_unlink, bool do_id_user, bool do_ui_user);
	inline void tag(bool value);
};

/**************** Main Lattices ****************/

class BlendDataLattices : public Pointer {
public:
	BlendDataLattices(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline Lattice create(const char * name);
	inline void remove(Lattice& lattice, bool do_unlink, bool do_id_user, bool do_ui_user);
	inline void tag(bool value);
};

/**************** Main Curves ****************/

class BlendDataCurves : public Pointer {
public:
	BlendDataCurves(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline Curve create(const char * name, int type);
	inline void remove(Curve& curve, bool do_unlink, bool do_id_user, bool do_ui_user);
	inline void tag(bool value);
};

/**************** Main Metaballs ****************/

class BlendDataMetaBalls : public Pointer {
public:
	BlendDataMetaBalls(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline MetaBall create(const char * name);
	inline void remove(MetaBall& metaball, bool do_unlink, bool do_id_user, bool do_ui_user);
	inline void tag(bool value);
};

/**************** Main Fonts ****************/

class BlendDataFonts : public Pointer {
public:
	BlendDataFonts(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline VectorFont load(const char * filepath, bool check_existing);
	inline void remove(VectorFont& vfont, bool do_unlink, bool do_id_user, bool do_ui_user);
	inline void tag(bool value);
};

/**************** Main Textures ****************/

class BlendDataTextures : public Pointer {
public:
	BlendDataTextures(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline Texture create(const char * name, int type);
	inline void remove(Texture& texture, bool do_unlink, bool do_id_user, bool do_ui_user);
	inline void tag(bool value);
};

/**************** Main Brushes ****************/

class BlendDataBrushes : public Pointer {
public:
	BlendDataBrushes(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline Brush create(const char * name, int mode);
	inline void remove(Brush& brush, bool do_unlink, bool do_id_user, bool do_ui_user);
	inline void tag(bool value);
	inline void create_gpencil_data(Brush& brush);
};

/**************** Main Worlds ****************/

class BlendDataWorlds : public Pointer {
public:
	BlendDataWorlds(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline World create(const char * name);
	inline void remove(World& world, bool do_unlink, bool do_id_user, bool do_ui_user);
	inline void tag(bool value);
};

/**************** Main Collections ****************/

class BlendDataCollections : public Pointer {
public:
	BlendDataCollections(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline Collection create(const char * name);
	inline void remove(Collection& collection, bool do_unlink, bool do_id_user, bool do_ui_user);
	inline void tag(bool value);
};

/**************** Main Texts ****************/

class BlendDataTexts : public Pointer {
public:
	BlendDataTexts(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline Text create(const char * name);
	inline void remove(Text& text, bool do_unlink, bool do_id_user, bool do_ui_user);
	inline Text load(const char * filepath, bool internal);
	inline void tag(bool value);
};

/**************** Main Speakers ****************/

class BlendDataSpeakers : public Pointer {
public:
	BlendDataSpeakers(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline Speaker create(const char * name);
	inline void remove(Speaker& speaker, bool do_unlink, bool do_id_user, bool do_ui_user);
	inline void tag(bool value);
};

/**************** Main Sounds ****************/

class BlendDataSounds : public Pointer {
public:
	BlendDataSounds(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline Sound load(const char * filepath, bool check_existing);
	inline void remove(Sound& sound, bool do_unlink, bool do_id_user, bool do_ui_user);
	inline void tag(bool value);
};

/**************** Main Armatures ****************/

class BlendDataArmatures : public Pointer {
public:
	BlendDataArmatures(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline Armature create(const char * name);
	inline void remove(Armature& armature, bool do_unlink, bool do_id_user, bool do_ui_user);
	inline void tag(bool value);
};

/**************** Main Actions ****************/

class BlendDataActions : public Pointer {
public:
	BlendDataActions(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline Action create(const char * name);
	inline void remove(Action& action, bool do_unlink, bool do_id_user, bool do_ui_user);
	inline void tag(bool value);
};

/**************** Main Particle Settings ****************/

class BlendDataParticles : public Pointer {
public:
	BlendDataParticles(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline ParticleSettings create(const char * name);
	inline void remove(ParticleSettings& particle, bool do_unlink, bool do_id_user, bool do_ui_user);
	inline void tag(bool value);
};

/**************** Main Palettes ****************/

class BlendDataPalettes : public Pointer {
public:
	BlendDataPalettes(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline Palette create(const char * name);
	inline void remove(Palette& palette, bool do_unlink, bool do_id_user, bool do_ui_user);
	inline void tag(bool value);
};

/**************** Main Grease Pencils ****************/

class BlendDataGreasePencils : public Pointer {
public:
	BlendDataGreasePencils(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline void tag(bool value);
	inline GreasePencil create(void *main, const char * name);
	inline void remove(GreasePencil& grease_pencil, bool do_unlink, bool do_id_user, bool do_ui_user);
};

/**************** Main Movie Clips ****************/

class BlendDataMovieClips : public Pointer {
public:
	BlendDataMovieClips(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline void tag(bool value);
	inline void remove(MovieClip& clip, bool do_unlink, bool do_id_user, bool do_ui_user);
	inline MovieClip load(const char * filepath, bool check_existing);
};

/**************** Main Masks ****************/

class BlendDataMasks : public Pointer {
public:
	BlendDataMasks(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline void tag(bool value);
	inline Mask create(const char * name);
	inline void remove(Mask& mask, bool do_unlink, bool do_id_user, bool do_ui_user);
};

/**************** Main Line Styles ****************/

class BlendDataLineStyles : public Pointer {
public:
	BlendDataLineStyles(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline void tag(bool value);
	inline FreestyleLineStyle create(const char * name);
	inline void remove(FreestyleLineStyle& linestyle, bool do_unlink, bool do_id_user, bool do_ui_user);
};

/**************** Main Cache Files ****************/

class BlendDataCacheFiles : public Pointer {
public:
	BlendDataCacheFiles(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline void tag(bool value);
};

/**************** Main Paint Curves ****************/

class BlendDataPaintCurves : public Pointer {
public:
	BlendDataPaintCurves(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline void tag(bool value);
};

/**************** Main Workspaces ****************/

class BlendDataWorkSpaces : public Pointer {
public:
	BlendDataWorkSpaces(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline void tag(bool value);
};

/**************** Main Light Probes ****************/

class BlendDataProbes : public Pointer {
public:
	BlendDataProbes(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline LightProbe create(const char * name);
	inline void remove(LightProbe& lightprobe, bool do_unlink, bool do_id_user, bool do_ui_user);
	inline void tag(bool value);
};

/**************** Mesh Vertices ****************/

class MeshVertices : public Pointer {
public:
	MeshVertices(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline void add(int count);
};

/**************** Mesh Edges ****************/

class MeshEdges : public Pointer {
public:
	MeshEdges(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline void add(int count);
};

/**************** Mesh Loops ****************/

class MeshLoops : public Pointer {
public:
	MeshLoops(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline void add(int count);
};

/**************** Mesh Polygons ****************/

class MeshPolygons : public Pointer {
public:
	MeshPolygons(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline int active(void);
	inline void active(int value);

	inline void add(int count);
};

/**************** UV Loop Layers ****************/

class UVLoopLayers : public Pointer {
public:
	UVLoopLayers(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline MeshUVLoopLayer active(void);
	inline int active_index(void);
	inline void active_index(int value);

	inline MeshUVLoopLayer create(const char * name, bool do_init);
	inline void remove(MeshUVLoopLayer& layer);
};

/**************** Loop Colors ****************/

class LoopColors : public Pointer {
public:
	LoopColors(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline MeshLoopColorLayer active(void);
	inline int active_index(void);
	inline void active_index(int value);

	inline MeshLoopColorLayer create(const char * name, bool do_init);
	inline void remove(MeshLoopColorLayer& layer);
};

/**************** Vertex Float Properties ****************/

class VertexFloatProperties : public Pointer {
public:
	VertexFloatProperties(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline MeshVertexFloatPropertyLayer create(const char * name);
};

/**************** Vertex Int Properties ****************/

class VertexIntProperties : public Pointer {
public:
	VertexIntProperties(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline MeshVertexIntPropertyLayer create(const char * name);
};

/**************** Vertex String Properties ****************/

class VertexStringProperties : public Pointer {
public:
	VertexStringProperties(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline MeshVertexStringPropertyLayer create(const char * name);
};

/**************** Polygon Float Properties ****************/

class PolygonFloatProperties : public Pointer {
public:
	PolygonFloatProperties(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline MeshPolygonFloatPropertyLayer create(const char * name);
};

/**************** Polygon Int Properties ****************/

class PolygonIntProperties : public Pointer {
public:
	PolygonIntProperties(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline MeshPolygonIntPropertyLayer create(const char * name);
};

/**************** Polygon String Properties ****************/

class PolygonStringProperties : public Pointer {
public:
	PolygonStringProperties(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline MeshPolygonStringPropertyLayer create(const char * name);
};

/**************** Mesh FaceMaps ****************/

class MeshFaceMapLayers : public Pointer {
public:
	MeshFaceMapLayers(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline MeshFaceMapLayer active(void);

	inline MeshFaceMapLayer create(const char * name);
	inline void remove(MeshFaceMapLayer& layer);
};

/**************** Mesh Loop Triangle ****************/

class MeshLoopTriangle : public Pointer {
public:
	MeshLoopTriangle(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline Array<int, 3> vertices(void);
	inline void vertices(int values[3]);
	inline Array<int, 3> loops(void);
	inline void loops(int values[3]);
	inline int polygon_index(void);
	inline void polygon_index(int value);
	inline Array<float, 3> normal(void);
	inline void normal(float values[3]);
	inline Array<float, 9> split_normals(void);
	inline void split_normals(float values[9]);
	inline float area(void);
	inline void area(float value);
	inline int index(void);
	inline void index(int value);
	inline int material_index(void);
	inline void material_index(int value);
	inline bool use_smooth(void);
	inline void use_smooth(bool value);

};

/**************** Meta Elements ****************/

class MetaBallElements : public Pointer {
public:
	MetaBallElements(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline MetaElement active(void);

	inline MetaElement create(int type);
	inline void remove(MetaElement& element);
	inline void clear();
};

/**************** Nla Strips ****************/

class NlaStrips : public Pointer {
public:
	NlaStrips(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline NlaStrip create(void *main, Context C, const char * name, int start, Action& action);
	inline void remove(void *main, Context C, NlaStrip& strip);
};

/**************** NLA-Strip F-Curves ****************/

class NlaStripFCurves : public Pointer {
public:
	NlaStripFCurves(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline FCurve find(const char * data_path, int index);
};

/**************** Node Inputs ****************/

class NodeInputs : public Pointer {
public:
	NodeInputs(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline NodeSocket create(void *main, const char * type, const char * name, const char * identifier);
	inline void remove(void *main, NodeSocket& socket);
	inline void clear(void *main);
	inline void move(void *main, int from_index, int to_index);
};

/**************** Node Outputs ****************/

class NodeOutputs : public Pointer {
public:
	NodeOutputs(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline NodeSocket create(void *main, const char * type, const char * name, const char * identifier);
	inline void remove(void *main, NodeSocket& socket);
	inline void clear(void *main);
	inline void move(void *main, int from_index, int to_index);
};

/**************** Nodes ****************/

class Nodes : public Pointer {
public:
	Nodes(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline Node active(void);

	inline Node create(Context C, const char * type);
	inline void remove(void *main, Node& node);
	inline void clear(void *main);
};

/**************** Node Links ****************/

class NodeLinks : public Pointer {
public:
	NodeLinks(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline NodeLink create(void *main, NodeSocket& input, NodeSocket& output, bool verify_limits);
	inline void remove(void *main, NodeLink& link);
	inline void clear(void *main);
};

/**************** Node Tree Inputs ****************/

class NodeTreeInputs : public Pointer {
public:
	NodeTreeInputs(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline NodeSocketInterface create(void *main, const char * type, const char * name);
	inline void remove(void *main, NodeSocketInterface& socket);
	inline void clear(void *main);
	inline void move(void *main, int from_index, int to_index);
};

/**************** Node Tree Outputs ****************/

class NodeTreeOutputs : public Pointer {
public:
	NodeTreeOutputs(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline NodeSocketInterface create(void *main, const char * type, const char * name);
	inline void remove(void *main, NodeSocketInterface& socket);
	inline void clear(void *main);
	inline void move(void *main, int from_index, int to_index);
};

/**************** File Output Slots ****************/

class CompositorNodeOutputFileFileSlots : public Pointer {
public:
	CompositorNodeOutputFileFileSlots(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline NodeSocket create(Context C, const char * name);
	inline void remove(void *main, NodeSocket& socket);
	inline void clear(void *main);
	inline void move(void *main, int from_index, int to_index);
};

/**************** File Output Slots ****************/

class CompositorNodeOutputFileLayerSlots : public Pointer {
public:
	CompositorNodeOutputFileLayerSlots(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline NodeSocket create(Context C, const char * name);
	inline void remove(void *main, NodeSocket& socket);
	inline void clear(void *main);
	inline void move(void *main, int from_index, int to_index);
};

/**************** Object Modifiers ****************/

class ObjectModifiers : public Pointer {
public:
	ObjectModifiers(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline Modifier create(Context C, const char * name, int type);
	inline void remove(Context C, Modifier& modifier);
	inline void clear(Context C);
};

/**************** Object Grease Pencil Modifiers ****************/

class ObjectGpencilModifiers : public Pointer {
public:
	ObjectGpencilModifiers(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline GpencilModifier create(Context C, const char * name, int type);
	inline void remove(Context C, GpencilModifier& greasepencil_modifier);
	inline void clear(Context C);
};

/**************** Object Shader Effects ****************/

class ObjectShaderFx : public Pointer {
public:
	ObjectShaderFx(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline ShaderFx create(Context C, const char * name, int type);
	inline void remove(Context C, ShaderFx& shader_fx);
	inline void clear(Context C);
};

/**************** Object Constraints ****************/

class ObjectConstraints : public Pointer {
public:
	ObjectConstraints(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline Constraint active(void);

	inline Constraint create(void *main, int type);
	inline void remove(void *main, Constraint& constraint);
	inline void clear(void *main);
};

/**************** Vertex Groups ****************/

class VertexGroups : public Pointer {
public:
	VertexGroups(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline VertexGroup active(void);
	inline int active_index(void);
	inline void active_index(int value);

	inline VertexGroup create(const char * name);
	inline void remove(VertexGroup& group);
	inline void clear();
};

/**************** Face Maps ****************/

class FaceMaps : public Pointer {
public:
	FaceMaps(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline FaceMap active(void);
	inline int active_index(void);
	inline void active_index(int value);

	inline FaceMap create(const char * name);
	inline void remove(FaceMap& group);
	inline void clear();
};

/**************** Particle Systems ****************/

class ParticleSystems : public Pointer {
public:
	ParticleSystems(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline ParticleSystem active(void);
	inline int active_index(void);
	inline void active_index(int value);

};

/**************** Point Caches ****************/

class PointCaches : public Pointer {
public:
	PointCaches(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline int active_index(void);
	inline void active_index(int value);

};

/**************** Palette Splines ****************/

class PaletteColors : public Pointer {
public:
	PaletteColors(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline PaletteColor active(void);

	inline PaletteColor create();
	inline void remove(PaletteColor& color);
	inline void clear();
};

/**************** Texture Slots ****************/

class ParticleSettingsTextureSlots : public Pointer {
public:
	ParticleSettingsTextureSlots(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline ParticleSettingsTextureSlot add(Context C);
	inline ParticleSettingsTextureSlot create(Context C, int index);
	inline void clear(Context C, int index);
};

/**************** Bone Groups ****************/

class BoneGroups : public Pointer {
public:
	BoneGroups(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline BoneGroup active(void);
	inline int active_index(void);
	inline void active_index(int value);

	inline BoneGroup create(const char * name);
	inline void remove(BoneGroup& group);
};

/**************** PoseBone Constraints ****************/

class PoseBoneConstraints : public Pointer {
public:
	PoseBoneConstraints(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline Constraint active(void);

	inline Constraint create(void *main, int type);
	inline void remove(void *main, Constraint& constraint);
};

/**************** Render Passes ****************/

class RenderPasses : public Pointer {
public:
	RenderPasses(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline RenderPass find_by_type(int pass_type, const char * view);
	inline RenderPass find_by_name(const char * name, const char * view);
};

/**************** Scene Objects ****************/

class SceneObjects : public Pointer {
public:
	SceneObjects(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

};

/**************** Keying Sets ****************/

class KeyingSets : public Pointer {
public:
	KeyingSets(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline KeyingSet active(void);
	inline int active_index(void);
	inline void active_index(int value);

	inline KeyingSet create(const char * idname, const char * name);
};

/**************** Keying Sets All ****************/

class KeyingSetsAll : public Pointer {
public:
	KeyingSetsAll(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline KeyingSet active(void);
	inline int active_index(void);
	inline void active_index(int value);

};

/**************** Timeline Markers ****************/

class TimelineMarkers : public Pointer {
public:
	TimelineMarkers(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline TimelineMarker create(const char * name, int frame);
	inline void remove(TimelineMarker& marker);
	inline void clear();
};

/**************** Render Layers ****************/

class ViewLayers : public Pointer {
public:
	ViewLayers(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline ViewLayer create(void *main, const char * name);
	inline void remove(void *main, ViewLayer& layer);
};

/**************** Render Views ****************/

class RenderViews : public Pointer {
public:
	RenderViews(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline int active_index(void);
	inline void active_index(int value);
	inline SceneRenderView active(void);

	inline SceneRenderView create(const char * name);
	inline void remove(void *main, SceneRenderView& view);
};

/**************** Area Spaces ****************/

class AreaSpaces : public Pointer {
public:
	AreaSpaces(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline Space active(void);

};

/**************** Strip Modifiers ****************/

class SequenceModifiers : public Pointer {
public:
	SequenceModifiers(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline SequenceModifier create(Context C, const char * name, int type);
	inline void remove(Context C, SequenceModifier& modifier);
	inline void clear(Context C);
};

/**************** Sequences ****************/

class Sequences : public Pointer {
public:
	Sequences(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline Sequence new_clip(const char * name, MovieClip& clip, int channel, int frame_start);
	inline Sequence new_mask(const char * name, Mask& mask, int channel, int frame_start);
	inline Sequence new_scene(const char * name, Scene& scene, int channel, int frame_start);
	inline Sequence new_image(const char * name, const char * filepath, int channel, int frame_start);
	inline Sequence new_movie(const char * name, const char * filepath, int channel, int frame_start);
	inline Sequence new_sound(void *main, const char * name, const char * filepath, int channel, int frame_start);
	inline Sequence new_effect(const char * name, int type, int channel, int frame_start, int frame_end, Sequence& seq1, Sequence& seq2, Sequence& seq3);
	inline void remove(Sequence& sequence);
};

/**************** SequenceElements ****************/

class SequenceElements : public Pointer {
public:
	SequenceElements(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline SequenceElement append(const char * filename);
	inline void pop(int index);
};

/**************** Path ****************/

class SpaceNodeEditorPath : public Pointer {
public:
	SpaceNodeEditorPath(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string to_string(void);
	inline void to_string(const std::string& value);

	inline void clear(Context C);
	inline void start(Context C, NodeTree& node_tree);
	inline void append(Context C, NodeTree& node_tree, Node& node);
	inline void pop(Context C);
};

/**************** User Add-ons ****************/

class Addons : public Pointer {
public:
	Addons(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline Addon create();
	inline void remove(Addon& addon);
};

/**************** Paths Compare ****************/

class PathCompareCollection : public Pointer {
public:
	PathCompareCollection(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline PathCompare create();
	inline void remove(PathCompare& pathcmp);
};

/**************** Studio Lights ****************/

class StudioLights : public Pointer {
public:
	StudioLights(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline StudioLight load(const char * path, int type);
	inline StudioLight create(const char * path);
	inline void remove(StudioLight& studio_light);
	inline void refresh();
};

/**************** KeyConfigs ****************/

class KeyConfigurations : public Pointer {
public:
	KeyConfigurations(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline KeyConfig active(void);
	inline KeyConfig default_value(void);
	inline KeyConfig addon(void);
	inline KeyConfig user(void);

	inline KeyConfig create(const char * name);
	inline void remove(KeyConfig& keyconfig);
	inline KeyMapItem find_item_from_operator(Context C, const char * idname, int context, OperatorProperties& properties, int include, int exclude, KeyMap *keymap);
	inline void update();
};

/**************** Key Maps ****************/

class KeyMaps : public Pointer {
public:
	KeyMaps(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline KeyMap create(const char * name, int space_type, int region_type, bool modal, bool tool);
	inline void remove(KeyMap& keymap);
	inline KeyMap find(const char * name, int space_type, int region_type);
	inline KeyMap find_modal(const char * name);
};

/**************** KeyMap Items ****************/

class KeyMapItems : public Pointer {
public:
	KeyMapItems(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline KeyMapItem create(const char * idname, int type, int value, bool any, bool shift, bool ctrl, bool alt, bool oskey, int key_modifier, bool head);
	inline KeyMapItem new_modal(const char * propvalue, int type, int value, bool any, bool shift, bool ctrl, bool alt, bool oskey, int key_modifier);
	inline KeyMapItem new_from_item(KeyMapItem& item, bool head);
	inline void remove(KeyMapItem& item);
	inline KeyMapItem from_id(int id);
	inline KeyMapItem find_from_operator(const char * idname, OperatorProperties& properties, int include, int exclude);
};

/**************** Gizmos ****************/

class Gizmos : public Pointer {
public:
	Gizmos(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline Gizmo create(const char * type);
	inline void remove(Context C, Gizmo& gizmo);
	inline void clear(Context C);
};

/**************** WorkSpace UI Tags ****************/

class wmOwnerIDs : public Pointer {
public:
	wmOwnerIDs(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline wmOwnerID create(const char * name);
	inline void remove(wmOwnerID& owner_id);
	inline void clear();
};

/**************** WorkSpace UI Tags ****************/

class wmTools : public Pointer {
public:
	wmTools(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline WorkSpaceTool from_space_view3d_mode(int mode, bool create);
	inline WorkSpaceTool from_space_image_mode(int mode, bool create);
	inline WorkSpaceTool from_space_node(bool create);
};

/**************** Movie Tracking Markers ****************/

class MovieTrackingMarkers : public Pointer {
public:
	MovieTrackingMarkers(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline MovieTrackingMarker find_frame(int frame, bool exact);
	inline MovieTrackingMarker insert_frame(int frame, float co[2]);
	inline void delete_frame(int frame);
};

/**************** Movie Tracking Plane Markers ****************/

class MovieTrackingPlaneMarkers : public Pointer {
public:
	MovieTrackingPlaneMarkers(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline MovieTrackingPlaneMarker find_frame(int frame, bool exact);
	inline MovieTrackingPlaneMarker insert_frame(int frame);
	inline void delete_frame(int frame);
};

/**************** Movie Tracks ****************/

class MovieTrackingTracks : public Pointer {
public:
	MovieTrackingTracks(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline MovieTrackingTrack active(void);

	inline MovieTrackingTrack create(const char * name, int frame);
};

/**************** Movie Plane Tracks ****************/

class MovieTrackingPlaneTracks : public Pointer {
public:
	MovieTrackingPlaneTracks(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline MovieTrackingPlaneTrack active(void);

};

/**************** Movie Tracks ****************/

class MovieTrackingObjectTracks : public Pointer {
public:
	MovieTrackingObjectTracks(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline MovieTrackingTrack active(void);

	inline MovieTrackingTrack create(const char * name, int frame);
};

/**************** Plane Tracks ****************/

class MovieTrackingObjectPlaneTracks : public Pointer {
public:
	MovieTrackingObjectPlaneTracks(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline MovieTrackingTrack active(void);

};

/**************** Reconstructed Cameras ****************/

class MovieTrackingReconstructedCameras : public Pointer {
public:
	MovieTrackingReconstructedCameras(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline MovieReconstructedCamera find_frame(int frame);
	inline void matrix_from_frame(int frame, float matrix[16]);
};

/**************** Movie Objects ****************/

class MovieTrackingObjects : public Pointer {
public:
	MovieTrackingObjects(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline MovieTrackingObject active(void);

	inline MovieTrackingObject create(const char * name);
	inline void remove(MovieTrackingObject& object);
};

/**************** Mask Splines ****************/

class MaskSplines : public Pointer {
public:
	MaskSplines(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline MaskSpline active(void);
	inline MaskSplinePoint active_point(void);

	inline MaskSpline create();
	inline void remove(MaskSpline& spline);
};

/**************** Mask Spline Points ****************/

class MaskSplinePoints : public Pointer {
public:
	MaskSplinePoints(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline void add(int count);
	inline void remove(MaskSplinePoint& point);
};

/**************** Mask Layers ****************/

class MaskLayers : public Pointer {
public:
	MaskLayers(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline MaskLayer active(void);

	inline MaskLayer create(const char * name);
	inline void remove(MaskLayer& layer);
	inline void clear();
};

/**************** Action ****************/

class Action : public ID {
public:
	Action(const PointerRNA &ptr_arg) :
		ID(ptr_arg),
		fcurves(ptr_arg),
		groups(ptr_arg),
		pose_markers(ptr_arg)
		{}

	COLLECTION_PROPERTY(ActionFCurves, FCurve, Action, fcurves, false, true, false)
	COLLECTION_PROPERTY(ActionGroups, ActionGroup, Action, groups, false, true, true)
	COLLECTION_PROPERTY(ActionPoseMarkers, TimelineMarker, Action, pose_markers, false, true, true)
	inline Array<float, 2> frame_range(void);
	inline void frame_range(float values[2]);
	enum id_root_enum {
		id_root_ACTION = 17217,
		id_root_ARMATURE = 21057,
		id_root_BRUSH = 21058,
		id_root_CAMERA = 16707,
		id_root_CACHEFILE = 17987,
		id_root_CURVE = 21827,
		id_root_FONT = 18006,
		id_root_GREASEPENCIL = 17479,
		id_root_COLLECTION = 21063,
		id_root_IMAGE = 19785,
		id_root_KEY = 17739,
		id_root_LIGHT = 16716,
		id_root_LIBRARY = 18764,
		id_root_LINESTYLE = 21324,
		id_root_LATTICE = 21580,
		id_root_MASK = 21325,
		id_root_MATERIAL = 16717,
		id_root_META = 16973,
		id_root_MESH = 17741,
		id_root_MOVIECLIP = 17229,
		id_root_NODETREE = 21582,
		id_root_OBJECT = 16975,
		id_root_PAINTCURVE = 17232,
		id_root_PALETTE = 19536,
		id_root_PARTICLE = 16720,
		id_root_LIGHT_PROBE = 20556,
		id_root_SCENE = 17235,
		id_root_SOUND = 20307,
		id_root_SPEAKER = 19283,
		id_root_TEXT = 22612,
		id_root_TEXTURE = 17748,
		id_root_WINDOWMANAGER = 19799,
		id_root_WORLD = 20311,
		id_root_WORKSPACE = 21335,
	};
	inline id_root_enum id_root(void);
	inline void id_root(id_root_enum value);

};

/**************** Action Group ****************/

class ActionGroup : public Pointer {
public:
	ActionGroup(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		channels(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string name(void);
	inline void name(const std::string& value);
	COLLECTION_PROPERTY(DefaultCollectionFunctions, FCurve, ActionGroup, channels, false, false, false)
	inline bool select(void);
	inline void select(bool value);
	inline bool lock(void);
	inline void lock(bool value);
	inline bool show_expanded(void);
	inline void show_expanded(bool value);
	enum color_set_enum {
		color_set_DEFAULT = 0,
		color_set_THEME01 = 1,
		color_set_THEME02 = 2,
		color_set_THEME03 = 3,
		color_set_THEME04 = 4,
		color_set_THEME05 = 5,
		color_set_THEME06 = 6,
		color_set_THEME07 = 7,
		color_set_THEME08 = 8,
		color_set_THEME09 = 9,
		color_set_THEME10 = 10,
		color_set_THEME11 = 11,
		color_set_THEME12 = 12,
		color_set_THEME13 = 13,
		color_set_THEME14 = 14,
		color_set_THEME15 = 15,
		color_set_THEME16 = 16,
		color_set_THEME17 = 17,
		color_set_THEME18 = 18,
		color_set_THEME19 = 19,
		color_set_THEME20 = 20,
		color_set_CUSTOM = -1,
	};
	inline color_set_enum color_set(void);
	inline void color_set(color_set_enum value);
	inline bool is_custom_color_set(void);
	inline void is_custom_color_set(bool value);
	inline ThemeBoneColorSet colors(void);

};

/**************** Dope Sheet ****************/

class DopeSheet : public Pointer {
public:
	DopeSheet(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline ID source(void);
	inline bool show_datablock_filters(void);
	inline void show_datablock_filters(bool value);
	inline bool show_only_selected(void);
	inline void show_only_selected(bool value);
	inline bool show_hidden(void);
	inline void show_hidden(bool value);
	inline bool use_datablock_sort(void);
	inline void use_datablock_sort(bool value);
	inline bool show_only_errors(void);
	inline void show_only_errors(bool value);
	inline Collection filter_collection(void);
	inline std::string filter_fcurve_name(void);
	inline void filter_fcurve_name(const std::string& value);
	inline std::string filter_text(void);
	inline void filter_text(const std::string& value);
	inline bool use_multi_word_filter(void);
	inline void use_multi_word_filter(bool value);
	inline bool show_missing_nla(void);
	inline void show_missing_nla(bool value);
	inline bool show_summary(void);
	inline void show_summary(bool value);
	inline bool show_expanded_summary(void);
	inline void show_expanded_summary(bool value);
	inline bool show_transforms(void);
	inline void show_transforms(bool value);
	inline bool show_shapekeys(void);
	inline void show_shapekeys(bool value);
	inline bool show_modifiers(void);
	inline void show_modifiers(bool value);
	inline bool show_meshes(void);
	inline void show_meshes(bool value);
	inline bool show_lattices(void);
	inline void show_lattices(bool value);
	inline bool show_cameras(void);
	inline void show_cameras(bool value);
	inline bool show_materials(void);
	inline void show_materials(bool value);
	inline bool show_lights(void);
	inline void show_lights(bool value);
	inline bool show_linestyles(void);
	inline void show_linestyles(bool value);
	inline bool show_textures(void);
	inline void show_textures(bool value);
	inline bool show_curves(void);
	inline void show_curves(bool value);
	inline bool show_worlds(void);
	inline void show_worlds(bool value);
	inline bool show_scenes(void);
	inline void show_scenes(bool value);
	inline bool show_particles(void);
	inline void show_particles(bool value);
	inline bool show_metaballs(void);
	inline void show_metaballs(bool value);
	inline bool show_armatures(void);
	inline void show_armatures(bool value);
	inline bool show_nodes(void);
	inline void show_nodes(bool value);
	inline bool show_speakers(void);
	inline void show_speakers(bool value);
	inline bool show_cache_files(void);
	inline void show_cache_files(bool value);
	inline bool show_gpencil(void);
	inline void show_gpencil(bool value);
	inline bool show_gpencil_3d_only(void);
	inline void show_gpencil_3d_only(bool value);

};

/**************** Animation Data ****************/

class AnimData : public Pointer {
public:
	AnimData(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		nla_tracks(ptr_arg),
		drivers(ptr_arg)
		{}

	inline Struct rna_type(void);
	COLLECTION_PROPERTY(NlaTracks, NlaTrack, AnimData, nla_tracks, false, true, true)
	inline Action action(void);
	enum action_extrapolation_enum {
		action_extrapolation_NOTHING = 2,
		action_extrapolation_HOLD = 0,
		action_extrapolation_HOLD_FORWARD = 1,
	};
	inline action_extrapolation_enum action_extrapolation(void);
	inline void action_extrapolation(action_extrapolation_enum value);
	enum action_blend_type_enum {
		action_blend_type_REPLACE = 0,
		action_blend_type_COMBINE = 4,
		action_blend_type_ADD = 1,
		action_blend_type_SUBTRACT = 2,
		action_blend_type_MULTIPLY = 3,
	};
	inline action_blend_type_enum action_blend_type(void);
	inline void action_blend_type(action_blend_type_enum value);
	inline float action_influence(void);
	inline void action_influence(float value);
	COLLECTION_PROPERTY(AnimDataDrivers, FCurve, AnimData, drivers, false, true, false)
	inline bool use_nla(void);
	inline void use_nla(bool value);
	inline bool use_tweak_mode(void);
	inline void use_tweak_mode(bool value);

};

/**************** Keying Set ****************/

class KeyingSet : public Pointer {
public:
	KeyingSet(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		paths(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string bl_idname(void);
	inline void bl_idname(const std::string& value);
	inline std::string bl_label(void);
	inline void bl_label(const std::string& value);
	inline std::string bl_description(void);
	inline void bl_description(const std::string& value);
	inline KeyingSetInfo type_info(void);
	COLLECTION_PROPERTY(KeyingSetPaths, KeyingSetPath, KeyingSet, paths, false, true, true)
	inline bool is_path_absolute(void);
	inline void is_path_absolute(bool value);
	inline bool use_insertkey_override_needed(void);
	inline void use_insertkey_override_needed(bool value);
	inline bool use_insertkey_override_visual(void);
	inline void use_insertkey_override_visual(bool value);
	inline bool use_insertkey_override_xyz_to_rgb(void);
	inline void use_insertkey_override_xyz_to_rgb(bool value);
	inline bool use_insertkey_needed(void);
	inline void use_insertkey_needed(bool value);
	inline bool use_insertkey_visual(void);
	inline void use_insertkey_visual(bool value);
	inline bool use_insertkey_xyz_to_rgb(void);
	inline void use_insertkey_xyz_to_rgb(bool value);

	inline void refresh(Context C);
};

/**************** Keying Set Path ****************/

class KeyingSetPath : public Pointer {
public:
	KeyingSetPath(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline ID id(void);
	enum id_type_enum {
		id_type_ACTION = 17217,
		id_type_ARMATURE = 21057,
		id_type_BRUSH = 21058,
		id_type_CAMERA = 16707,
		id_type_CACHEFILE = 17987,
		id_type_CURVE = 21827,
		id_type_FONT = 18006,
		id_type_GREASEPENCIL = 17479,
		id_type_COLLECTION = 21063,
		id_type_IMAGE = 19785,
		id_type_KEY = 17739,
		id_type_LIGHT = 16716,
		id_type_LIBRARY = 18764,
		id_type_LINESTYLE = 21324,
		id_type_LATTICE = 21580,
		id_type_MASK = 21325,
		id_type_MATERIAL = 16717,
		id_type_META = 16973,
		id_type_MESH = 17741,
		id_type_MOVIECLIP = 17229,
		id_type_NODETREE = 21582,
		id_type_OBJECT = 16975,
		id_type_PAINTCURVE = 17232,
		id_type_PALETTE = 19536,
		id_type_PARTICLE = 16720,
		id_type_LIGHT_PROBE = 20556,
		id_type_SCENE = 17235,
		id_type_SOUND = 20307,
		id_type_SPEAKER = 19283,
		id_type_TEXT = 22612,
		id_type_TEXTURE = 17748,
		id_type_WINDOWMANAGER = 19799,
		id_type_WORLD = 20311,
		id_type_WORKSPACE = 21335,
	};
	inline id_type_enum id_type(void);
	inline void id_type(id_type_enum value);
	inline std::string group(void);
	inline void group(const std::string& value);
	enum group_method_enum {
		group_method_NAMED = 0,
		group_method_NONE = 1,
		group_method_KEYINGSET = 2,
	};
	inline group_method_enum group_method(void);
	inline void group_method(group_method_enum value);
	inline std::string data_path(void);
	inline void data_path(const std::string& value);
	inline int array_index(void);
	inline void array_index(int value);
	inline bool use_entire_array(void);
	inline void use_entire_array(bool value);
	inline bool use_insertkey_override_needed(void);
	inline void use_insertkey_override_needed(bool value);
	inline bool use_insertkey_override_visual(void);
	inline void use_insertkey_override_visual(bool value);
	inline bool use_insertkey_override_xyz_to_rgb(void);
	inline void use_insertkey_override_xyz_to_rgb(bool value);
	inline bool use_insertkey_needed(void);
	inline void use_insertkey_needed(bool value);
	inline bool use_insertkey_visual(void);
	inline void use_insertkey_visual(bool value);
	inline bool use_insertkey_xyz_to_rgb(void);
	inline void use_insertkey_xyz_to_rgb(bool value);

};

/**************** Keying Set Info ****************/

class KeyingSetInfo : public Pointer {
public:
	KeyingSetInfo(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string bl_idname(void);
	inline void bl_idname(const std::string& value);
	inline std::string bl_label(void);
	inline void bl_label(const std::string& value);
	inline std::string bl_description(void);
	inline void bl_description(const std::string& value);
	enum bl_options_enum {
		bl_options_INSERTKEY_NEEDED = 1,
		bl_options_INSERTKEY_VISUAL = 2,
		bl_options_INSERTKEY_XYZ_TO_RGB = 32,
	};
	inline bl_options_enum bl_options(void);
	inline void bl_options(bl_options_enum value);

};

/**************** Animation Visualization ****************/

class AnimViz : public Pointer {
public:
	AnimViz(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline AnimVizMotionPaths motion_path(void);

};

/**************** Motion Path Settings ****************/

class AnimVizMotionPaths : public Pointer {
public:
	AnimVizMotionPaths(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	enum type_enum {
		type_CURRENT_FRAME = 1,
		type_RANGE = 0,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	enum bake_location_enum {
		bake_location_HEADS = 2,
		bake_location_TAILS = 0,
	};
	inline bake_location_enum bake_location(void);
	inline void bake_location(bake_location_enum value);
	inline bool show_frame_numbers(void);
	inline void show_frame_numbers(bool value);
	inline bool show_keyframe_highlight(void);
	inline void show_keyframe_highlight(bool value);
	inline bool show_keyframe_numbers(void);
	inline void show_keyframe_numbers(bool value);
	inline bool show_keyframe_action_all(void);
	inline void show_keyframe_action_all(bool value);
	inline int frame_step(void);
	inline void frame_step(int value);
	inline int frame_start(void);
	inline void frame_start(int value);
	inline int frame_end(void);
	inline void frame_end(int value);
	inline int frame_before(void);
	inline void frame_before(int value);
	inline int frame_after(void);
	inline void frame_after(int value);
	inline bool has_motion_paths(void);
	inline void has_motion_paths(bool value);

};

/**************** Motion Path ****************/

class MotionPath : public Pointer {
public:
	MotionPath(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		points(ptr_arg)
		{}

	inline Struct rna_type(void);
	COLLECTION_PROPERTY(DefaultCollectionFunctions, MotionPathVert, MotionPath, points, true, true, false)
	inline int frame_start(void);
	inline void frame_start(int value);
	inline int frame_end(void);
	inline void frame_end(int value);
	inline int length(void);
	inline void length(int value);
	inline Array<float, 3> color(void);
	inline void color(float values[3]);
	inline int line_thickness(void);
	inline void line_thickness(int value);
	inline bool use_bone_head(void);
	inline void use_bone_head(bool value);
	inline bool is_modified(void);
	inline void is_modified(bool value);
	inline bool use_custom_color(void);
	inline void use_custom_color(bool value);
	inline bool lines(void);
	inline void lines(bool value);

};

/**************** Motion Path Cache Point ****************/

class MotionPathVert : public Pointer {
public:
	MotionPathVert(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline Array<float, 3> co(void);
	inline void co(float values[3]);
	inline bool select(void);
	inline void select(bool value);

};

/**************** Armature ****************/

class Armature : public ID {
public:
	Armature(const PointerRNA &ptr_arg) :
		ID(ptr_arg),
		bones(ptr_arg),
		edit_bones(ptr_arg)
		{}

	inline AnimData animation_data(void);
	COLLECTION_PROPERTY(ArmatureBones, Bone, Armature, bones, false, false, true)
	COLLECTION_PROPERTY(ArmatureEditBones, EditBone, Armature, edit_bones, false, true, true)
	enum pose_position_enum {
		pose_position_POSE = 0,
		pose_position_REST = 1,
	};
	inline pose_position_enum pose_position(void);
	inline void pose_position(pose_position_enum value);
	enum display_type_enum {
		display_type_OCTAHEDRAL = 0,
		display_type_STICK = 1,
		display_type_BBONE = 2,
		display_type_ENVELOPE = 3,
		display_type_WIRE = 4,
	};
	inline display_type_enum display_type(void);
	inline void display_type(display_type_enum value);
	inline Array<bool, 32> layers(void);
	inline void layers(bool values[32]);
	inline Array<bool, 32> layers_protected(void);
	inline void layers_protected(bool values[32]);
	inline bool show_axes(void);
	inline void show_axes(bool value);
	inline bool show_names(void);
	inline void show_names(bool value);
	inline bool use_deform_delay(void);
	inline void use_deform_delay(bool value);
	inline bool use_mirror_x(void);
	inline void use_mirror_x(bool value);
	inline bool use_auto_ik(void);
	inline void use_auto_ik(bool value);
	inline bool show_bone_custom_shapes(void);
	inline void show_bone_custom_shapes(bool value);
	inline bool show_group_colors(void);
	inline void show_group_colors(bool value);
	inline bool is_editmode(void);
	inline void is_editmode(bool value);

	inline void transform(void *main, float matrix[16]);
};

/**************** Bone ****************/

class Bone : public Pointer {
public:
	Bone(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		children(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline Bone parent(void);
	COLLECTION_PROPERTY(DefaultCollectionFunctions, Bone, Bone, children, false, true, true)
	inline std::string name(void);
	inline void name(const std::string& value);
	inline Array<bool, 32> layers(void);
	inline void layers(bool values[32]);
	inline bool use_connect(void);
	inline void use_connect(bool value);
	inline bool use_inherit_rotation(void);
	inline void use_inherit_rotation(bool value);
	inline bool use_envelope_multiply(void);
	inline void use_envelope_multiply(bool value);
	inline bool use_deform(void);
	inline void use_deform(bool value);
	inline bool use_inherit_scale(void);
	inline void use_inherit_scale(bool value);
	inline bool use_local_location(void);
	inline void use_local_location(bool value);
	inline bool use_relative_parent(void);
	inline void use_relative_parent(bool value);
	inline bool show_wire(void);
	inline void show_wire(bool value);
	inline bool use_cyclic_offset(void);
	inline void use_cyclic_offset(bool value);
	inline bool hide_select(void);
	inline void hide_select(bool value);
	inline float envelope_distance(void);
	inline void envelope_distance(float value);
	inline float envelope_weight(void);
	inline void envelope_weight(float value);
	inline float head_radius(void);
	inline void head_radius(float value);
	inline float tail_radius(void);
	inline void tail_radius(float value);
	inline int bbone_segments(void);
	inline void bbone_segments(int value);
	inline float bbone_x(void);
	inline void bbone_x(float value);
	inline float bbone_z(void);
	inline void bbone_z(float value);
	enum bbone_handle_type_start_enum {
		bbone_handle_type_start_AUTO = 0,
		bbone_handle_type_start_ABSOLUTE = 1,
		bbone_handle_type_start_RELATIVE = 2,
		bbone_handle_type_start_TANGENT = 3,
	};
	inline bbone_handle_type_start_enum bbone_handle_type_start(void);
	inline void bbone_handle_type_start(bbone_handle_type_start_enum value);
	inline Bone bbone_custom_handle_start(void);
	enum bbone_handle_type_end_enum {
		bbone_handle_type_end_AUTO = 0,
		bbone_handle_type_end_ABSOLUTE = 1,
		bbone_handle_type_end_RELATIVE = 2,
		bbone_handle_type_end_TANGENT = 3,
	};
	inline bbone_handle_type_end_enum bbone_handle_type_end(void);
	inline void bbone_handle_type_end(bbone_handle_type_end_enum value);
	inline Bone bbone_custom_handle_end(void);
	inline float bbone_rollin(void);
	inline void bbone_rollin(float value);
	inline float bbone_rollout(void);
	inline void bbone_rollout(float value);
	inline bool use_endroll_as_inroll(void);
	inline void use_endroll_as_inroll(bool value);
	inline float bbone_curveinx(void);
	inline void bbone_curveinx(float value);
	inline float bbone_curveiny(void);
	inline void bbone_curveiny(float value);
	inline float bbone_curveoutx(void);
	inline void bbone_curveoutx(float value);
	inline float bbone_curveouty(void);
	inline void bbone_curveouty(float value);
	inline float bbone_easein(void);
	inline void bbone_easein(float value);
	inline float bbone_easeout(void);
	inline void bbone_easeout(float value);
	inline float bbone_scalein(void);
	inline void bbone_scalein(float value);
	inline float bbone_scaleout(void);
	inline void bbone_scaleout(float value);
	inline bool hide(void);
	inline void hide(bool value);
	inline bool select(void);
	inline void select(bool value);
	inline bool select_head(void);
	inline void select_head(bool value);
	inline bool select_tail(void);
	inline void select_tail(bool value);
	inline Array<float, 9> matrix(void);
	inline void matrix(float values[9]);
	inline Array<float, 16> matrix_local(void);
	inline void matrix_local(float values[16]);
	inline Array<float, 3> tail(void);
	inline void tail(float values[3]);
	inline Array<float, 3> tail_local(void);
	inline void tail_local(float values[3]);
	inline Array<float, 3> head(void);
	inline void head(float values[3]);
	inline Array<float, 3> head_local(void);
	inline void head_local(float values[3]);

	inline float evaluate_envelope(float point[3]);
	inline void convert_local_to_pose(float matrix_return[16], float matrix[16], float matrix_local[16], float parent_matrix[16], float parent_matrix_local[16], bool invert);
	inline void MatrixFromAxisRoll(float axis[3], float roll, float result_matrix[9]);
	inline void AxisRollFromMatrix(float matrix[9], float axis[3], float result_axis[3], float *result_roll);
};

/**************** Edit Bone ****************/

class EditBone : public Pointer {
public:
	EditBone(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline EditBone parent(void);
	inline float roll(void);
	inline void roll(float value);
	inline Array<float, 3> head(void);
	inline void head(float values[3]);
	inline Array<float, 3> tail(void);
	inline void tail(float values[3]);
	inline std::string name(void);
	inline void name(const std::string& value);
	inline Array<bool, 32> layers(void);
	inline void layers(bool values[32]);
	inline bool use_connect(void);
	inline void use_connect(bool value);
	inline bool use_inherit_rotation(void);
	inline void use_inherit_rotation(bool value);
	inline bool use_envelope_multiply(void);
	inline void use_envelope_multiply(bool value);
	inline bool use_deform(void);
	inline void use_deform(bool value);
	inline bool use_inherit_scale(void);
	inline void use_inherit_scale(bool value);
	inline bool use_local_location(void);
	inline void use_local_location(bool value);
	inline bool use_relative_parent(void);
	inline void use_relative_parent(bool value);
	inline bool show_wire(void);
	inline void show_wire(bool value);
	inline bool use_cyclic_offset(void);
	inline void use_cyclic_offset(bool value);
	inline bool hide_select(void);
	inline void hide_select(bool value);
	inline float envelope_distance(void);
	inline void envelope_distance(float value);
	inline float envelope_weight(void);
	inline void envelope_weight(float value);
	inline float head_radius(void);
	inline void head_radius(float value);
	inline float tail_radius(void);
	inline void tail_radius(float value);
	inline int bbone_segments(void);
	inline void bbone_segments(int value);
	inline float bbone_x(void);
	inline void bbone_x(float value);
	inline float bbone_z(void);
	inline void bbone_z(float value);
	enum bbone_handle_type_start_enum {
		bbone_handle_type_start_AUTO = 0,
		bbone_handle_type_start_ABSOLUTE = 1,
		bbone_handle_type_start_RELATIVE = 2,
		bbone_handle_type_start_TANGENT = 3,
	};
	inline bbone_handle_type_start_enum bbone_handle_type_start(void);
	inline void bbone_handle_type_start(bbone_handle_type_start_enum value);
	inline EditBone bbone_custom_handle_start(void);
	enum bbone_handle_type_end_enum {
		bbone_handle_type_end_AUTO = 0,
		bbone_handle_type_end_ABSOLUTE = 1,
		bbone_handle_type_end_RELATIVE = 2,
		bbone_handle_type_end_TANGENT = 3,
	};
	inline bbone_handle_type_end_enum bbone_handle_type_end(void);
	inline void bbone_handle_type_end(bbone_handle_type_end_enum value);
	inline EditBone bbone_custom_handle_end(void);
	inline float bbone_rollin(void);
	inline void bbone_rollin(float value);
	inline float bbone_rollout(void);
	inline void bbone_rollout(float value);
	inline bool use_endroll_as_inroll(void);
	inline void use_endroll_as_inroll(bool value);
	inline float bbone_curveinx(void);
	inline void bbone_curveinx(float value);
	inline float bbone_curveiny(void);
	inline void bbone_curveiny(float value);
	inline float bbone_curveoutx(void);
	inline void bbone_curveoutx(float value);
	inline float bbone_curveouty(void);
	inline void bbone_curveouty(float value);
	inline float bbone_easein(void);
	inline void bbone_easein(float value);
	inline float bbone_easeout(void);
	inline void bbone_easeout(float value);
	inline float bbone_scalein(void);
	inline void bbone_scalein(float value);
	inline float bbone_scaleout(void);
	inline void bbone_scaleout(float value);
	inline bool hide(void);
	inline void hide(bool value);
	inline bool lock(void);
	inline void lock(bool value);
	inline bool select(void);
	inline void select(bool value);
	inline bool select_head(void);
	inline void select_head(bool value);
	inline bool select_tail(void);
	inline void select_tail(bool value);
	inline Array<float, 16> matrix(void);
	inline void matrix(float values[16]);

	inline void align_roll(float vector[3]);
};

/**************** Boid Rule ****************/

class BoidRule : public Pointer {
public:
	BoidRule(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string name(void);
	inline void name(const std::string& value);
	enum type_enum {
		type_GOAL = 1,
		type_AVOID = 2,
		type_AVOID_COLLISION = 3,
		type_SEPARATE = 4,
		type_FLOCK = 5,
		type_FOLLOW_LEADER = 6,
		type_AVERAGE_SPEED = 7,
		type_FIGHT = 8,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	inline bool use_in_air(void);
	inline void use_in_air(bool value);
	inline bool use_on_land(void);
	inline void use_on_land(bool value);

};

/**************** Goal ****************/

class BoidRuleGoal : public BoidRule {
public:
	BoidRuleGoal(const PointerRNA &ptr_arg) :
		BoidRule(ptr_arg)
		{}

	inline Object object(void);
	inline bool use_predict(void);
	inline void use_predict(bool value);

};

/**************** Avoid ****************/

class BoidRuleAvoid : public BoidRule {
public:
	BoidRuleAvoid(const PointerRNA &ptr_arg) :
		BoidRule(ptr_arg)
		{}

	inline Object object(void);
	inline bool use_predict(void);
	inline void use_predict(bool value);
	inline float fear_factor(void);
	inline void fear_factor(float value);

};

/**************** Avoid Collision ****************/

class BoidRuleAvoidCollision : public BoidRule {
public:
	BoidRuleAvoidCollision(const PointerRNA &ptr_arg) :
		BoidRule(ptr_arg)
		{}

	inline bool use_avoid(void);
	inline void use_avoid(bool value);
	inline bool use_avoid_collision(void);
	inline void use_avoid_collision(bool value);
	inline float look_ahead(void);
	inline void look_ahead(float value);

};

/**************** Follow Leader ****************/

class BoidRuleFollowLeader : public BoidRule {
public:
	BoidRuleFollowLeader(const PointerRNA &ptr_arg) :
		BoidRule(ptr_arg)
		{}

	inline Object object(void);
	inline float distance(void);
	inline void distance(float value);
	inline int queue_count(void);
	inline void queue_count(int value);
	inline bool use_line(void);
	inline void use_line(bool value);

};

/**************** Average Speed ****************/

class BoidRuleAverageSpeed : public BoidRule {
public:
	BoidRuleAverageSpeed(const PointerRNA &ptr_arg) :
		BoidRule(ptr_arg)
		{}

	inline float wander(void);
	inline void wander(float value);
	inline float level(void);
	inline void level(float value);
	inline float speed(void);
	inline void speed(float value);

};

/**************** Fight ****************/

class BoidRuleFight : public BoidRule {
public:
	BoidRuleFight(const PointerRNA &ptr_arg) :
		BoidRule(ptr_arg)
		{}

	inline float distance(void);
	inline void distance(float value);
	inline float flee_distance(void);
	inline void flee_distance(float value);

};

/**************** Boid State ****************/

class BoidState : public Pointer {
public:
	BoidState(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		rules(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string name(void);
	inline void name(const std::string& value);
	enum ruleset_type_enum {
		ruleset_type_FUZZY = 0,
		ruleset_type_RANDOM = 1,
		ruleset_type_AVERAGE = 2,
	};
	inline ruleset_type_enum ruleset_type(void);
	inline void ruleset_type(ruleset_type_enum value);
	COLLECTION_PROPERTY(DefaultCollectionFunctions, BoidRule, BoidState, rules, false, true, true)
	inline BoidRule active_boid_rule(void);
	inline int active_boid_rule_index(void);
	inline void active_boid_rule_index(int value);
	inline float rule_fuzzy(void);
	inline void rule_fuzzy(float value);
	inline float volume(void);
	inline void volume(float value);
	inline float falloff(void);
	inline void falloff(float value);

};

/**************** Boid Settings ****************/

class BoidSettings : public Pointer {
public:
	BoidSettings(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		states(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline float land_smooth(void);
	inline void land_smooth(float value);
	inline float bank(void);
	inline void bank(float value);
	inline float pitch(void);
	inline void pitch(float value);
	inline float height(void);
	inline void height(float value);
	COLLECTION_PROPERTY(DefaultCollectionFunctions, BoidState, BoidSettings, states, false, true, true)
	inline BoidRule active_boid_state(void);
	inline int active_boid_state_index(void);
	inline void active_boid_state_index(int value);
	inline float health(void);
	inline void health(float value);
	inline float strength(void);
	inline void strength(float value);
	inline float aggression(void);
	inline void aggression(float value);
	inline float accuracy(void);
	inline void accuracy(float value);
	inline float range(void);
	inline void range(float value);
	inline float air_speed_min(void);
	inline void air_speed_min(float value);
	inline float air_speed_max(void);
	inline void air_speed_max(float value);
	inline float air_acc_max(void);
	inline void air_acc_max(float value);
	inline float air_ave_max(void);
	inline void air_ave_max(float value);
	inline float air_personal_space(void);
	inline void air_personal_space(float value);
	inline float land_jump_speed(void);
	inline void land_jump_speed(float value);
	inline float land_speed_max(void);
	inline void land_speed_max(float value);
	inline float land_acc_max(void);
	inline void land_acc_max(float value);
	inline float land_ave_max(void);
	inline void land_ave_max(float value);
	inline float land_personal_space(void);
	inline void land_personal_space(float value);
	inline float land_stick_force(void);
	inline void land_stick_force(float value);
	inline bool use_flight(void);
	inline void use_flight(bool value);
	inline bool use_land(void);
	inline void use_land(bool value);
	inline bool use_climb(void);
	inline void use_climb(bool value);

};

/**************** Brush ****************/

class Brush : public ID {
public:
	Brush(const PointerRNA &ptr_arg) :
		ID(ptr_arg)
		{}

	enum blend_enum {
		blend_MIX = 0,
		blend_DARKEN = 5,
		blend_MUL = 3,
		blend_COLORBURN = 10,
		blend_LINEARBURN = 11,
		blend_LIGHTEN = 4,
		blend_SCREEN = 13,
		blend_COLORDODGE = 12,
		blend_ADD = 1,
		blend_OVERLAY = 8,
		blend_SOFTLIGHT = 14,
		blend_HARDLIGHT = 9,
		blend_VIVIDLIGHT = 16,
		blend_LINEARLIGHT = 17,
		blend_PINLIGHT = 15,
		blend_DIFFERENCE = 18,
		blend_EXCLUSION = 19,
		blend_SUB = 2,
		blend_HUE = 20,
		blend_SATURATION = 21,
		blend_COLOR = 23,
		blend_LUMINOSITY = 22,
		blend_ERASE_ALPHA = 6,
		blend_ADD_ALPHA = 7,
	};
	inline blend_enum blend(void);
	inline void blend(blend_enum value);
	enum sculpt_tool_enum {
		sculpt_tool_DRAW = 1,
		sculpt_tool_CLAY = 8,
		sculpt_tool_CLAY_STRIPS = 18,
		sculpt_tool_LAYER = 6,
		sculpt_tool_INFLATE = 4,
		sculpt_tool_BLOB = 17,
		sculpt_tool_CREASE = 16,
		sculpt_tool_SMOOTH = 2,
		sculpt_tool_FLATTEN = 7,
		sculpt_tool_FILL = 9,
		sculpt_tool_SCRAPE = 10,
		sculpt_tool_PINCH = 3,
		sculpt_tool_GRAB = 5,
		sculpt_tool_SNAKE_HOOK = 13,
		sculpt_tool_THUMB = 12,
		sculpt_tool_NUDGE = 11,
		sculpt_tool_ROTATE = 14,
		sculpt_tool_MASK = 19,
		sculpt_tool_SIMPLIFY = 15,
	};
	inline sculpt_tool_enum sculpt_tool(void);
	inline void sculpt_tool(sculpt_tool_enum value);
	enum vertex_tool_enum {
		vertex_tool_DRAW = 0,
		vertex_tool_BLUR = 1,
		vertex_tool_AVERAGE = 2,
		vertex_tool_SMEAR = 3,
	};
	inline vertex_tool_enum vertex_tool(void);
	inline void vertex_tool(vertex_tool_enum value);
	enum weight_tool_enum {
		weight_tool_DRAW = 0,
		weight_tool_BLUR = 1,
		weight_tool_AVERAGE = 2,
		weight_tool_SMEAR = 3,
	};
	inline weight_tool_enum weight_tool(void);
	inline void weight_tool(weight_tool_enum value);
	enum image_tool_enum {
		image_tool_DRAW = 0,
		image_tool_SOFTEN = 1,
		image_tool_SMEAR = 2,
		image_tool_CLONE = 3,
		image_tool_FILL = 4,
		image_tool_MASK = 5,
	};
	inline image_tool_enum image_tool(void);
	inline void image_tool(image_tool_enum value);
	enum gpencil_tool_enum {
		gpencil_tool_DRAW = 0,
		gpencil_tool_FILL = 1,
		gpencil_tool_ERASE = 2,
	};
	inline gpencil_tool_enum gpencil_tool(void);
	inline void gpencil_tool(gpencil_tool_enum value);
	enum direction_enum {
		direction_ADD = 0,
		direction_SUBTRACT = 512,
	};
	inline direction_enum direction(void);
	inline void direction(direction_enum value);
	enum stroke_method_enum {
		stroke_method_DOTS = 0,
		stroke_method_DRAG_DOT = 8388608,
		stroke_method_SPACE = 1024,
		stroke_method_AIRBRUSH = 1,
		stroke_method_ANCHORED = 256,
		stroke_method_LINE = 536870912,
		stroke_method_CURVE = -2147483648,
	};
	inline stroke_method_enum stroke_method(void);
	inline void stroke_method(stroke_method_enum value);
	enum sculpt_plane_enum {
		sculpt_plane_AREA = 0,
		sculpt_plane_VIEW = 1,
		sculpt_plane_X = 2,
		sculpt_plane_Y = 3,
		sculpt_plane_Z = 4,
	};
	inline sculpt_plane_enum sculpt_plane(void);
	inline void sculpt_plane(sculpt_plane_enum value);
	enum mask_tool_enum {
		mask_tool_DRAW = 0,
		mask_tool_SMOOTH = 1,
	};
	inline mask_tool_enum mask_tool(void);
	inline void mask_tool(mask_tool_enum value);
	inline int size(void);
	inline void size(int value);
	inline float unprojected_radius(void);
	inline void unprojected_radius(float value);
	inline float jitter(void);
	inline void jitter(float value);
	inline int jitter_absolute(void);
	inline void jitter_absolute(int value);
	inline int spacing(void);
	inline void spacing(int value);
	inline int grad_spacing(void);
	inline void grad_spacing(int value);
	inline int smooth_stroke_radius(void);
	inline void smooth_stroke_radius(int value);
	inline float smooth_stroke_factor(void);
	inline void smooth_stroke_factor(float value);
	inline float rate(void);
	inline void rate(float value);
	inline Array<float, 3> color(void);
	inline void color(float values[3]);
	inline Array<float, 3> secondary_color(void);
	inline void secondary_color(float values[3]);
	inline float weight(void);
	inline void weight(float value);
	inline float strength(void);
	inline void strength(float value);
	inline float plane_offset(void);
	inline void plane_offset(float value);
	inline float plane_trim(void);
	inline void plane_trim(float value);
	inline float height(void);
	inline void height(float value);
	inline float texture_sample_bias(void);
	inline void texture_sample_bias(float value);
	inline float normal_weight(void);
	inline void normal_weight(float value);
	inline float rake_factor(void);
	inline void rake_factor(float value);
	inline float crease_pinch_factor(void);
	inline void crease_pinch_factor(float value);
	inline float auto_smooth_factor(void);
	inline void auto_smooth_factor(float value);
	inline float topology_rake_factor(void);
	inline void topology_rake_factor(float value);
	inline Array<float, 2> stencil_pos(void);
	inline void stencil_pos(float values[2]);
	inline Array<float, 2> stencil_dimension(void);
	inline void stencil_dimension(float values[2]);
	inline Array<float, 2> mask_stencil_pos(void);
	inline void mask_stencil_pos(float values[2]);
	inline Array<float, 2> mask_stencil_dimension(void);
	inline void mask_stencil_dimension(float values[2]);
	inline float sharp_threshold(void);
	inline void sharp_threshold(float value);
	inline float fill_threshold(void);
	inline void fill_threshold(float value);
	inline int blur_kernel_radius(void);
	inline void blur_kernel_radius(int value);
	enum blur_mode_enum {
		blur_mode_BOX = 1,
		blur_mode_GAUSSIAN = 0,
	};
	inline blur_mode_enum blur_mode(void);
	inline void blur_mode(blur_mode_enum value);
	inline float falloff_angle(void);
	inline void falloff_angle(float value);
	inline bool use_projected(void);
	inline void use_projected(bool value);
	inline bool use_airbrush(void);
	inline void use_airbrush(bool value);
	inline bool use_original_normal(void);
	inline void use_original_normal(bool value);
	inline bool use_pressure_strength(void);
	inline void use_pressure_strength(bool value);
	inline bool use_offset_pressure(void);
	inline void use_offset_pressure(bool value);
	inline bool use_pressure_size(void);
	inline void use_pressure_size(bool value);
	inline bool use_gradient(void);
	inline void use_gradient(bool value);
	inline bool use_pressure_jitter(void);
	inline void use_pressure_jitter(bool value);
	inline bool use_pressure_spacing(void);
	inline void use_pressure_spacing(bool value);
	enum use_pressure_masking_enum {
		use_pressure_masking_NONE = 0,
		use_pressure_masking_RAMP = 2,
		use_pressure_masking_CUTOFF = 4,
	};
	inline use_pressure_masking_enum use_pressure_masking(void);
	inline void use_pressure_masking(use_pressure_masking_enum value);
	inline bool use_inverse_smooth_pressure(void);
	inline void use_inverse_smooth_pressure(bool value);
	inline bool use_relative_jitter(void);
	inline void use_relative_jitter(bool value);
	inline bool use_plane_trim(void);
	inline void use_plane_trim(bool value);
	inline bool use_frontface(void);
	inline void use_frontface(bool value);
	inline bool use_frontface_falloff(void);
	inline void use_frontface_falloff(bool value);
	inline bool use_anchor(void);
	inline void use_anchor(bool value);
	inline bool use_space(void);
	inline void use_space(bool value);
	inline bool use_line(void);
	inline void use_line(bool value);
	inline bool use_curve(void);
	inline void use_curve(bool value);
	inline bool use_smooth_stroke(void);
	inline void use_smooth_stroke(bool value);
	inline bool use_persistent(void);
	inline void use_persistent(bool value);
	inline bool use_accumulate(void);
	inline void use_accumulate(bool value);
	inline bool use_space_attenuation(void);
	inline void use_space_attenuation(bool value);
	inline bool use_adaptive_space(void);
	inline void use_adaptive_space(bool value);
	enum use_locked_size_enum {
		use_locked_size_VIEW = 0,
		use_locked_size_SCENE = 1048576,
	};
	inline use_locked_size_enum use_locked_size(void);
	inline void use_locked_size(use_locked_size_enum value);
	inline bool use_edge_to_edge(void);
	inline void use_edge_to_edge(bool value);
	inline bool use_restore_mesh(void);
	inline void use_restore_mesh(bool value);
	inline bool use_alpha(void);
	inline void use_alpha(bool value);
	inline CurveMapping curve(void);
	inline PaintCurve paint_curve(void);
	inline ColorRamp gradient(void);
	enum gradient_stroke_mode_enum {
		gradient_stroke_mode_PRESSURE = 0,
		gradient_stroke_mode_SPACING_REPEAT = 1,
		gradient_stroke_mode_SPACING_CLAMP = 2,
	};
	inline gradient_stroke_mode_enum gradient_stroke_mode(void);
	inline void gradient_stroke_mode(gradient_stroke_mode_enum value);
	enum gradient_fill_mode_enum {
		gradient_fill_mode_LINEAR = 0,
		gradient_fill_mode_RADIAL = 1,
	};
	inline gradient_fill_mode_enum gradient_fill_mode(void);
	inline void gradient_fill_mode(gradient_fill_mode_enum value);
	inline bool use_primary_overlay(void);
	inline void use_primary_overlay(bool value);
	inline bool use_secondary_overlay(void);
	inline void use_secondary_overlay(bool value);
	inline bool use_cursor_overlay(void);
	inline void use_cursor_overlay(bool value);
	inline bool use_cursor_overlay_override(void);
	inline void use_cursor_overlay_override(bool value);
	inline bool use_primary_overlay_override(void);
	inline void use_primary_overlay_override(bool value);
	inline bool use_secondary_overlay_override(void);
	inline void use_secondary_overlay_override(bool value);
	inline bool use_paint_sculpt(void);
	inline void use_paint_sculpt(bool value);
	inline bool use_paint_vertex(void);
	inline void use_paint_vertex(bool value);
	inline bool use_paint_weight(void);
	inline void use_paint_weight(bool value);
	inline bool use_paint_image(void);
	inline void use_paint_image(bool value);
	inline bool use_paint_grease_pencil(void);
	inline void use_paint_grease_pencil(bool value);
	inline BrushTextureSlot texture_slot(void);
	inline Texture texture(void);
	inline BrushTextureSlot mask_texture_slot(void);
	inline Texture mask_texture(void);
	inline int texture_overlay_alpha(void);
	inline void texture_overlay_alpha(int value);
	inline int mask_overlay_alpha(void);
	inline void mask_overlay_alpha(int value);
	inline int cursor_overlay_alpha(void);
	inline void cursor_overlay_alpha(int value);
	inline Array<float, 3> cursor_color_add(void);
	inline void cursor_color_add(float values[3]);
	inline Array<float, 3> cursor_color_subtract(void);
	inline void cursor_color_subtract(float values[3]);
	inline bool use_custom_icon(void);
	inline void use_custom_icon(bool value);
	inline std::string icon_filepath(void);
	inline void icon_filepath(const std::string& value);
	inline Image clone_image(void);
	inline float clone_alpha(void);
	inline void clone_alpha(float value);
	inline Array<float, 2> clone_offset(void);
	inline void clone_offset(float values[2]);
	inline BrushCapabilities brush_capabilities(void);
	inline BrushCapabilitiesSculpt sculpt_capabilities(void);
	inline BrushCapabilitiesImagePaint image_paint_capabilities(void);
	inline BrushCapabilitiesVertexPaint vertex_paint_capabilities(void);
	inline BrushCapabilitiesWeightPaint weight_paint_capabilities(void);
	inline BrushGpencilSettings gpencil_settings(void);

};

/**************** Brush Capabilities ****************/

class BrushCapabilities : public Pointer {
public:
	BrushCapabilities(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline bool has_overlay(void);
	inline void has_overlay(bool value);
	inline bool has_random_texture_angle(void);
	inline void has_random_texture_angle(bool value);
	inline bool has_spacing(void);
	inline void has_spacing(bool value);
	inline bool has_smooth_stroke(void);
	inline void has_smooth_stroke(bool value);

};

/**************** Sculpt Capabilities ****************/

class BrushCapabilitiesSculpt : public Pointer {
public:
	BrushCapabilitiesSculpt(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline bool has_accumulate(void);
	inline void has_accumulate(bool value);
	inline bool has_auto_smooth(void);
	inline void has_auto_smooth(bool value);
	inline bool has_topology_rake(void);
	inline void has_topology_rake(bool value);
	inline bool has_height(void);
	inline void has_height(bool value);
	inline bool has_jitter(void);
	inline void has_jitter(bool value);
	inline bool has_normal_weight(void);
	inline void has_normal_weight(bool value);
	inline bool has_rake_factor(void);
	inline void has_rake_factor(bool value);
	inline bool has_persistence(void);
	inline void has_persistence(bool value);
	inline bool has_pinch_factor(void);
	inline void has_pinch_factor(bool value);
	inline bool has_plane_offset(void);
	inline void has_plane_offset(bool value);
	inline bool has_random_texture_angle(void);
	inline void has_random_texture_angle(bool value);
	inline bool has_sculpt_plane(void);
	inline void has_sculpt_plane(bool value);
	inline bool has_secondary_color(void);
	inline void has_secondary_color(bool value);
	inline bool has_smooth_stroke(void);
	inline void has_smooth_stroke(bool value);
	inline bool has_space_attenuation(void);
	inline void has_space_attenuation(bool value);
	inline bool has_strength_pressure(void);
	inline void has_strength_pressure(bool value);
	inline bool has_direction(void);
	inline void has_direction(bool value);
	inline bool has_gravity(void);
	inline void has_gravity(bool value);

};

/**************** Image Paint Capabilities ****************/

class BrushCapabilitiesImagePaint : public Pointer {
public:
	BrushCapabilitiesImagePaint(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline bool has_accumulate(void);
	inline void has_accumulate(bool value);
	inline bool has_space_attenuation(void);
	inline void has_space_attenuation(bool value);
	inline bool has_radius(void);
	inline void has_radius(bool value);
	inline bool has_color(void);
	inline void has_color(bool value);

};

/**************** Vertex Paint Capabilities ****************/

class BrushCapabilitiesVertexPaint : public Pointer {
public:
	BrushCapabilitiesVertexPaint(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline bool has_color(void);
	inline void has_color(bool value);

};

/**************** Weight Paint Capabilities ****************/

class BrushCapabilitiesWeightPaint : public Pointer {
public:
	BrushCapabilitiesWeightPaint(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline bool has_weight(void);
	inline void has_weight(bool value);

};

/**************** Grease Pencil Brush Settings ****************/

class BrushGpencilSettings : public Pointer {
public:
	BrushGpencilSettings(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline float pen_sensitivity_factor(void);
	inline void pen_sensitivity_factor(float value);
	inline float pen_strength(void);
	inline void pen_strength(float value);
	inline float pen_jitter(void);
	inline void pen_jitter(float value);
	inline float random_pressure(void);
	inline void random_pressure(float value);
	inline float random_strength(void);
	inline void random_strength(float value);
	inline float random_subdiv(void);
	inline void random_subdiv(float value);
	inline float angle(void);
	inline void angle(float value);
	inline float angle_factor(void);
	inline void angle_factor(float value);
	inline float pen_smooth_factor(void);
	inline void pen_smooth_factor(float value);
	inline int pen_smooth_steps(void);
	inline void pen_smooth_steps(int value);
	inline float pen_thick_smooth_factor(void);
	inline void pen_thick_smooth_factor(float value);
	inline int pen_thick_smooth_steps(void);
	inline void pen_thick_smooth_steps(int value);
	inline int pen_subdivision_steps(void);
	inline void pen_subdivision_steps(int value);
	inline CurveMapping curve_sensitivity(void);
	inline CurveMapping curve_strength(void);
	inline CurveMapping curve_jitter(void);
	inline float fill_threshold(void);
	inline void fill_threshold(float value);
	inline int fill_leak(void);
	inline void fill_leak(int value);
	inline int fill_factor(void);
	inline void fill_factor(int value);
	inline int fill_simplify_level(void);
	inline void fill_simplify_level(int value);
	inline float uv_random(void);
	inline void uv_random(float value);
	inline int input_samples(void);
	inline void input_samples(int value);
	inline float active_smooth_factor(void);
	inline void active_smooth_factor(float value);
	inline float eraser_strength_factor(void);
	inline void eraser_strength_factor(float value);
	inline float eraser_thickness_factor(void);
	inline void eraser_thickness_factor(float value);
	enum gp_icon_enum {
		gp_icon_PENCIL = 1,
		gp_icon_PEN = 2,
		gp_icon_INK = 3,
		gp_icon_INKNOISE = 4,
		gp_icon_BLOCK = 5,
		gp_icon_MARKER = 6,
		gp_icon_FILL = 7,
		gp_icon_SOFT = 8,
		gp_icon_HARD = 9,
		gp_icon_STROKE = 10,
	};
	inline gp_icon_enum gp_icon(void);
	inline void gp_icon(gp_icon_enum value);
	inline bool use_pressure(void);
	inline void use_pressure(bool value);
	inline bool use_strength_pressure(void);
	inline void use_strength_pressure(bool value);
	inline bool use_jitter_pressure(void);
	inline void use_jitter_pressure(bool value);
	inline bool use_settings_stabilizer(void);
	inline void use_settings_stabilizer(bool value);
	inline bool use_cursor(void);
	inline void use_cursor(bool value);
	enum eraser_mode_enum {
		eraser_mode_SOFT = 0,
		eraser_mode_HARD = 1,
		eraser_mode_STROKE = 2,
	};
	inline eraser_mode_enum eraser_mode(void);
	inline void eraser_mode(eraser_mode_enum value);
	enum fill_draw_mode_enum {
		fill_draw_mode_BOTH = 0,
		fill_draw_mode_STROKE = 1,
		fill_draw_mode_CONTROL = 2,
	};
	inline fill_draw_mode_enum fill_draw_mode(void);
	inline void fill_draw_mode(fill_draw_mode_enum value);
	inline bool trim(void);
	inline void trim(bool value);
	inline Material material(void);
	inline bool show_fill_boundary(void);
	inline void show_fill_boundary(bool value);
	inline bool show_fill(void);
	inline void show_fill(bool value);
	inline bool use_default_eraser(void);
	inline void use_default_eraser(bool value);
	inline bool use_settings_postprocess(void);
	inline void use_settings_postprocess(bool value);
	inline bool use_settings_random(void);
	inline void use_settings_random(bool value);
	inline bool use_material_pin(void);
	inline void use_material_pin(bool value);
	inline bool show_lasso(void);
	inline void show_lasso(bool value);
	inline bool use_occlude_eraser(void);
	inline void use_occlude_eraser(bool value);

};

/**************** Brush Texture Slot ****************/

class BrushTextureSlot : public TextureSlot {
public:
	BrushTextureSlot(const PointerRNA &ptr_arg) :
		TextureSlot(ptr_arg)
		{}

	inline float angle(void);
	inline void angle(float value);
	enum map_mode_enum {
		map_mode_VIEW_PLANE = 0,
		map_mode_AREA_PLANE = 3,
		map_mode_TILED = 1,
		map_mode_3D = 2,
		map_mode_RANDOM = 4,
		map_mode_STENCIL = 5,
	};
	inline map_mode_enum map_mode(void);
	inline void map_mode(map_mode_enum value);
	enum tex_paint_map_mode_enum {
		tex_paint_map_mode_VIEW_PLANE = 0,
		tex_paint_map_mode_TILED = 1,
		tex_paint_map_mode_3D = 2,
		tex_paint_map_mode_RANDOM = 4,
		tex_paint_map_mode_STENCIL = 5,
	};
	inline tex_paint_map_mode_enum tex_paint_map_mode(void);
	inline void tex_paint_map_mode(tex_paint_map_mode_enum value);
	enum mask_map_mode_enum {
		mask_map_mode_VIEW_PLANE = 0,
		mask_map_mode_TILED = 1,
		mask_map_mode_RANDOM = 4,
		mask_map_mode_STENCIL = 5,
	};
	inline mask_map_mode_enum mask_map_mode(void);
	inline void mask_map_mode(mask_map_mode_enum value);
	inline bool use_rake(void);
	inline void use_rake(bool value);
	inline bool use_random(void);
	inline void use_random(bool value);
	inline float random_angle(void);
	inline void random_angle(float value);
	inline bool has_texture_angle_source(void);
	inline void has_texture_angle_source(bool value);
	inline bool has_random_texture_angle(void);
	inline void has_random_texture_angle(bool value);
	inline bool has_texture_angle(void);
	inline void has_texture_angle(bool value);

};

/**************** Operator Stroke Element ****************/

class OperatorStrokeElement : public PropertyGroup {
public:
	OperatorStrokeElement(const PointerRNA &ptr_arg) :
		PropertyGroup(ptr_arg)
		{}


};

/**************** CacheFile ****************/

class CacheFile : public ID {
public:
	CacheFile(const PointerRNA &ptr_arg) :
		ID(ptr_arg),
		object_paths(ptr_arg)
		{}

	inline std::string filepath(void);
	inline void filepath(const std::string& value);
	inline bool is_sequence(void);
	inline void is_sequence(bool value);
	inline bool override_frame(void);
	inline void override_frame(bool value);
	inline float frame(void);
	inline void frame(float value);
	inline float frame_offset(void);
	inline void frame_offset(float value);
	enum forward_axis_enum {
		forward_axis_POS_X = 0,
		forward_axis_POS_Y = 1,
		forward_axis_POS_Z = 2,
		forward_axis_NEG_X = 3,
		forward_axis_NEG_Y = 4,
		forward_axis_NEG_Z = 5,
	};
	inline forward_axis_enum forward_axis(void);
	inline void forward_axis(forward_axis_enum value);
	enum up_axis_enum {
		up_axis_POS_X = 0,
		up_axis_POS_Y = 1,
		up_axis_POS_Z = 2,
		up_axis_NEG_X = 3,
		up_axis_NEG_Y = 4,
		up_axis_NEG_Z = 5,
	};
	inline up_axis_enum up_axis(void);
	inline void up_axis(up_axis_enum value);
	inline float scale(void);
	inline void scale(float value);
	COLLECTION_PROPERTY(AlembicObjectPaths, AlembicObjectPath, CacheFile, object_paths, false, true, true)
	inline AnimData animation_data(void);

};

/**************** Object Path ****************/

class AlembicObjectPath : public Pointer {
public:
	AlembicObjectPath(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string path(void);
	inline void path(const std::string& value);

};

/**************** Camera ****************/

class Camera : public ID {
public:
	Camera(const PointerRNA &ptr_arg) :
		ID(ptr_arg),
		background_images(ptr_arg)
		{}

	enum type_enum {
		type_PERSP = 0,
		type_ORTHO = 1,
		type_PANO = 2,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	enum sensor_fit_enum {
		sensor_fit_AUTO = 0,
		sensor_fit_HORIZONTAL = 1,
		sensor_fit_VERTICAL = 2,
	};
	inline sensor_fit_enum sensor_fit(void);
	inline void sensor_fit(sensor_fit_enum value);
	inline float passepartout_alpha(void);
	inline void passepartout_alpha(float value);
	inline float angle_x(void);
	inline void angle_x(float value);
	inline float angle_y(void);
	inline void angle_y(float value);
	inline float angle(void);
	inline void angle(float value);
	inline float clip_start(void);
	inline void clip_start(float value);
	inline float clip_end(void);
	inline void clip_end(float value);
	inline float lens(void);
	inline void lens(float value);
	inline float sensor_width(void);
	inline void sensor_width(float value);
	inline float sensor_height(void);
	inline void sensor_height(float value);
	inline float ortho_scale(void);
	inline void ortho_scale(float value);
	inline float display_size(void);
	inline void display_size(float value);
	inline float shift_x(void);
	inline void shift_x(float value);
	inline float shift_y(void);
	inline void shift_y(float value);
	inline float dof_distance(void);
	inline void dof_distance(float value);
	inline CameraStereoData stereo(void);
	inline bool show_limits(void);
	inline void show_limits(bool value);
	inline bool show_mist(void);
	inline void show_mist(bool value);
	inline bool show_passepartout(void);
	inline void show_passepartout(bool value);
	inline bool show_safe_areas(void);
	inline void show_safe_areas(bool value);
	inline bool show_safe_center(void);
	inline void show_safe_center(bool value);
	inline bool show_name(void);
	inline void show_name(bool value);
	inline bool show_sensor(void);
	inline void show_sensor(bool value);
	inline bool show_background_images(void);
	inline void show_background_images(bool value);
	enum lens_unit_enum {
		lens_unit_MILLIMETERS = 0,
		lens_unit_FOV = 32,
	};
	inline lens_unit_enum lens_unit(void);
	inline void lens_unit(lens_unit_enum value);
	inline bool show_composition_center(void);
	inline void show_composition_center(bool value);
	inline bool show_composition_center_diagonal(void);
	inline void show_composition_center_diagonal(bool value);
	inline bool show_composition_thirds(void);
	inline void show_composition_thirds(bool value);
	inline bool show_composition_golden(void);
	inline void show_composition_golden(bool value);
	inline bool show_composition_golden_tria_a(void);
	inline void show_composition_golden_tria_a(bool value);
	inline bool show_composition_golden_tria_b(void);
	inline void show_composition_golden_tria_b(bool value);
	inline bool show_composition_harmony_tri_a(void);
	inline void show_composition_harmony_tri_a(bool value);
	inline bool show_composition_harmony_tri_b(void);
	inline void show_composition_harmony_tri_b(bool value);
	inline Object dof_object(void);
	inline GPUDOFSettings gpu_dof(void);
	COLLECTION_PROPERTY(CameraBackgroundImages, CameraBackgroundImage, Camera, background_images, false, true, false)
	inline AnimData animation_data(void);

	inline void view_frame(Scene& scene, float result_1[3], float result_2[3], float result_3[3], float result_4[3]);
};

/**************** Background Image ****************/

class CameraBackgroundImage : public Pointer {
public:
	CameraBackgroundImage(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	enum source_enum {
		source_IMAGE = 0,
		source_MOVIE_CLIP = 1,
	};
	inline source_enum source(void);
	inline void source(source_enum value);
	inline Image image(void);
	inline MovieClip clip(void);
	inline ImageUser image_user(void);
	inline MovieClipUser clip_user(void);
	inline Array<float, 2> offset(void);
	inline void offset(float values[2]);
	inline float scale(void);
	inline void scale(float value);
	inline float rotation(void);
	inline void rotation(float value);
	inline bool use_flip_x(void);
	inline void use_flip_x(bool value);
	inline bool use_flip_y(void);
	inline void use_flip_y(bool value);
	inline float alpha(void);
	inline void alpha(float value);
	inline bool show_expanded(void);
	inline void show_expanded(bool value);
	inline bool use_camera_clip(void);
	inline void use_camera_clip(bool value);
	inline bool show_background_image(void);
	inline void show_background_image(bool value);
	inline bool show_on_foreground(void);
	inline void show_on_foreground(bool value);
	enum display_depth_enum {
		display_depth_BACK = 0,
		display_depth_FRONT = 16,
	};
	inline display_depth_enum display_depth(void);
	inline void display_depth(display_depth_enum value);
	enum frame_method_enum {
		frame_method_STRETCH = 0,
		frame_method_FIT = 32,
		frame_method_CROP = 96,
	};
	inline frame_method_enum frame_method(void);
	inline void frame_method(frame_method_enum value);

};

/**************** Stereo ****************/

class CameraStereoData : public Pointer {
public:
	CameraStereoData(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	enum convergence_mode_enum {
		convergence_mode_OFFAXIS = 0,
		convergence_mode_PARALLEL = 1,
		convergence_mode_TOE = 2,
	};
	inline convergence_mode_enum convergence_mode(void);
	inline void convergence_mode(convergence_mode_enum value);
	enum pivot_enum {
		pivot_LEFT = 0,
		pivot_RIGHT = 1,
		pivot_CENTER = 2,
	};
	inline pivot_enum pivot(void);
	inline void pivot(pivot_enum value);
	inline float interocular_distance(void);
	inline void interocular_distance(float value);
	inline float convergence_distance(void);
	inline void convergence_distance(float value);
	inline bool use_spherical_stereo(void);
	inline void use_spherical_stereo(bool value);
	inline bool use_pole_merge(void);
	inline void use_pole_merge(bool value);
	inline float pole_merge_angle_from(void);
	inline void pole_merge_angle_from(float value);
	inline float pole_merge_angle_to(void);
	inline void pole_merge_angle_to(float value);

};

/**************** Solver Result ****************/

class ClothSolverResult : public Pointer {
public:
	ClothSolverResult(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	enum status_enum {
		status_SUCCESS = 1,
		status_NUMERICAL_ISSUE = 2,
		status_NO_CONVERGENCE = 4,
		status_INVALID_INPUT = 8,
	};
	inline status_enum status(void);
	inline void status(status_enum value);
	inline float max_error(void);
	inline void max_error(float value);
	inline float min_error(void);
	inline void min_error(float value);
	inline float avg_error(void);
	inline void avg_error(float value);
	inline int max_iterations(void);
	inline void max_iterations(int value);
	inline int min_iterations(void);
	inline void min_iterations(int value);
	inline float avg_iterations(void);
	inline void avg_iterations(float value);

};

/**************** Cloth Settings ****************/

class ClothSettings : public Pointer {
public:
	ClothSettings(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline float goal_min(void);
	inline void goal_min(float value);
	inline float goal_max(void);
	inline void goal_max(float value);
	inline float goal_default(void);
	inline void goal_default(float value);
	inline float goal_spring(void);
	inline void goal_spring(float value);
	inline float goal_friction(void);
	inline void goal_friction(float value);
	inline float internal_friction(void);
	inline void internal_friction(float value);
	inline float collider_friction(void);
	inline void collider_friction(float value);
	inline float density_target(void);
	inline void density_target(float value);
	inline float density_strength(void);
	inline void density_strength(float value);
	inline float mass(void);
	inline void mass(float value);
	inline std::string vertex_group_mass(void);
	inline void vertex_group_mass(const std::string& value);
	inline Array<float, 3> gravity(void);
	inline void gravity(float values[3]);
	inline float air_damping(void);
	inline void air_damping(float value);
	inline float pin_stiffness(void);
	inline void pin_stiffness(float value);
	inline int quality(void);
	inline void quality(int value);
	inline float time_scale(void);
	inline void time_scale(float value);
	inline std::string vertex_group_shrink(void);
	inline void vertex_group_shrink(const std::string& value);
	inline float shrink_min(void);
	inline void shrink_min(float value);
	inline float shrink_max(void);
	inline void shrink_max(float value);
	inline float voxel_cell_size(void);
	inline void voxel_cell_size(float value);
	inline float tension_damping(void);
	inline void tension_damping(float value);
	inline float compression_damping(void);
	inline void compression_damping(float value);
	inline float shear_damping(void);
	inline void shear_damping(float value);
	inline float tension_stiffness(void);
	inline void tension_stiffness(float value);
	inline float tension_stiffness_max(void);
	inline void tension_stiffness_max(float value);
	inline float compression_stiffness(void);
	inline void compression_stiffness(float value);
	inline float compression_stiffness_max(void);
	inline void compression_stiffness_max(float value);
	inline float shear_stiffness(void);
	inline void shear_stiffness(float value);
	inline float shear_stiffness_max(void);
	inline void shear_stiffness_max(float value);
	inline float sewing_force_max(void);
	inline void sewing_force_max(float value);
	inline std::string vertex_group_structural_stiffness(void);
	inline void vertex_group_structural_stiffness(const std::string& value);
	inline std::string vertex_group_shear_stiffness(void);
	inline void vertex_group_shear_stiffness(const std::string& value);
	inline float bending_stiffness(void);
	inline void bending_stiffness(float value);
	inline float bending_stiffness_max(void);
	inline void bending_stiffness_max(float value);
	inline float bending_damping(void);
	inline void bending_damping(float value);
	inline bool use_sewing_springs(void);
	inline void use_sewing_springs(bool value);
	inline std::string vertex_group_bending(void);
	inline void vertex_group_bending(const std::string& value);
	inline EffectorWeights effector_weights(void);
	inline ShapeKey rest_shape_key(void);
	inline bool use_dynamic_mesh(void);
	inline void use_dynamic_mesh(bool value);
	enum bending_model_enum {
		bending_model_ANGULAR = 1,
		bending_model_LINEAR = 0,
	};
	inline bending_model_enum bending_model(void);
	inline void bending_model(bending_model_enum value);

};

/**************** Cloth Collision Settings ****************/

class ClothCollisionSettings : public Pointer {
public:
	ClothCollisionSettings(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline bool use_collision(void);
	inline void use_collision(bool value);
	inline float distance_min(void);
	inline void distance_min(float value);
	inline float friction(void);
	inline void friction(float value);
	inline float damping(void);
	inline void damping(float value);
	inline int collision_quality(void);
	inline void collision_quality(int value);
	inline float impulse_clamp(void);
	inline void impulse_clamp(float value);
	inline bool use_self_collision(void);
	inline void use_self_collision(bool value);
	inline float self_distance_min(void);
	inline void self_distance_min(float value);
	inline float self_friction(void);
	inline void self_friction(float value);
	inline Collection collection(void);
	inline std::string vertex_group_self_collisions(void);
	inline void vertex_group_self_collisions(const std::string& value);
	inline float self_impulse_clamp(void);
	inline void self_impulse_clamp(float value);

};

/**************** Collection ****************/

class Collection : public ID {
public:
	Collection(const PointerRNA &ptr_arg) :
		ID(ptr_arg),
		objects(ptr_arg),
		all_objects(ptr_arg),
		children(ptr_arg)
		{}

	inline Array<float, 3> instance_offset(void);
	inline void instance_offset(float values[3]);
	COLLECTION_PROPERTY(CollectionObjects, Object, Collection, objects, false, false, false)
	COLLECTION_PROPERTY(DefaultCollectionFunctions, Object, Collection, all_objects, false, false, false)
	COLLECTION_PROPERTY(CollectionChildren, Collection, Collection, children, false, true, true)
	inline bool hide_select(void);
	inline void hide_select(bool value);
	inline bool hide_viewport(void);
	inline void hide_viewport(bool value);
	inline bool hide_render(void);
	inline void hide_render(bool value);

};

/**************** CurveMapPoint ****************/

class CurveMapPoint : public Pointer {
public:
	CurveMapPoint(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline Array<float, 2> location(void);
	inline void location(float values[2]);
	enum handle_type_enum {
		handle_type_AUTO = 0,
		handle_type_AUTO_CLAMPED = 4,
		handle_type_VECTOR = 2,
	};
	inline handle_type_enum handle_type(void);
	inline void handle_type(handle_type_enum value);
	inline bool select(void);
	inline void select(bool value);

};

/**************** CurveMap ****************/

class CurveMap : public Pointer {
public:
	CurveMap(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		points(ptr_arg)
		{}

	inline Struct rna_type(void);
	enum extend_enum {
		extend_HORIZONTAL = 0,
		extend_EXTRAPOLATED = 1,
	};
	inline extend_enum extend(void);
	inline void extend(extend_enum value);
	COLLECTION_PROPERTY(CurveMapPoints, CurveMapPoint, CurveMap, points, true, true, false)

	inline float evaluate(float position);
};

/**************** CurveMapping ****************/

class CurveMapping : public Pointer {
public:
	CurveMapping(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		curves(ptr_arg)
		{}

	inline Struct rna_type(void);
	enum tone_enum {
		tone_STANDARD = 0,
		tone_FILMLIKE = 2,
	};
	inline tone_enum tone(void);
	inline void tone(tone_enum value);
	inline bool use_clip(void);
	inline void use_clip(bool value);
	inline float clip_min_x(void);
	inline void clip_min_x(float value);
	inline float clip_min_y(void);
	inline void clip_min_y(float value);
	inline float clip_max_x(void);
	inline void clip_max_x(float value);
	inline float clip_max_y(void);
	inline void clip_max_y(float value);
	COLLECTION_PROPERTY(DefaultCollectionFunctions, CurveMap, CurveMapping, curves, true, false, false)
	inline Array<float, 3> black_level(void);
	inline void black_level(float values[3]);
	inline Array<float, 3> white_level(void);
	inline void white_level(float values[3]);

	inline void update();
	inline void initialize();
};

/**************** Color Ramp Element ****************/

class ColorRampElement : public Pointer {
public:
	ColorRampElement(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline Array<float, 4> color(void);
	inline void color(float values[4]);
	inline float alpha(void);
	inline void alpha(float value);
	inline float position(void);
	inline void position(float value);

};

/**************** Color Ramp ****************/

class ColorRamp : public Pointer {
public:
	ColorRamp(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		elements(ptr_arg)
		{}

	inline Struct rna_type(void);
	COLLECTION_PROPERTY(ColorRampElements, ColorRampElement, ColorRamp, elements, true, true, false)
	enum interpolation_enum {
		interpolation_EASE = 1,
		interpolation_CARDINAL = 3,
		interpolation_LINEAR = 0,
		interpolation_B_SPLINE = 2,
		interpolation_CONSTANT = 4,
	};
	inline interpolation_enum interpolation(void);
	inline void interpolation(interpolation_enum value);
	enum hue_interpolation_enum {
		hue_interpolation_NEAR = 0,
		hue_interpolation_FAR = 1,
		hue_interpolation_CW = 2,
		hue_interpolation_CCW = 3,
	};
	inline hue_interpolation_enum hue_interpolation(void);
	inline void hue_interpolation(hue_interpolation_enum value);
	enum color_mode_enum {
		color_mode_RGB = 0,
		color_mode_HSV = 1,
		color_mode_HSL = 2,
	};
	inline color_mode_enum color_mode(void);
	inline void color_mode(color_mode_enum value);

	inline void evaluate(float position, float color[4]);
};

/**************** Histogram ****************/

class Histogram : public Pointer {
public:
	Histogram(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	enum mode_enum {
		mode_LUMA = 0,
		mode_RGB = 1,
		mode_R = 2,
		mode_G = 3,
		mode_B = 4,
		mode_A = 5,
	};
	inline mode_enum mode(void);
	inline void mode(mode_enum value);
	inline bool show_line(void);
	inline void show_line(bool value);

};

/**************** Scopes ****************/

class Scopes : public Pointer {
public:
	Scopes(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline bool use_full_resolution(void);
	inline void use_full_resolution(bool value);
	inline float accuracy(void);
	inline void accuracy(float value);
	inline Histogram histogram(void);
	enum waveform_mode_enum {
		waveform_mode_LUMA = 0,
		waveform_mode_PARADE = 1,
		waveform_mode_YCBCR601 = 2,
		waveform_mode_YCBCR709 = 3,
		waveform_mode_YCBCRJPG = 4,
		waveform_mode_RGB = 5,
	};
	inline waveform_mode_enum waveform_mode(void);
	inline void waveform_mode(waveform_mode_enum value);
	inline float waveform_alpha(void);
	inline void waveform_alpha(float value);
	inline float vectorscope_alpha(void);
	inline void vectorscope_alpha(float value);

};

/**************** ColorManagedDisplaySettings ****************/

class ColorManagedDisplaySettings : public Pointer {
public:
	ColorManagedDisplaySettings(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	enum display_device_enum {
		display_device_DEFAULT = 0,
	};
	inline display_device_enum display_device(void);
	inline void display_device(display_device_enum value);

};

/**************** ColorManagedViewSettings ****************/

class ColorManagedViewSettings : public Pointer {
public:
	ColorManagedViewSettings(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	enum look_enum {
		look_NONE = 0,
	};
	inline look_enum look(void);
	inline void look(look_enum value);
	enum view_transform_enum {
		view_transform_NONE = 0,
	};
	inline view_transform_enum view_transform(void);
	inline void view_transform(view_transform_enum value);
	inline float exposure(void);
	inline void exposure(float value);
	inline float gamma(void);
	inline void gamma(float value);
	inline CurveMapping curve_mapping(void);
	inline bool use_curve_mapping(void);
	inline void use_curve_mapping(bool value);

};

/**************** ColorManagedInputColorspaceSettings ****************/

class ColorManagedInputColorspaceSettings : public Pointer {
public:
	ColorManagedInputColorspaceSettings(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	enum name_enum {
		name_NONE = 0,
	};
	inline name_enum name(void);
	inline void name(name_enum value);

};

/**************** ColorManagedSequencerColorspaceSettings ****************/

class ColorManagedSequencerColorspaceSettings : public Pointer {
public:
	ColorManagedSequencerColorspaceSettings(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	enum name_enum {
		name_NONE = 0,
	};
	inline name_enum name(void);
	inline void name(name_enum value);

};

/**************** Constraint ****************/

class Constraint : public Pointer {
public:
	Constraint(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string name(void);
	inline void name(const std::string& value);
	enum type_enum {
		type_CAMERA_SOLVER = 27,
		type_FOLLOW_TRACK = 26,
		type_OBJECT_SOLVER = 28,
		type_COPY_LOCATION = 9,
		type_COPY_ROTATION = 8,
		type_COPY_SCALE = 10,
		type_COPY_TRANSFORMS = 23,
		type_LIMIT_DISTANCE = 14,
		type_LIMIT_LOCATION = 6,
		type_LIMIT_ROTATION = 5,
		type_LIMIT_SCALE = 7,
		type_MAINTAIN_VOLUME = 24,
		type_TRANSFORM = 19,
		type_TRANSFORM_CACHE = 29,
		type_CLAMP_TO = 18,
		type_DAMPED_TRACK = 21,
		type_IK = 3,
		type_LOCKED_TRACK = 13,
		type_SPLINE_IK = 22,
		type_STRETCH_TO = 15,
		type_TRACK_TO = 2,
		type_ACTION = 12,
		type_ARMATURE = 30,
		type_CHILD_OF = 1,
		type_FLOOR = 16,
		type_FOLLOW_PATH = 4,
		type_PIVOT = 25,
		type_SHRINKWRAP = 20,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	enum owner_space_enum {
		owner_space_WORLD = 0,
		owner_space_POSE = 2,
		owner_space_LOCAL_WITH_PARENT = 3,
		owner_space_LOCAL = 1,
	};
	inline owner_space_enum owner_space(void);
	inline void owner_space(owner_space_enum value);
	enum target_space_enum {
		target_space_WORLD = 0,
		target_space_POSE = 2,
		target_space_LOCAL_WITH_PARENT = 3,
		target_space_LOCAL = 1,
	};
	inline target_space_enum target_space(void);
	inline void target_space(target_space_enum value);
	inline bool mute(void);
	inline void mute(bool value);
	inline bool show_expanded(void);
	inline void show_expanded(bool value);
	inline bool is_valid(void);
	inline void is_valid(bool value);
	inline bool active(void);
	inline void active(bool value);
	inline bool is_proxy_local(void);
	inline void is_proxy_local(bool value);
	inline float influence(void);
	inline void influence(float value);
	inline float error_location(void);
	inline void error_location(float value);
	inline float error_rotation(void);
	inline void error_rotation(float value);

};

/**************** Constraint Target ****************/

class ConstraintTarget : public Pointer {
public:
	ConstraintTarget(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline Object target(void);
	inline std::string subtarget(void);
	inline void subtarget(const std::string& value);

};

/**************** Constraint Target Bone ****************/

class ConstraintTargetBone : public Pointer {
public:
	ConstraintTargetBone(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline Object target(void);
	inline std::string subtarget(void);
	inline void subtarget(const std::string& value);
	inline float weight(void);
	inline void weight(float value);

};

/**************** Child Of Constraint ****************/

class ChildOfConstraint : public Constraint {
public:
	ChildOfConstraint(const PointerRNA &ptr_arg) :
		Constraint(ptr_arg)
		{}

	inline Object target(void);
	inline std::string subtarget(void);
	inline void subtarget(const std::string& value);
	inline bool use_location_x(void);
	inline void use_location_x(bool value);
	inline bool use_location_y(void);
	inline void use_location_y(bool value);
	inline bool use_location_z(void);
	inline void use_location_z(bool value);
	inline bool use_rotation_x(void);
	inline void use_rotation_x(bool value);
	inline bool use_rotation_y(void);
	inline void use_rotation_y(bool value);
	inline bool use_rotation_z(void);
	inline void use_rotation_z(bool value);
	inline bool use_scale_x(void);
	inline void use_scale_x(bool value);
	inline bool use_scale_y(void);
	inline void use_scale_y(bool value);
	inline bool use_scale_z(void);
	inline void use_scale_z(bool value);
	inline Array<float, 16> inverse_matrix(void);
	inline void inverse_matrix(float values[16]);

};

/**************** Python Constraint ****************/

class PythonConstraint : public Constraint {
public:
	PythonConstraint(const PointerRNA &ptr_arg) :
		Constraint(ptr_arg),
		targets(ptr_arg)
		{}

	COLLECTION_PROPERTY(DefaultCollectionFunctions, ConstraintTarget, PythonConstraint, targets, false, true, false)
	inline int target_count(void);
	inline void target_count(int value);
	inline Text text(void);
	inline bool use_targets(void);
	inline void use_targets(bool value);
	inline bool has_script_error(void);
	inline void has_script_error(bool value);

};

/**************** Armature Constraint ****************/

class ArmatureConstraint : public Constraint {
public:
	ArmatureConstraint(const PointerRNA &ptr_arg) :
		Constraint(ptr_arg),
		targets(ptr_arg)
		{}

	COLLECTION_PROPERTY(ArmatureConstraintTargets, ConstraintTargetBone, ArmatureConstraint, targets, false, true, false)
	inline bool use_deform_preserve_volume(void);
	inline void use_deform_preserve_volume(bool value);
	inline bool use_bone_envelopes(void);
	inline void use_bone_envelopes(bool value);
	inline bool use_current_location(void);
	inline void use_current_location(bool value);

};

/**************** Stretch To Constraint ****************/

class StretchToConstraint : public Constraint {
public:
	StretchToConstraint(const PointerRNA &ptr_arg) :
		Constraint(ptr_arg)
		{}

	inline float head_tail(void);
	inline void head_tail(float value);
	inline bool use_bbone_shape(void);
	inline void use_bbone_shape(bool value);
	inline Object target(void);
	inline std::string subtarget(void);
	inline void subtarget(const std::string& value);
	enum volume_enum {
		volume_VOLUME_XZX = 0,
		volume_VOLUME_X = 1,
		volume_VOLUME_Z = 2,
		volume_NO_VOLUME = 3,
	};
	inline volume_enum volume(void);
	inline void volume(volume_enum value);
	enum keep_axis_enum {
		keep_axis_PLANE_X = 0,
		keep_axis_PLANE_Z = 2,
	};
	inline keep_axis_enum keep_axis(void);
	inline void keep_axis(keep_axis_enum value);
	inline float rest_length(void);
	inline void rest_length(float value);
	inline float bulge(void);
	inline void bulge(float value);
	inline bool use_bulge_min(void);
	inline void use_bulge_min(bool value);
	inline bool use_bulge_max(void);
	inline void use_bulge_max(bool value);
	inline float bulge_min(void);
	inline void bulge_min(float value);
	inline float bulge_max(void);
	inline void bulge_max(float value);
	inline float bulge_smooth(void);
	inline void bulge_smooth(float value);

};

/**************** Follow Path Constraint ****************/

class FollowPathConstraint : public Constraint {
public:
	FollowPathConstraint(const PointerRNA &ptr_arg) :
		Constraint(ptr_arg)
		{}

	inline Object target(void);
	inline float offset(void);
	inline void offset(float value);
	inline float offset_factor(void);
	inline void offset_factor(float value);
	enum forward_axis_enum {
		forward_axis_FORWARD_X = 0,
		forward_axis_FORWARD_Y = 1,
		forward_axis_FORWARD_Z = 2,
		forward_axis_TRACK_NEGATIVE_X = 3,
		forward_axis_TRACK_NEGATIVE_Y = 4,
		forward_axis_TRACK_NEGATIVE_Z = 5,
	};
	inline forward_axis_enum forward_axis(void);
	inline void forward_axis(forward_axis_enum value);
	enum up_axis_enum {
		up_axis_UP_X = 0,
		up_axis_UP_Y = 1,
		up_axis_UP_Z = 2,
	};
	inline up_axis_enum up_axis(void);
	inline void up_axis(up_axis_enum value);
	inline bool use_curve_follow(void);
	inline void use_curve_follow(bool value);
	inline bool use_fixed_location(void);
	inline void use_fixed_location(bool value);
	inline bool use_curve_radius(void);
	inline void use_curve_radius(bool value);

};

/**************** Locked Track Constraint ****************/

class LockedTrackConstraint : public Constraint {
public:
	LockedTrackConstraint(const PointerRNA &ptr_arg) :
		Constraint(ptr_arg)
		{}

	inline float head_tail(void);
	inline void head_tail(float value);
	inline bool use_bbone_shape(void);
	inline void use_bbone_shape(bool value);
	inline Object target(void);
	inline std::string subtarget(void);
	inline void subtarget(const std::string& value);
	enum track_axis_enum {
		track_axis_TRACK_X = 0,
		track_axis_TRACK_Y = 1,
		track_axis_TRACK_Z = 2,
		track_axis_TRACK_NEGATIVE_X = 3,
		track_axis_TRACK_NEGATIVE_Y = 4,
		track_axis_TRACK_NEGATIVE_Z = 5,
	};
	inline track_axis_enum track_axis(void);
	inline void track_axis(track_axis_enum value);
	enum lock_axis_enum {
		lock_axis_LOCK_X = 0,
		lock_axis_LOCK_Y = 1,
		lock_axis_LOCK_Z = 2,
	};
	inline lock_axis_enum lock_axis(void);
	inline void lock_axis(lock_axis_enum value);

};

/**************** Action Constraint ****************/

class ActionConstraint : public Constraint {
public:
	ActionConstraint(const PointerRNA &ptr_arg) :
		Constraint(ptr_arg)
		{}

	inline Object target(void);
	inline std::string subtarget(void);
	inline void subtarget(const std::string& value);
	enum transform_channel_enum {
		transform_channel_LOCATION_X = 20,
		transform_channel_LOCATION_Y = 21,
		transform_channel_LOCATION_Z = 22,
		transform_channel_ROTATION_X = 0,
		transform_channel_ROTATION_Y = 1,
		transform_channel_ROTATION_Z = 2,
		transform_channel_SCALE_X = 10,
		transform_channel_SCALE_Y = 11,
		transform_channel_SCALE_Z = 12,
	};
	inline transform_channel_enum transform_channel(void);
	inline void transform_channel(transform_channel_enum value);
	inline Action action(void);
	inline bool use_bone_object_action(void);
	inline void use_bone_object_action(bool value);
	inline int frame_start(void);
	inline void frame_start(int value);
	inline int frame_end(void);
	inline void frame_end(int value);
	inline float max(void);
	inline void max(float value);
	inline float min(void);
	inline void min(float value);

};

/**************** Copy Scale Constraint ****************/

class CopyScaleConstraint : public Constraint {
public:
	CopyScaleConstraint(const PointerRNA &ptr_arg) :
		Constraint(ptr_arg)
		{}

	inline Object target(void);
	inline std::string subtarget(void);
	inline void subtarget(const std::string& value);
	inline bool use_x(void);
	inline void use_x(bool value);
	inline bool use_y(void);
	inline void use_y(bool value);
	inline bool use_z(void);
	inline void use_z(bool value);
	inline bool use_offset(void);
	inline void use_offset(bool value);
	inline bool use_add(void);
	inline void use_add(bool value);

};

/**************** Maintain Volume Constraint ****************/

class MaintainVolumeConstraint : public Constraint {
public:
	MaintainVolumeConstraint(const PointerRNA &ptr_arg) :
		Constraint(ptr_arg)
		{}

	enum free_axis_enum {
		free_axis_SAMEVOL_X = 0,
		free_axis_SAMEVOL_Y = 1,
		free_axis_SAMEVOL_Z = 2,
	};
	inline free_axis_enum free_axis(void);
	inline void free_axis(free_axis_enum value);
	inline float volume(void);
	inline void volume(float value);

};

/**************** Copy Location Constraint ****************/

class CopyLocationConstraint : public Constraint {
public:
	CopyLocationConstraint(const PointerRNA &ptr_arg) :
		Constraint(ptr_arg)
		{}

	inline float head_tail(void);
	inline void head_tail(float value);
	inline bool use_bbone_shape(void);
	inline void use_bbone_shape(bool value);
	inline Object target(void);
	inline std::string subtarget(void);
	inline void subtarget(const std::string& value);
	inline bool use_x(void);
	inline void use_x(bool value);
	inline bool use_y(void);
	inline void use_y(bool value);
	inline bool use_z(void);
	inline void use_z(bool value);
	inline bool invert_x(void);
	inline void invert_x(bool value);
	inline bool invert_y(void);
	inline void invert_y(bool value);
	inline bool invert_z(void);
	inline void invert_z(bool value);
	inline bool use_offset(void);
	inline void use_offset(bool value);

};

/**************** Copy Rotation Constraint ****************/

class CopyRotationConstraint : public Constraint {
public:
	CopyRotationConstraint(const PointerRNA &ptr_arg) :
		Constraint(ptr_arg)
		{}

	inline Object target(void);
	inline std::string subtarget(void);
	inline void subtarget(const std::string& value);
	inline bool use_x(void);
	inline void use_x(bool value);
	inline bool use_y(void);
	inline void use_y(bool value);
	inline bool use_z(void);
	inline void use_z(bool value);
	inline bool invert_x(void);
	inline void invert_x(bool value);
	inline bool invert_y(void);
	inline void invert_y(bool value);
	inline bool invert_z(void);
	inline void invert_z(bool value);
	inline bool use_offset(void);
	inline void use_offset(bool value);

};

/**************** Copy Transforms Constraint ****************/

class CopyTransformsConstraint : public Constraint {
public:
	CopyTransformsConstraint(const PointerRNA &ptr_arg) :
		Constraint(ptr_arg)
		{}

	inline float head_tail(void);
	inline void head_tail(float value);
	inline bool use_bbone_shape(void);
	inline void use_bbone_shape(bool value);
	inline Object target(void);
	inline std::string subtarget(void);
	inline void subtarget(const std::string& value);

};

/**************** Floor Constraint ****************/

class FloorConstraint : public Constraint {
public:
	FloorConstraint(const PointerRNA &ptr_arg) :
		Constraint(ptr_arg)
		{}

	inline Object target(void);
	inline std::string subtarget(void);
	inline void subtarget(const std::string& value);
	enum floor_location_enum {
		floor_location_FLOOR_X = 0,
		floor_location_FLOOR_Y = 1,
		floor_location_FLOOR_Z = 2,
		floor_location_FLOOR_NEGATIVE_X = 3,
		floor_location_FLOOR_NEGATIVE_Y = 4,
		floor_location_FLOOR_NEGATIVE_Z = 5,
	};
	inline floor_location_enum floor_location(void);
	inline void floor_location(floor_location_enum value);
	inline bool use_sticky(void);
	inline void use_sticky(bool value);
	inline bool use_rotation(void);
	inline void use_rotation(bool value);
	inline float offset(void);
	inline void offset(float value);

};

/**************** Track To Constraint ****************/

class TrackToConstraint : public Constraint {
public:
	TrackToConstraint(const PointerRNA &ptr_arg) :
		Constraint(ptr_arg)
		{}

	inline float head_tail(void);
	inline void head_tail(float value);
	inline bool use_bbone_shape(void);
	inline void use_bbone_shape(bool value);
	inline Object target(void);
	inline std::string subtarget(void);
	inline void subtarget(const std::string& value);
	enum track_axis_enum {
		track_axis_TRACK_X = 0,
		track_axis_TRACK_Y = 1,
		track_axis_TRACK_Z = 2,
		track_axis_TRACK_NEGATIVE_X = 3,
		track_axis_TRACK_NEGATIVE_Y = 4,
		track_axis_TRACK_NEGATIVE_Z = 5,
	};
	inline track_axis_enum track_axis(void);
	inline void track_axis(track_axis_enum value);
	enum up_axis_enum {
		up_axis_UP_X = 0,
		up_axis_UP_Y = 1,
		up_axis_UP_Z = 2,
	};
	inline up_axis_enum up_axis(void);
	inline void up_axis(up_axis_enum value);
	inline bool use_target_z(void);
	inline void use_target_z(bool value);

};

/**************** Kinematic Constraint ****************/

class KinematicConstraint : public Constraint {
public:
	KinematicConstraint(const PointerRNA &ptr_arg) :
		Constraint(ptr_arg)
		{}

	inline Object target(void);
	inline std::string subtarget(void);
	inline void subtarget(const std::string& value);
	inline int iterations(void);
	inline void iterations(int value);
	inline Object pole_target(void);
	inline std::string pole_subtarget(void);
	inline void pole_subtarget(const std::string& value);
	inline float pole_angle(void);
	inline void pole_angle(float value);
	inline float weight(void);
	inline void weight(float value);
	inline float orient_weight(void);
	inline void orient_weight(float value);
	inline int chain_count(void);
	inline void chain_count(int value);
	inline bool use_tail(void);
	inline void use_tail(bool value);
	enum reference_axis_enum {
		reference_axis_BONE = 0,
		reference_axis_TARGET = 16384,
	};
	inline reference_axis_enum reference_axis(void);
	inline void reference_axis(reference_axis_enum value);
	inline bool use_location(void);
	inline void use_location(bool value);
	inline bool lock_location_x(void);
	inline void lock_location_x(bool value);
	inline bool lock_location_y(void);
	inline void lock_location_y(bool value);
	inline bool lock_location_z(void);
	inline void lock_location_z(bool value);
	inline bool use_rotation(void);
	inline void use_rotation(bool value);
	inline bool lock_rotation_x(void);
	inline void lock_rotation_x(bool value);
	inline bool lock_rotation_y(void);
	inline void lock_rotation_y(bool value);
	inline bool lock_rotation_z(void);
	inline void lock_rotation_z(bool value);
	inline bool use_stretch(void);
	inline void use_stretch(bool value);
	enum ik_type_enum {
		ik_type_COPY_POSE = 0,
		ik_type_DISTANCE = 1,
	};
	inline ik_type_enum ik_type(void);
	inline void ik_type(ik_type_enum value);
	enum limit_mode_enum {
		limit_mode_LIMITDIST_INSIDE = 0,
		limit_mode_LIMITDIST_OUTSIDE = 1,
		limit_mode_LIMITDIST_ONSURFACE = 2,
	};
	inline limit_mode_enum limit_mode(void);
	inline void limit_mode(limit_mode_enum value);
	inline float distance(void);
	inline void distance(float value);

};

/**************** Clamp To Constraint ****************/

class ClampToConstraint : public Constraint {
public:
	ClampToConstraint(const PointerRNA &ptr_arg) :
		Constraint(ptr_arg)
		{}

	inline Object target(void);
	enum main_axis_enum {
		main_axis_CLAMPTO_AUTO = 0,
		main_axis_CLAMPTO_X = 1,
		main_axis_CLAMPTO_Y = 2,
		main_axis_CLAMPTO_Z = 3,
	};
	inline main_axis_enum main_axis(void);
	inline void main_axis(main_axis_enum value);
	inline bool use_cyclic(void);
	inline void use_cyclic(bool value);

};

/**************** Limit Distance Constraint ****************/

class LimitDistanceConstraint : public Constraint {
public:
	LimitDistanceConstraint(const PointerRNA &ptr_arg) :
		Constraint(ptr_arg)
		{}

	inline float head_tail(void);
	inline void head_tail(float value);
	inline bool use_bbone_shape(void);
	inline void use_bbone_shape(bool value);
	inline Object target(void);
	inline std::string subtarget(void);
	inline void subtarget(const std::string& value);
	inline float distance(void);
	inline void distance(float value);
	enum limit_mode_enum {
		limit_mode_LIMITDIST_INSIDE = 0,
		limit_mode_LIMITDIST_OUTSIDE = 1,
		limit_mode_LIMITDIST_ONSURFACE = 2,
	};
	inline limit_mode_enum limit_mode(void);
	inline void limit_mode(limit_mode_enum value);
	inline bool use_transform_limit(void);
	inline void use_transform_limit(bool value);

};

/**************** Limit Size Constraint ****************/

class LimitScaleConstraint : public Constraint {
public:
	LimitScaleConstraint(const PointerRNA &ptr_arg) :
		Constraint(ptr_arg)
		{}

	inline bool use_min_x(void);
	inline void use_min_x(bool value);
	inline bool use_min_y(void);
	inline void use_min_y(bool value);
	inline bool use_min_z(void);
	inline void use_min_z(bool value);
	inline bool use_max_x(void);
	inline void use_max_x(bool value);
	inline bool use_max_y(void);
	inline void use_max_y(bool value);
	inline bool use_max_z(void);
	inline void use_max_z(bool value);
	inline float min_x(void);
	inline void min_x(float value);
	inline float min_y(void);
	inline void min_y(float value);
	inline float min_z(void);
	inline void min_z(float value);
	inline float max_x(void);
	inline void max_x(float value);
	inline float max_y(void);
	inline void max_y(float value);
	inline float max_z(void);
	inline void max_z(float value);
	inline bool use_transform_limit(void);
	inline void use_transform_limit(bool value);

};

/**************** Limit Rotation Constraint ****************/

class LimitRotationConstraint : public Constraint {
public:
	LimitRotationConstraint(const PointerRNA &ptr_arg) :
		Constraint(ptr_arg)
		{}

	inline bool use_limit_x(void);
	inline void use_limit_x(bool value);
	inline bool use_limit_y(void);
	inline void use_limit_y(bool value);
	inline bool use_limit_z(void);
	inline void use_limit_z(bool value);
	inline float min_x(void);
	inline void min_x(float value);
	inline float min_y(void);
	inline void min_y(float value);
	inline float min_z(void);
	inline void min_z(float value);
	inline float max_x(void);
	inline void max_x(float value);
	inline float max_y(void);
	inline void max_y(float value);
	inline float max_z(void);
	inline void max_z(float value);
	inline bool use_transform_limit(void);
	inline void use_transform_limit(bool value);

};

/**************** Limit Location Constraint ****************/

class LimitLocationConstraint : public Constraint {
public:
	LimitLocationConstraint(const PointerRNA &ptr_arg) :
		Constraint(ptr_arg)
		{}

	inline bool use_min_x(void);
	inline void use_min_x(bool value);
	inline bool use_min_y(void);
	inline void use_min_y(bool value);
	inline bool use_min_z(void);
	inline void use_min_z(bool value);
	inline bool use_max_x(void);
	inline void use_max_x(bool value);
	inline bool use_max_y(void);
	inline void use_max_y(bool value);
	inline bool use_max_z(void);
	inline void use_max_z(bool value);
	inline float min_x(void);
	inline void min_x(float value);
	inline float min_y(void);
	inline void min_y(float value);
	inline float min_z(void);
	inline void min_z(float value);
	inline float max_x(void);
	inline void max_x(float value);
	inline float max_y(void);
	inline void max_y(float value);
	inline float max_z(void);
	inline void max_z(float value);
	inline bool use_transform_limit(void);
	inline void use_transform_limit(bool value);

};

/**************** Transformation Constraint ****************/

class TransformConstraint : public Constraint {
public:
	TransformConstraint(const PointerRNA &ptr_arg) :
		Constraint(ptr_arg)
		{}

	inline Object target(void);
	inline std::string subtarget(void);
	inline void subtarget(const std::string& value);
	enum map_from_enum {
		map_from_LOCATION = 0,
		map_from_ROTATION = 1,
		map_from_SCALE = 2,
	};
	inline map_from_enum map_from(void);
	inline void map_from(map_from_enum value);
	enum map_to_enum {
		map_to_LOCATION = 0,
		map_to_ROTATION = 1,
		map_to_SCALE = 2,
	};
	inline map_to_enum map_to(void);
	inline void map_to(map_to_enum value);
	enum map_to_x_from_enum {
		map_to_x_from_X = 0,
		map_to_x_from_Y = 1,
		map_to_x_from_Z = 2,
	};
	inline map_to_x_from_enum map_to_x_from(void);
	inline void map_to_x_from(map_to_x_from_enum value);
	enum map_to_y_from_enum {
		map_to_y_from_X = 0,
		map_to_y_from_Y = 1,
		map_to_y_from_Z = 2,
	};
	inline map_to_y_from_enum map_to_y_from(void);
	inline void map_to_y_from(map_to_y_from_enum value);
	enum map_to_z_from_enum {
		map_to_z_from_X = 0,
		map_to_z_from_Y = 1,
		map_to_z_from_Z = 2,
	};
	inline map_to_z_from_enum map_to_z_from(void);
	inline void map_to_z_from(map_to_z_from_enum value);
	inline bool use_motion_extrapolate(void);
	inline void use_motion_extrapolate(bool value);
	inline float from_min_x(void);
	inline void from_min_x(float value);
	inline float from_min_y(void);
	inline void from_min_y(float value);
	inline float from_min_z(void);
	inline void from_min_z(float value);
	inline float from_max_x(void);
	inline void from_max_x(float value);
	inline float from_max_y(void);
	inline void from_max_y(float value);
	inline float from_max_z(void);
	inline void from_max_z(float value);
	inline float to_min_x(void);
	inline void to_min_x(float value);
	inline float to_min_y(void);
	inline void to_min_y(float value);
	inline float to_min_z(void);
	inline void to_min_z(float value);
	inline float to_max_x(void);
	inline void to_max_x(float value);
	inline float to_max_y(void);
	inline void to_max_y(float value);
	inline float to_max_z(void);
	inline void to_max_z(float value);
	inline float from_min_x_rot(void);
	inline void from_min_x_rot(float value);
	inline float from_min_y_rot(void);
	inline void from_min_y_rot(float value);
	inline float from_min_z_rot(void);
	inline void from_min_z_rot(float value);
	inline float from_max_x_rot(void);
	inline void from_max_x_rot(float value);
	inline float from_max_y_rot(void);
	inline void from_max_y_rot(float value);
	inline float from_max_z_rot(void);
	inline void from_max_z_rot(float value);
	inline float to_min_x_rot(void);
	inline void to_min_x_rot(float value);
	inline float to_min_y_rot(void);
	inline void to_min_y_rot(float value);
	inline float to_min_z_rot(void);
	inline void to_min_z_rot(float value);
	inline float to_max_x_rot(void);
	inline void to_max_x_rot(float value);
	inline float to_max_y_rot(void);
	inline void to_max_y_rot(float value);
	inline float to_max_z_rot(void);
	inline void to_max_z_rot(float value);
	inline float from_min_x_scale(void);
	inline void from_min_x_scale(float value);
	inline float from_min_y_scale(void);
	inline void from_min_y_scale(float value);
	inline float from_min_z_scale(void);
	inline void from_min_z_scale(float value);
	inline float from_max_x_scale(void);
	inline void from_max_x_scale(float value);
	inline float from_max_y_scale(void);
	inline void from_max_y_scale(float value);
	inline float from_max_z_scale(void);
	inline void from_max_z_scale(float value);
	inline float to_min_x_scale(void);
	inline void to_min_x_scale(float value);
	inline float to_min_y_scale(void);
	inline void to_min_y_scale(float value);
	inline float to_min_z_scale(void);
	inline void to_min_z_scale(float value);
	inline float to_max_x_scale(void);
	inline void to_max_x_scale(float value);
	inline float to_max_y_scale(void);
	inline void to_max_y_scale(float value);
	inline float to_max_z_scale(void);
	inline void to_max_z_scale(float value);

};

/**************** Shrinkwrap Constraint ****************/

class ShrinkwrapConstraint : public Constraint {
public:
	ShrinkwrapConstraint(const PointerRNA &ptr_arg) :
		Constraint(ptr_arg)
		{}

	inline Object target(void);
	enum shrinkwrap_type_enum {
		shrinkwrap_type_NEAREST_SURFACE = 0,
		shrinkwrap_type_PROJECT = 1,
		shrinkwrap_type_NEAREST_VERTEX = 2,
		shrinkwrap_type_TARGET_PROJECT = 3,
	};
	inline shrinkwrap_type_enum shrinkwrap_type(void);
	inline void shrinkwrap_type(shrinkwrap_type_enum value);
	enum wrap_mode_enum {
		wrap_mode_ON_SURFACE = 0,
		wrap_mode_INSIDE = 1,
		wrap_mode_OUTSIDE = 2,
		wrap_mode_OUTSIDE_SURFACE = 3,
		wrap_mode_ABOVE_SURFACE = 4,
	};
	inline wrap_mode_enum wrap_mode(void);
	inline void wrap_mode(wrap_mode_enum value);
	inline float distance(void);
	inline void distance(float value);
	enum project_axis_enum {
		project_axis_POS_X = 0,
		project_axis_POS_Y = 1,
		project_axis_POS_Z = 2,
		project_axis_NEG_X = 3,
		project_axis_NEG_Y = 4,
		project_axis_NEG_Z = 5,
	};
	inline project_axis_enum project_axis(void);
	inline void project_axis(project_axis_enum value);
	enum project_axis_space_enum {
		project_axis_space_WORLD = 0,
		project_axis_space_POSE = 2,
		project_axis_space_LOCAL_WITH_PARENT = 3,
		project_axis_space_LOCAL = 1,
	};
	inline project_axis_space_enum project_axis_space(void);
	inline void project_axis_space(project_axis_space_enum value);
	inline float project_limit(void);
	inline void project_limit(float value);
	inline bool use_project_opposite(void);
	inline void use_project_opposite(bool value);
	enum cull_face_enum {
		cull_face_OFF = 0,
		cull_face_FRONT = 8,
		cull_face_BACK = 16,
	};
	inline cull_face_enum cull_face(void);
	inline void cull_face(cull_face_enum value);
	inline bool use_invert_cull(void);
	inline void use_invert_cull(bool value);
	inline bool use_track_normal(void);
	inline void use_track_normal(bool value);
	enum track_axis_enum {
		track_axis_TRACK_X = 0,
		track_axis_TRACK_Y = 1,
		track_axis_TRACK_Z = 2,
		track_axis_TRACK_NEGATIVE_X = 3,
		track_axis_TRACK_NEGATIVE_Y = 4,
		track_axis_TRACK_NEGATIVE_Z = 5,
	};
	inline track_axis_enum track_axis(void);
	inline void track_axis(track_axis_enum value);

};

/**************** Damped Track Constraint ****************/

class DampedTrackConstraint : public Constraint {
public:
	DampedTrackConstraint(const PointerRNA &ptr_arg) :
		Constraint(ptr_arg)
		{}

	inline float head_tail(void);
	inline void head_tail(float value);
	inline bool use_bbone_shape(void);
	inline void use_bbone_shape(bool value);
	inline Object target(void);
	inline std::string subtarget(void);
	inline void subtarget(const std::string& value);
	enum track_axis_enum {
		track_axis_TRACK_X = 0,
		track_axis_TRACK_Y = 1,
		track_axis_TRACK_Z = 2,
		track_axis_TRACK_NEGATIVE_X = 3,
		track_axis_TRACK_NEGATIVE_Y = 4,
		track_axis_TRACK_NEGATIVE_Z = 5,
	};
	inline track_axis_enum track_axis(void);
	inline void track_axis(track_axis_enum value);

};

/**************** Spline IK Constraint ****************/

class SplineIKConstraint : public Constraint {
public:
	SplineIKConstraint(const PointerRNA &ptr_arg) :
		Constraint(ptr_arg)
		{}

	inline Object target(void);
	inline int chain_count(void);
	inline void chain_count(int value);
	inline Array<float, 32> joint_bindings(void);
	inline void joint_bindings(float values[32]);
	inline bool use_chain_offset(void);
	inline void use_chain_offset(bool value);
	inline bool use_even_divisions(void);
	inline void use_even_divisions(bool value);
	inline bool use_y_stretch(void);
	inline void use_y_stretch(bool value);
	inline bool use_curve_radius(void);
	inline void use_curve_radius(bool value);
	enum xz_scale_mode_enum {
		xz_scale_mode_NONE = 0,
		xz_scale_mode_BONE_ORIGINAL = 1,
		xz_scale_mode_INVERSE_PRESERVE = 2,
		xz_scale_mode_VOLUME_PRESERVE = 3,
	};
	inline xz_scale_mode_enum xz_scale_mode(void);
	inline void xz_scale_mode(xz_scale_mode_enum value);
	inline float bulge(void);
	inline void bulge(float value);
	inline bool use_bulge_min(void);
	inline void use_bulge_min(bool value);
	inline bool use_bulge_max(void);
	inline void use_bulge_max(bool value);
	inline float bulge_min(void);
	inline void bulge_min(float value);
	inline float bulge_max(void);
	inline void bulge_max(float value);
	inline float bulge_smooth(void);
	inline void bulge_smooth(float value);

};

/**************** Pivot Constraint ****************/

class PivotConstraint : public Constraint {
public:
	PivotConstraint(const PointerRNA &ptr_arg) :
		Constraint(ptr_arg)
		{}

	inline float head_tail(void);
	inline void head_tail(float value);
	inline bool use_bbone_shape(void);
	inline void use_bbone_shape(bool value);
	inline Object target(void);
	inline std::string subtarget(void);
	inline void subtarget(const std::string& value);
	inline bool use_relative_location(void);
	inline void use_relative_location(bool value);
	inline Array<float, 3> offset(void);
	inline void offset(float values[3]);
	enum rotation_range_enum {
		rotation_range_ALWAYS_ACTIVE = -1,
		rotation_range_NX = 0,
		rotation_range_NY = 1,
		rotation_range_NZ = 2,
		rotation_range_X = 3,
		rotation_range_Y = 4,
		rotation_range_Z = 5,
	};
	inline rotation_range_enum rotation_range(void);
	inline void rotation_range(rotation_range_enum value);

};

/**************** Follow Track Constraint ****************/

class FollowTrackConstraint : public Constraint {
public:
	FollowTrackConstraint(const PointerRNA &ptr_arg) :
		Constraint(ptr_arg)
		{}

	inline MovieClip clip(void);
	inline std::string track(void);
	inline void track(const std::string& value);
	inline bool use_active_clip(void);
	inline void use_active_clip(bool value);
	inline bool use_3d_position(void);
	inline void use_3d_position(bool value);
	inline std::string object(void);
	inline void object(const std::string& value);
	inline Object camera(void);
	inline Object depth_object(void);
	enum frame_method_enum {
		frame_method_STRETCH = 0,
		frame_method_FIT = 1,
		frame_method_CROP = 2,
	};
	inline frame_method_enum frame_method(void);
	inline void frame_method(frame_method_enum value);
	inline bool use_undistorted_position(void);
	inline void use_undistorted_position(bool value);

};

/**************** Camera Solver Constraint ****************/

class CameraSolverConstraint : public Constraint {
public:
	CameraSolverConstraint(const PointerRNA &ptr_arg) :
		Constraint(ptr_arg)
		{}

	inline MovieClip clip(void);
	inline bool use_active_clip(void);
	inline void use_active_clip(bool value);

};

/**************** Object Solver Constraint ****************/

class ObjectSolverConstraint : public Constraint {
public:
	ObjectSolverConstraint(const PointerRNA &ptr_arg) :
		Constraint(ptr_arg)
		{}

	inline MovieClip clip(void);
	inline bool use_active_clip(void);
	inline void use_active_clip(bool value);
	inline std::string object(void);
	inline void object(const std::string& value);
	inline Object camera(void);

};

/**************** Transform Cache Constraint ****************/

class TransformCacheConstraint : public Constraint {
public:
	TransformCacheConstraint(const PointerRNA &ptr_arg) :
		Constraint(ptr_arg)
		{}

	inline CacheFile cache_file(void);
	inline std::string object_path(void);
	inline void object_path(const std::string& value);

};

/**************** Context ****************/

class Context : public Pointer {
public:
	Context(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline WindowManager window_manager(void);
	inline Window window(void);
	inline WorkSpace workspace(void);
	inline Screen screen(void);
	inline Area area(void);
	inline Space space_data(void);
	inline Region region(void);
	inline RegionView3D region_data(void);
	inline GizmoGroup gizmo_group(void);
	inline BlendData blend_data(void);
	inline Depsgraph depsgraph(void);
	inline Scene scene(void);
	inline ViewLayer view_layer(void);
	inline std::string engine(void);
	inline void engine(const std::string& value);
	inline Collection collection(void);
	inline LayerCollection layer_collection(void);
	inline ToolSettings tool_settings(void);
	inline Preferences preferences(void);
	enum mode_enum {
		mode_EDIT_MESH = 0,
		mode_EDIT_CURVE = 1,
		mode_EDIT_SURFACE = 2,
		mode_EDIT_TEXT = 3,
		mode_EDIT_ARMATURE = 4,
		mode_EDIT_METABALL = 5,
		mode_EDIT_LATTICE = 6,
		mode_POSE = 7,
		mode_SCULPT = 8,
		mode_PAINT_WEIGHT = 9,
		mode_PAINT_VERTEX = 10,
		mode_PAINT_TEXTURE = 11,
		mode_PARTICLE = 12,
		mode_OBJECT = 13,
		mode_PAINT_GPENCIL = 14,
		mode_EDIT_GPENCIL = 15,
		mode_SCULPT_GPENCIL = 16,
		mode_WEIGHT_GPENCIL = 17,
	};
	inline mode_enum mode(void);
	inline void mode(mode_enum value);

};

/**************** Curve ****************/

class Curve : public ID {
public:
	Curve(const PointerRNA &ptr_arg) :
		ID(ptr_arg),
		splines(ptr_arg),
		materials(ptr_arg)
		{}

	inline Key shape_keys(void);
	COLLECTION_PROPERTY(CurveSplines, Spline, Curve, splines, false, false, false)
	inline int path_duration(void);
	inline void path_duration(int value);
	inline bool use_path(void);
	inline void use_path(bool value);
	inline bool use_path_follow(void);
	inline void use_path_follow(bool value);
	inline bool use_stretch(void);
	inline void use_stretch(bool value);
	inline bool use_deform_bounds(void);
	inline void use_deform_bounds(bool value);
	inline bool use_radius(void);
	inline void use_radius(bool value);
	inline int bevel_resolution(void);
	inline void bevel_resolution(int value);
	inline float offset(void);
	inline void offset(float value);
	inline float extrude(void);
	inline void extrude(float value);
	inline float bevel_depth(void);
	inline void bevel_depth(float value);
	inline int resolution_u(void);
	inline void resolution_u(int value);
	inline int resolution_v(void);
	inline void resolution_v(int value);
	inline int render_resolution_u(void);
	inline void render_resolution_u(int value);
	inline int render_resolution_v(void);
	inline void render_resolution_v(int value);
	inline float eval_time(void);
	inline void eval_time(float value);
	inline Object bevel_object(void);
	inline Object taper_object(void);
	enum dimensions_enum {
		dimensions_2D = 0,
		dimensions_3D = 1,
	};
	inline dimensions_enum dimensions(void);
	inline void dimensions(dimensions_enum value);
	enum fill_mode_enum {
		fill_mode_FULL = 0,
		fill_mode_BACK = 4,
		fill_mode_FRONT = 2,
		fill_mode_HALF = 6,
	};
	inline fill_mode_enum fill_mode(void);
	inline void fill_mode(fill_mode_enum value);
	enum twist_mode_enum {
		twist_mode_Z_UP = 0,
		twist_mode_MINIMUM = 3,
		twist_mode_TANGENT = 4,
	};
	inline twist_mode_enum twist_mode(void);
	inline void twist_mode(twist_mode_enum value);
	enum bevel_factor_mapping_start_enum {
		bevel_factor_mapping_start_RESOLUTION = 0,
		bevel_factor_mapping_start_SEGMENTS = 1,
		bevel_factor_mapping_start_SPLINE = 2,
	};
	inline bevel_factor_mapping_start_enum bevel_factor_mapping_start(void);
	inline void bevel_factor_mapping_start(bevel_factor_mapping_start_enum value);
	enum bevel_factor_mapping_end_enum {
		bevel_factor_mapping_end_RESOLUTION = 0,
		bevel_factor_mapping_end_SEGMENTS = 1,
		bevel_factor_mapping_end_SPLINE = 2,
	};
	inline bevel_factor_mapping_end_enum bevel_factor_mapping_end(void);
	inline void bevel_factor_mapping_end(bevel_factor_mapping_end_enum value);
	inline float twist_smooth(void);
	inline void twist_smooth(float value);
	inline bool use_fill_deform(void);
	inline void use_fill_deform(bool value);
	inline bool use_fill_caps(void);
	inline void use_fill_caps(bool value);
	inline bool use_map_taper(void);
	inline void use_map_taper(bool value);
	inline bool use_auto_texspace(void);
	inline void use_auto_texspace(bool value);
	inline Array<float, 3> texspace_location(void);
	inline void texspace_location(float values[3]);
	inline Array<float, 3> texspace_size(void);
	inline void texspace_size(float values[3]);
	inline bool use_uv_as_generated(void);
	inline void use_uv_as_generated(bool value);
	COLLECTION_PROPERTY(IDMaterials, Material, Curve, materials, true, true, true)
	inline float bevel_factor_start(void);
	inline void bevel_factor_start(float value);
	inline float bevel_factor_end(void);
	inline void bevel_factor_end(float value);
	inline bool is_editmode(void);
	inline void is_editmode(bool value);
	inline AnimData animation_data(void);

	inline void transform(float matrix[16], bool shape_keys);
	inline bool validate_material_indices();
	inline void update_gpu_tag();
};

/**************** Surface Curve ****************/

class SurfaceCurve : public Curve {
public:
	SurfaceCurve(const PointerRNA &ptr_arg) :
		Curve(ptr_arg)
		{}

	inline bool use_uv_as_generated(void);
	inline void use_uv_as_generated(bool value);

};

/**************** Text Curve ****************/

class TextCurve : public Curve {
public:
	TextCurve(const PointerRNA &ptr_arg) :
		Curve(ptr_arg),
		text_boxes(ptr_arg),
		body_format(ptr_arg)
		{}

	enum align_x_enum {
		align_x_LEFT = 0,
		align_x_CENTER = 1,
		align_x_RIGHT = 2,
		align_x_JUSTIFY = 3,
		align_x_FLUSH = 4,
	};
	inline align_x_enum align_x(void);
	inline void align_x(align_x_enum value);
	enum align_y_enum {
		align_y_TOP_BASELINE = 0,
		align_y_TOP = 1,
		align_y_CENTER = 2,
		align_y_BOTTOM = 4,
		align_y_BOTTOM_BASELINE = 3,
	};
	inline align_y_enum align_y(void);
	inline void align_y(align_y_enum value);
	enum overflow_enum {
		overflow_NONE = 0,
		overflow_SCALE = 1,
		overflow_TRUNCATE = 2,
	};
	inline overflow_enum overflow(void);
	inline void overflow(overflow_enum value);
	inline float size(void);
	inline void size(float value);
	inline float small_caps_scale(void);
	inline void small_caps_scale(float value);
	inline float space_line(void);
	inline void space_line(float value);
	inline float space_word(void);
	inline void space_word(float value);
	inline float space_character(void);
	inline void space_character(float value);
	inline float shear(void);
	inline void shear(float value);
	inline float offset_x(void);
	inline void offset_x(float value);
	inline float offset_y(void);
	inline void offset_y(float value);
	inline float underline_position(void);
	inline void underline_position(float value);
	inline float underline_height(void);
	inline void underline_height(float value);
	COLLECTION_PROPERTY(DefaultCollectionFunctions, TextBox, TextCurve, text_boxes, true, true, false)
	inline int active_textbox(void);
	inline void active_textbox(int value);
	inline std::string family(void);
	inline void family(const std::string& value);
	inline std::string body(void);
	inline void body(const std::string& value);
	COLLECTION_PROPERTY(DefaultCollectionFunctions, TextCharacterFormat, TextCurve, body_format, true, true, false)
	inline Object follow_curve(void);
	inline VectorFont font(void);
	inline VectorFont font_bold(void);
	inline VectorFont font_italic(void);
	inline VectorFont font_bold_italic(void);
	inline TextCharacterFormat edit_format(void);
	inline bool use_fast_edit(void);
	inline void use_fast_edit(bool value);
	inline bool use_uv_as_generated(void);
	inline void use_uv_as_generated(bool value);

};

/**************** Text Box ****************/

class TextBox : public Pointer {
public:
	TextBox(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline float x(void);
	inline void x(float value);
	inline float y(void);
	inline void y(float value);
	inline float width(void);
	inline void width(float value);
	inline float height(void);
	inline void height(float value);

};

/**************** Text Character Format ****************/

class TextCharacterFormat : public Pointer {
public:
	TextCharacterFormat(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline bool use_bold(void);
	inline void use_bold(bool value);
	inline bool use_italic(void);
	inline void use_italic(bool value);
	inline bool use_underline(void);
	inline void use_underline(bool value);
	inline bool use_small_caps(void);
	inline void use_small_caps(bool value);
	inline int material_index(void);
	inline void material_index(int value);
	inline int kerning(void);
	inline void kerning(int value);

};

/**************** SplinePoint ****************/

class SplinePoint : public Pointer {
public:
	SplinePoint(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline bool select(void);
	inline void select(bool value);
	inline bool hide(void);
	inline void hide(bool value);
	inline Array<float, 4> co(void);
	inline void co(float values[4]);
	inline float weight(void);
	inline void weight(float value);
	inline float tilt(void);
	inline void tilt(float value);
	inline float weight_softbody(void);
	inline void weight_softbody(float value);
	inline float radius(void);
	inline void radius(float value);

};

/**************** Bezier Curve Point ****************/

class BezierSplinePoint : public Pointer {
public:
	BezierSplinePoint(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline bool select_left_handle(void);
	inline void select_left_handle(bool value);
	inline bool select_right_handle(void);
	inline void select_right_handle(bool value);
	inline bool select_control_point(void);
	inline void select_control_point(bool value);
	inline bool hide(void);
	inline void hide(bool value);
	enum handle_left_type_enum {
		handle_left_type_FREE = 0,
		handle_left_type_VECTOR = 2,
		handle_left_type_ALIGNED = 3,
		handle_left_type_AUTO = 1,
	};
	inline handle_left_type_enum handle_left_type(void);
	inline void handle_left_type(handle_left_type_enum value);
	enum handle_right_type_enum {
		handle_right_type_FREE = 0,
		handle_right_type_VECTOR = 2,
		handle_right_type_ALIGNED = 3,
		handle_right_type_AUTO = 1,
	};
	inline handle_right_type_enum handle_right_type(void);
	inline void handle_right_type(handle_right_type_enum value);
	inline Array<float, 3> handle_left(void);
	inline void handle_left(float values[3]);
	inline Array<float, 3> co(void);
	inline void co(float values[3]);
	inline Array<float, 3> handle_right(void);
	inline void handle_right(float values[3]);
	inline float tilt(void);
	inline void tilt(float value);
	inline float weight_softbody(void);
	inline void weight_softbody(float value);
	inline float radius(void);
	inline void radius(float value);

};

/**************** Spline ****************/

class Spline : public Pointer {
public:
	Spline(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		points(ptr_arg),
		bezier_points(ptr_arg)
		{}

	inline Struct rna_type(void);
	COLLECTION_PROPERTY(SplinePoints, SplinePoint, Spline, points, true, true, false)
	COLLECTION_PROPERTY(SplineBezierPoints, BezierSplinePoint, Spline, bezier_points, true, true, false)
	enum tilt_interpolation_enum {
		tilt_interpolation_LINEAR = 0,
		tilt_interpolation_CARDINAL = 1,
		tilt_interpolation_BSPLINE = 2,
		tilt_interpolation_EASE = 3,
	};
	inline tilt_interpolation_enum tilt_interpolation(void);
	inline void tilt_interpolation(tilt_interpolation_enum value);
	enum radius_interpolation_enum {
		radius_interpolation_LINEAR = 0,
		radius_interpolation_CARDINAL = 1,
		radius_interpolation_BSPLINE = 2,
		radius_interpolation_EASE = 3,
	};
	inline radius_interpolation_enum radius_interpolation(void);
	inline void radius_interpolation(radius_interpolation_enum value);
	enum type_enum {
		type_POLY = 0,
		type_BEZIER = 1,
		type_BSPLINE = 2,
		type_CARDINAL = 3,
		type_NURBS = 4,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	inline int point_count_u(void);
	inline void point_count_u(int value);
	inline int point_count_v(void);
	inline void point_count_v(int value);
	inline int order_u(void);
	inline void order_u(int value);
	inline int order_v(void);
	inline void order_v(int value);
	inline int resolution_u(void);
	inline void resolution_u(int value);
	inline int resolution_v(void);
	inline void resolution_v(int value);
	inline bool use_cyclic_u(void);
	inline void use_cyclic_u(bool value);
	inline bool use_cyclic_v(void);
	inline void use_cyclic_v(bool value);
	inline bool use_endpoint_u(void);
	inline void use_endpoint_u(bool value);
	inline bool use_endpoint_v(void);
	inline void use_endpoint_v(bool value);
	inline bool use_bezier_u(void);
	inline void use_bezier_u(bool value);
	inline bool use_bezier_v(void);
	inline void use_bezier_v(bool value);
	inline bool use_smooth(void);
	inline void use_smooth(bool value);
	inline bool hide(void);
	inline void hide(bool value);
	inline int material_index(void);
	inline void material_index(int value);
	inline int character_index(void);
	inline void character_index(int value);

	inline float calc_length(int resolution);
};

/**************** Canvas Settings ****************/

class DynamicPaintCanvasSettings : public Pointer {
public:
	DynamicPaintCanvasSettings(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		canvas_surfaces(ptr_arg)
		{}

	inline Struct rna_type(void);
	COLLECTION_PROPERTY(DynamicPaintSurfaces, DynamicPaintSurface, DynamicPaintCanvasSettings, canvas_surfaces, false, false, false)

};

/**************** Brush Settings ****************/

class DynamicPaintBrushSettings : public Pointer {
public:
	DynamicPaintBrushSettings(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline Array<float, 3> paint_color(void);
	inline void paint_color(float values[3]);
	inline float paint_alpha(void);
	inline void paint_alpha(float value);
	inline bool use_absolute_alpha(void);
	inline void use_absolute_alpha(bool value);
	inline float paint_wetness(void);
	inline void paint_wetness(float value);
	inline bool use_paint_erase(void);
	inline void use_paint_erase(bool value);
	enum wave_type_enum {
		wave_type_CHANGE = 3,
		wave_type_DEPTH = 0,
		wave_type_FORCE = 1,
		wave_type_REFLECT = 2,
	};
	inline wave_type_enum wave_type(void);
	inline void wave_type(wave_type_enum value);
	inline float wave_factor(void);
	inline void wave_factor(float value);
	inline float wave_clamp(void);
	inline void wave_clamp(float value);
	inline bool use_smudge(void);
	inline void use_smudge(bool value);
	inline float smudge_strength(void);
	inline void smudge_strength(float value);
	inline float velocity_max(void);
	inline void velocity_max(float value);
	inline bool use_velocity_alpha(void);
	inline void use_velocity_alpha(bool value);
	inline bool use_velocity_depth(void);
	inline void use_velocity_depth(bool value);
	inline bool use_velocity_color(void);
	inline void use_velocity_color(bool value);
	enum paint_source_enum {
		paint_source_PARTICLE_SYSTEM = 3,
		paint_source_POINT = 4,
		paint_source_DISTANCE = 1,
		paint_source_VOLUME_DISTANCE = 2,
		paint_source_VOLUME = 0,
	};
	inline paint_source_enum paint_source(void);
	inline void paint_source(paint_source_enum value);
	inline float paint_distance(void);
	inline void paint_distance(float value);
	inline bool use_proximity_ramp_alpha(void);
	inline void use_proximity_ramp_alpha(bool value);
	enum proximity_falloff_enum {
		proximity_falloff_SMOOTH = 1,
		proximity_falloff_CONSTANT = 0,
		proximity_falloff_RAMP = 2,
	};
	inline proximity_falloff_enum proximity_falloff(void);
	inline void proximity_falloff(proximity_falloff_enum value);
	inline bool use_proximity_project(void);
	inline void use_proximity_project(bool value);
	enum ray_direction_enum {
		ray_direction_CANVAS = 0,
		ray_direction_BRUSH = 1,
		ray_direction_Z_AXIS = 2,
	};
	inline ray_direction_enum ray_direction(void);
	inline void ray_direction(ray_direction_enum value);
	inline bool invert_proximity(void);
	inline void invert_proximity(bool value);
	inline bool use_negative_volume(void);
	inline void use_negative_volume(bool value);
	inline ParticleSystem particle_system(void);
	inline bool use_particle_radius(void);
	inline void use_particle_radius(bool value);
	inline float solid_radius(void);
	inline void solid_radius(float value);
	inline float smooth_radius(void);
	inline void smooth_radius(float value);
	inline ColorRamp paint_ramp(void);
	inline ColorRamp velocity_ramp(void);

};

/**************** Paint Surface ****************/

class DynamicPaintSurface : public Pointer {
public:
	DynamicPaintSurface(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	enum surface_format_enum {
		surface_format_VERTEX = 1,
		surface_format_IMAGE = 2,
	};
	inline surface_format_enum surface_format(void);
	inline void surface_format(surface_format_enum value);
	enum surface_type_enum {
		surface_type_PAINT = 0,
	};
	inline surface_type_enum surface_type(void);
	inline void surface_type(surface_type_enum value);
	inline bool is_active(void);
	inline void is_active(bool value);
	inline bool show_preview(void);
	inline void show_preview(bool value);
	inline std::string name(void);
	inline void name(const std::string& value);
	inline Collection brush_collection(void);
	inline bool use_dissolve(void);
	inline void use_dissolve(bool value);
	inline int dissolve_speed(void);
	inline void dissolve_speed(int value);
	inline bool use_drying(void);
	inline void use_drying(bool value);
	inline int dry_speed(void);
	inline void dry_speed(int value);
	inline int image_resolution(void);
	inline void image_resolution(int value);
	inline std::string uv_layer(void);
	inline void uv_layer(const std::string& value);
	inline int frame_start(void);
	inline void frame_start(int value);
	inline int frame_end(void);
	inline void frame_end(int value);
	inline int frame_substeps(void);
	inline void frame_substeps(int value);
	inline bool use_antialiasing(void);
	inline void use_antialiasing(bool value);
	inline float brush_influence_scale(void);
	inline void brush_influence_scale(float value);
	inline float brush_radius_scale(void);
	inline void brush_radius_scale(float value);
	enum init_color_type_enum {
		init_color_type_NONE = 0,
		init_color_type_COLOR = 1,
		init_color_type_TEXTURE = 2,
		init_color_type_VERTEX_COLOR = 3,
	};
	inline init_color_type_enum init_color_type(void);
	inline void init_color_type(init_color_type_enum value);
	inline Array<float, 4> init_color(void);
	inline void init_color(float values[4]);
	inline Texture init_texture(void);
	inline std::string init_layername(void);
	inline void init_layername(const std::string& value);
	enum effect_ui_enum {
		effect_ui_SPREAD = 1,
		effect_ui_DRIP = 2,
		effect_ui_SHRINK = 3,
	};
	inline effect_ui_enum effect_ui(void);
	inline void effect_ui(effect_ui_enum value);
	inline bool use_dry_log(void);
	inline void use_dry_log(bool value);
	inline bool use_dissolve_log(void);
	inline void use_dissolve_log(bool value);
	inline bool use_spread(void);
	inline void use_spread(bool value);
	inline float spread_speed(void);
	inline void spread_speed(float value);
	inline float color_dry_threshold(void);
	inline void color_dry_threshold(float value);
	inline float color_spread_speed(void);
	inline void color_spread_speed(float value);
	inline bool use_drip(void);
	inline void use_drip(bool value);
	inline bool use_shrink(void);
	inline void use_shrink(bool value);
	inline float shrink_speed(void);
	inline void shrink_speed(float value);
	inline EffectorWeights effector_weights(void);
	inline float drip_velocity(void);
	inline void drip_velocity(float value);
	inline float drip_acceleration(void);
	inline void drip_acceleration(float value);
	inline bool use_premultiply(void);
	inline void use_premultiply(bool value);
	inline std::string image_output_path(void);
	inline void image_output_path(const std::string& value);
	inline std::string output_name_a(void);
	inline void output_name_a(const std::string& value);
	inline bool use_output_a(void);
	inline void use_output_a(bool value);
	inline std::string output_name_b(void);
	inline void output_name_b(const std::string& value);
	inline bool use_output_b(void);
	inline void use_output_b(bool value);
	enum preview_id_enum {
		preview_id_PAINT = 0,
		preview_id_WETMAP = 1,
	};
	inline preview_id_enum preview_id(void);
	inline void preview_id(preview_id_enum value);
	inline float depth_clamp(void);
	inline void depth_clamp(float value);
	inline float displace_factor(void);
	inline void displace_factor(float value);
	enum image_fileformat_enum {
		image_fileformat_PNG = 0,
		image_fileformat_OPENEXR = 1,
	};
	inline image_fileformat_enum image_fileformat(void);
	inline void image_fileformat(image_fileformat_enum value);
	enum displace_type_enum {
		displace_type_DISPLACE = 0,
		displace_type_DEPTH = 1,
	};
	inline displace_type_enum displace_type(void);
	inline void displace_type(displace_type_enum value);
	inline bool use_incremental_displace(void);
	inline void use_incremental_displace(bool value);
	inline float wave_damping(void);
	inline void wave_damping(float value);
	inline float wave_speed(void);
	inline void wave_speed(float value);
	inline float wave_timescale(void);
	inline void wave_timescale(float value);
	inline float wave_spring(void);
	inline void wave_spring(float value);
	inline float wave_smoothness(void);
	inline void wave_smoothness(float value);
	inline bool use_wave_open_border(void);
	inline void use_wave_open_border(bool value);
	inline PointCache point_cache(void);
	inline bool is_cache_user(void);
	inline void is_cache_user(bool value);
	inline bool use_color_preview(void);
	inline void use_color_preview(bool value);

	inline bool output_exists(Object& object, int index);
};

/**************** F-Curve ****************/

class FCurve : public Pointer {
public:
	FCurve(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		sampled_points(ptr_arg),
		keyframe_points(ptr_arg),
		modifiers(ptr_arg)
		{}

	inline Struct rna_type(void);
	enum extrapolation_enum {
		extrapolation_CONSTANT = 0,
		extrapolation_LINEAR = 1,
	};
	inline extrapolation_enum extrapolation(void);
	inline void extrapolation(extrapolation_enum value);
	inline Driver driver(void);
	inline ActionGroup group(void);
	inline std::string data_path(void);
	inline void data_path(const std::string& value);
	inline int array_index(void);
	inline void array_index(int value);
	enum color_mode_enum {
		color_mode_AUTO_RAINBOW = 0,
		color_mode_AUTO_RGB = 1,
		color_mode_AUTO_YRGB = 3,
		color_mode_CUSTOM = 2,
	};
	inline color_mode_enum color_mode(void);
	inline void color_mode(color_mode_enum value);
	inline Array<float, 3> color(void);
	inline void color(float values[3]);
	inline bool select(void);
	inline void select(bool value);
	inline bool lock(void);
	inline void lock(bool value);
	inline bool mute(void);
	inline void mute(bool value);
	inline bool hide(void);
	inline void hide(bool value);
	enum auto_smoothing_enum {
		auto_smoothing_NONE = 0,
		auto_smoothing_CONT_ACCEL = 1,
	};
	inline auto_smoothing_enum auto_smoothing(void);
	inline void auto_smoothing(auto_smoothing_enum value);
	inline bool is_valid(void);
	inline void is_valid(bool value);
	COLLECTION_PROPERTY(DefaultCollectionFunctions, FCurveSample, FCurve, sampled_points, true, true, false)
	COLLECTION_PROPERTY(FCurveKeyframePoints, Keyframe, FCurve, keyframe_points, true, true, false)
	COLLECTION_PROPERTY(FCurveModifiers, FModifier, FCurve, modifiers, false, true, false)

	inline float evaluate(float frame);
	inline void update();
	inline void range(float range[2]);
	inline void update_autoflags(Context C, AnyType& data);
	inline void convert_to_samples(int start, int end);
	inline void convert_to_keyframes(int start, int end);
};

/**************** Keyframe ****************/

class Keyframe : public Pointer {
public:
	Keyframe(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline bool select_left_handle(void);
	inline void select_left_handle(bool value);
	inline bool select_right_handle(void);
	inline void select_right_handle(bool value);
	inline bool select_control_point(void);
	inline void select_control_point(bool value);
	enum handle_left_type_enum {
		handle_left_type_FREE = 0,
		handle_left_type_ALIGNED = 3,
		handle_left_type_VECTOR = 2,
		handle_left_type_AUTO = 1,
		handle_left_type_AUTO_CLAMPED = 4,
	};
	inline handle_left_type_enum handle_left_type(void);
	inline void handle_left_type(handle_left_type_enum value);
	enum handle_right_type_enum {
		handle_right_type_FREE = 0,
		handle_right_type_ALIGNED = 3,
		handle_right_type_VECTOR = 2,
		handle_right_type_AUTO = 1,
		handle_right_type_AUTO_CLAMPED = 4,
	};
	inline handle_right_type_enum handle_right_type(void);
	inline void handle_right_type(handle_right_type_enum value);
	enum interpolation_enum {
		interpolation_CONSTANT = 0,
		interpolation_LINEAR = 1,
		interpolation_BEZIER = 2,
		interpolation_SINE = 12,
		interpolation_QUAD = 9,
		interpolation_CUBIC = 6,
		interpolation_QUART = 10,
		interpolation_QUINT = 11,
		interpolation_EXPO = 8,
		interpolation_CIRC = 5,
		interpolation_BACK = 3,
		interpolation_BOUNCE = 4,
		interpolation_ELASTIC = 7,
	};
	inline interpolation_enum interpolation(void);
	inline void interpolation(interpolation_enum value);
	enum type_enum {
		type_KEYFRAME = 0,
		type_BREAKDOWN = 2,
		type_MOVING_HOLD = 4,
		type_EXTREME = 1,
		type_JITTER = 3,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	enum easing_enum {
		easing_AUTO = 0,
		easing_EASE_IN = 1,
		easing_EASE_OUT = 2,
		easing_EASE_IN_OUT = 3,
	};
	inline easing_enum easing(void);
	inline void easing(easing_enum value);
	inline float back(void);
	inline void back(float value);
	inline float amplitude(void);
	inline void amplitude(float value);
	inline float period(void);
	inline void period(float value);
	inline Array<float, 2> handle_left(void);
	inline void handle_left(float values[2]);
	inline Array<float, 2> co(void);
	inline void co(float values[2]);
	inline Array<float, 2> handle_right(void);
	inline void handle_right(float values[2]);

};

/**************** F-Curve Sample ****************/

class FCurveSample : public Pointer {
public:
	FCurveSample(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline bool select(void);
	inline void select(bool value);
	inline Array<float, 2> co(void);
	inline void co(float values[2]);

};

/**************** Driver Target ****************/

class DriverTarget : public Pointer {
public:
	DriverTarget(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline ID id(void);
	enum id_type_enum {
		id_type_ACTION = 17217,
		id_type_ARMATURE = 21057,
		id_type_BRUSH = 21058,
		id_type_CAMERA = 16707,
		id_type_CACHEFILE = 17987,
		id_type_CURVE = 21827,
		id_type_FONT = 18006,
		id_type_GREASEPENCIL = 17479,
		id_type_COLLECTION = 21063,
		id_type_IMAGE = 19785,
		id_type_KEY = 17739,
		id_type_LIGHT = 16716,
		id_type_LIBRARY = 18764,
		id_type_LINESTYLE = 21324,
		id_type_LATTICE = 21580,
		id_type_MASK = 21325,
		id_type_MATERIAL = 16717,
		id_type_META = 16973,
		id_type_MESH = 17741,
		id_type_MOVIECLIP = 17229,
		id_type_NODETREE = 21582,
		id_type_OBJECT = 16975,
		id_type_PAINTCURVE = 17232,
		id_type_PALETTE = 19536,
		id_type_PARTICLE = 16720,
		id_type_LIGHT_PROBE = 20556,
		id_type_SCENE = 17235,
		id_type_SOUND = 20307,
		id_type_SPEAKER = 19283,
		id_type_TEXT = 22612,
		id_type_TEXTURE = 17748,
		id_type_WINDOWMANAGER = 19799,
		id_type_WORLD = 20311,
		id_type_WORKSPACE = 21335,
	};
	inline id_type_enum id_type(void);
	inline void id_type(id_type_enum value);
	inline std::string data_path(void);
	inline void data_path(const std::string& value);
	inline std::string bone_target(void);
	inline void bone_target(const std::string& value);
	enum transform_type_enum {
		transform_type_LOC_X = 0,
		transform_type_LOC_Y = 1,
		transform_type_LOC_Z = 2,
		transform_type_ROT_X = 3,
		transform_type_ROT_Y = 4,
		transform_type_ROT_Z = 5,
		transform_type_SCALE_X = 6,
		transform_type_SCALE_Y = 7,
		transform_type_SCALE_Z = 8,
	};
	inline transform_type_enum transform_type(void);
	inline void transform_type(transform_type_enum value);
	enum transform_space_enum {
		transform_space_WORLD_SPACE = 0,
		transform_space_TRANSFORM_SPACE = 4,
		transform_space_LOCAL_SPACE = 12,
	};
	inline transform_space_enum transform_space(void);
	inline void transform_space(transform_space_enum value);

};

/**************** Driver Variable ****************/

class DriverVariable : public Pointer {
public:
	DriverVariable(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		targets(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string name(void);
	inline void name(const std::string& value);
	enum type_enum {
		type_SINGLE_PROP = 0,
		type_TRANSFORMS = 3,
		type_ROTATION_DIFF = 1,
		type_LOC_DIFF = 2,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	COLLECTION_PROPERTY(DefaultCollectionFunctions, DriverTarget, DriverVariable, targets, true, true, false)
	inline bool is_name_valid(void);
	inline void is_name_valid(bool value);

};

/**************** Driver ****************/

class Driver : public Pointer {
public:
	Driver(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		variables(ptr_arg)
		{}

	inline Struct rna_type(void);
	enum type_enum {
		type_AVERAGE = 0,
		type_SUM = 2,
		type_SCRIPTED = 1,
		type_MIN = 3,
		type_MAX = 4,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	inline std::string expression(void);
	inline void expression(const std::string& value);
	COLLECTION_PROPERTY(ChannelDriverVariables, DriverVariable, Driver, variables, false, true, true)
	inline bool use_self(void);
	inline void use_self(bool value);
	inline bool is_valid(void);
	inline void is_valid(bool value);
	inline bool is_simple_expression(void);
	inline void is_simple_expression(bool value);

};

/**************** F-Modifier ****************/

class FModifier : public Pointer {
public:
	FModifier(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	enum type_enum {
		type_NULL = 0,
		type_GENERATOR = 1,
		type_FNGENERATOR = 2,
		type_ENVELOPE = 3,
		type_CYCLES = 4,
		type_NOISE = 5,
		type_LIMITS = 8,
		type_STEPPED = 9,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	inline bool show_expanded(void);
	inline void show_expanded(bool value);
	inline bool mute(void);
	inline void mute(bool value);
	inline bool is_valid(void);
	inline void is_valid(bool value);
	inline bool active(void);
	inline void active(bool value);
	inline bool use_restricted_range(void);
	inline void use_restricted_range(bool value);
	inline float frame_start(void);
	inline void frame_start(float value);
	inline float frame_end(void);
	inline void frame_end(float value);
	inline float blend_in(void);
	inline void blend_in(float value);
	inline float blend_out(void);
	inline void blend_out(float value);
	inline bool use_influence(void);
	inline void use_influence(bool value);
	inline float influence(void);
	inline void influence(float value);

};

/**************** Generator F-Modifier ****************/

class FModifierGenerator : public FModifier {
public:
	FModifierGenerator(const PointerRNA &ptr_arg) :
		FModifier(ptr_arg)
		{}

	inline bool use_additive(void);
	inline void use_additive(bool value);
	enum mode_enum {
		mode_POLYNOMIAL = 0,
		mode_POLYNOMIAL_FACTORISED = 1,
	};
	inline mode_enum mode(void);
	inline void mode(mode_enum value);
	inline int poly_order(void);
	inline void poly_order(int value);
	inline Array<float, 32> coefficients(void);
	inline void coefficients(float values[32]);

};

/**************** Built-In Function F-Modifier ****************/

class FModifierFunctionGenerator : public FModifier {
public:
	FModifierFunctionGenerator(const PointerRNA &ptr_arg) :
		FModifier(ptr_arg)
		{}

	inline float amplitude(void);
	inline void amplitude(float value);
	inline float phase_multiplier(void);
	inline void phase_multiplier(float value);
	inline float phase_offset(void);
	inline void phase_offset(float value);
	inline float value_offset(void);
	inline void value_offset(float value);
	inline bool use_additive(void);
	inline void use_additive(bool value);
	enum function_type_enum {
		function_type_SIN = 0,
		function_type_COS = 1,
		function_type_TAN = 2,
		function_type_SQRT = 3,
		function_type_LN = 4,
		function_type_SINC = 5,
	};
	inline function_type_enum function_type(void);
	inline void function_type(function_type_enum value);

};

/**************** Envelope F-Modifier ****************/

class FModifierEnvelope : public FModifier {
public:
	FModifierEnvelope(const PointerRNA &ptr_arg) :
		FModifier(ptr_arg),
		control_points(ptr_arg)
		{}

	COLLECTION_PROPERTY(FModifierEnvelopeControlPoints, FModifierEnvelopeControlPoint, FModifierEnvelope, control_points, true, true, false)
	inline float reference_value(void);
	inline void reference_value(float value);
	inline float default_min(void);
	inline void default_min(float value);
	inline float default_max(void);
	inline void default_max(float value);

};

/**************** Envelope Control Point ****************/

class FModifierEnvelopeControlPoint : public Pointer {
public:
	FModifierEnvelopeControlPoint(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline float min(void);
	inline void min(float value);
	inline float max(void);
	inline void max(float value);
	inline float frame(void);
	inline void frame(float value);

};

/**************** Cycles F-Modifier ****************/

class FModifierCycles : public FModifier {
public:
	FModifierCycles(const PointerRNA &ptr_arg) :
		FModifier(ptr_arg)
		{}

	enum mode_before_enum {
		mode_before_NONE = 0,
		mode_before_REPEAT = 1,
		mode_before_REPEAT_OFFSET = 2,
		mode_before_MIRROR = 3,
	};
	inline mode_before_enum mode_before(void);
	inline void mode_before(mode_before_enum value);
	inline int cycles_before(void);
	inline void cycles_before(int value);
	enum mode_after_enum {
		mode_after_NONE = 0,
		mode_after_REPEAT = 1,
		mode_after_REPEAT_OFFSET = 2,
		mode_after_MIRROR = 3,
	};
	inline mode_after_enum mode_after(void);
	inline void mode_after(mode_after_enum value);
	inline int cycles_after(void);
	inline void cycles_after(int value);

};

/**************** Python F-Modifier ****************/

class FModifierPython : public FModifier {
public:
	FModifierPython(const PointerRNA &ptr_arg) :
		FModifier(ptr_arg)
		{}


};

/**************** Limit F-Modifier ****************/

class FModifierLimits : public FModifier {
public:
	FModifierLimits(const PointerRNA &ptr_arg) :
		FModifier(ptr_arg)
		{}

	inline bool use_min_x(void);
	inline void use_min_x(bool value);
	inline bool use_min_y(void);
	inline void use_min_y(bool value);
	inline bool use_max_x(void);
	inline void use_max_x(bool value);
	inline bool use_max_y(void);
	inline void use_max_y(bool value);
	inline float min_x(void);
	inline void min_x(float value);
	inline float min_y(void);
	inline void min_y(float value);
	inline float max_x(void);
	inline void max_x(float value);
	inline float max_y(void);
	inline void max_y(float value);

};

/**************** Noise F-Modifier ****************/

class FModifierNoise : public FModifier {
public:
	FModifierNoise(const PointerRNA &ptr_arg) :
		FModifier(ptr_arg)
		{}

	enum blend_type_enum {
		blend_type_REPLACE = 0,
		blend_type_ADD = 1,
		blend_type_SUBTRACT = 2,
		blend_type_MULTIPLY = 3,
	};
	inline blend_type_enum blend_type(void);
	inline void blend_type(blend_type_enum value);
	inline float scale(void);
	inline void scale(float value);
	inline float strength(void);
	inline void strength(float value);
	inline float phase(void);
	inline void phase(float value);
	inline float offset(void);
	inline void offset(float value);
	inline int depth(void);
	inline void depth(int value);

};

/**************** Stepped Interpolation F-Modifier ****************/

class FModifierStepped : public FModifier {
public:
	FModifierStepped(const PointerRNA &ptr_arg) :
		FModifier(ptr_arg)
		{}

	inline float frame_step(void);
	inline void frame_step(float value);
	inline float frame_offset(void);
	inline void frame_offset(float value);
	inline bool use_frame_start(void);
	inline void use_frame_start(bool value);
	inline bool use_frame_end(void);
	inline void use_frame_end(bool value);
	inline float frame_start(void);
	inline void frame_start(float value);
	inline float frame_end(void);
	inline void frame_end(float value);

};

/**************** Fluid Simulation Settings ****************/

class FluidSettings : public Pointer {
public:
	FluidSettings(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	enum type_enum {
		type_NONE = 1,
		type_DOMAIN = 2,
		type_FLUID = 4,
		type_OBSTACLE = 8,
		type_INFLOW = 16,
		type_OUTFLOW = 32,
		type_PARTICLE = 64,
		type_CONTROL = 128,
	};
	inline type_enum type(void);
	inline void type(type_enum value);

};

/**************** Domain Fluid Simulation Settings ****************/

class DomainFluidSettings : public FluidSettings {
public:
	DomainFluidSettings(const PointerRNA &ptr_arg) :
		FluidSettings(ptr_arg),
		fluid_mesh_vertices(ptr_arg)
		{}

	inline int threads(void);
	inline void threads(int value);
	inline int resolution(void);
	inline void resolution(int value);
	inline int preview_resolution(void);
	inline void preview_resolution(int value);
	enum viewport_display_mode_enum {
		viewport_display_mode_GEOMETRY = 1,
		viewport_display_mode_PREVIEW = 2,
		viewport_display_mode_FINAL = 3,
	};
	inline viewport_display_mode_enum viewport_display_mode(void);
	inline void viewport_display_mode(viewport_display_mode_enum value);
	enum render_display_mode_enum {
		render_display_mode_GEOMETRY = 1,
		render_display_mode_PREVIEW = 2,
		render_display_mode_FINAL = 3,
	};
	inline render_display_mode_enum render_display_mode(void);
	inline void render_display_mode(render_display_mode_enum value);
	inline bool use_reverse_frames(void);
	inline void use_reverse_frames(bool value);
	inline std::string filepath(void);
	inline void filepath(const std::string& value);
	inline std::string memory_estimate(void);
	inline void memory_estimate(const std::string& value);
	inline Array<float, 3> gravity(void);
	inline void gravity(float values[3]);
	inline bool use_time_override(void);
	inline void use_time_override(bool value);
	inline float start_time(void);
	inline void start_time(float value);
	inline float end_time(void);
	inline void end_time(float value);
	inline int frame_offset(void);
	inline void frame_offset(int value);
	inline float simulation_scale(void);
	inline void simulation_scale(float value);
	inline float simulation_rate(void);
	inline void simulation_rate(float value);
	inline float viscosity_base(void);
	inline void viscosity_base(float value);
	inline int viscosity_exponent(void);
	inline void viscosity_exponent(int value);
	inline int grid_levels(void);
	inline void grid_levels(int value);
	inline float compressibility(void);
	inline void compressibility(float value);
	enum slip_type_enum {
		slip_type_NOSLIP = 512,
		slip_type_PARTIALSLIP = 1024,
		slip_type_FREESLIP = 2048,
	};
	inline slip_type_enum slip_type(void);
	inline void slip_type(slip_type_enum value);
	inline float partial_slip_factor(void);
	inline void partial_slip_factor(float value);
	inline float surface_smooth(void);
	inline void surface_smooth(float value);
	inline int surface_subdivisions(void);
	inline void surface_subdivisions(int value);
	inline bool use_speed_vectors(void);
	inline void use_speed_vectors(bool value);
	inline bool use_surface_noobs(void);
	inline void use_surface_noobs(bool value);
	inline int tracer_particles(void);
	inline void tracer_particles(int value);
	inline float generate_particles(void);
	inline void generate_particles(float value);
	COLLECTION_PROPERTY(DefaultCollectionFunctions, FluidVertexVelocity, DomainFluidSettings, fluid_mesh_vertices, true, true, false)

};

/**************** Fluid Mesh Velocity ****************/

class FluidVertexVelocity : public Pointer {
public:
	FluidVertexVelocity(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline Array<float, 3> velocity(void);
	inline void velocity(float values[3]);

};

/**************** Fluid Fluid Simulation Settings ****************/

class FluidFluidSettings : public FluidSettings {
public:
	FluidFluidSettings(const PointerRNA &ptr_arg) :
		FluidSettings(ptr_arg)
		{}

	inline bool use(void);
	inline void use(bool value);
	enum volume_initialization_enum {
		volume_initialization_VOLUME = 1,
		volume_initialization_SHELL = 2,
		volume_initialization_BOTH = 3,
	};
	inline volume_initialization_enum volume_initialization(void);
	inline void volume_initialization(volume_initialization_enum value);
	inline bool use_animated_mesh(void);
	inline void use_animated_mesh(bool value);
	inline Array<float, 3> initial_velocity(void);
	inline void initial_velocity(float values[3]);

};

/**************** Obstacle Fluid Simulation Settings ****************/

class ObstacleFluidSettings : public FluidSettings {
public:
	ObstacleFluidSettings(const PointerRNA &ptr_arg) :
		FluidSettings(ptr_arg)
		{}

	inline bool use(void);
	inline void use(bool value);
	enum volume_initialization_enum {
		volume_initialization_VOLUME = 1,
		volume_initialization_SHELL = 2,
		volume_initialization_BOTH = 3,
	};
	inline volume_initialization_enum volume_initialization(void);
	inline void volume_initialization(volume_initialization_enum value);
	inline bool use_animated_mesh(void);
	inline void use_animated_mesh(bool value);
	enum slip_type_enum {
		slip_type_NOSLIP = 512,
		slip_type_PARTIALSLIP = 1024,
		slip_type_FREESLIP = 2048,
	};
	inline slip_type_enum slip_type(void);
	inline void slip_type(slip_type_enum value);
	inline float partial_slip_factor(void);
	inline void partial_slip_factor(float value);
	inline float impact_factor(void);
	inline void impact_factor(float value);

};

/**************** Inflow Fluid Simulation Settings ****************/

class InflowFluidSettings : public FluidSettings {
public:
	InflowFluidSettings(const PointerRNA &ptr_arg) :
		FluidSettings(ptr_arg)
		{}

	inline bool use(void);
	inline void use(bool value);
	enum volume_initialization_enum {
		volume_initialization_VOLUME = 1,
		volume_initialization_SHELL = 2,
		volume_initialization_BOTH = 3,
	};
	inline volume_initialization_enum volume_initialization(void);
	inline void volume_initialization(volume_initialization_enum value);
	inline bool use_animated_mesh(void);
	inline void use_animated_mesh(bool value);
	inline Array<float, 3> inflow_velocity(void);
	inline void inflow_velocity(float values[3]);
	inline bool use_local_coords(void);
	inline void use_local_coords(bool value);

};

/**************** Outflow Fluid Simulation Settings ****************/

class OutflowFluidSettings : public FluidSettings {
public:
	OutflowFluidSettings(const PointerRNA &ptr_arg) :
		FluidSettings(ptr_arg)
		{}

	inline bool use(void);
	inline void use(bool value);
	enum volume_initialization_enum {
		volume_initialization_VOLUME = 1,
		volume_initialization_SHELL = 2,
		volume_initialization_BOTH = 3,
	};
	inline volume_initialization_enum volume_initialization(void);
	inline void volume_initialization(volume_initialization_enum value);
	inline bool use_animated_mesh(void);
	inline void use_animated_mesh(bool value);

};

/**************** Particle Fluid Simulation Settings ****************/

class ParticleFluidSettings : public FluidSettings {
public:
	ParticleFluidSettings(const PointerRNA &ptr_arg) :
		FluidSettings(ptr_arg)
		{}

	inline bool use_drops(void);
	inline void use_drops(bool value);
	inline bool use_floats(void);
	inline void use_floats(bool value);
	inline bool show_tracer(void);
	inline void show_tracer(bool value);
	inline float particle_influence(void);
	inline void particle_influence(float value);
	inline float alpha_influence(void);
	inline void alpha_influence(float value);
	inline std::string filepath(void);
	inline void filepath(const std::string& value);

};

/**************** Control Fluid Simulation Settings ****************/

class ControlFluidSettings : public FluidSettings {
public:
	ControlFluidSettings(const PointerRNA &ptr_arg) :
		FluidSettings(ptr_arg)
		{}

	inline bool use(void);
	inline void use(bool value);
	inline float start_time(void);
	inline void start_time(float value);
	inline float end_time(void);
	inline void end_time(float value);
	inline float attraction_strength(void);
	inline void attraction_strength(float value);
	inline float attraction_radius(void);
	inline void attraction_radius(float value);
	inline float velocity_strength(void);
	inline void velocity_strength(float value);
	inline float velocity_radius(void);
	inline void velocity_radius(float value);
	inline float quality(void);
	inline void quality(float value);
	inline bool use_reverse_frames(void);
	inline void use_reverse_frames(bool value);

};

/**************** Grease Pencil ****************/

class GreasePencil : public ID {
public:
	GreasePencil(const PointerRNA &ptr_arg) :
		ID(ptr_arg),
		layers(ptr_arg),
		materials(ptr_arg)
		{}

	COLLECTION_PROPERTY(GreasePencilLayers, GPencilLayer, GreasePencil, layers, false, true, true)
	inline AnimData animation_data(void);
	COLLECTION_PROPERTY(IDMaterials, Material, GreasePencil, materials, true, true, true)
	enum stroke_depth_order_enum {
		stroke_depth_order_2D = 0,
		stroke_depth_order_3D = 1,
	};
	inline stroke_depth_order_enum stroke_depth_order(void);
	inline void stroke_depth_order(stroke_depth_order_enum value);
	inline bool use_stroke_edit_mode(void);
	inline void use_stroke_edit_mode(bool value);
	inline bool is_stroke_paint_mode(void);
	inline void is_stroke_paint_mode(bool value);
	inline bool is_stroke_sculpt_mode(void);
	inline void is_stroke_sculpt_mode(bool value);
	inline bool is_stroke_weight_mode(void);
	inline void is_stroke_weight_mode(bool value);
	inline bool use_onion_skinning(void);
	inline void use_onion_skinning(bool value);
	inline bool show_stroke_direction(void);
	inline void show_stroke_direction(bool value);
	enum stroke_thickness_space_enum {
		stroke_thickness_space_WORLDSPACE = 0,
		stroke_thickness_space_SCREENSPACE = 32768,
	};
	inline stroke_thickness_space_enum stroke_thickness_space(void);
	inline void stroke_thickness_space(stroke_thickness_space_enum value);
	inline float pixel_factor(void);
	inline void pixel_factor(float value);
	inline bool use_multiedit(void);
	inline void use_multiedit(bool value);
	inline bool use_force_fill_recalc(void);
	inline void use_force_fill_recalc(bool value);
	inline bool use_adaptive_uv(void);
	inline void use_adaptive_uv(bool value);
	inline bool use_autolock_layers(void);
	inline void use_autolock_layers(bool value);
	inline Array<float, 4> edit_line_color(void);
	inline void edit_line_color(float values[4]);
	inline int ghost_before_range(void);
	inline void ghost_before_range(int value);
	inline int ghost_after_range(void);
	inline void ghost_after_range(int value);
	inline bool use_ghost_custom_colors(void);
	inline void use_ghost_custom_colors(bool value);
	inline Array<float, 3> before_color(void);
	inline void before_color(float values[3]);
	inline Array<float, 3> after_color(void);
	inline void after_color(float values[3]);
	inline bool use_ghosts_always(void);
	inline void use_ghosts_always(bool value);
	enum onion_mode_enum {
		onion_mode_ABSOLUTE = 0,
		onion_mode_RELATIVE = 1,
		onion_mode_SELECTED = 2,
	};
	inline onion_mode_enum onion_mode(void);
	inline void onion_mode(onion_mode_enum value);
	inline bool use_onion_fade(void);
	inline void use_onion_fade(bool value);
	inline bool use_onion_loop(void);
	inline void use_onion_loop(bool value);
	inline float onion_factor(void);
	inline void onion_factor(float value);
	inline float zdepth_offset(void);
	inline void zdepth_offset(float value);
	inline GreasePencilGrid grid(void);

	inline void clear();
};

/**************** Grid and Canvas Settings ****************/

class GreasePencilGrid : public Pointer {
public:
	GreasePencilGrid(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline Array<float, 2> scale(void);
	inline void scale(float values[2]);
	inline Array<float, 3> color(void);
	inline void color(float values[3]);
	inline int lines(void);
	inline void lines(int value);
	inline Array<float, 2> offset(void);
	inline void offset(float values[2]);

};

/**************** Grease Pencil Layer ****************/

class GPencilLayer : public Pointer {
public:
	GPencilLayer(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		frames(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string info(void);
	inline void info(const std::string& value);
	COLLECTION_PROPERTY(GPencilFrames, GPencilFrame, GPencilLayer, frames, false, true, false)
	inline GPencilFrame active_frame(void);
	inline float opacity(void);
	inline void opacity(float value);
	inline Array<float, 3> channel_color(void);
	inline void channel_color(float values[3]);
	inline Array<float, 3> color(void);
	inline void color(float values[3]);
	inline int thickness(void);
	inline void thickness(int value);
	inline Array<float, 3> tint_color(void);
	inline void tint_color(float values[3]);
	inline float tint_factor(void);
	inline void tint_factor(float value);
	inline int line_change(void);
	inline void line_change(int value);
	inline bool use_onion_skinning(void);
	inline void use_onion_skinning(bool value);
	inline bool use_annotation_onion_skinning(void);
	inline void use_annotation_onion_skinning(bool value);
	inline int annotation_onion_before_range(void);
	inline void annotation_onion_before_range(int value);
	inline int annotation_onion_after_range(void);
	inline void annotation_onion_after_range(int value);
	inline Array<float, 3> annotation_onion_before_color(void);
	inline void annotation_onion_before_color(float values[3]);
	inline Array<float, 3> annotation_onion_after_color(void);
	inline void annotation_onion_after_color(float values[3]);
	inline int pass_index(void);
	inline void pass_index(int value);
	inline std::string viewlayer_render(void);
	inline void viewlayer_render(const std::string& value);
	enum blend_mode_enum {
		blend_mode_NORMAL = 0,
		blend_mode_OVERLAY = 1,
		blend_mode_ADD = 2,
		blend_mode_SUBTRACT = 3,
		blend_mode_MULTIPLY = 4,
		blend_mode_DIVIDE = 5,
	};
	inline blend_mode_enum blend_mode(void);
	inline void blend_mode(blend_mode_enum value);
	inline bool hide(void);
	inline void hide(bool value);
	inline bool annotation_hide(void);
	inline void annotation_hide(bool value);
	inline bool lock(void);
	inline void lock(bool value);
	inline bool lock_frame(void);
	inline void lock_frame(bool value);
	inline bool lock_material(void);
	inline void lock_material(bool value);
	inline bool clamp_layer(void);
	inline void clamp_layer(bool value);
	inline bool use_solo_mode(void);
	inline void use_solo_mode(bool value);
	inline bool select(void);
	inline void select(bool value);
	inline bool show_points(void);
	inline void show_points(bool value);
	inline bool show_in_front(void);
	inline void show_in_front(bool value);
	inline Object parent(void);
	enum parent_type_enum {
		parent_type_OBJECT = 0,
		parent_type_ARMATURE = 4,
		parent_type_BONE = 7,
	};
	inline parent_type_enum parent_type(void);
	inline void parent_type(parent_type_enum value);
	inline std::string parent_bone(void);
	inline void parent_bone(const std::string& value);
	inline Array<float, 16> matrix_inverse(void);
	inline void matrix_inverse(float values[16]);
	inline bool is_parented(void);
	inline void is_parented(bool value);

	inline void clear();
};

/**************** Grease Pencil Frame ****************/

class GPencilFrame : public Pointer {
public:
	GPencilFrame(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		strokes(ptr_arg)
		{}

	inline Struct rna_type(void);
	COLLECTION_PROPERTY(GPencilStrokes, GPencilStroke, GPencilFrame, strokes, false, true, false)
	inline int frame_number(void);
	inline void frame_number(int value);
	inline bool is_edited(void);
	inline void is_edited(bool value);
	inline bool select(void);
	inline void select(bool value);

	inline void clear();
};

/**************** Grease Pencil Stroke ****************/

class GPencilStroke : public Pointer {
public:
	GPencilStroke(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		points(ptr_arg),
		groups(ptr_arg),
		triangles(ptr_arg)
		{}

	inline Struct rna_type(void);
	COLLECTION_PROPERTY(GPencilStrokePoints, GPencilStrokePoint, GPencilStroke, points, true, true, false)
	COLLECTION_PROPERTY(DefaultCollectionFunctions, GpencilVertexGroupElement, GPencilStroke, groups, false, false, false)
	COLLECTION_PROPERTY(DefaultCollectionFunctions, GPencilTriangle, GPencilStroke, triangles, true, true, false)
	inline int material_index(void);
	inline void material_index(int value);
	enum display_mode_enum {
		display_mode_SCREEN = 0,
		display_mode_3DSPACE = 1,
		display_mode_2DSPACE = 2,
		display_mode_2DIMAGE = 4,
	};
	inline display_mode_enum display_mode(void);
	inline void display_mode(display_mode_enum value);
	inline bool select(void);
	inline void select(bool value);
	inline bool draw_cyclic(void);
	inline void draw_cyclic(bool value);
	enum start_cap_mode_enum {
		start_cap_mode_ROUND = 0,
		start_cap_mode_FLAT = 1,
	};
	inline start_cap_mode_enum start_cap_mode(void);
	inline void start_cap_mode(start_cap_mode_enum value);
	enum end_cap_mode_enum {
		end_cap_mode_ROUND = 0,
		end_cap_mode_FLAT = 1,
	};
	inline end_cap_mode_enum end_cap_mode(void);
	inline void end_cap_mode(end_cap_mode_enum value);
	inline bool is_nofill_stroke(void);
	inline void is_nofill_stroke(bool value);
	inline int line_width(void);
	inline void line_width(int value);

};

/**************** Grease Pencil Stroke Point ****************/

class GPencilStrokePoint : public Pointer {
public:
	GPencilStrokePoint(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline Array<float, 3> co(void);
	inline void co(float values[3]);
	inline float pressure(void);
	inline void pressure(float value);
	inline float strength(void);
	inline void strength(float value);
	inline float uv_factor(void);
	inline void uv_factor(float value);
	inline float uv_rotation(void);
	inline void uv_rotation(float value);
	inline bool select(void);
	inline void select(bool value);

};

/**************** Triangle ****************/

class GPencilTriangle : public Pointer {
public:
	GPencilTriangle(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline int v1(void);
	inline void v1(int value);
	inline int v2(void);
	inline void v2(int value);
	inline int v3(void);
	inline void v3(int value);
	inline Array<float, 2> uv1(void);
	inline void uv1(float values[2]);
	inline Array<float, 2> uv2(void);
	inline void uv2(float values[2]);
	inline Array<float, 2> uv3(void);
	inline void uv3(float values[2]);

};

/**************** Vertex Group Element ****************/

class GpencilVertexGroupElement : public Pointer {
public:
	GpencilVertexGroupElement(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline int group(void);
	inline void group(int value);
	inline float weight(void);
	inline void weight(float value);

};

/**************** Render Slot ****************/

class RenderSlot : public Pointer {
public:
	RenderSlot(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string name(void);
	inline void name(const std::string& value);

	inline void clear(ImageUser& iuser);
};

/**************** Image ****************/

class Image : public ID {
public:
	Image(const PointerRNA &ptr_arg) :
		ID(ptr_arg),
		packed_files(ptr_arg),
		render_slots(ptr_arg)
		{}

	inline std::string filepath(void);
	inline void filepath(const std::string& value);
	inline std::string filepath_raw(void);
	inline void filepath_raw(const std::string& value);
	enum file_format_enum {
		file_format_BMP = 20,
		file_format_IRIS = 1,
		file_format_PNG = 17,
		file_format_JPEG = 4,
		file_format_JPEG2000 = 30,
		file_format_TARGA = 0,
		file_format_TARGA_RAW = 14,
		file_format_CINEON = 26,
		file_format_DPX = 27,
		file_format_OPEN_EXR_MULTILAYER = 28,
		file_format_OPEN_EXR = 23,
		file_format_HDR = 21,
		file_format_TIFF = 22,
		file_format_AVI_JPEG = 16,
		file_format_AVI_RAW = 15,
		file_format_FFMPEG = 24,
	};
	inline file_format_enum file_format(void);
	inline void file_format(file_format_enum value);
	enum source_enum {
		source_FILE = 1,
		source_SEQUENCE = 2,
		source_MOVIE = 3,
		source_GENERATED = 4,
		source_VIEWER = 5,
	};
	inline source_enum source(void);
	inline void source(source_enum value);
	enum type_enum {
		type_IMAGE = 0,
		type_MULTILAYER = 1,
		type_UV_TEST = 2,
		type_RENDER_RESULT = 4,
		type_COMPOSITING = 5,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	inline PackedFile packed_file(void);
	COLLECTION_PROPERTY(DefaultCollectionFunctions, ImagePackedFile, Image, packed_files, false, true, true)
	inline bool use_view_as_render(void);
	inline void use_view_as_render(bool value);
	inline bool use_alpha(void);
	inline void use_alpha(bool value);
	inline bool use_deinterlace(void);
	inline void use_deinterlace(bool value);
	inline bool use_multiview(void);
	inline void use_multiview(bool value);
	inline bool is_stereo_3d(void);
	inline void is_stereo_3d(bool value);
	inline bool is_multiview(void);
	inline void is_multiview(bool value);
	inline bool is_dirty(void);
	inline void is_dirty(bool value);
	enum generated_type_enum {
		generated_type_BLANK = 0,
		generated_type_UV_GRID = 1,
		generated_type_COLOR_GRID = 2,
	};
	inline generated_type_enum generated_type(void);
	inline void generated_type(generated_type_enum value);
	inline int generated_width(void);
	inline void generated_width(int value);
	inline int generated_height(void);
	inline void generated_height(int value);
	inline bool use_generated_float(void);
	inline void use_generated_float(bool value);
	inline Array<float, 4> generated_color(void);
	inline void generated_color(float values[4]);
	inline Array<float, 2> display_aspect(void);
	inline void display_aspect(float values[2]);
	inline int bindcode(void);
	inline void bindcode(int value);
	COLLECTION_PROPERTY(RenderSlots, RenderSlot, Image, render_slots, false, true, false)
	inline bool has_data(void);
	inline void has_data(bool value);
	inline int depth(void);
	inline void depth(int value);
	inline Array<int, 2> size(void);
	inline void size(int values[2]);
	inline Array<float, 2> resolution(void);
	inline void resolution(float values[2]);
	inline int frame_duration(void);
	inline void frame_duration(int value);
	inline DynamicArray<float> pixels(void);
	inline void pixels(float values[]);
	inline int channels(void);
	inline void channels(int value);
	inline bool is_float(void);
	inline void is_float(bool value);
	inline ColorManagedInputColorspaceSettings colorspace_settings(void);
	enum alpha_mode_enum {
		alpha_mode_STRAIGHT = 0,
		alpha_mode_PREMUL = 1,
	};
	inline alpha_mode_enum alpha_mode(void);
	inline void alpha_mode(alpha_mode_enum value);
	enum views_format_enum {
		views_format_INDIVIDUAL = 0,
		views_format_STEREO_3D = 1,
	};
	inline views_format_enum views_format(void);
	inline void views_format(views_format_enum value);
	inline Stereo3dFormat stereo_3d_format(void);

	inline void save_render(Context C, const char * filepath, Scene& scene);
	inline void save(void *main, Context C);
	inline void pack(void *main, Context C, bool as_png, const char * data, int data_len);
	inline void unpack(void *main, int method);
	inline void reload(void *main);
	inline void update();
	inline void scale(int width, int height);
	inline int gl_touch(int frame, int filter, int mag);
	inline int gl_load(int frame, int filter, int mag);
	inline void gl_free();
	inline void filepath_from_user(ImageUser& image_user, char * filepath);
	inline void buffers_free();
};

/**************** Image User ****************/

class ImageUser : public Pointer {
public:
	ImageUser(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline bool use_auto_refresh(void);
	inline void use_auto_refresh(bool value);
	inline int frame_current(void);
	inline void frame_current(int value);
	inline bool use_cyclic(void);
	inline void use_cyclic(bool value);
	inline int frame_duration(void);
	inline void frame_duration(int value);
	inline int frame_offset(void);
	inline void frame_offset(int value);
	inline int frame_start(void);
	inline void frame_start(int value);
	inline int multilayer_layer(void);
	inline void multilayer_layer(int value);
	inline int multilayer_pass(void);
	inline void multilayer_pass(int value);
	inline int multilayer_view(void);
	inline void multilayer_view(int value);

};

/**************** ImagePackedFile ****************/

class ImagePackedFile : public Pointer {
public:
	ImagePackedFile(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline PackedFile packed_file(void);
	inline std::string filepath(void);
	inline void filepath(const std::string& value);

	inline void save(void *main);
};

/**************** Key ****************/

class Key : public ID {
public:
	Key(const PointerRNA &ptr_arg) :
		ID(ptr_arg),
		key_blocks(ptr_arg)
		{}

	inline ShapeKey reference_key(void);
	COLLECTION_PROPERTY(DefaultCollectionFunctions, ShapeKey, Key, key_blocks, false, true, true)
	inline AnimData animation_data(void);
	inline ID user(void);
	inline bool use_relative(void);
	inline void use_relative(bool value);
	inline float eval_time(void);
	inline void eval_time(float value);

};

/**************** Shape Key ****************/

class ShapeKey : public Pointer {
public:
	ShapeKey(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		data(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string name(void);
	inline void name(const std::string& value);
	inline float frame(void);
	inline void frame(float value);
	inline float value(void);
	inline void value(float value);
	enum interpolation_enum {
		interpolation_KEY_LINEAR = 0,
		interpolation_KEY_CARDINAL = 1,
		interpolation_KEY_CATMULL_ROM = 3,
		interpolation_KEY_BSPLINE = 2,
	};
	inline interpolation_enum interpolation(void);
	inline void interpolation(interpolation_enum value);
	inline std::string vertex_group(void);
	inline void vertex_group(const std::string& value);
	inline ShapeKey relative_key(void);
	inline bool mute(void);
	inline void mute(bool value);
	inline float slider_min(void);
	inline void slider_min(float value);
	inline float slider_max(void);
	inline void slider_max(float value);
	COLLECTION_PROPERTY(DefaultCollectionFunctions, UnknownType, ShapeKey, data, true, true, false)

	inline void normals_vertex_get(int *normals_len, float **normals);
	inline void normals_polygon_get(int *normals_len, float **normals);
	inline void normals_split_get(int *normals_len, float **normals);
};

/**************** Shape Key Point ****************/

class ShapeKeyPoint : public Pointer {
public:
	ShapeKeyPoint(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline Array<float, 3> co(void);
	inline void co(float values[3]);

};

/**************** Shape Key Curve Point ****************/

class ShapeKeyCurvePoint : public Pointer {
public:
	ShapeKeyCurvePoint(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline Array<float, 3> co(void);
	inline void co(float values[3]);
	inline float tilt(void);
	inline void tilt(float value);
	inline float radius(void);
	inline void radius(float value);

};

/**************** Shape Key Bezier Point ****************/

class ShapeKeyBezierPoint : public Pointer {
public:
	ShapeKeyBezierPoint(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline Array<float, 3> co(void);
	inline void co(float values[3]);
	inline Array<float, 3> handle_left(void);
	inline void handle_left(float values[3]);
	inline Array<float, 3> handle_right(void);
	inline void handle_right(float values[3]);
	inline float tilt(void);
	inline void tilt(float value);
	inline float radius(void);
	inline void radius(float value);

};

/**************** Light ****************/

class Light : public ID {
public:
	Light(const PointerRNA &ptr_arg) :
		ID(ptr_arg)
		{}

	enum type_enum {
		type_POINT = 0,
		type_SUN = 1,
		type_SPOT = 2,
		type_AREA = 4,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	inline float distance(void);
	inline void distance(float value);
	inline Array<float, 3> color(void);
	inline void color(float values[3]);
	inline float specular_factor(void);
	inline void specular_factor(float value);
	inline bool use_custom_distance(void);
	inline void use_custom_distance(bool value);
	inline float cutoff_distance(void);
	inline void cutoff_distance(float value);
	inline NodeTree node_tree(void);
	inline bool use_nodes(void);
	inline void use_nodes(bool value);
	inline AnimData animation_data(void);

};

/**************** Point Light ****************/

class PointLight : public Light {
public:
	PointLight(const PointerRNA &ptr_arg) :
		Light(ptr_arg)
		{}

	inline float energy(void);
	inline void energy(float value);
	enum falloff_type_enum {
		falloff_type_CONSTANT = 0,
		falloff_type_INVERSE_LINEAR = 1,
		falloff_type_INVERSE_SQUARE = 2,
		falloff_type_INVERSE_COEFFICIENTS = 5,
		falloff_type_CUSTOM_CURVE = 3,
		falloff_type_LINEAR_QUADRATIC_WEIGHTED = 4,
	};
	inline falloff_type_enum falloff_type(void);
	inline void falloff_type(falloff_type_enum value);
	inline CurveMapping falloff_curve(void);
	inline float linear_attenuation(void);
	inline void linear_attenuation(float value);
	inline float quadratic_attenuation(void);
	inline void quadratic_attenuation(float value);
	inline float constant_coefficient(void);
	inline void constant_coefficient(float value);
	inline float linear_coefficient(void);
	inline void linear_coefficient(float value);
	inline float quadratic_coefficient(void);
	inline void quadratic_coefficient(float value);
	inline bool use_shadow(void);
	inline void use_shadow(bool value);
	inline int shadow_buffer_size(void);
	inline void shadow_buffer_size(int value);
	inline float shadow_buffer_clip_start(void);
	inline void shadow_buffer_clip_start(float value);
	inline float shadow_buffer_clip_end(void);
	inline void shadow_buffer_clip_end(float value);
	inline float shadow_buffer_bias(void);
	inline void shadow_buffer_bias(float value);
	inline float shadow_buffer_bleed_bias(void);
	inline void shadow_buffer_bleed_bias(float value);
	inline float shadow_buffer_exp(void);
	inline void shadow_buffer_exp(float value);
	inline float shadow_buffer_soft(void);
	inline void shadow_buffer_soft(float value);
	inline int shadow_buffer_samples(void);
	inline void shadow_buffer_samples(int value);
	inline Array<float, 3> shadow_color(void);
	inline void shadow_color(float values[3]);
	inline float shadow_soft_size(void);
	inline void shadow_soft_size(float value);
	inline bool use_contact_shadow(void);
	inline void use_contact_shadow(bool value);
	inline float contact_shadow_distance(void);
	inline void contact_shadow_distance(float value);
	inline float contact_shadow_bias(void);
	inline void contact_shadow_bias(float value);
	inline float contact_shadow_soft_size(void);
	inline void contact_shadow_soft_size(float value);
	inline float contact_shadow_thickness(void);
	inline void contact_shadow_thickness(float value);

};

/**************** Area Light ****************/

class AreaLight : public Light {
public:
	AreaLight(const PointerRNA &ptr_arg) :
		Light(ptr_arg)
		{}

	inline float energy(void);
	inline void energy(float value);
	inline bool use_shadow(void);
	inline void use_shadow(bool value);
	inline int shadow_buffer_size(void);
	inline void shadow_buffer_size(int value);
	inline float shadow_buffer_clip_start(void);
	inline void shadow_buffer_clip_start(float value);
	inline float shadow_buffer_clip_end(void);
	inline void shadow_buffer_clip_end(float value);
	inline float shadow_buffer_bias(void);
	inline void shadow_buffer_bias(float value);
	inline float shadow_buffer_bleed_bias(void);
	inline void shadow_buffer_bleed_bias(float value);
	inline float shadow_buffer_exp(void);
	inline void shadow_buffer_exp(float value);
	inline float shadow_buffer_soft(void);
	inline void shadow_buffer_soft(float value);
	inline int shadow_buffer_samples(void);
	inline void shadow_buffer_samples(int value);
	inline Array<float, 3> shadow_color(void);
	inline void shadow_color(float values[3]);
	inline float shadow_soft_size(void);
	inline void shadow_soft_size(float value);
	inline bool use_contact_shadow(void);
	inline void use_contact_shadow(bool value);
	inline float contact_shadow_distance(void);
	inline void contact_shadow_distance(float value);
	inline float contact_shadow_bias(void);
	inline void contact_shadow_bias(float value);
	inline float contact_shadow_soft_size(void);
	inline void contact_shadow_soft_size(float value);
	inline float contact_shadow_thickness(void);
	inline void contact_shadow_thickness(float value);
	enum falloff_type_enum {
		falloff_type_CONSTANT = 0,
		falloff_type_INVERSE_LINEAR = 1,
		falloff_type_INVERSE_SQUARE = 2,
		falloff_type_INVERSE_COEFFICIENTS = 5,
		falloff_type_CUSTOM_CURVE = 3,
		falloff_type_LINEAR_QUADRATIC_WEIGHTED = 4,
	};
	inline falloff_type_enum falloff_type(void);
	inline void falloff_type(falloff_type_enum value);
	inline CurveMapping falloff_curve(void);
	inline float linear_attenuation(void);
	inline void linear_attenuation(float value);
	inline float quadratic_attenuation(void);
	inline void quadratic_attenuation(float value);
	inline float constant_coefficient(void);
	inline void constant_coefficient(float value);
	inline float linear_coefficient(void);
	inline void linear_coefficient(float value);
	inline float quadratic_coefficient(void);
	inline void quadratic_coefficient(float value);
	enum shape_enum {
		shape_SQUARE = 0,
		shape_RECTANGLE = 1,
		shape_DISK = 4,
		shape_ELLIPSE = 5,
	};
	inline shape_enum shape(void);
	inline void shape(shape_enum value);
	inline float size(void);
	inline void size(float value);
	inline float size_y(void);
	inline void size_y(float value);

};

/**************** Spot Light ****************/

class SpotLight : public Light {
public:
	SpotLight(const PointerRNA &ptr_arg) :
		Light(ptr_arg)
		{}

	inline float energy(void);
	inline void energy(float value);
	enum falloff_type_enum {
		falloff_type_CONSTANT = 0,
		falloff_type_INVERSE_LINEAR = 1,
		falloff_type_INVERSE_SQUARE = 2,
		falloff_type_INVERSE_COEFFICIENTS = 5,
		falloff_type_CUSTOM_CURVE = 3,
		falloff_type_LINEAR_QUADRATIC_WEIGHTED = 4,
	};
	inline falloff_type_enum falloff_type(void);
	inline void falloff_type(falloff_type_enum value);
	inline CurveMapping falloff_curve(void);
	inline float linear_attenuation(void);
	inline void linear_attenuation(float value);
	inline float quadratic_attenuation(void);
	inline void quadratic_attenuation(float value);
	inline float constant_coefficient(void);
	inline void constant_coefficient(float value);
	inline float linear_coefficient(void);
	inline void linear_coefficient(float value);
	inline float quadratic_coefficient(void);
	inline void quadratic_coefficient(float value);
	inline bool use_shadow(void);
	inline void use_shadow(bool value);
	inline int shadow_buffer_size(void);
	inline void shadow_buffer_size(int value);
	inline float shadow_buffer_clip_start(void);
	inline void shadow_buffer_clip_start(float value);
	inline float shadow_buffer_clip_end(void);
	inline void shadow_buffer_clip_end(float value);
	inline float shadow_buffer_bias(void);
	inline void shadow_buffer_bias(float value);
	inline float shadow_buffer_bleed_bias(void);
	inline void shadow_buffer_bleed_bias(float value);
	inline float shadow_buffer_exp(void);
	inline void shadow_buffer_exp(float value);
	inline float shadow_buffer_soft(void);
	inline void shadow_buffer_soft(float value);
	inline int shadow_buffer_samples(void);
	inline void shadow_buffer_samples(int value);
	inline Array<float, 3> shadow_color(void);
	inline void shadow_color(float values[3]);
	inline float shadow_soft_size(void);
	inline void shadow_soft_size(float value);
	inline bool use_contact_shadow(void);
	inline void use_contact_shadow(bool value);
	inline float contact_shadow_distance(void);
	inline void contact_shadow_distance(float value);
	inline float contact_shadow_bias(void);
	inline void contact_shadow_bias(float value);
	inline float contact_shadow_soft_size(void);
	inline void contact_shadow_soft_size(float value);
	inline float contact_shadow_thickness(void);
	inline void contact_shadow_thickness(float value);
	inline bool use_square(void);
	inline void use_square(bool value);
	inline float spot_blend(void);
	inline void spot_blend(float value);
	inline float spot_size(void);
	inline void spot_size(float value);
	inline bool show_cone(void);
	inline void show_cone(bool value);

};

/**************** Sun Light ****************/

class SunLight : public Light {
public:
	SunLight(const PointerRNA &ptr_arg) :
		Light(ptr_arg)
		{}

	inline float energy(void);
	inline void energy(float value);
	inline bool use_shadow(void);
	inline void use_shadow(bool value);
	inline int shadow_buffer_size(void);
	inline void shadow_buffer_size(int value);
	inline float shadow_buffer_clip_start(void);
	inline void shadow_buffer_clip_start(float value);
	inline float shadow_buffer_clip_end(void);
	inline void shadow_buffer_clip_end(float value);
	inline float shadow_buffer_bias(void);
	inline void shadow_buffer_bias(float value);
	inline float shadow_buffer_bleed_bias(void);
	inline void shadow_buffer_bleed_bias(float value);
	inline float shadow_buffer_exp(void);
	inline void shadow_buffer_exp(float value);
	inline float shadow_buffer_soft(void);
	inline void shadow_buffer_soft(float value);
	inline int shadow_buffer_samples(void);
	inline void shadow_buffer_samples(int value);
	inline Array<float, 3> shadow_color(void);
	inline void shadow_color(float values[3]);
	inline float shadow_soft_size(void);
	inline void shadow_soft_size(float value);
	inline bool use_contact_shadow(void);
	inline void use_contact_shadow(bool value);
	inline float contact_shadow_distance(void);
	inline void contact_shadow_distance(float value);
	inline float contact_shadow_bias(void);
	inline void contact_shadow_bias(float value);
	inline float contact_shadow_soft_size(void);
	inline void contact_shadow_soft_size(float value);
	inline float contact_shadow_thickness(void);
	inline void contact_shadow_thickness(float value);
	inline float shadow_cascade_max_distance(void);
	inline void shadow_cascade_max_distance(float value);
	inline int shadow_cascade_count(void);
	inline void shadow_cascade_count(int value);
	inline float shadow_cascade_exponent(void);
	inline void shadow_cascade_exponent(float value);
	inline float shadow_cascade_fade(void);
	inline void shadow_cascade_fade(float value);

};

/**************** Lattice ****************/

class Lattice : public ID {
public:
	Lattice(const PointerRNA &ptr_arg) :
		ID(ptr_arg),
		points(ptr_arg)
		{}

	inline int points_u(void);
	inline void points_u(int value);
	inline int points_v(void);
	inline void points_v(int value);
	inline int points_w(void);
	inline void points_w(int value);
	enum interpolation_type_u_enum {
		interpolation_type_u_KEY_LINEAR = 0,
		interpolation_type_u_KEY_CARDINAL = 1,
		interpolation_type_u_KEY_CATMULL_ROM = 3,
		interpolation_type_u_KEY_BSPLINE = 2,
	};
	inline interpolation_type_u_enum interpolation_type_u(void);
	inline void interpolation_type_u(interpolation_type_u_enum value);
	enum interpolation_type_v_enum {
		interpolation_type_v_KEY_LINEAR = 0,
		interpolation_type_v_KEY_CARDINAL = 1,
		interpolation_type_v_KEY_CATMULL_ROM = 3,
		interpolation_type_v_KEY_BSPLINE = 2,
	};
	inline interpolation_type_v_enum interpolation_type_v(void);
	inline void interpolation_type_v(interpolation_type_v_enum value);
	enum interpolation_type_w_enum {
		interpolation_type_w_KEY_LINEAR = 0,
		interpolation_type_w_KEY_CARDINAL = 1,
		interpolation_type_w_KEY_CATMULL_ROM = 3,
		interpolation_type_w_KEY_BSPLINE = 2,
	};
	inline interpolation_type_w_enum interpolation_type_w(void);
	inline void interpolation_type_w(interpolation_type_w_enum value);
	inline bool use_outside(void);
	inline void use_outside(bool value);
	inline std::string vertex_group(void);
	inline void vertex_group(const std::string& value);
	inline Key shape_keys(void);
	COLLECTION_PROPERTY(DefaultCollectionFunctions, LatticePoint, Lattice, points, false, false, false)
	inline bool is_editmode(void);
	inline void is_editmode(bool value);
	inline AnimData animation_data(void);

	inline void transform(float matrix[16], bool shape_keys);
	inline void update_gpu_tag();
};

/**************** LatticePoint ****************/

class LatticePoint : public Pointer {
public:
	LatticePoint(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		groups(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline bool select(void);
	inline void select(bool value);
	inline Array<float, 3> co(void);
	inline void co(float values[3]);
	inline Array<float, 3> co_deform(void);
	inline void co_deform(float values[3]);
	inline float weight_softbody(void);
	inline void weight_softbody(float value);
	COLLECTION_PROPERTY(DefaultCollectionFunctions, VertexGroupElement, LatticePoint, groups, false, false, false)

};

/**************** View Layer ****************/

class ViewLayer : public Pointer {
public:
	ViewLayer(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		objects(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string name(void);
	inline void name(const std::string& value);
	inline Material material_override(void);
	inline int samples(void);
	inline void samples(int value);
	inline float pass_alpha_threshold(void);
	inline void pass_alpha_threshold(float value);
	inline bool use_zmask(void);
	inline void use_zmask(bool value);
	inline bool invert_zmask(void);
	inline void invert_zmask(bool value);
	inline bool use_all_z(void);
	inline void use_all_z(bool value);
	inline bool use_solid(void);
	inline void use_solid(bool value);
	inline bool use_halo(void);
	inline void use_halo(bool value);
	inline bool use_ztransp(void);
	inline void use_ztransp(bool value);
	inline bool use_sky(void);
	inline void use_sky(bool value);
	inline bool use_ao(void);
	inline void use_ao(bool value);
	inline bool use_edge_enhance(void);
	inline void use_edge_enhance(bool value);
	inline bool use_strand(void);
	inline void use_strand(bool value);
	inline bool use_pass_combined(void);
	inline void use_pass_combined(bool value);
	inline bool use_pass_z(void);
	inline void use_pass_z(bool value);
	inline bool use_pass_vector(void);
	inline void use_pass_vector(bool value);
	inline bool use_pass_normal(void);
	inline void use_pass_normal(bool value);
	inline bool use_pass_uv(void);
	inline void use_pass_uv(bool value);
	inline bool use_pass_mist(void);
	inline void use_pass_mist(bool value);
	inline bool use_pass_object_index(void);
	inline void use_pass_object_index(bool value);
	inline bool use_pass_material_index(void);
	inline void use_pass_material_index(bool value);
	inline bool use_pass_shadow(void);
	inline void use_pass_shadow(bool value);
	inline bool use_pass_ambient_occlusion(void);
	inline void use_pass_ambient_occlusion(bool value);
	inline bool use_pass_emit(void);
	inline void use_pass_emit(bool value);
	inline bool use_pass_environment(void);
	inline void use_pass_environment(bool value);
	inline bool use_pass_diffuse_direct(void);
	inline void use_pass_diffuse_direct(bool value);
	inline bool use_pass_diffuse_indirect(void);
	inline void use_pass_diffuse_indirect(bool value);
	inline bool use_pass_diffuse_color(void);
	inline void use_pass_diffuse_color(bool value);
	inline bool use_pass_glossy_direct(void);
	inline void use_pass_glossy_direct(bool value);
	inline bool use_pass_glossy_indirect(void);
	inline void use_pass_glossy_indirect(bool value);
	inline bool use_pass_glossy_color(void);
	inline void use_pass_glossy_color(bool value);
	inline bool use_pass_transmission_direct(void);
	inline void use_pass_transmission_direct(bool value);
	inline bool use_pass_transmission_indirect(void);
	inline void use_pass_transmission_indirect(bool value);
	inline bool use_pass_transmission_color(void);
	inline void use_pass_transmission_color(bool value);
	inline bool use_pass_subsurface_direct(void);
	inline void use_pass_subsurface_direct(bool value);
	inline bool use_pass_subsurface_indirect(void);
	inline void use_pass_subsurface_indirect(bool value);
	inline bool use_pass_subsurface_color(void);
	inline void use_pass_subsurface_color(bool value);
	inline LayerCollection layer_collection(void);
	inline LayerCollection active_layer_collection(void);
	COLLECTION_PROPERTY(LayerObjects, Object, ViewLayer, objects, false, true, true)
	inline bool use(void);
	inline void use(bool value);
	inline bool use_freestyle(void);
	inline void use_freestyle(bool value);
	inline FreestyleSettings freestyle_settings(void);
	inline Depsgraph depsgraph(void);

	inline void update_render_passes();
	inline void update(void *main);
};

/**************** Freestyle Line Set ****************/

class FreestyleLineSet : public Pointer {
public:
	FreestyleLineSet(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline FreestyleLineStyle linestyle(void);
	inline std::string name(void);
	inline void name(const std::string& value);
	inline bool show_render(void);
	inline void show_render(bool value);
	inline bool select_by_visibility(void);
	inline void select_by_visibility(bool value);
	inline bool select_by_edge_types(void);
	inline void select_by_edge_types(bool value);
	inline bool select_by_collection(void);
	inline void select_by_collection(bool value);
	inline bool select_by_image_border(void);
	inline void select_by_image_border(bool value);
	inline bool select_by_face_marks(void);
	inline void select_by_face_marks(bool value);
	enum edge_type_negation_enum {
		edge_type_negation_INCLUSIVE = 0,
		edge_type_negation_EXCLUSIVE = 4,
	};
	inline edge_type_negation_enum edge_type_negation(void);
	inline void edge_type_negation(edge_type_negation_enum value);
	enum edge_type_combination_enum {
		edge_type_combination_OR = 0,
		edge_type_combination_AND = 8,
	};
	inline edge_type_combination_enum edge_type_combination(void);
	inline void edge_type_combination(edge_type_combination_enum value);
	inline Collection collection(void);
	enum collection_negation_enum {
		collection_negation_INCLUSIVE = 0,
		collection_negation_EXCLUSIVE = 16,
	};
	inline collection_negation_enum collection_negation(void);
	inline void collection_negation(collection_negation_enum value);
	enum face_mark_negation_enum {
		face_mark_negation_INCLUSIVE = 0,
		face_mark_negation_EXCLUSIVE = 32,
	};
	inline face_mark_negation_enum face_mark_negation(void);
	inline void face_mark_negation(face_mark_negation_enum value);
	enum face_mark_condition_enum {
		face_mark_condition_ONE = 0,
		face_mark_condition_BOTH = 64,
	};
	inline face_mark_condition_enum face_mark_condition(void);
	inline void face_mark_condition(face_mark_condition_enum value);
	inline bool select_silhouette(void);
	inline void select_silhouette(bool value);
	inline bool select_border(void);
	inline void select_border(bool value);
	inline bool select_crease(void);
	inline void select_crease(bool value);
	inline bool select_ridge_valley(void);
	inline void select_ridge_valley(bool value);
	inline bool select_suggestive_contour(void);
	inline void select_suggestive_contour(bool value);
	inline bool select_material_boundary(void);
	inline void select_material_boundary(bool value);
	inline bool select_contour(void);
	inline void select_contour(bool value);
	inline bool select_external_contour(void);
	inline void select_external_contour(bool value);
	inline bool select_edge_mark(void);
	inline void select_edge_mark(bool value);
	inline bool exclude_silhouette(void);
	inline void exclude_silhouette(bool value);
	inline bool exclude_border(void);
	inline void exclude_border(bool value);
	inline bool exclude_crease(void);
	inline void exclude_crease(bool value);
	inline bool exclude_ridge_valley(void);
	inline void exclude_ridge_valley(bool value);
	inline bool exclude_suggestive_contour(void);
	inline void exclude_suggestive_contour(bool value);
	inline bool exclude_material_boundary(void);
	inline void exclude_material_boundary(bool value);
	inline bool exclude_contour(void);
	inline void exclude_contour(bool value);
	inline bool exclude_external_contour(void);
	inline void exclude_external_contour(bool value);
	inline bool exclude_edge_mark(void);
	inline void exclude_edge_mark(bool value);
	enum visibility_enum {
		visibility_VISIBLE = 1,
		visibility_HIDDEN = 2,
		visibility_RANGE = 3,
	};
	inline visibility_enum visibility(void);
	inline void visibility(visibility_enum value);
	inline int qi_start(void);
	inline void qi_start(int value);
	inline int qi_end(void);
	inline void qi_end(int value);

};

/**************** Freestyle Module ****************/

class FreestyleModuleSettings : public Pointer {
public:
	FreestyleModuleSettings(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline Text script(void);
	inline bool use(void);
	inline void use(bool value);

};

/**************** Freestyle Settings ****************/

class FreestyleSettings : public Pointer {
public:
	FreestyleSettings(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		modules(ptr_arg),
		linesets(ptr_arg)
		{}

	inline Struct rna_type(void);
	COLLECTION_PROPERTY(FreestyleModules, FreestyleModuleSettings, FreestyleSettings, modules, false, true, false)
	enum mode_enum {
		mode_SCRIPT = 1,
		mode_EDITOR = 2,
	};
	inline mode_enum mode(void);
	inline void mode(mode_enum value);
	inline bool use_culling(void);
	inline void use_culling(bool value);
	inline bool use_suggestive_contours(void);
	inline void use_suggestive_contours(bool value);
	inline bool use_ridges_and_valleys(void);
	inline void use_ridges_and_valleys(bool value);
	inline bool use_material_boundaries(void);
	inline void use_material_boundaries(bool value);
	inline bool use_smoothness(void);
	inline void use_smoothness(bool value);
	inline bool use_advanced_options(void);
	inline void use_advanced_options(bool value);
	inline bool use_view_map_cache(void);
	inline void use_view_map_cache(bool value);
	inline float sphere_radius(void);
	inline void sphere_radius(float value);
	inline float kr_derivative_epsilon(void);
	inline void kr_derivative_epsilon(float value);
	inline float crease_angle(void);
	inline void crease_angle(float value);
	COLLECTION_PROPERTY(Linesets, FreestyleLineSet, FreestyleSettings, linesets, false, true, true)

};

/**************** Layer Collection ****************/

class LayerCollection : public Pointer {
public:
	LayerCollection(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		children(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline Collection collection(void);
	inline std::string name(void);
	inline void name(const std::string& value);
	COLLECTION_PROPERTY(DefaultCollectionFunctions, LayerCollection, LayerCollection, children, false, true, true)
	inline bool exclude(void);
	inline void exclude(bool value);
	inline bool holdout(void);
	inline void holdout(bool value);
	inline bool indirect_only(void);
	inline void indirect_only(bool value);
	inline bool hide_viewport(void);
	inline void hide_viewport(bool value);
	inline bool is_visible(void);
	inline void is_visible(bool value);

	inline bool has_objects();
	inline bool has_selected_objects(ViewLayer& view_layer);
};

/**************** Object Base ****************/

class ObjectBase : public Pointer {
public:
	ObjectBase(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline Object object(void);
	inline bool select(void);
	inline void select(bool value);

};

/**************** Line Style Modifier ****************/

class LineStyleModifier : public Pointer {
public:
	LineStyleModifier(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

};

/**************** Line Style Color Modifier ****************/

class LineStyleColorModifier : public LineStyleModifier {
public:
	LineStyleColorModifier(const PointerRNA &ptr_arg) :
		LineStyleModifier(ptr_arg)
		{}


};

/**************** Along Stroke ****************/

class LineStyleColorModifier_AlongStroke : public LineStyleColorModifier {
public:
	LineStyleColorModifier_AlongStroke(const PointerRNA &ptr_arg) :
		LineStyleColorModifier(ptr_arg)
		{}

	enum type_enum {
		type_ALONG_STROKE = 1,
		type_CREASE_ANGLE = 21,
		type_CURVATURE_3D = 23,
		type_DISTANCE_FROM_CAMERA = 2,
		type_DISTANCE_FROM_OBJECT = 3,
		type_MATERIAL = 4,
		type_NOISE = 20,
		type_TANGENT = 19,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	inline std::string name(void);
	inline void name(const std::string& value);
	enum blend_enum {
		blend_MIX = 0,
		blend_DARKEN = 7,
		blend_MULTIPLY = 2,
		blend_BURN = 11,
		blend_LIGHTEN = 8,
		blend_SCREEN = 4,
		blend_DODGE = 10,
		blend_ADD = 1,
		blend_OVERLAY = 9,
		blend_SOFT_LIGHT = 16,
		blend_LINEAR_LIGHT = 17,
		blend_DIFFERENCE = 6,
		blend_SUBTRACT = 3,
		blend_DIVIDE = 5,
		blend_HUE = 12,
		blend_SATURATION = 13,
		blend_COLOR = 15,
		blend_VALUE = 14,
	};
	inline blend_enum blend(void);
	inline void blend(blend_enum value);
	inline float influence(void);
	inline void influence(float value);
	inline bool use(void);
	inline void use(bool value);
	inline bool expanded(void);
	inline void expanded(bool value);
	inline ColorRamp color_ramp(void);

};

/**************** Distance from Camera ****************/

class LineStyleColorModifier_DistanceFromCamera : public LineStyleColorModifier {
public:
	LineStyleColorModifier_DistanceFromCamera(const PointerRNA &ptr_arg) :
		LineStyleColorModifier(ptr_arg)
		{}

	enum type_enum {
		type_ALONG_STROKE = 1,
		type_CREASE_ANGLE = 21,
		type_CURVATURE_3D = 23,
		type_DISTANCE_FROM_CAMERA = 2,
		type_DISTANCE_FROM_OBJECT = 3,
		type_MATERIAL = 4,
		type_NOISE = 20,
		type_TANGENT = 19,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	inline std::string name(void);
	inline void name(const std::string& value);
	enum blend_enum {
		blend_MIX = 0,
		blend_DARKEN = 7,
		blend_MULTIPLY = 2,
		blend_BURN = 11,
		blend_LIGHTEN = 8,
		blend_SCREEN = 4,
		blend_DODGE = 10,
		blend_ADD = 1,
		blend_OVERLAY = 9,
		blend_SOFT_LIGHT = 16,
		blend_LINEAR_LIGHT = 17,
		blend_DIFFERENCE = 6,
		blend_SUBTRACT = 3,
		blend_DIVIDE = 5,
		blend_HUE = 12,
		blend_SATURATION = 13,
		blend_COLOR = 15,
		blend_VALUE = 14,
	};
	inline blend_enum blend(void);
	inline void blend(blend_enum value);
	inline float influence(void);
	inline void influence(float value);
	inline bool use(void);
	inline void use(bool value);
	inline bool expanded(void);
	inline void expanded(bool value);
	inline ColorRamp color_ramp(void);
	inline float range_min(void);
	inline void range_min(float value);
	inline float range_max(void);
	inline void range_max(float value);

};

/**************** Distance from Object ****************/

class LineStyleColorModifier_DistanceFromObject : public LineStyleColorModifier {
public:
	LineStyleColorModifier_DistanceFromObject(const PointerRNA &ptr_arg) :
		LineStyleColorModifier(ptr_arg)
		{}

	enum type_enum {
		type_ALONG_STROKE = 1,
		type_CREASE_ANGLE = 21,
		type_CURVATURE_3D = 23,
		type_DISTANCE_FROM_CAMERA = 2,
		type_DISTANCE_FROM_OBJECT = 3,
		type_MATERIAL = 4,
		type_NOISE = 20,
		type_TANGENT = 19,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	inline std::string name(void);
	inline void name(const std::string& value);
	enum blend_enum {
		blend_MIX = 0,
		blend_DARKEN = 7,
		blend_MULTIPLY = 2,
		blend_BURN = 11,
		blend_LIGHTEN = 8,
		blend_SCREEN = 4,
		blend_DODGE = 10,
		blend_ADD = 1,
		blend_OVERLAY = 9,
		blend_SOFT_LIGHT = 16,
		blend_LINEAR_LIGHT = 17,
		blend_DIFFERENCE = 6,
		blend_SUBTRACT = 3,
		blend_DIVIDE = 5,
		blend_HUE = 12,
		blend_SATURATION = 13,
		blend_COLOR = 15,
		blend_VALUE = 14,
	};
	inline blend_enum blend(void);
	inline void blend(blend_enum value);
	inline float influence(void);
	inline void influence(float value);
	inline bool use(void);
	inline void use(bool value);
	inline bool expanded(void);
	inline void expanded(bool value);
	inline ColorRamp color_ramp(void);
	inline float range_min(void);
	inline void range_min(float value);
	inline float range_max(void);
	inline void range_max(float value);
	inline Object target(void);

};

/**************** Material ****************/

class LineStyleColorModifier_Material : public LineStyleColorModifier {
public:
	LineStyleColorModifier_Material(const PointerRNA &ptr_arg) :
		LineStyleColorModifier(ptr_arg)
		{}

	enum type_enum {
		type_ALONG_STROKE = 1,
		type_CREASE_ANGLE = 21,
		type_CURVATURE_3D = 23,
		type_DISTANCE_FROM_CAMERA = 2,
		type_DISTANCE_FROM_OBJECT = 3,
		type_MATERIAL = 4,
		type_NOISE = 20,
		type_TANGENT = 19,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	inline std::string name(void);
	inline void name(const std::string& value);
	enum blend_enum {
		blend_MIX = 0,
		blend_DARKEN = 7,
		blend_MULTIPLY = 2,
		blend_BURN = 11,
		blend_LIGHTEN = 8,
		blend_SCREEN = 4,
		blend_DODGE = 10,
		blend_ADD = 1,
		blend_OVERLAY = 9,
		blend_SOFT_LIGHT = 16,
		blend_LINEAR_LIGHT = 17,
		blend_DIFFERENCE = 6,
		blend_SUBTRACT = 3,
		blend_DIVIDE = 5,
		blend_HUE = 12,
		blend_SATURATION = 13,
		blend_COLOR = 15,
		blend_VALUE = 14,
	};
	inline blend_enum blend(void);
	inline void blend(blend_enum value);
	inline float influence(void);
	inline void influence(float value);
	inline bool use(void);
	inline void use(bool value);
	inline bool expanded(void);
	inline void expanded(bool value);
	enum material_attribute_enum {
		material_attribute_LINE = 11,
		material_attribute_LINE_R = 12,
		material_attribute_LINE_G = 13,
		material_attribute_LINE_B = 14,
		material_attribute_LINE_A = 15,
		material_attribute_DIFF = 1,
		material_attribute_DIFF_R = 2,
		material_attribute_DIFF_G = 3,
		material_attribute_DIFF_B = 4,
		material_attribute_SPEC = 5,
		material_attribute_SPEC_R = 6,
		material_attribute_SPEC_G = 7,
		material_attribute_SPEC_B = 8,
		material_attribute_SPEC_HARD = 9,
		material_attribute_ALPHA = 10,
	};
	inline material_attribute_enum material_attribute(void);
	inline void material_attribute(material_attribute_enum value);
	inline ColorRamp color_ramp(void);
	inline bool use_ramp(void);
	inline void use_ramp(bool value);

};

/**************** Tangent ****************/

class LineStyleColorModifier_Tangent : public LineStyleColorModifier {
public:
	LineStyleColorModifier_Tangent(const PointerRNA &ptr_arg) :
		LineStyleColorModifier(ptr_arg)
		{}

	enum type_enum {
		type_ALONG_STROKE = 1,
		type_CREASE_ANGLE = 21,
		type_CURVATURE_3D = 23,
		type_DISTANCE_FROM_CAMERA = 2,
		type_DISTANCE_FROM_OBJECT = 3,
		type_MATERIAL = 4,
		type_NOISE = 20,
		type_TANGENT = 19,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	inline std::string name(void);
	inline void name(const std::string& value);
	enum blend_enum {
		blend_MIX = 0,
		blend_DARKEN = 7,
		blend_MULTIPLY = 2,
		blend_BURN = 11,
		blend_LIGHTEN = 8,
		blend_SCREEN = 4,
		blend_DODGE = 10,
		blend_ADD = 1,
		blend_OVERLAY = 9,
		blend_SOFT_LIGHT = 16,
		blend_LINEAR_LIGHT = 17,
		blend_DIFFERENCE = 6,
		blend_SUBTRACT = 3,
		blend_DIVIDE = 5,
		blend_HUE = 12,
		blend_SATURATION = 13,
		blend_COLOR = 15,
		blend_VALUE = 14,
	};
	inline blend_enum blend(void);
	inline void blend(blend_enum value);
	inline float influence(void);
	inline void influence(float value);
	inline bool use(void);
	inline void use(bool value);
	inline bool expanded(void);
	inline void expanded(bool value);
	inline ColorRamp color_ramp(void);

};

/**************** Noise ****************/

class LineStyleColorModifier_Noise : public LineStyleColorModifier {
public:
	LineStyleColorModifier_Noise(const PointerRNA &ptr_arg) :
		LineStyleColorModifier(ptr_arg)
		{}

	enum type_enum {
		type_ALONG_STROKE = 1,
		type_CREASE_ANGLE = 21,
		type_CURVATURE_3D = 23,
		type_DISTANCE_FROM_CAMERA = 2,
		type_DISTANCE_FROM_OBJECT = 3,
		type_MATERIAL = 4,
		type_NOISE = 20,
		type_TANGENT = 19,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	inline std::string name(void);
	inline void name(const std::string& value);
	enum blend_enum {
		blend_MIX = 0,
		blend_DARKEN = 7,
		blend_MULTIPLY = 2,
		blend_BURN = 11,
		blend_LIGHTEN = 8,
		blend_SCREEN = 4,
		blend_DODGE = 10,
		blend_ADD = 1,
		blend_OVERLAY = 9,
		blend_SOFT_LIGHT = 16,
		blend_LINEAR_LIGHT = 17,
		blend_DIFFERENCE = 6,
		blend_SUBTRACT = 3,
		blend_DIVIDE = 5,
		blend_HUE = 12,
		blend_SATURATION = 13,
		blend_COLOR = 15,
		blend_VALUE = 14,
	};
	inline blend_enum blend(void);
	inline void blend(blend_enum value);
	inline float influence(void);
	inline void influence(float value);
	inline bool use(void);
	inline void use(bool value);
	inline bool expanded(void);
	inline void expanded(bool value);
	inline ColorRamp color_ramp(void);
	inline float amplitude(void);
	inline void amplitude(float value);
	inline float period(void);
	inline void period(float value);
	inline int seed(void);
	inline void seed(int value);

};

/**************** Crease Angle ****************/

class LineStyleColorModifier_CreaseAngle : public LineStyleColorModifier {
public:
	LineStyleColorModifier_CreaseAngle(const PointerRNA &ptr_arg) :
		LineStyleColorModifier(ptr_arg)
		{}

	enum type_enum {
		type_ALONG_STROKE = 1,
		type_CREASE_ANGLE = 21,
		type_CURVATURE_3D = 23,
		type_DISTANCE_FROM_CAMERA = 2,
		type_DISTANCE_FROM_OBJECT = 3,
		type_MATERIAL = 4,
		type_NOISE = 20,
		type_TANGENT = 19,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	inline std::string name(void);
	inline void name(const std::string& value);
	enum blend_enum {
		blend_MIX = 0,
		blend_DARKEN = 7,
		blend_MULTIPLY = 2,
		blend_BURN = 11,
		blend_LIGHTEN = 8,
		blend_SCREEN = 4,
		blend_DODGE = 10,
		blend_ADD = 1,
		blend_OVERLAY = 9,
		blend_SOFT_LIGHT = 16,
		blend_LINEAR_LIGHT = 17,
		blend_DIFFERENCE = 6,
		blend_SUBTRACT = 3,
		blend_DIVIDE = 5,
		blend_HUE = 12,
		blend_SATURATION = 13,
		blend_COLOR = 15,
		blend_VALUE = 14,
	};
	inline blend_enum blend(void);
	inline void blend(blend_enum value);
	inline float influence(void);
	inline void influence(float value);
	inline bool use(void);
	inline void use(bool value);
	inline bool expanded(void);
	inline void expanded(bool value);
	inline ColorRamp color_ramp(void);
	inline float angle_min(void);
	inline void angle_min(float value);
	inline float angle_max(void);
	inline void angle_max(float value);

};

/**************** Curvature 3D ****************/

class LineStyleColorModifier_Curvature_3D : public LineStyleColorModifier {
public:
	LineStyleColorModifier_Curvature_3D(const PointerRNA &ptr_arg) :
		LineStyleColorModifier(ptr_arg)
		{}

	enum type_enum {
		type_ALONG_STROKE = 1,
		type_CREASE_ANGLE = 21,
		type_CURVATURE_3D = 23,
		type_DISTANCE_FROM_CAMERA = 2,
		type_DISTANCE_FROM_OBJECT = 3,
		type_MATERIAL = 4,
		type_NOISE = 20,
		type_TANGENT = 19,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	inline std::string name(void);
	inline void name(const std::string& value);
	enum blend_enum {
		blend_MIX = 0,
		blend_DARKEN = 7,
		blend_MULTIPLY = 2,
		blend_BURN = 11,
		blend_LIGHTEN = 8,
		blend_SCREEN = 4,
		blend_DODGE = 10,
		blend_ADD = 1,
		blend_OVERLAY = 9,
		blend_SOFT_LIGHT = 16,
		blend_LINEAR_LIGHT = 17,
		blend_DIFFERENCE = 6,
		blend_SUBTRACT = 3,
		blend_DIVIDE = 5,
		blend_HUE = 12,
		blend_SATURATION = 13,
		blend_COLOR = 15,
		blend_VALUE = 14,
	};
	inline blend_enum blend(void);
	inline void blend(blend_enum value);
	inline float influence(void);
	inline void influence(float value);
	inline bool use(void);
	inline void use(bool value);
	inline bool expanded(void);
	inline void expanded(bool value);
	inline ColorRamp color_ramp(void);
	inline float curvature_min(void);
	inline void curvature_min(float value);
	inline float curvature_max(void);
	inline void curvature_max(float value);

};

/**************** Line Style Alpha Modifier ****************/

class LineStyleAlphaModifier : public LineStyleModifier {
public:
	LineStyleAlphaModifier(const PointerRNA &ptr_arg) :
		LineStyleModifier(ptr_arg)
		{}


};

/**************** Along Stroke ****************/

class LineStyleAlphaModifier_AlongStroke : public LineStyleAlphaModifier {
public:
	LineStyleAlphaModifier_AlongStroke(const PointerRNA &ptr_arg) :
		LineStyleAlphaModifier(ptr_arg)
		{}

	enum type_enum {
		type_ALONG_STROKE = 1,
		type_CREASE_ANGLE = 21,
		type_CURVATURE_3D = 23,
		type_DISTANCE_FROM_CAMERA = 2,
		type_DISTANCE_FROM_OBJECT = 3,
		type_MATERIAL = 4,
		type_NOISE = 20,
		type_TANGENT = 19,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	inline std::string name(void);
	inline void name(const std::string& value);
	enum blend_enum {
		blend_MIX = 0,
		blend_ADD = 1,
		blend_SUBTRACT = 3,
		blend_MULTIPLY = 2,
		blend_DIVIDE = 4,
		blend_DIFFERENCE = 5,
		blend_MINIMUM = 6,
		blend_MAXIMUM = 7,
	};
	inline blend_enum blend(void);
	inline void blend(blend_enum value);
	inline float influence(void);
	inline void influence(float value);
	inline bool use(void);
	inline void use(bool value);
	inline bool expanded(void);
	inline void expanded(bool value);
	enum mapping_enum {
		mapping_LINEAR = 0,
		mapping_CURVE = 1,
	};
	inline mapping_enum mapping(void);
	inline void mapping(mapping_enum value);
	inline bool invert(void);
	inline void invert(bool value);
	inline CurveMapping curve(void);

};

/**************** Distance from Camera ****************/

class LineStyleAlphaModifier_DistanceFromCamera : public LineStyleAlphaModifier {
public:
	LineStyleAlphaModifier_DistanceFromCamera(const PointerRNA &ptr_arg) :
		LineStyleAlphaModifier(ptr_arg)
		{}

	enum type_enum {
		type_ALONG_STROKE = 1,
		type_CREASE_ANGLE = 21,
		type_CURVATURE_3D = 23,
		type_DISTANCE_FROM_CAMERA = 2,
		type_DISTANCE_FROM_OBJECT = 3,
		type_MATERIAL = 4,
		type_NOISE = 20,
		type_TANGENT = 19,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	inline std::string name(void);
	inline void name(const std::string& value);
	enum blend_enum {
		blend_MIX = 0,
		blend_ADD = 1,
		blend_SUBTRACT = 3,
		blend_MULTIPLY = 2,
		blend_DIVIDE = 4,
		blend_DIFFERENCE = 5,
		blend_MINIMUM = 6,
		blend_MAXIMUM = 7,
	};
	inline blend_enum blend(void);
	inline void blend(blend_enum value);
	inline float influence(void);
	inline void influence(float value);
	inline bool use(void);
	inline void use(bool value);
	inline bool expanded(void);
	inline void expanded(bool value);
	enum mapping_enum {
		mapping_LINEAR = 0,
		mapping_CURVE = 1,
	};
	inline mapping_enum mapping(void);
	inline void mapping(mapping_enum value);
	inline bool invert(void);
	inline void invert(bool value);
	inline CurveMapping curve(void);
	inline float range_min(void);
	inline void range_min(float value);
	inline float range_max(void);
	inline void range_max(float value);

};

/**************** Distance from Object ****************/

class LineStyleAlphaModifier_DistanceFromObject : public LineStyleAlphaModifier {
public:
	LineStyleAlphaModifier_DistanceFromObject(const PointerRNA &ptr_arg) :
		LineStyleAlphaModifier(ptr_arg)
		{}

	enum type_enum {
		type_ALONG_STROKE = 1,
		type_CREASE_ANGLE = 21,
		type_CURVATURE_3D = 23,
		type_DISTANCE_FROM_CAMERA = 2,
		type_DISTANCE_FROM_OBJECT = 3,
		type_MATERIAL = 4,
		type_NOISE = 20,
		type_TANGENT = 19,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	inline std::string name(void);
	inline void name(const std::string& value);
	enum blend_enum {
		blend_MIX = 0,
		blend_ADD = 1,
		blend_SUBTRACT = 3,
		blend_MULTIPLY = 2,
		blend_DIVIDE = 4,
		blend_DIFFERENCE = 5,
		blend_MINIMUM = 6,
		blend_MAXIMUM = 7,
	};
	inline blend_enum blend(void);
	inline void blend(blend_enum value);
	inline float influence(void);
	inline void influence(float value);
	inline bool use(void);
	inline void use(bool value);
	inline bool expanded(void);
	inline void expanded(bool value);
	enum mapping_enum {
		mapping_LINEAR = 0,
		mapping_CURVE = 1,
	};
	inline mapping_enum mapping(void);
	inline void mapping(mapping_enum value);
	inline bool invert(void);
	inline void invert(bool value);
	inline CurveMapping curve(void);
	inline float range_min(void);
	inline void range_min(float value);
	inline float range_max(void);
	inline void range_max(float value);
	inline Object target(void);

};

/**************** Material ****************/

class LineStyleAlphaModifier_Material : public LineStyleAlphaModifier {
public:
	LineStyleAlphaModifier_Material(const PointerRNA &ptr_arg) :
		LineStyleAlphaModifier(ptr_arg)
		{}

	enum type_enum {
		type_ALONG_STROKE = 1,
		type_CREASE_ANGLE = 21,
		type_CURVATURE_3D = 23,
		type_DISTANCE_FROM_CAMERA = 2,
		type_DISTANCE_FROM_OBJECT = 3,
		type_MATERIAL = 4,
		type_NOISE = 20,
		type_TANGENT = 19,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	inline std::string name(void);
	inline void name(const std::string& value);
	enum blend_enum {
		blend_MIX = 0,
		blend_ADD = 1,
		blend_SUBTRACT = 3,
		blend_MULTIPLY = 2,
		blend_DIVIDE = 4,
		blend_DIFFERENCE = 5,
		blend_MINIMUM = 6,
		blend_MAXIMUM = 7,
	};
	inline blend_enum blend(void);
	inline void blend(blend_enum value);
	inline float influence(void);
	inline void influence(float value);
	inline bool use(void);
	inline void use(bool value);
	inline bool expanded(void);
	inline void expanded(bool value);
	enum material_attribute_enum {
		material_attribute_LINE = 11,
		material_attribute_LINE_R = 12,
		material_attribute_LINE_G = 13,
		material_attribute_LINE_B = 14,
		material_attribute_LINE_A = 15,
		material_attribute_DIFF = 1,
		material_attribute_DIFF_R = 2,
		material_attribute_DIFF_G = 3,
		material_attribute_DIFF_B = 4,
		material_attribute_SPEC = 5,
		material_attribute_SPEC_R = 6,
		material_attribute_SPEC_G = 7,
		material_attribute_SPEC_B = 8,
		material_attribute_SPEC_HARD = 9,
		material_attribute_ALPHA = 10,
	};
	inline material_attribute_enum material_attribute(void);
	inline void material_attribute(material_attribute_enum value);
	enum mapping_enum {
		mapping_LINEAR = 0,
		mapping_CURVE = 1,
	};
	inline mapping_enum mapping(void);
	inline void mapping(mapping_enum value);
	inline bool invert(void);
	inline void invert(bool value);
	inline CurveMapping curve(void);

};

/**************** Tangent ****************/

class LineStyleAlphaModifier_Tangent : public LineStyleAlphaModifier {
public:
	LineStyleAlphaModifier_Tangent(const PointerRNA &ptr_arg) :
		LineStyleAlphaModifier(ptr_arg)
		{}

	enum type_enum {
		type_ALONG_STROKE = 1,
		type_CREASE_ANGLE = 21,
		type_CURVATURE_3D = 23,
		type_DISTANCE_FROM_CAMERA = 2,
		type_DISTANCE_FROM_OBJECT = 3,
		type_MATERIAL = 4,
		type_NOISE = 20,
		type_TANGENT = 19,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	inline std::string name(void);
	inline void name(const std::string& value);
	enum blend_enum {
		blend_MIX = 0,
		blend_ADD = 1,
		blend_SUBTRACT = 3,
		blend_MULTIPLY = 2,
		blend_DIVIDE = 4,
		blend_DIFFERENCE = 5,
		blend_MINIMUM = 6,
		blend_MAXIMUM = 7,
	};
	inline blend_enum blend(void);
	inline void blend(blend_enum value);
	inline float influence(void);
	inline void influence(float value);
	inline bool use(void);
	inline void use(bool value);
	inline bool expanded(void);
	inline void expanded(bool value);
	enum mapping_enum {
		mapping_LINEAR = 0,
		mapping_CURVE = 1,
	};
	inline mapping_enum mapping(void);
	inline void mapping(mapping_enum value);
	inline bool invert(void);
	inline void invert(bool value);
	inline CurveMapping curve(void);

};

/**************** Noise ****************/

class LineStyleAlphaModifier_Noise : public LineStyleAlphaModifier {
public:
	LineStyleAlphaModifier_Noise(const PointerRNA &ptr_arg) :
		LineStyleAlphaModifier(ptr_arg)
		{}

	enum type_enum {
		type_ALONG_STROKE = 1,
		type_CREASE_ANGLE = 21,
		type_CURVATURE_3D = 23,
		type_DISTANCE_FROM_CAMERA = 2,
		type_DISTANCE_FROM_OBJECT = 3,
		type_MATERIAL = 4,
		type_NOISE = 20,
		type_TANGENT = 19,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	inline std::string name(void);
	inline void name(const std::string& value);
	enum blend_enum {
		blend_MIX = 0,
		blend_ADD = 1,
		blend_SUBTRACT = 3,
		blend_MULTIPLY = 2,
		blend_DIVIDE = 4,
		blend_DIFFERENCE = 5,
		blend_MINIMUM = 6,
		blend_MAXIMUM = 7,
	};
	inline blend_enum blend(void);
	inline void blend(blend_enum value);
	inline float influence(void);
	inline void influence(float value);
	inline bool use(void);
	inline void use(bool value);
	inline bool expanded(void);
	inline void expanded(bool value);
	enum mapping_enum {
		mapping_LINEAR = 0,
		mapping_CURVE = 1,
	};
	inline mapping_enum mapping(void);
	inline void mapping(mapping_enum value);
	inline bool invert(void);
	inline void invert(bool value);
	inline CurveMapping curve(void);
	inline float amplitude(void);
	inline void amplitude(float value);
	inline float period(void);
	inline void period(float value);
	inline int seed(void);
	inline void seed(int value);

};

/**************** Crease Angle ****************/

class LineStyleAlphaModifier_CreaseAngle : public LineStyleAlphaModifier {
public:
	LineStyleAlphaModifier_CreaseAngle(const PointerRNA &ptr_arg) :
		LineStyleAlphaModifier(ptr_arg)
		{}

	enum type_enum {
		type_ALONG_STROKE = 1,
		type_CREASE_ANGLE = 21,
		type_CURVATURE_3D = 23,
		type_DISTANCE_FROM_CAMERA = 2,
		type_DISTANCE_FROM_OBJECT = 3,
		type_MATERIAL = 4,
		type_NOISE = 20,
		type_TANGENT = 19,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	inline std::string name(void);
	inline void name(const std::string& value);
	enum blend_enum {
		blend_MIX = 0,
		blend_ADD = 1,
		blend_SUBTRACT = 3,
		blend_MULTIPLY = 2,
		blend_DIVIDE = 4,
		blend_DIFFERENCE = 5,
		blend_MINIMUM = 6,
		blend_MAXIMUM = 7,
	};
	inline blend_enum blend(void);
	inline void blend(blend_enum value);
	inline float influence(void);
	inline void influence(float value);
	inline bool use(void);
	inline void use(bool value);
	inline bool expanded(void);
	inline void expanded(bool value);
	enum mapping_enum {
		mapping_LINEAR = 0,
		mapping_CURVE = 1,
	};
	inline mapping_enum mapping(void);
	inline void mapping(mapping_enum value);
	inline bool invert(void);
	inline void invert(bool value);
	inline CurveMapping curve(void);
	inline float angle_min(void);
	inline void angle_min(float value);
	inline float angle_max(void);
	inline void angle_max(float value);

};

/**************** Curvature 3D ****************/

class LineStyleAlphaModifier_Curvature_3D : public LineStyleAlphaModifier {
public:
	LineStyleAlphaModifier_Curvature_3D(const PointerRNA &ptr_arg) :
		LineStyleAlphaModifier(ptr_arg)
		{}

	enum type_enum {
		type_ALONG_STROKE = 1,
		type_CREASE_ANGLE = 21,
		type_CURVATURE_3D = 23,
		type_DISTANCE_FROM_CAMERA = 2,
		type_DISTANCE_FROM_OBJECT = 3,
		type_MATERIAL = 4,
		type_NOISE = 20,
		type_TANGENT = 19,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	inline std::string name(void);
	inline void name(const std::string& value);
	enum blend_enum {
		blend_MIX = 0,
		blend_ADD = 1,
		blend_SUBTRACT = 3,
		blend_MULTIPLY = 2,
		blend_DIVIDE = 4,
		blend_DIFFERENCE = 5,
		blend_MINIMUM = 6,
		blend_MAXIMUM = 7,
	};
	inline blend_enum blend(void);
	inline void blend(blend_enum value);
	inline float influence(void);
	inline void influence(float value);
	inline bool use(void);
	inline void use(bool value);
	inline bool expanded(void);
	inline void expanded(bool value);
	enum mapping_enum {
		mapping_LINEAR = 0,
		mapping_CURVE = 1,
	};
	inline mapping_enum mapping(void);
	inline void mapping(mapping_enum value);
	inline bool invert(void);
	inline void invert(bool value);
	inline CurveMapping curve(void);
	inline float curvature_min(void);
	inline void curvature_min(float value);
	inline float curvature_max(void);
	inline void curvature_max(float value);

};

/**************** Line Style Thickness Modifier ****************/

class LineStyleThicknessModifier : public LineStyleModifier {
public:
	LineStyleThicknessModifier(const PointerRNA &ptr_arg) :
		LineStyleModifier(ptr_arg)
		{}


};

/**************** Tangent ****************/

class LineStyleThicknessModifier_Tangent : public LineStyleThicknessModifier {
public:
	LineStyleThicknessModifier_Tangent(const PointerRNA &ptr_arg) :
		LineStyleThicknessModifier(ptr_arg)
		{}

	enum type_enum {
		type_ALONG_STROKE = 1,
		type_CALLIGRAPHY = 13,
		type_CREASE_ANGLE = 21,
		type_CURVATURE_3D = 23,
		type_DISTANCE_FROM_CAMERA = 2,
		type_DISTANCE_FROM_OBJECT = 3,
		type_MATERIAL = 4,
		type_NOISE = 20,
		type_TANGENT = 19,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	inline std::string name(void);
	inline void name(const std::string& value);
	enum blend_enum {
		blend_MIX = 0,
		blend_ADD = 1,
		blend_SUBTRACT = 3,
		blend_MULTIPLY = 2,
		blend_DIVIDE = 4,
		blend_DIFFERENCE = 5,
		blend_MINIMUM = 6,
		blend_MAXIMUM = 7,
	};
	inline blend_enum blend(void);
	inline void blend(blend_enum value);
	inline float influence(void);
	inline void influence(float value);
	inline bool use(void);
	inline void use(bool value);
	inline bool expanded(void);
	inline void expanded(bool value);
	enum mapping_enum {
		mapping_LINEAR = 0,
		mapping_CURVE = 1,
	};
	inline mapping_enum mapping(void);
	inline void mapping(mapping_enum value);
	inline bool invert(void);
	inline void invert(bool value);
	inline CurveMapping curve(void);
	inline float thickness_min(void);
	inline void thickness_min(float value);
	inline float thickness_max(void);
	inline void thickness_max(float value);

};

/**************** Along Stroke ****************/

class LineStyleThicknessModifier_AlongStroke : public LineStyleThicknessModifier {
public:
	LineStyleThicknessModifier_AlongStroke(const PointerRNA &ptr_arg) :
		LineStyleThicknessModifier(ptr_arg)
		{}

	enum type_enum {
		type_ALONG_STROKE = 1,
		type_CALLIGRAPHY = 13,
		type_CREASE_ANGLE = 21,
		type_CURVATURE_3D = 23,
		type_DISTANCE_FROM_CAMERA = 2,
		type_DISTANCE_FROM_OBJECT = 3,
		type_MATERIAL = 4,
		type_NOISE = 20,
		type_TANGENT = 19,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	inline std::string name(void);
	inline void name(const std::string& value);
	enum blend_enum {
		blend_MIX = 0,
		blend_ADD = 1,
		blend_SUBTRACT = 3,
		blend_MULTIPLY = 2,
		blend_DIVIDE = 4,
		blend_DIFFERENCE = 5,
		blend_MINIMUM = 6,
		blend_MAXIMUM = 7,
	};
	inline blend_enum blend(void);
	inline void blend(blend_enum value);
	inline float influence(void);
	inline void influence(float value);
	inline bool use(void);
	inline void use(bool value);
	inline bool expanded(void);
	inline void expanded(bool value);
	enum mapping_enum {
		mapping_LINEAR = 0,
		mapping_CURVE = 1,
	};
	inline mapping_enum mapping(void);
	inline void mapping(mapping_enum value);
	inline bool invert(void);
	inline void invert(bool value);
	inline CurveMapping curve(void);
	inline float value_min(void);
	inline void value_min(float value);
	inline float value_max(void);
	inline void value_max(float value);

};

/**************** Distance from Camera ****************/

class LineStyleThicknessModifier_DistanceFromCamera : public LineStyleThicknessModifier {
public:
	LineStyleThicknessModifier_DistanceFromCamera(const PointerRNA &ptr_arg) :
		LineStyleThicknessModifier(ptr_arg)
		{}

	enum type_enum {
		type_ALONG_STROKE = 1,
		type_CALLIGRAPHY = 13,
		type_CREASE_ANGLE = 21,
		type_CURVATURE_3D = 23,
		type_DISTANCE_FROM_CAMERA = 2,
		type_DISTANCE_FROM_OBJECT = 3,
		type_MATERIAL = 4,
		type_NOISE = 20,
		type_TANGENT = 19,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	inline std::string name(void);
	inline void name(const std::string& value);
	enum blend_enum {
		blend_MIX = 0,
		blend_ADD = 1,
		blend_SUBTRACT = 3,
		blend_MULTIPLY = 2,
		blend_DIVIDE = 4,
		blend_DIFFERENCE = 5,
		blend_MINIMUM = 6,
		blend_MAXIMUM = 7,
	};
	inline blend_enum blend(void);
	inline void blend(blend_enum value);
	inline float influence(void);
	inline void influence(float value);
	inline bool use(void);
	inline void use(bool value);
	inline bool expanded(void);
	inline void expanded(bool value);
	enum mapping_enum {
		mapping_LINEAR = 0,
		mapping_CURVE = 1,
	};
	inline mapping_enum mapping(void);
	inline void mapping(mapping_enum value);
	inline bool invert(void);
	inline void invert(bool value);
	inline CurveMapping curve(void);
	inline float range_min(void);
	inline void range_min(float value);
	inline float range_max(void);
	inline void range_max(float value);
	inline float value_min(void);
	inline void value_min(float value);
	inline float value_max(void);
	inline void value_max(float value);

};

/**************** Distance from Object ****************/

class LineStyleThicknessModifier_DistanceFromObject : public LineStyleThicknessModifier {
public:
	LineStyleThicknessModifier_DistanceFromObject(const PointerRNA &ptr_arg) :
		LineStyleThicknessModifier(ptr_arg)
		{}

	enum type_enum {
		type_ALONG_STROKE = 1,
		type_CALLIGRAPHY = 13,
		type_CREASE_ANGLE = 21,
		type_CURVATURE_3D = 23,
		type_DISTANCE_FROM_CAMERA = 2,
		type_DISTANCE_FROM_OBJECT = 3,
		type_MATERIAL = 4,
		type_NOISE = 20,
		type_TANGENT = 19,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	inline std::string name(void);
	inline void name(const std::string& value);
	enum blend_enum {
		blend_MIX = 0,
		blend_ADD = 1,
		blend_SUBTRACT = 3,
		blend_MULTIPLY = 2,
		blend_DIVIDE = 4,
		blend_DIFFERENCE = 5,
		blend_MINIMUM = 6,
		blend_MAXIMUM = 7,
	};
	inline blend_enum blend(void);
	inline void blend(blend_enum value);
	inline float influence(void);
	inline void influence(float value);
	inline bool use(void);
	inline void use(bool value);
	inline bool expanded(void);
	inline void expanded(bool value);
	enum mapping_enum {
		mapping_LINEAR = 0,
		mapping_CURVE = 1,
	};
	inline mapping_enum mapping(void);
	inline void mapping(mapping_enum value);
	inline bool invert(void);
	inline void invert(bool value);
	inline CurveMapping curve(void);
	inline float range_min(void);
	inline void range_min(float value);
	inline float range_max(void);
	inline void range_max(float value);
	inline float value_min(void);
	inline void value_min(float value);
	inline float value_max(void);
	inline void value_max(float value);
	inline Object target(void);

};

/**************** Material ****************/

class LineStyleThicknessModifier_Material : public LineStyleThicknessModifier {
public:
	LineStyleThicknessModifier_Material(const PointerRNA &ptr_arg) :
		LineStyleThicknessModifier(ptr_arg)
		{}

	enum type_enum {
		type_ALONG_STROKE = 1,
		type_CALLIGRAPHY = 13,
		type_CREASE_ANGLE = 21,
		type_CURVATURE_3D = 23,
		type_DISTANCE_FROM_CAMERA = 2,
		type_DISTANCE_FROM_OBJECT = 3,
		type_MATERIAL = 4,
		type_NOISE = 20,
		type_TANGENT = 19,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	inline std::string name(void);
	inline void name(const std::string& value);
	enum blend_enum {
		blend_MIX = 0,
		blend_ADD = 1,
		blend_SUBTRACT = 3,
		blend_MULTIPLY = 2,
		blend_DIVIDE = 4,
		blend_DIFFERENCE = 5,
		blend_MINIMUM = 6,
		blend_MAXIMUM = 7,
	};
	inline blend_enum blend(void);
	inline void blend(blend_enum value);
	inline float influence(void);
	inline void influence(float value);
	inline bool use(void);
	inline void use(bool value);
	inline bool expanded(void);
	inline void expanded(bool value);
	enum material_attribute_enum {
		material_attribute_LINE = 11,
		material_attribute_LINE_R = 12,
		material_attribute_LINE_G = 13,
		material_attribute_LINE_B = 14,
		material_attribute_LINE_A = 15,
		material_attribute_DIFF = 1,
		material_attribute_DIFF_R = 2,
		material_attribute_DIFF_G = 3,
		material_attribute_DIFF_B = 4,
		material_attribute_SPEC = 5,
		material_attribute_SPEC_R = 6,
		material_attribute_SPEC_G = 7,
		material_attribute_SPEC_B = 8,
		material_attribute_SPEC_HARD = 9,
		material_attribute_ALPHA = 10,
	};
	inline material_attribute_enum material_attribute(void);
	inline void material_attribute(material_attribute_enum value);
	enum mapping_enum {
		mapping_LINEAR = 0,
		mapping_CURVE = 1,
	};
	inline mapping_enum mapping(void);
	inline void mapping(mapping_enum value);
	inline bool invert(void);
	inline void invert(bool value);
	inline CurveMapping curve(void);
	inline float value_min(void);
	inline void value_min(float value);
	inline float value_max(void);
	inline void value_max(float value);

};

/**************** Calligraphy ****************/

class LineStyleThicknessModifier_Calligraphy : public LineStyleThicknessModifier {
public:
	LineStyleThicknessModifier_Calligraphy(const PointerRNA &ptr_arg) :
		LineStyleThicknessModifier(ptr_arg)
		{}

	enum type_enum {
		type_ALONG_STROKE = 1,
		type_CALLIGRAPHY = 13,
		type_CREASE_ANGLE = 21,
		type_CURVATURE_3D = 23,
		type_DISTANCE_FROM_CAMERA = 2,
		type_DISTANCE_FROM_OBJECT = 3,
		type_MATERIAL = 4,
		type_NOISE = 20,
		type_TANGENT = 19,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	inline std::string name(void);
	inline void name(const std::string& value);
	enum blend_enum {
		blend_MIX = 0,
		blend_ADD = 1,
		blend_SUBTRACT = 3,
		blend_MULTIPLY = 2,
		blend_DIVIDE = 4,
		blend_DIFFERENCE = 5,
		blend_MINIMUM = 6,
		blend_MAXIMUM = 7,
	};
	inline blend_enum blend(void);
	inline void blend(blend_enum value);
	inline float influence(void);
	inline void influence(float value);
	inline bool use(void);
	inline void use(bool value);
	inline bool expanded(void);
	inline void expanded(bool value);
	inline float orientation(void);
	inline void orientation(float value);
	inline float thickness_min(void);
	inline void thickness_min(float value);
	inline float thickness_max(void);
	inline void thickness_max(float value);

};

/**************** Noise ****************/

class LineStyleThicknessModifier_Noise : public LineStyleThicknessModifier {
public:
	LineStyleThicknessModifier_Noise(const PointerRNA &ptr_arg) :
		LineStyleThicknessModifier(ptr_arg)
		{}

	enum type_enum {
		type_ALONG_STROKE = 1,
		type_CALLIGRAPHY = 13,
		type_CREASE_ANGLE = 21,
		type_CURVATURE_3D = 23,
		type_DISTANCE_FROM_CAMERA = 2,
		type_DISTANCE_FROM_OBJECT = 3,
		type_MATERIAL = 4,
		type_NOISE = 20,
		type_TANGENT = 19,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	inline std::string name(void);
	inline void name(const std::string& value);
	enum blend_enum {
		blend_MIX = 0,
		blend_ADD = 1,
		blend_SUBTRACT = 3,
		blend_MULTIPLY = 2,
		blend_DIVIDE = 4,
		blend_DIFFERENCE = 5,
		blend_MINIMUM = 6,
		blend_MAXIMUM = 7,
	};
	inline blend_enum blend(void);
	inline void blend(blend_enum value);
	inline float influence(void);
	inline void influence(float value);
	inline bool use(void);
	inline void use(bool value);
	inline bool expanded(void);
	inline void expanded(bool value);
	inline float amplitude(void);
	inline void amplitude(float value);
	inline float period(void);
	inline void period(float value);
	inline int seed(void);
	inline void seed(int value);
	inline bool use_asymmetric(void);
	inline void use_asymmetric(bool value);

};

/**************** Curvature 3D ****************/

class LineStyleThicknessModifier_Curvature_3D : public LineStyleThicknessModifier {
public:
	LineStyleThicknessModifier_Curvature_3D(const PointerRNA &ptr_arg) :
		LineStyleThicknessModifier(ptr_arg)
		{}

	enum type_enum {
		type_ALONG_STROKE = 1,
		type_CALLIGRAPHY = 13,
		type_CREASE_ANGLE = 21,
		type_CURVATURE_3D = 23,
		type_DISTANCE_FROM_CAMERA = 2,
		type_DISTANCE_FROM_OBJECT = 3,
		type_MATERIAL = 4,
		type_NOISE = 20,
		type_TANGENT = 19,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	inline std::string name(void);
	inline void name(const std::string& value);
	enum blend_enum {
		blend_MIX = 0,
		blend_ADD = 1,
		blend_SUBTRACT = 3,
		blend_MULTIPLY = 2,
		blend_DIVIDE = 4,
		blend_DIFFERENCE = 5,
		blend_MINIMUM = 6,
		blend_MAXIMUM = 7,
	};
	inline blend_enum blend(void);
	inline void blend(blend_enum value);
	inline float influence(void);
	inline void influence(float value);
	inline bool use(void);
	inline void use(bool value);
	inline bool expanded(void);
	inline void expanded(bool value);
	enum mapping_enum {
		mapping_LINEAR = 0,
		mapping_CURVE = 1,
	};
	inline mapping_enum mapping(void);
	inline void mapping(mapping_enum value);
	inline bool invert(void);
	inline void invert(bool value);
	inline CurveMapping curve(void);
	inline float thickness_min(void);
	inline void thickness_min(float value);
	inline float thickness_max(void);
	inline void thickness_max(float value);
	inline float curvature_min(void);
	inline void curvature_min(float value);
	inline float curvature_max(void);
	inline void curvature_max(float value);

};

/**************** Crease Angle ****************/

class LineStyleThicknessModifier_CreaseAngle : public LineStyleThicknessModifier {
public:
	LineStyleThicknessModifier_CreaseAngle(const PointerRNA &ptr_arg) :
		LineStyleThicknessModifier(ptr_arg)
		{}

	enum type_enum {
		type_ALONG_STROKE = 1,
		type_CALLIGRAPHY = 13,
		type_CREASE_ANGLE = 21,
		type_CURVATURE_3D = 23,
		type_DISTANCE_FROM_CAMERA = 2,
		type_DISTANCE_FROM_OBJECT = 3,
		type_MATERIAL = 4,
		type_NOISE = 20,
		type_TANGENT = 19,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	inline std::string name(void);
	inline void name(const std::string& value);
	enum blend_enum {
		blend_MIX = 0,
		blend_ADD = 1,
		blend_SUBTRACT = 3,
		blend_MULTIPLY = 2,
		blend_DIVIDE = 4,
		blend_DIFFERENCE = 5,
		blend_MINIMUM = 6,
		blend_MAXIMUM = 7,
	};
	inline blend_enum blend(void);
	inline void blend(blend_enum value);
	inline float influence(void);
	inline void influence(float value);
	inline bool use(void);
	inline void use(bool value);
	inline bool expanded(void);
	inline void expanded(bool value);
	enum mapping_enum {
		mapping_LINEAR = 0,
		mapping_CURVE = 1,
	};
	inline mapping_enum mapping(void);
	inline void mapping(mapping_enum value);
	inline bool invert(void);
	inline void invert(bool value);
	inline CurveMapping curve(void);
	inline float angle_min(void);
	inline void angle_min(float value);
	inline float angle_max(void);
	inline void angle_max(float value);
	inline float thickness_min(void);
	inline void thickness_min(float value);
	inline float thickness_max(void);
	inline void thickness_max(float value);

};

/**************** Line Style Geometry Modifier ****************/

class LineStyleGeometryModifier : public LineStyleModifier {
public:
	LineStyleGeometryModifier(const PointerRNA &ptr_arg) :
		LineStyleModifier(ptr_arg)
		{}


};

/**************** Sampling ****************/

class LineStyleGeometryModifier_Sampling : public LineStyleGeometryModifier {
public:
	LineStyleGeometryModifier_Sampling(const PointerRNA &ptr_arg) :
		LineStyleGeometryModifier(ptr_arg)
		{}

	enum type_enum {
		type_2D_OFFSET = 17,
		type_2D_TRANSFORM = 18,
		type_BACKBONE_STRETCHER = 11,
		type_BEZIER_CURVE = 6,
		type_BLUEPRINT = 16,
		type_GUIDING_LINES = 15,
		type_PERLIN_NOISE_1D = 9,
		type_PERLIN_NOISE_2D = 10,
		type_POLYGONIZATION = 14,
		type_SAMPLING = 5,
		type_SIMPLIFICATION = 22,
		type_SINUS_DISPLACEMENT = 7,
		type_SPATIAL_NOISE = 8,
		type_TIP_REMOVER = 12,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	inline std::string name(void);
	inline void name(const std::string& value);
	inline bool use(void);
	inline void use(bool value);
	inline bool expanded(void);
	inline void expanded(bool value);
	inline float sampling(void);
	inline void sampling(float value);

};

/**************** Bezier Curve ****************/

class LineStyleGeometryModifier_BezierCurve : public LineStyleGeometryModifier {
public:
	LineStyleGeometryModifier_BezierCurve(const PointerRNA &ptr_arg) :
		LineStyleGeometryModifier(ptr_arg)
		{}

	enum type_enum {
		type_2D_OFFSET = 17,
		type_2D_TRANSFORM = 18,
		type_BACKBONE_STRETCHER = 11,
		type_BEZIER_CURVE = 6,
		type_BLUEPRINT = 16,
		type_GUIDING_LINES = 15,
		type_PERLIN_NOISE_1D = 9,
		type_PERLIN_NOISE_2D = 10,
		type_POLYGONIZATION = 14,
		type_SAMPLING = 5,
		type_SIMPLIFICATION = 22,
		type_SINUS_DISPLACEMENT = 7,
		type_SPATIAL_NOISE = 8,
		type_TIP_REMOVER = 12,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	inline std::string name(void);
	inline void name(const std::string& value);
	inline bool use(void);
	inline void use(bool value);
	inline bool expanded(void);
	inline void expanded(bool value);
	inline float error(void);
	inline void error(float value);

};

/**************** Sinus Displacement ****************/

class LineStyleGeometryModifier_SinusDisplacement : public LineStyleGeometryModifier {
public:
	LineStyleGeometryModifier_SinusDisplacement(const PointerRNA &ptr_arg) :
		LineStyleGeometryModifier(ptr_arg)
		{}

	enum type_enum {
		type_2D_OFFSET = 17,
		type_2D_TRANSFORM = 18,
		type_BACKBONE_STRETCHER = 11,
		type_BEZIER_CURVE = 6,
		type_BLUEPRINT = 16,
		type_GUIDING_LINES = 15,
		type_PERLIN_NOISE_1D = 9,
		type_PERLIN_NOISE_2D = 10,
		type_POLYGONIZATION = 14,
		type_SAMPLING = 5,
		type_SIMPLIFICATION = 22,
		type_SINUS_DISPLACEMENT = 7,
		type_SPATIAL_NOISE = 8,
		type_TIP_REMOVER = 12,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	inline std::string name(void);
	inline void name(const std::string& value);
	inline bool use(void);
	inline void use(bool value);
	inline bool expanded(void);
	inline void expanded(bool value);
	inline float wavelength(void);
	inline void wavelength(float value);
	inline float amplitude(void);
	inline void amplitude(float value);
	inline float phase(void);
	inline void phase(float value);

};

/**************** Spatial Noise ****************/

class LineStyleGeometryModifier_SpatialNoise : public LineStyleGeometryModifier {
public:
	LineStyleGeometryModifier_SpatialNoise(const PointerRNA &ptr_arg) :
		LineStyleGeometryModifier(ptr_arg)
		{}

	enum type_enum {
		type_2D_OFFSET = 17,
		type_2D_TRANSFORM = 18,
		type_BACKBONE_STRETCHER = 11,
		type_BEZIER_CURVE = 6,
		type_BLUEPRINT = 16,
		type_GUIDING_LINES = 15,
		type_PERLIN_NOISE_1D = 9,
		type_PERLIN_NOISE_2D = 10,
		type_POLYGONIZATION = 14,
		type_SAMPLING = 5,
		type_SIMPLIFICATION = 22,
		type_SINUS_DISPLACEMENT = 7,
		type_SPATIAL_NOISE = 8,
		type_TIP_REMOVER = 12,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	inline std::string name(void);
	inline void name(const std::string& value);
	inline bool use(void);
	inline void use(bool value);
	inline bool expanded(void);
	inline void expanded(bool value);
	inline float amplitude(void);
	inline void amplitude(float value);
	inline float scale(void);
	inline void scale(float value);
	inline int octaves(void);
	inline void octaves(int value);
	inline bool smooth(void);
	inline void smooth(bool value);
	inline bool use_pure_random(void);
	inline void use_pure_random(bool value);

};

/**************** Perlin Noise 1D ****************/

class LineStyleGeometryModifier_PerlinNoise1D : public LineStyleGeometryModifier {
public:
	LineStyleGeometryModifier_PerlinNoise1D(const PointerRNA &ptr_arg) :
		LineStyleGeometryModifier(ptr_arg)
		{}

	enum type_enum {
		type_2D_OFFSET = 17,
		type_2D_TRANSFORM = 18,
		type_BACKBONE_STRETCHER = 11,
		type_BEZIER_CURVE = 6,
		type_BLUEPRINT = 16,
		type_GUIDING_LINES = 15,
		type_PERLIN_NOISE_1D = 9,
		type_PERLIN_NOISE_2D = 10,
		type_POLYGONIZATION = 14,
		type_SAMPLING = 5,
		type_SIMPLIFICATION = 22,
		type_SINUS_DISPLACEMENT = 7,
		type_SPATIAL_NOISE = 8,
		type_TIP_REMOVER = 12,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	inline std::string name(void);
	inline void name(const std::string& value);
	inline bool use(void);
	inline void use(bool value);
	inline bool expanded(void);
	inline void expanded(bool value);
	inline float frequency(void);
	inline void frequency(float value);
	inline float amplitude(void);
	inline void amplitude(float value);
	inline int octaves(void);
	inline void octaves(int value);
	inline float angle(void);
	inline void angle(float value);
	inline int seed(void);
	inline void seed(int value);

};

/**************** Perlin Noise 2D ****************/

class LineStyleGeometryModifier_PerlinNoise2D : public LineStyleGeometryModifier {
public:
	LineStyleGeometryModifier_PerlinNoise2D(const PointerRNA &ptr_arg) :
		LineStyleGeometryModifier(ptr_arg)
		{}

	enum type_enum {
		type_2D_OFFSET = 17,
		type_2D_TRANSFORM = 18,
		type_BACKBONE_STRETCHER = 11,
		type_BEZIER_CURVE = 6,
		type_BLUEPRINT = 16,
		type_GUIDING_LINES = 15,
		type_PERLIN_NOISE_1D = 9,
		type_PERLIN_NOISE_2D = 10,
		type_POLYGONIZATION = 14,
		type_SAMPLING = 5,
		type_SIMPLIFICATION = 22,
		type_SINUS_DISPLACEMENT = 7,
		type_SPATIAL_NOISE = 8,
		type_TIP_REMOVER = 12,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	inline std::string name(void);
	inline void name(const std::string& value);
	inline bool use(void);
	inline void use(bool value);
	inline bool expanded(void);
	inline void expanded(bool value);
	inline float frequency(void);
	inline void frequency(float value);
	inline float amplitude(void);
	inline void amplitude(float value);
	inline int octaves(void);
	inline void octaves(int value);
	inline float angle(void);
	inline void angle(float value);
	inline int seed(void);
	inline void seed(int value);

};

/**************** Backbone Stretcher ****************/

class LineStyleGeometryModifier_BackboneStretcher : public LineStyleGeometryModifier {
public:
	LineStyleGeometryModifier_BackboneStretcher(const PointerRNA &ptr_arg) :
		LineStyleGeometryModifier(ptr_arg)
		{}

	enum type_enum {
		type_2D_OFFSET = 17,
		type_2D_TRANSFORM = 18,
		type_BACKBONE_STRETCHER = 11,
		type_BEZIER_CURVE = 6,
		type_BLUEPRINT = 16,
		type_GUIDING_LINES = 15,
		type_PERLIN_NOISE_1D = 9,
		type_PERLIN_NOISE_2D = 10,
		type_POLYGONIZATION = 14,
		type_SAMPLING = 5,
		type_SIMPLIFICATION = 22,
		type_SINUS_DISPLACEMENT = 7,
		type_SPATIAL_NOISE = 8,
		type_TIP_REMOVER = 12,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	inline std::string name(void);
	inline void name(const std::string& value);
	inline bool use(void);
	inline void use(bool value);
	inline bool expanded(void);
	inline void expanded(bool value);
	inline float backbone_length(void);
	inline void backbone_length(float value);

};

/**************** Tip Remover ****************/

class LineStyleGeometryModifier_TipRemover : public LineStyleGeometryModifier {
public:
	LineStyleGeometryModifier_TipRemover(const PointerRNA &ptr_arg) :
		LineStyleGeometryModifier(ptr_arg)
		{}

	enum type_enum {
		type_2D_OFFSET = 17,
		type_2D_TRANSFORM = 18,
		type_BACKBONE_STRETCHER = 11,
		type_BEZIER_CURVE = 6,
		type_BLUEPRINT = 16,
		type_GUIDING_LINES = 15,
		type_PERLIN_NOISE_1D = 9,
		type_PERLIN_NOISE_2D = 10,
		type_POLYGONIZATION = 14,
		type_SAMPLING = 5,
		type_SIMPLIFICATION = 22,
		type_SINUS_DISPLACEMENT = 7,
		type_SPATIAL_NOISE = 8,
		type_TIP_REMOVER = 12,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	inline std::string name(void);
	inline void name(const std::string& value);
	inline bool use(void);
	inline void use(bool value);
	inline bool expanded(void);
	inline void expanded(bool value);
	inline float tip_length(void);
	inline void tip_length(float value);

};

/**************** Polygonalization ****************/

class LineStyleGeometryModifier_Polygonalization : public LineStyleGeometryModifier {
public:
	LineStyleGeometryModifier_Polygonalization(const PointerRNA &ptr_arg) :
		LineStyleGeometryModifier(ptr_arg)
		{}

	enum type_enum {
		type_2D_OFFSET = 17,
		type_2D_TRANSFORM = 18,
		type_BACKBONE_STRETCHER = 11,
		type_BEZIER_CURVE = 6,
		type_BLUEPRINT = 16,
		type_GUIDING_LINES = 15,
		type_PERLIN_NOISE_1D = 9,
		type_PERLIN_NOISE_2D = 10,
		type_POLYGONIZATION = 14,
		type_SAMPLING = 5,
		type_SIMPLIFICATION = 22,
		type_SINUS_DISPLACEMENT = 7,
		type_SPATIAL_NOISE = 8,
		type_TIP_REMOVER = 12,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	inline std::string name(void);
	inline void name(const std::string& value);
	inline bool use(void);
	inline void use(bool value);
	inline bool expanded(void);
	inline void expanded(bool value);
	inline float error(void);
	inline void error(float value);

};

/**************** Guiding Lines ****************/

class LineStyleGeometryModifier_GuidingLines : public LineStyleGeometryModifier {
public:
	LineStyleGeometryModifier_GuidingLines(const PointerRNA &ptr_arg) :
		LineStyleGeometryModifier(ptr_arg)
		{}

	enum type_enum {
		type_2D_OFFSET = 17,
		type_2D_TRANSFORM = 18,
		type_BACKBONE_STRETCHER = 11,
		type_BEZIER_CURVE = 6,
		type_BLUEPRINT = 16,
		type_GUIDING_LINES = 15,
		type_PERLIN_NOISE_1D = 9,
		type_PERLIN_NOISE_2D = 10,
		type_POLYGONIZATION = 14,
		type_SAMPLING = 5,
		type_SIMPLIFICATION = 22,
		type_SINUS_DISPLACEMENT = 7,
		type_SPATIAL_NOISE = 8,
		type_TIP_REMOVER = 12,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	inline std::string name(void);
	inline void name(const std::string& value);
	inline bool use(void);
	inline void use(bool value);
	inline bool expanded(void);
	inline void expanded(bool value);
	inline float offset(void);
	inline void offset(float value);

};

/**************** Blueprint ****************/

class LineStyleGeometryModifier_Blueprint : public LineStyleGeometryModifier {
public:
	LineStyleGeometryModifier_Blueprint(const PointerRNA &ptr_arg) :
		LineStyleGeometryModifier(ptr_arg)
		{}

	enum type_enum {
		type_2D_OFFSET = 17,
		type_2D_TRANSFORM = 18,
		type_BACKBONE_STRETCHER = 11,
		type_BEZIER_CURVE = 6,
		type_BLUEPRINT = 16,
		type_GUIDING_LINES = 15,
		type_PERLIN_NOISE_1D = 9,
		type_PERLIN_NOISE_2D = 10,
		type_POLYGONIZATION = 14,
		type_SAMPLING = 5,
		type_SIMPLIFICATION = 22,
		type_SINUS_DISPLACEMENT = 7,
		type_SPATIAL_NOISE = 8,
		type_TIP_REMOVER = 12,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	inline std::string name(void);
	inline void name(const std::string& value);
	inline bool use(void);
	inline void use(bool value);
	inline bool expanded(void);
	inline void expanded(bool value);
	enum shape_enum {
		shape_CIRCLES = 1,
		shape_ELLIPSES = 2,
		shape_SQUARES = 4,
	};
	inline shape_enum shape(void);
	inline void shape(shape_enum value);
	inline int rounds(void);
	inline void rounds(int value);
	inline float backbone_length(void);
	inline void backbone_length(float value);
	inline int random_radius(void);
	inline void random_radius(int value);
	inline int random_center(void);
	inline void random_center(int value);
	inline int random_backbone(void);
	inline void random_backbone(int value);

};

/**************** 2D Offset ****************/

class LineStyleGeometryModifier_2DOffset : public LineStyleGeometryModifier {
public:
	LineStyleGeometryModifier_2DOffset(const PointerRNA &ptr_arg) :
		LineStyleGeometryModifier(ptr_arg)
		{}

	enum type_enum {
		type_2D_OFFSET = 17,
		type_2D_TRANSFORM = 18,
		type_BACKBONE_STRETCHER = 11,
		type_BEZIER_CURVE = 6,
		type_BLUEPRINT = 16,
		type_GUIDING_LINES = 15,
		type_PERLIN_NOISE_1D = 9,
		type_PERLIN_NOISE_2D = 10,
		type_POLYGONIZATION = 14,
		type_SAMPLING = 5,
		type_SIMPLIFICATION = 22,
		type_SINUS_DISPLACEMENT = 7,
		type_SPATIAL_NOISE = 8,
		type_TIP_REMOVER = 12,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	inline std::string name(void);
	inline void name(const std::string& value);
	inline bool use(void);
	inline void use(bool value);
	inline bool expanded(void);
	inline void expanded(bool value);
	inline float start(void);
	inline void start(float value);
	inline float end(void);
	inline void end(float value);
	inline float x(void);
	inline void x(float value);
	inline float y(void);
	inline void y(float value);

};

/**************** 2D Transform ****************/

class LineStyleGeometryModifier_2DTransform : public LineStyleGeometryModifier {
public:
	LineStyleGeometryModifier_2DTransform(const PointerRNA &ptr_arg) :
		LineStyleGeometryModifier(ptr_arg)
		{}

	enum type_enum {
		type_2D_OFFSET = 17,
		type_2D_TRANSFORM = 18,
		type_BACKBONE_STRETCHER = 11,
		type_BEZIER_CURVE = 6,
		type_BLUEPRINT = 16,
		type_GUIDING_LINES = 15,
		type_PERLIN_NOISE_1D = 9,
		type_PERLIN_NOISE_2D = 10,
		type_POLYGONIZATION = 14,
		type_SAMPLING = 5,
		type_SIMPLIFICATION = 22,
		type_SINUS_DISPLACEMENT = 7,
		type_SPATIAL_NOISE = 8,
		type_TIP_REMOVER = 12,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	inline std::string name(void);
	inline void name(const std::string& value);
	inline bool use(void);
	inline void use(bool value);
	inline bool expanded(void);
	inline void expanded(bool value);
	enum pivot_enum {
		pivot_CENTER = 1,
		pivot_START = 2,
		pivot_END = 3,
		pivot_PARAM = 4,
		pivot_ABSOLUTE = 5,
	};
	inline pivot_enum pivot(void);
	inline void pivot(pivot_enum value);
	inline float scale_x(void);
	inline void scale_x(float value);
	inline float scale_y(void);
	inline void scale_y(float value);
	inline float angle(void);
	inline void angle(float value);
	inline float pivot_u(void);
	inline void pivot_u(float value);
	inline float pivot_x(void);
	inline void pivot_x(float value);
	inline float pivot_y(void);
	inline void pivot_y(float value);

};

/**************** Simplification ****************/

class LineStyleGeometryModifier_Simplification : public LineStyleGeometryModifier {
public:
	LineStyleGeometryModifier_Simplification(const PointerRNA &ptr_arg) :
		LineStyleGeometryModifier(ptr_arg)
		{}

	enum type_enum {
		type_2D_OFFSET = 17,
		type_2D_TRANSFORM = 18,
		type_BACKBONE_STRETCHER = 11,
		type_BEZIER_CURVE = 6,
		type_BLUEPRINT = 16,
		type_GUIDING_LINES = 15,
		type_PERLIN_NOISE_1D = 9,
		type_PERLIN_NOISE_2D = 10,
		type_POLYGONIZATION = 14,
		type_SAMPLING = 5,
		type_SIMPLIFICATION = 22,
		type_SINUS_DISPLACEMENT = 7,
		type_SPATIAL_NOISE = 8,
		type_TIP_REMOVER = 12,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	inline std::string name(void);
	inline void name(const std::string& value);
	inline bool use(void);
	inline void use(bool value);
	inline bool expanded(void);
	inline void expanded(bool value);
	inline float tolerance(void);
	inline void tolerance(float value);

};

/**************** Freestyle Line Style ****************/

class FreestyleLineStyle : public ID {
public:
	FreestyleLineStyle(const PointerRNA &ptr_arg) :
		ID(ptr_arg),
		texture_slots(ptr_arg),
		color_modifiers(ptr_arg),
		alpha_modifiers(ptr_arg),
		thickness_modifiers(ptr_arg),
		geometry_modifiers(ptr_arg)
		{}

	COLLECTION_PROPERTY(LineStyleTextureSlots, LineStyleTextureSlot, FreestyleLineStyle, texture_slots, false, false, false)
	inline Texture active_texture(void);
	inline int active_texture_index(void);
	inline void active_texture_index(int value);
	enum panel_enum {
		panel_STROKES = 1,
		panel_COLOR = 2,
		panel_ALPHA = 3,
		panel_THICKNESS = 4,
		panel_GEOMETRY = 5,
		panel_TEXTURE = 6,
	};
	inline panel_enum panel(void);
	inline void panel(panel_enum value);
	inline Array<float, 3> color(void);
	inline void color(float values[3]);
	inline float alpha(void);
	inline void alpha(float value);
	inline float thickness(void);
	inline void thickness(float value);
	enum thickness_position_enum {
		thickness_position_CENTER = 1,
		thickness_position_INSIDE = 2,
		thickness_position_OUTSIDE = 3,
		thickness_position_RELATIVE = 4,
	};
	inline thickness_position_enum thickness_position(void);
	inline void thickness_position(thickness_position_enum value);
	inline float thickness_ratio(void);
	inline void thickness_ratio(float value);
	COLLECTION_PROPERTY(LineStyleColorModifiers, LineStyleColorModifier, FreestyleLineStyle, color_modifiers, false, true, false)
	COLLECTION_PROPERTY(LineStyleAlphaModifiers, LineStyleAlphaModifier, FreestyleLineStyle, alpha_modifiers, false, true, false)
	COLLECTION_PROPERTY(LineStyleThicknessModifiers, LineStyleThicknessModifier, FreestyleLineStyle, thickness_modifiers, false, true, false)
	COLLECTION_PROPERTY(LineStyleGeometryModifiers, LineStyleGeometryModifier, FreestyleLineStyle, geometry_modifiers, false, true, false)
	inline bool use_chaining(void);
	inline void use_chaining(bool value);
	enum chaining_enum {
		chaining_PLAIN = 1,
		chaining_SKETCHY = 2,
	};
	inline chaining_enum chaining(void);
	inline void chaining(chaining_enum value);
	inline int rounds(void);
	inline void rounds(int value);
	inline bool use_same_object(void);
	inline void use_same_object(bool value);
	inline bool use_split_length(void);
	inline void use_split_length(bool value);
	inline float split_length(void);
	inline void split_length(float value);
	inline bool use_angle_min(void);
	inline void use_angle_min(bool value);
	inline float angle_min(void);
	inline void angle_min(float value);
	inline bool use_angle_max(void);
	inline void use_angle_max(bool value);
	inline float angle_max(void);
	inline void angle_max(float value);
	inline bool use_length_min(void);
	inline void use_length_min(bool value);
	inline float length_min(void);
	inline void length_min(float value);
	inline bool use_length_max(void);
	inline void use_length_max(bool value);
	inline float length_max(void);
	inline void length_max(float value);
	inline bool use_chain_count(void);
	inline void use_chain_count(bool value);
	inline int chain_count(void);
	inline void chain_count(int value);
	inline bool use_split_pattern(void);
	inline void use_split_pattern(bool value);
	inline int split_dash1(void);
	inline void split_dash1(int value);
	inline int split_gap1(void);
	inline void split_gap1(int value);
	inline int split_dash2(void);
	inline void split_dash2(int value);
	inline int split_gap2(void);
	inline void split_gap2(int value);
	inline int split_dash3(void);
	inline void split_dash3(int value);
	inline int split_gap3(void);
	inline void split_gap3(int value);
	inline bool material_boundary(void);
	inline void material_boundary(bool value);
	inline bool use_sorting(void);
	inline void use_sorting(bool value);
	enum sort_key_enum {
		sort_key_DISTANCE_FROM_CAMERA = 1,
		sort_key_2D_LENGTH = 2,
		sort_key_PROJECTED_X = 3,
		sort_key_PROJECTED_Y = 4,
	};
	inline sort_key_enum sort_key(void);
	inline void sort_key(sort_key_enum value);
	enum sort_order_enum {
		sort_order_DEFAULT = 0,
		sort_order_REVERSE = 4096,
	};
	inline sort_order_enum sort_order(void);
	inline void sort_order(sort_order_enum value);
	enum integration_type_enum {
		integration_type_MEAN = 1,
		integration_type_MIN = 2,
		integration_type_MAX = 3,
		integration_type_FIRST = 4,
		integration_type_LAST = 5,
	};
	inline integration_type_enum integration_type(void);
	inline void integration_type(integration_type_enum value);
	inline bool use_dashed_line(void);
	inline void use_dashed_line(bool value);
	enum caps_enum {
		caps_BUTT = 1,
		caps_ROUND = 2,
		caps_SQUARE = 3,
	};
	inline caps_enum caps(void);
	inline void caps(caps_enum value);
	inline int dash1(void);
	inline void dash1(int value);
	inline int gap1(void);
	inline void gap1(int value);
	inline int dash2(void);
	inline void dash2(int value);
	inline int gap2(void);
	inline void gap2(int value);
	inline int dash3(void);
	inline void dash3(int value);
	inline int gap3(void);
	inline void gap3(int value);
	inline bool use_texture(void);
	inline void use_texture(bool value);
	inline float texture_spacing(void);
	inline void texture_spacing(float value);
	inline AnimData animation_data(void);
	inline NodeTree node_tree(void);
	inline bool use_nodes(void);
	inline void use_nodes(bool value);

};

/**************** LineStyle Texture Slot ****************/

class LineStyleTextureSlot : public TextureSlot {
public:
	LineStyleTextureSlot(const PointerRNA &ptr_arg) :
		TextureSlot(ptr_arg)
		{}

	enum mapping_x_enum {
		mapping_x_NONE = 0,
		mapping_x_X = 1,
		mapping_x_Y = 2,
		mapping_x_Z = 3,
	};
	inline mapping_x_enum mapping_x(void);
	inline void mapping_x(mapping_x_enum value);
	enum mapping_y_enum {
		mapping_y_NONE = 0,
		mapping_y_X = 1,
		mapping_y_Y = 2,
		mapping_y_Z = 3,
	};
	inline mapping_y_enum mapping_y(void);
	inline void mapping_y(mapping_y_enum value);
	enum mapping_z_enum {
		mapping_z_NONE = 0,
		mapping_z_X = 1,
		mapping_z_Y = 2,
		mapping_z_Z = 3,
	};
	inline mapping_z_enum mapping_z(void);
	inline void mapping_z(mapping_z_enum value);
	enum mapping_enum {
		mapping_FLAT = 0,
		mapping_CUBE = 1,
		mapping_TUBE = 2,
		mapping_SPHERE = 3,
	};
	inline mapping_enum mapping(void);
	inline void mapping(mapping_enum value);
	inline bool use_map_color_diffuse(void);
	inline void use_map_color_diffuse(bool value);
	inline bool use_map_alpha(void);
	inline void use_map_alpha(bool value);
	enum texture_coords_enum {
		texture_coords_WINDOW = 1024,
		texture_coords_GLOBAL = 8,
		texture_coords_ALONG_STROKE = 16,
		texture_coords_ORCO = 1,
	};
	inline texture_coords_enum texture_coords(void);
	inline void texture_coords(texture_coords_enum value);
	inline float alpha_factor(void);
	inline void alpha_factor(float value);
	inline float diffuse_color_factor(void);
	inline void diffuse_color_factor(float value);

};

/**************** Blendfile Data ****************/

class BlendData : public Pointer {
public:
	BlendData(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		cameras(ptr_arg),
		scenes(ptr_arg),
		objects(ptr_arg),
		materials(ptr_arg),
		node_groups(ptr_arg),
		meshes(ptr_arg),
		lights(ptr_arg),
		libraries(ptr_arg),
		screens(ptr_arg),
		window_managers(ptr_arg),
		images(ptr_arg),
		lattices(ptr_arg),
		curves(ptr_arg),
		metaballs(ptr_arg),
		fonts(ptr_arg),
		textures(ptr_arg),
		brushes(ptr_arg),
		worlds(ptr_arg),
		collections(ptr_arg),
		shape_keys(ptr_arg),
		texts(ptr_arg),
		speakers(ptr_arg),
		sounds(ptr_arg),
		armatures(ptr_arg),
		actions(ptr_arg),
		particles(ptr_arg),
		palettes(ptr_arg),
		grease_pencils(ptr_arg),
		movieclips(ptr_arg),
		masks(ptr_arg),
		linestyles(ptr_arg),
		cache_files(ptr_arg),
		paint_curves(ptr_arg),
		workspaces(ptr_arg),
		lightprobes(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string filepath(void);
	inline void filepath(const std::string& value);
	inline bool is_dirty(void);
	inline void is_dirty(bool value);
	inline bool is_saved(void);
	inline void is_saved(bool value);
	inline bool use_autopack(void);
	inline void use_autopack(bool value);
	inline Array<int, 3> version(void);
	inline void version(int values[3]);
	COLLECTION_PROPERTY(BlendDataCameras, Camera, BlendData, cameras, false, false, false)
	COLLECTION_PROPERTY(BlendDataScenes, Scene, BlendData, scenes, false, false, false)
	COLLECTION_PROPERTY(BlendDataObjects, Object, BlendData, objects, false, false, false)
	COLLECTION_PROPERTY(BlendDataMaterials, Material, BlendData, materials, false, false, false)
	COLLECTION_PROPERTY(BlendDataNodeTrees, NodeTree, BlendData, node_groups, false, false, false)
	COLLECTION_PROPERTY(BlendDataMeshes, Mesh, BlendData, meshes, false, false, false)
	COLLECTION_PROPERTY(BlendDataLights, Light, BlendData, lights, false, false, false)
	COLLECTION_PROPERTY(BlendDataLibraries, Library, BlendData, libraries, false, false, false)
	COLLECTION_PROPERTY(BlendDataScreens, Screen, BlendData, screens, false, false, false)
	COLLECTION_PROPERTY(BlendDataWindowManagers, WindowManager, BlendData, window_managers, false, false, false)
	COLLECTION_PROPERTY(BlendDataImages, Image, BlendData, images, false, false, false)
	COLLECTION_PROPERTY(BlendDataLattices, Lattice, BlendData, lattices, false, false, false)
	COLLECTION_PROPERTY(BlendDataCurves, Curve, BlendData, curves, false, false, false)
	COLLECTION_PROPERTY(BlendDataMetaBalls, MetaBall, BlendData, metaballs, false, false, false)
	COLLECTION_PROPERTY(BlendDataFonts, VectorFont, BlendData, fonts, false, false, false)
	COLLECTION_PROPERTY(BlendDataTextures, Texture, BlendData, textures, false, false, false)
	COLLECTION_PROPERTY(BlendDataBrushes, Brush, BlendData, brushes, false, false, false)
	COLLECTION_PROPERTY(BlendDataWorlds, World, BlendData, worlds, false, false, false)
	COLLECTION_PROPERTY(BlendDataCollections, Collection, BlendData, collections, false, false, false)
	COLLECTION_PROPERTY(DefaultCollectionFunctions, Key, BlendData, shape_keys, false, false, false)
	COLLECTION_PROPERTY(BlendDataTexts, Text, BlendData, texts, false, false, false)
	COLLECTION_PROPERTY(BlendDataSpeakers, Speaker, BlendData, speakers, false, false, false)
	COLLECTION_PROPERTY(BlendDataSounds, Sound, BlendData, sounds, false, false, false)
	COLLECTION_PROPERTY(BlendDataArmatures, Armature, BlendData, armatures, false, false, false)
	COLLECTION_PROPERTY(BlendDataActions, Action, BlendData, actions, false, false, false)
	COLLECTION_PROPERTY(BlendDataParticles, ParticleSettings, BlendData, particles, false, false, false)
	COLLECTION_PROPERTY(BlendDataPalettes, Palette, BlendData, palettes, false, false, false)
	COLLECTION_PROPERTY(BlendDataGreasePencils, GreasePencil, BlendData, grease_pencils, false, false, false)
	COLLECTION_PROPERTY(BlendDataMovieClips, MovieClip, BlendData, movieclips, false, false, false)
	COLLECTION_PROPERTY(BlendDataMasks, Mask, BlendData, masks, false, false, false)
	COLLECTION_PROPERTY(BlendDataLineStyles, FreestyleLineStyle, BlendData, linestyles, false, false, false)
	COLLECTION_PROPERTY(BlendDataCacheFiles, CacheFile, BlendData, cache_files, false, false, false)
	COLLECTION_PROPERTY(BlendDataPaintCurves, PaintCurve, BlendData, paint_curves, false, false, false)
	COLLECTION_PROPERTY(BlendDataWorkSpaces, WorkSpace, BlendData, workspaces, false, false, false)
	COLLECTION_PROPERTY(BlendDataProbes, LightProbe, BlendData, lightprobes, false, false, false)

};

/**************** Material ****************/

class Material : public ID {
public:
	Material(const PointerRNA &ptr_arg) :
		ID(ptr_arg),
		texture_paint_images(ptr_arg),
		texture_paint_slots(ptr_arg)
		{}

	enum blend_method_enum {
		blend_method_OPAQUE = 0,
		blend_method_ADD = 1,
		blend_method_MULTIPLY = 2,
		blend_method_CLIP = 3,
		blend_method_HASHED = 4,
		blend_method_BLEND = 5,
	};
	inline blend_method_enum blend_method(void);
	inline void blend_method(blend_method_enum value);
	enum shadow_method_enum {
		shadow_method_NONE = 0,
		shadow_method_OPAQUE = 1,
		shadow_method_CLIP = 2,
		shadow_method_HASHED = 3,
	};
	inline shadow_method_enum shadow_method(void);
	inline void shadow_method(shadow_method_enum value);
	inline float alpha_threshold(void);
	inline void alpha_threshold(float value);
	inline bool show_transparent_back(void);
	inline void show_transparent_back(bool value);
	inline bool use_screen_refraction(void);
	inline void use_screen_refraction(bool value);
	inline bool use_sss_translucency(void);
	inline void use_sss_translucency(bool value);
	inline float refraction_depth(void);
	inline void refraction_depth(float value);
	enum preview_render_type_enum {
		preview_render_type_FLAT = 0,
		preview_render_type_SPHERE = 1,
		preview_render_type_CUBE = 2,
		preview_render_type_MONKEY = 3,
		preview_render_type_HAIR = 10,
		preview_render_type_SPHERE_A = 4,
	};
	inline preview_render_type_enum preview_render_type(void);
	inline void preview_render_type(preview_render_type_enum value);
	inline int pass_index(void);
	inline void pass_index(int value);
	inline NodeTree node_tree(void);
	inline bool use_nodes(void);
	inline void use_nodes(bool value);
	inline AnimData animation_data(void);
	COLLECTION_PROPERTY(DefaultCollectionFunctions, Image, Material, texture_paint_images, false, true, true)
	COLLECTION_PROPERTY(DefaultCollectionFunctions, TexPaintSlot, Material, texture_paint_slots, false, false, false)
	inline int paint_active_slot(void);
	inline void paint_active_slot(int value);
	inline int paint_clone_slot(void);
	inline void paint_clone_slot(int value);
	inline Array<float, 4> diffuse_color(void);
	inline void diffuse_color(float values[4]);
	inline Array<float, 3> specular_color(void);
	inline void specular_color(float values[3]);
	inline float roughness(void);
	inline void roughness(float value);
	inline float specular_intensity(void);
	inline void specular_intensity(float value);
	inline float metallic(void);
	inline void metallic(float value);
	inline Array<float, 4> line_color(void);
	inline void line_color(float values[4]);
	inline int line_priority(void);
	inline void line_priority(int value);
	inline MaterialGPencilStyle grease_pencil(void);
	inline bool is_grease_pencil(void);
	inline void is_grease_pencil(bool value);

};

/**************** Texture Paint Slot ****************/

class TexPaintSlot : public Pointer {
public:
	TexPaintSlot(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string uv_layer(void);
	inline void uv_layer(const std::string& value);
	inline bool is_valid(void);
	inline void is_valid(bool value);

};

/**************** Grease Pencil Color ****************/

class MaterialGPencilStyle : public Pointer {
public:
	MaterialGPencilStyle(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline Array<float, 4> color(void);
	inline void color(float values[4]);
	inline Array<float, 4> fill_color(void);
	inline void fill_color(float values[4]);
	inline Array<float, 4> mix_color(void);
	inline void mix_color(float values[4]);
	inline float mix_factor(void);
	inline void mix_factor(float value);
	inline Array<float, 2> pattern_scale(void);
	inline void pattern_scale(float values[2]);
	inline Array<float, 2> pattern_shift(void);
	inline void pattern_shift(float values[2]);
	inline float pattern_angle(void);
	inline void pattern_angle(float value);
	inline float pattern_radius(void);
	inline void pattern_radius(float value);
	inline float pattern_gridsize(void);
	inline void pattern_gridsize(float value);
	inline float texture_angle(void);
	inline void texture_angle(float value);
	inline Array<float, 2> texture_scale(void);
	inline void texture_scale(float values[2]);
	inline Array<float, 2> texture_offset(void);
	inline void texture_offset(float values[2]);
	inline float texture_opacity(void);
	inline void texture_opacity(float value);
	inline float pixel_size(void);
	inline void pixel_size(float value);
	inline bool hide(void);
	inline void hide(bool value);
	inline bool lock(void);
	inline void lock(bool value);
	inline bool ghost(void);
	inline void ghost(bool value);
	inline bool texture_clamp(void);
	inline void texture_clamp(bool value);
	inline bool texture_mix(void);
	inline void texture_mix(bool value);
	inline bool flip(void);
	inline void flip(bool value);
	inline bool use_stroke_pattern(void);
	inline void use_stroke_pattern(bool value);
	inline bool use_fill_pattern(void);
	inline void use_fill_pattern(bool value);
	inline bool show_stroke(void);
	inline void show_stroke(bool value);
	inline bool show_fill(void);
	inline void show_fill(bool value);
	inline int pass_index(void);
	inline void pass_index(int value);
	enum mode_enum {
		mode_LINE = 0,
		mode_DOTS = 1,
		mode_BOX = 2,
	};
	inline mode_enum mode(void);
	inline void mode(mode_enum value);
	enum stroke_style_enum {
		stroke_style_SOLID = 0,
		stroke_style_TEXTURE = 1,
	};
	inline stroke_style_enum stroke_style(void);
	inline void stroke_style(stroke_style_enum value);
	inline Image stroke_image(void);
	enum fill_style_enum {
		fill_style_SOLID = 0,
		fill_style_GRADIENT = 1,
		fill_style_CHESSBOARD = 2,
		fill_style_TEXTURE = 3,
	};
	inline fill_style_enum fill_style(void);
	inline void fill_style(fill_style_enum value);
	enum gradient_type_enum {
		gradient_type_LINEAR = 0,
		gradient_type_RADIAL = 1,
	};
	inline gradient_type_enum gradient_type(void);
	inline void gradient_type(gradient_type_enum value);
	inline Image fill_image(void);
	inline bool is_stroke_visible(void);
	inline void is_stroke_visible(bool value);
	inline bool is_fill_visible(void);
	inline void is_fill_visible(bool value);

};

/**************** Mesh ****************/

class Mesh : public ID {
public:
	Mesh(const PointerRNA &ptr_arg) :
		ID(ptr_arg),
		vertices(ptr_arg),
		edges(ptr_arg),
		loops(ptr_arg),
		polygons(ptr_arg),
		loop_triangles(ptr_arg),
		uv_layers(ptr_arg),
		vertex_colors(ptr_arg),
		vertex_layers_float(ptr_arg),
		vertex_layers_int(ptr_arg),
		vertex_layers_string(ptr_arg),
		polygon_layers_float(ptr_arg),
		polygon_layers_int(ptr_arg),
		polygon_layers_string(ptr_arg),
		face_maps(ptr_arg),
		skin_vertices(ptr_arg),
		vertex_paint_masks(ptr_arg),
		materials(ptr_arg)
		{}

	COLLECTION_PROPERTY(MeshVertices, MeshVertex, Mesh, vertices, true, true, false)
	COLLECTION_PROPERTY(MeshEdges, MeshEdge, Mesh, edges, true, true, false)
	COLLECTION_PROPERTY(MeshLoops, MeshLoop, Mesh, loops, true, true, false)
	COLLECTION_PROPERTY(MeshPolygons, MeshPolygon, Mesh, polygons, true, true, false)
	COLLECTION_PROPERTY(MeshLoopTriangle, MeshLoopTriangle, Mesh, loop_triangles, true, true, false)
	inline Mesh texture_mesh(void);
	COLLECTION_PROPERTY(UVLoopLayers, MeshUVLoopLayer, Mesh, uv_layers, true, true, true)
	inline MeshUVLoopLayer uv_layer_clone(void);
	inline int uv_layer_clone_index(void);
	inline void uv_layer_clone_index(int value);
	inline MeshUVLoopLayer uv_layer_stencil(void);
	inline int uv_layer_stencil_index(void);
	inline void uv_layer_stencil_index(int value);
	COLLECTION_PROPERTY(LoopColors, MeshLoopColorLayer, Mesh, vertex_colors, true, true, true)
	COLLECTION_PROPERTY(VertexFloatProperties, MeshVertexFloatPropertyLayer, Mesh, vertex_layers_float, true, true, true)
	COLLECTION_PROPERTY(VertexIntProperties, MeshVertexIntPropertyLayer, Mesh, vertex_layers_int, true, true, true)
	COLLECTION_PROPERTY(VertexStringProperties, MeshVertexStringPropertyLayer, Mesh, vertex_layers_string, true, true, true)
	COLLECTION_PROPERTY(PolygonFloatProperties, MeshPolygonFloatPropertyLayer, Mesh, polygon_layers_float, true, true, true)
	COLLECTION_PROPERTY(PolygonIntProperties, MeshPolygonIntPropertyLayer, Mesh, polygon_layers_int, true, true, true)
	COLLECTION_PROPERTY(PolygonStringProperties, MeshPolygonStringPropertyLayer, Mesh, polygon_layers_string, true, true, true)
	COLLECTION_PROPERTY(MeshFaceMapLayers, MeshFaceMapLayer, Mesh, face_maps, true, true, true)
	COLLECTION_PROPERTY(DefaultCollectionFunctions, MeshSkinVertexLayer, Mesh, skin_vertices, true, true, true)
	COLLECTION_PROPERTY(DefaultCollectionFunctions, MeshPaintMaskLayer, Mesh, vertex_paint_masks, true, true, false)
	inline bool use_auto_smooth(void);
	inline void use_auto_smooth(bool value);
	inline float auto_smooth_angle(void);
	inline void auto_smooth_angle(float value);
	inline bool has_custom_normals(void);
	inline void has_custom_normals(bool value);
	inline bool show_double_sided(void);
	inline void show_double_sided(bool value);
	inline Mesh texco_mesh(void);
	inline Key shape_keys(void);
	inline bool use_auto_texspace(void);
	inline void use_auto_texspace(bool value);
	inline bool use_mirror_x(void);
	inline void use_mirror_x(bool value);
	inline bool use_mirror_topology(void);
	inline void use_mirror_topology(bool value);
	inline bool use_paint_mask(void);
	inline void use_paint_mask(bool value);
	inline bool use_paint_mask_vertex(void);
	inline void use_paint_mask_vertex(bool value);
	inline bool use_customdata_vertex_bevel(void);
	inline void use_customdata_vertex_bevel(bool value);
	inline bool use_customdata_edge_bevel(void);
	inline void use_customdata_edge_bevel(bool value);
	inline bool use_customdata_edge_crease(void);
	inline void use_customdata_edge_crease(bool value);
	inline int total_vert_sel(void);
	inline void total_vert_sel(int value);
	inline int total_edge_sel(void);
	inline void total_edge_sel(int value);
	inline int total_face_sel(void);
	inline void total_face_sel(int value);
	inline bool is_editmode(void);
	inline void is_editmode(bool value);
	inline AnimData animation_data(void);
	inline bool auto_texspace(void);
	inline void auto_texspace(bool value);
	inline Array<float, 3> texspace_location(void);
	inline void texspace_location(float values[3]);
	inline Array<float, 3> texspace_size(void);
	inline void texspace_size(float values[3]);
	COLLECTION_PROPERTY(IDMaterials, Material, Mesh, materials, true, true, true)

	inline void transform(float matrix[16], bool shape_keys);
	inline void flip_normals();
	inline void calc_normals();
	inline void create_normals_split();
	inline void calc_normals_split();
	inline void free_normals_split();
	inline void split_faces(bool free_loop_normals);
	inline void calc_tangents(const char * uvmap);
	inline void free_tangents();
	inline void calc_loop_triangles();
	inline void calc_smooth_groups(bool use_bitflags, int *poly_groups_len, int **poly_groups, int *groups);
	inline void normals_split_custom_set(int normals_len, float *normals);
	inline void normals_split_custom_set_from_vertices(int normals_len, float *normals);
	inline void update(Context C, bool calc_edges, bool calc_edges_loose, bool calc_loop_triangles);
	inline void update_gpu_tag();
	inline const char * unit_test_compare(Mesh& mesh);
	inline bool validate(bool verbose, bool clean_customdata);
	inline bool validate_material_indices();
	inline void count_selected_items(int result[3]);
};

/**************** Mesh Loop Triangles ****************/

class MeshLoopTriangles : public Pointer {
public:
	MeshLoopTriangles(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

};

/**************** Mesh Skin Vertex Layer ****************/

class MeshSkinVertexLayer : public Pointer {
public:
	MeshSkinVertexLayer(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		data(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string name(void);
	inline void name(const std::string& value);
	COLLECTION_PROPERTY(DefaultCollectionFunctions, MeshSkinVertex, MeshSkinVertexLayer, data, true, true, false)

};

/**************** Skin Vertex ****************/

class MeshSkinVertex : public Pointer {
public:
	MeshSkinVertex(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline Array<float, 2> radius(void);
	inline void radius(float values[2]);
	inline bool use_root(void);
	inline void use_root(bool value);
	inline bool use_loose(void);
	inline void use_loose(bool value);

};

/**************** Mesh Paint Mask Layer ****************/

class MeshPaintMaskLayer : public Pointer {
public:
	MeshPaintMaskLayer(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		data(ptr_arg)
		{}

	inline Struct rna_type(void);
	COLLECTION_PROPERTY(DefaultCollectionFunctions, MeshPaintMaskProperty, MeshPaintMaskLayer, data, true, true, false)

};

/**************** Mesh Paint Mask Property ****************/

class MeshPaintMaskProperty : public Pointer {
public:
	MeshPaintMaskProperty(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline float value(void);
	inline void value(float value);

};

/**************** Mesh Vertex ****************/

class MeshVertex : public Pointer {
public:
	MeshVertex(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		groups(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline Array<float, 3> co(void);
	inline void co(float values[3]);
	inline Array<float, 3> normal(void);
	inline void normal(float values[3]);
	inline bool select(void);
	inline void select(bool value);
	inline bool hide(void);
	inline void hide(bool value);
	inline float bevel_weight(void);
	inline void bevel_weight(float value);
	COLLECTION_PROPERTY(DefaultCollectionFunctions, VertexGroupElement, MeshVertex, groups, false, false, false)
	inline int index(void);
	inline void index(int value);
	inline Array<float, 3> undeformed_co(void);
	inline void undeformed_co(float values[3]);

};

/**************** Vertex Group Element ****************/

class VertexGroupElement : public Pointer {
public:
	VertexGroupElement(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline int group(void);
	inline void group(int value);
	inline float weight(void);
	inline void weight(float value);

};

/**************** Mesh Edge ****************/

class MeshEdge : public Pointer {
public:
	MeshEdge(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline Array<int, 2> vertices(void);
	inline void vertices(int values[2]);
	inline float crease(void);
	inline void crease(float value);
	inline float bevel_weight(void);
	inline void bevel_weight(float value);
	inline bool select(void);
	inline void select(bool value);
	inline bool hide(void);
	inline void hide(bool value);
	inline bool use_seam(void);
	inline void use_seam(bool value);
	inline bool use_edge_sharp(void);
	inline void use_edge_sharp(bool value);
	inline bool is_loose(void);
	inline void is_loose(bool value);
	inline bool use_freestyle_mark(void);
	inline void use_freestyle_mark(bool value);
	inline int index(void);
	inline void index(int value);

};

/**************** Mesh Loop ****************/

class MeshLoop : public Pointer {
public:
	MeshLoop(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline int vertex_index(void);
	inline void vertex_index(int value);
	inline int edge_index(void);
	inline void edge_index(int value);
	inline int index(void);
	inline void index(int value);
	inline Array<float, 3> normal(void);
	inline void normal(float values[3]);
	inline Array<float, 3> tangent(void);
	inline void tangent(float values[3]);
	inline float bitangent_sign(void);
	inline void bitangent_sign(float value);
	inline Array<float, 3> bitangent(void);
	inline void bitangent(float values[3]);

};

/**************** Mesh Polygon ****************/

class MeshPolygon : public Pointer {
public:
	MeshPolygon(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline Array<int, 3> vertices(void);
	inline void vertices(int values[3]);
	inline int loop_start(void);
	inline void loop_start(int value);
	inline int loop_total(void);
	inline void loop_total(int value);
	inline int material_index(void);
	inline void material_index(int value);
	inline bool select(void);
	inline void select(bool value);
	inline bool hide(void);
	inline void hide(bool value);
	inline bool use_smooth(void);
	inline void use_smooth(bool value);
	inline bool use_freestyle_mark(void);
	inline void use_freestyle_mark(bool value);
	inline Array<float, 3> normal(void);
	inline void normal(float values[3]);
	inline Array<float, 3> center(void);
	inline void center(float values[3]);
	inline float area(void);
	inline void area(float value);
	inline int index(void);
	inline void index(int value);

	inline void flip();
};

/**************** MeshUVLoopLayer ****************/

class MeshUVLoopLayer : public Pointer {
public:
	MeshUVLoopLayer(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		data(ptr_arg)
		{}

	inline Struct rna_type(void);
	COLLECTION_PROPERTY(DefaultCollectionFunctions, MeshUVLoop, MeshUVLoopLayer, data, true, true, false)
	inline std::string name(void);
	inline void name(const std::string& value);
	inline bool active(void);
	inline void active(bool value);
	inline bool active_render(void);
	inline void active_render(bool value);
	inline bool active_clone(void);
	inline void active_clone(bool value);

};

/**************** MeshUVLoop ****************/

class MeshUVLoop : public Pointer {
public:
	MeshUVLoop(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline Array<float, 2> uv(void);
	inline void uv(float values[2]);
	inline bool pin_uv(void);
	inline void pin_uv(bool value);
	inline bool select(void);
	inline void select(bool value);
	inline bool select_edge(void);
	inline void select_edge(bool value);

};

/**************** Mesh Vertex Color Layer ****************/

class MeshLoopColorLayer : public Pointer {
public:
	MeshLoopColorLayer(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		data(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string name(void);
	inline void name(const std::string& value);
	inline bool active(void);
	inline void active(bool value);
	inline bool active_render(void);
	inline void active_render(bool value);
	COLLECTION_PROPERTY(DefaultCollectionFunctions, MeshLoopColor, MeshLoopColorLayer, data, true, true, false)

};

/**************** Mesh Vertex Color ****************/

class MeshLoopColor : public Pointer {
public:
	MeshLoopColor(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline Array<float, 4> color(void);
	inline void color(float values[4]);

};

/**************** Mesh Vertex Float Property Layer ****************/

class MeshVertexFloatPropertyLayer : public Pointer {
public:
	MeshVertexFloatPropertyLayer(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		data(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string name(void);
	inline void name(const std::string& value);
	COLLECTION_PROPERTY(DefaultCollectionFunctions, MeshVertexFloatProperty, MeshVertexFloatPropertyLayer, data, true, true, false)

};

/**************** Mesh Vertex Float Property ****************/

class MeshVertexFloatProperty : public Pointer {
public:
	MeshVertexFloatProperty(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline float value(void);
	inline void value(float value);

};

/**************** Mesh Polygon Float Property Layer ****************/

class MeshPolygonFloatPropertyLayer : public Pointer {
public:
	MeshPolygonFloatPropertyLayer(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		data(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string name(void);
	inline void name(const std::string& value);
	COLLECTION_PROPERTY(DefaultCollectionFunctions, MeshPolygonFloatProperty, MeshPolygonFloatPropertyLayer, data, true, true, false)

};

/**************** Mesh Polygon Float Property ****************/

class MeshPolygonFloatProperty : public Pointer {
public:
	MeshPolygonFloatProperty(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline float value(void);
	inline void value(float value);

};

/**************** Mesh Vertex Int Property Layer ****************/

class MeshVertexIntPropertyLayer : public Pointer {
public:
	MeshVertexIntPropertyLayer(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		data(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string name(void);
	inline void name(const std::string& value);
	COLLECTION_PROPERTY(DefaultCollectionFunctions, MeshVertexIntProperty, MeshVertexIntPropertyLayer, data, true, true, false)

};

/**************** Mesh Vertex Int Property ****************/

class MeshVertexIntProperty : public Pointer {
public:
	MeshVertexIntProperty(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline int value(void);
	inline void value(int value);

};

/**************** Mesh Polygon Int Property Layer ****************/

class MeshPolygonIntPropertyLayer : public Pointer {
public:
	MeshPolygonIntPropertyLayer(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		data(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string name(void);
	inline void name(const std::string& value);
	COLLECTION_PROPERTY(DefaultCollectionFunctions, MeshPolygonIntProperty, MeshPolygonIntPropertyLayer, data, true, true, false)

};

/**************** Mesh Polygon Int Property ****************/

class MeshPolygonIntProperty : public Pointer {
public:
	MeshPolygonIntProperty(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline int value(void);
	inline void value(int value);

};

/**************** Mesh Vertex String Property Layer ****************/

class MeshVertexStringPropertyLayer : public Pointer {
public:
	MeshVertexStringPropertyLayer(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		data(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string name(void);
	inline void name(const std::string& value);
	COLLECTION_PROPERTY(DefaultCollectionFunctions, MeshVertexStringProperty, MeshVertexStringPropertyLayer, data, true, true, false)

};

/**************** Mesh Vertex String Property ****************/

class MeshVertexStringProperty : public Pointer {
public:
	MeshVertexStringProperty(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string value(void);
	inline void value(const std::string& value);

};

/**************** Mesh Polygon String Property Layer ****************/

class MeshPolygonStringPropertyLayer : public Pointer {
public:
	MeshPolygonStringPropertyLayer(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		data(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string name(void);
	inline void name(const std::string& value);
	COLLECTION_PROPERTY(DefaultCollectionFunctions, MeshPolygonStringProperty, MeshPolygonStringPropertyLayer, data, true, true, false)

};

/**************** Mesh Polygon String Property ****************/

class MeshPolygonStringProperty : public Pointer {
public:
	MeshPolygonStringProperty(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string value(void);
	inline void value(const std::string& value);

};

/**************** Mesh Face Map Layer ****************/

class MeshFaceMapLayer : public Pointer {
public:
	MeshFaceMapLayer(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		data(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string name(void);
	inline void name(const std::string& value);
	COLLECTION_PROPERTY(DefaultCollectionFunctions, MeshFaceMap, MeshFaceMapLayer, data, true, true, false)

};

/**************** Int Property ****************/

class MeshFaceMap : public Pointer {
public:
	MeshFaceMap(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline int value(void);
	inline void value(int value);

};

/**************** Meta Element ****************/

class MetaElement : public Pointer {
public:
	MetaElement(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	enum type_enum {
		type_BALL = 0,
		type_CAPSULE = 4,
		type_PLANE = 5,
		type_ELLIPSOID = 6,
		type_CUBE = 7,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	inline Array<float, 3> co(void);
	inline void co(float values[3]);
	inline Array<float, 4> rotation(void);
	inline void rotation(float values[4]);
	inline float radius(void);
	inline void radius(float value);
	inline float size_x(void);
	inline void size_x(float value);
	inline float size_y(void);
	inline void size_y(float value);
	inline float size_z(void);
	inline void size_z(float value);
	inline float stiffness(void);
	inline void stiffness(float value);
	inline bool use_negative(void);
	inline void use_negative(bool value);
	inline bool hide(void);
	inline void hide(bool value);

};

/**************** MetaBall ****************/

class MetaBall : public ID {
public:
	MetaBall(const PointerRNA &ptr_arg) :
		ID(ptr_arg),
		elements(ptr_arg),
		materials(ptr_arg)
		{}

	COLLECTION_PROPERTY(MetaBallElements, MetaElement, MetaBall, elements, false, true, false)
	enum update_method_enum {
		update_method_UPDATE_ALWAYS = 0,
		update_method_HALFRES = 1,
		update_method_FAST = 2,
		update_method_NEVER = 3,
	};
	inline update_method_enum update_method(void);
	inline void update_method(update_method_enum value);
	inline float resolution(void);
	inline void resolution(float value);
	inline float render_resolution(void);
	inline void render_resolution(float value);
	inline float threshold(void);
	inline void threshold(float value);
	inline bool use_auto_texspace(void);
	inline void use_auto_texspace(bool value);
	inline Array<float, 3> texspace_location(void);
	inline void texspace_location(float values[3]);
	inline Array<float, 3> texspace_size(void);
	inline void texspace_size(float values[3]);
	COLLECTION_PROPERTY(IDMaterials, Material, MetaBall, materials, true, true, true)
	inline bool is_editmode(void);
	inline void is_editmode(bool value);
	inline AnimData animation_data(void);

	inline void transform(float matrix[16]);
	inline void update_gpu_tag();
};

/**************** Modifier ****************/

class Modifier : public Pointer {
public:
	Modifier(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string name(void);
	inline void name(const std::string& value);
	enum type_enum {
		type_DATA_TRANSFER = 49,
		type_MESH_CACHE = 46,
		type_MESH_SEQUENCE_CACHE = 52,
		type_NORMAL_EDIT = 50,
		type_WEIGHTED_NORMAL = 54,
		type_UV_PROJECT = 15,
		type_UV_WARP = 45,
		type_VERTEX_WEIGHT_EDIT = 36,
		type_VERTEX_WEIGHT_MIX = 37,
		type_VERTEX_WEIGHT_PROXIMITY = 38,
		type_ARRAY = 12,
		type_BEVEL = 24,
		type_BOOLEAN = 11,
		type_BUILD = 4,
		type_DECIMATE = 6,
		type_EDGE_SPLIT = 13,
		type_MASK = 27,
		type_MIRROR = 5,
		type_MULTIRES = 29,
		type_REMESH = 41,
		type_SCREW = 34,
		type_SKIN = 42,
		type_SOLIDIFY = 33,
		type_SUBSURF = 1,
		type_TRIANGULATE = 44,
		type_WIREFRAME = 48,
		type_ARMATURE = 8,
		type_CAST = 17,
		type_CURVE = 3,
		type_DISPLACE = 14,
		type_HOOK = 9,
		type_LAPLACIANDEFORM = 47,
		type_LATTICE = 2,
		type_MESH_DEFORM = 18,
		type_SHRINKWRAP = 25,
		type_SIMPLE_DEFORM = 28,
		type_SMOOTH = 16,
		type_CORRECTIVE_SMOOTH = 51,
		type_LAPLACIANSMOOTH = 43,
		type_SURFACE_DEFORM = 53,
		type_WARP = 35,
		type_WAVE = 7,
		type_CLOTH = 22,
		type_COLLISION = 23,
		type_DYNAMIC_PAINT = 40,
		type_EXPLODE = 21,
		type_FLUID_SIMULATION = 26,
		type_OCEAN = 39,
		type_PARTICLE_INSTANCE = 20,
		type_PARTICLE_SYSTEM = 19,
		type_SMOKE = 31,
		type_SOFT_BODY = 10,
		type_SURFACE = 30,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	inline bool show_viewport(void);
	inline void show_viewport(bool value);
	inline bool show_render(void);
	inline void show_render(bool value);
	inline bool show_in_editmode(void);
	inline void show_in_editmode(bool value);
	inline bool show_on_cage(void);
	inline void show_on_cage(bool value);
	inline bool show_expanded(void);
	inline void show_expanded(bool value);
	inline bool use_apply_on_spline(void);
	inline void use_apply_on_spline(bool value);

};

/**************** Subsurf Modifier ****************/

class SubsurfModifier : public Modifier {
public:
	SubsurfModifier(const PointerRNA &ptr_arg) :
		Modifier(ptr_arg)
		{}

	enum uv_smooth_enum {
		uv_smooth_NONE = 0,
		uv_smooth_PRESERVE_CORNERS = 1,
	};
	inline uv_smooth_enum uv_smooth(void);
	inline void uv_smooth(uv_smooth_enum value);
	inline int quality(void);
	inline void quality(int value);
	enum subdivision_type_enum {
		subdivision_type_CATMULL_CLARK = 0,
		subdivision_type_SIMPLE = 1,
	};
	inline subdivision_type_enum subdivision_type(void);
	inline void subdivision_type(subdivision_type_enum value);
	inline int levels(void);
	inline void levels(int value);
	inline int render_levels(void);
	inline void render_levels(int value);
	inline bool show_only_control_edges(void);
	inline void show_only_control_edges(bool value);
	inline bool use_creases(void);
	inline void use_creases(bool value);

};

/**************** Lattice Modifier ****************/

class LatticeModifier : public Modifier {
public:
	LatticeModifier(const PointerRNA &ptr_arg) :
		Modifier(ptr_arg)
		{}

	inline Object object(void);
	inline std::string vertex_group(void);
	inline void vertex_group(const std::string& value);
	inline float strength(void);
	inline void strength(float value);

};

/**************** Curve Modifier ****************/

class CurveModifier : public Modifier {
public:
	CurveModifier(const PointerRNA &ptr_arg) :
		Modifier(ptr_arg)
		{}

	inline Object object(void);
	inline std::string vertex_group(void);
	inline void vertex_group(const std::string& value);
	enum deform_axis_enum {
		deform_axis_POS_X = 1,
		deform_axis_POS_Y = 2,
		deform_axis_POS_Z = 3,
		deform_axis_NEG_X = 4,
		deform_axis_NEG_Y = 5,
		deform_axis_NEG_Z = 6,
	};
	inline deform_axis_enum deform_axis(void);
	inline void deform_axis(deform_axis_enum value);

};

/**************** Build Modifier ****************/

class BuildModifier : public Modifier {
public:
	BuildModifier(const PointerRNA &ptr_arg) :
		Modifier(ptr_arg)
		{}

	inline float frame_start(void);
	inline void frame_start(float value);
	inline float frame_duration(void);
	inline void frame_duration(float value);
	inline bool use_reverse(void);
	inline void use_reverse(bool value);
	inline bool use_random_order(void);
	inline void use_random_order(bool value);
	inline int seed(void);
	inline void seed(int value);

};

/**************** Mirror Modifier ****************/

class MirrorModifier : public Modifier {
public:
	MirrorModifier(const PointerRNA &ptr_arg) :
		Modifier(ptr_arg)
		{}

	inline Array<bool, 3> use_axis(void);
	inline void use_axis(bool values[3]);
	inline Array<bool, 3> use_bisect_axis(void);
	inline void use_bisect_axis(bool values[3]);
	inline Array<bool, 3> use_bisect_flip_axis(void);
	inline void use_bisect_flip_axis(bool values[3]);
	inline bool use_clip(void);
	inline void use_clip(bool value);
	inline bool use_mirror_vertex_groups(void);
	inline void use_mirror_vertex_groups(bool value);
	inline bool use_mirror_merge(void);
	inline void use_mirror_merge(bool value);
	inline bool use_mirror_u(void);
	inline void use_mirror_u(bool value);
	inline bool use_mirror_v(void);
	inline void use_mirror_v(bool value);
	inline float mirror_offset_u(void);
	inline void mirror_offset_u(float value);
	inline float mirror_offset_v(void);
	inline void mirror_offset_v(float value);
	inline float offset_u(void);
	inline void offset_u(float value);
	inline float offset_v(void);
	inline void offset_v(float value);
	inline float merge_threshold(void);
	inline void merge_threshold(float value);
	inline Object mirror_object(void);

};

/**************** Decimate Modifier ****************/

class DecimateModifier : public Modifier {
public:
	DecimateModifier(const PointerRNA &ptr_arg) :
		Modifier(ptr_arg)
		{}

	enum decimate_type_enum {
		decimate_type_COLLAPSE = 0,
		decimate_type_UNSUBDIV = 1,
		decimate_type_DISSOLVE = 2,
	};
	inline decimate_type_enum decimate_type(void);
	inline void decimate_type(decimate_type_enum value);
	inline float ratio(void);
	inline void ratio(float value);
	inline int iterations(void);
	inline void iterations(int value);
	inline float angle_limit(void);
	inline void angle_limit(float value);
	inline std::string vertex_group(void);
	inline void vertex_group(const std::string& value);
	inline bool invert_vertex_group(void);
	inline void invert_vertex_group(bool value);
	inline bool use_collapse_triangulate(void);
	inline void use_collapse_triangulate(bool value);
	inline bool use_symmetry(void);
	inline void use_symmetry(bool value);
	enum symmetry_axis_enum {
		symmetry_axis_X = 0,
		symmetry_axis_Y = 1,
		symmetry_axis_Z = 2,
	};
	inline symmetry_axis_enum symmetry_axis(void);
	inline void symmetry_axis(symmetry_axis_enum value);
	inline float vertex_group_factor(void);
	inline void vertex_group_factor(float value);
	inline bool use_dissolve_boundaries(void);
	inline void use_dissolve_boundaries(bool value);
	enum delimit_enum {
		delimit_NORMAL = 1,
		delimit_MATERIAL = 2,
		delimit_SEAM = 4,
		delimit_SHARP = 8,
		delimit_UV = 16,
	};
	inline delimit_enum delimit(void);
	inline void delimit(delimit_enum value);
	inline int face_count(void);
	inline void face_count(int value);

};

/**************** Wave Modifier ****************/

class WaveModifier : public Modifier {
public:
	WaveModifier(const PointerRNA &ptr_arg) :
		Modifier(ptr_arg)
		{}

	inline bool use_x(void);
	inline void use_x(bool value);
	inline bool use_y(void);
	inline void use_y(bool value);
	inline bool use_cyclic(void);
	inline void use_cyclic(bool value);
	inline bool use_normal(void);
	inline void use_normal(bool value);
	inline bool use_normal_x(void);
	inline void use_normal_x(bool value);
	inline bool use_normal_y(void);
	inline void use_normal_y(bool value);
	inline bool use_normal_z(void);
	inline void use_normal_z(bool value);
	inline float time_offset(void);
	inline void time_offset(float value);
	inline float lifetime(void);
	inline void lifetime(float value);
	inline float damping_time(void);
	inline void damping_time(float value);
	inline float falloff_radius(void);
	inline void falloff_radius(float value);
	inline float start_position_x(void);
	inline void start_position_x(float value);
	inline float start_position_y(void);
	inline void start_position_y(float value);
	inline Object start_position_object(void);
	inline std::string vertex_group(void);
	inline void vertex_group(const std::string& value);
	inline float speed(void);
	inline void speed(float value);
	inline float height(void);
	inline void height(float value);
	inline float width(void);
	inline void width(float value);
	inline float narrowness(void);
	inline void narrowness(float value);
	inline Texture texture(void);
	enum texture_coords_enum {
		texture_coords_LOCAL = 0,
		texture_coords_GLOBAL = 1,
		texture_coords_OBJECT = 2,
		texture_coords_UV = 3,
	};
	inline texture_coords_enum texture_coords(void);
	inline void texture_coords(texture_coords_enum value);
	inline std::string uv_layer(void);
	inline void uv_layer(const std::string& value);
	inline Object texture_coords_object(void);

};

/**************** Armature Modifier ****************/

class ArmatureModifier : public Modifier {
public:
	ArmatureModifier(const PointerRNA &ptr_arg) :
		Modifier(ptr_arg)
		{}

	inline Object object(void);
	inline bool use_bone_envelopes(void);
	inline void use_bone_envelopes(bool value);
	inline bool use_vertex_groups(void);
	inline void use_vertex_groups(bool value);
	inline bool use_deform_preserve_volume(void);
	inline void use_deform_preserve_volume(bool value);
	inline bool use_multi_modifier(void);
	inline void use_multi_modifier(bool value);
	inline std::string vertex_group(void);
	inline void vertex_group(const std::string& value);
	inline bool invert_vertex_group(void);
	inline void invert_vertex_group(bool value);

};

/**************** Hook Modifier ****************/

class HookModifier : public Modifier {
public:
	HookModifier(const PointerRNA &ptr_arg) :
		Modifier(ptr_arg)
		{}

	inline float strength(void);
	inline void strength(float value);
	enum falloff_type_enum {
		falloff_type_NONE = 0,
		falloff_type_CURVE = 1,
		falloff_type_SMOOTH = 3,
		falloff_type_SPHERE = 7,
		falloff_type_ROOT = 4,
		falloff_type_INVERSE_SQUARE = 8,
		falloff_type_SHARP = 2,
		falloff_type_LINEAR = 5,
		falloff_type_CONSTANT = 6,
	};
	inline falloff_type_enum falloff_type(void);
	inline void falloff_type(falloff_type_enum value);
	inline float falloff_radius(void);
	inline void falloff_radius(float value);
	inline CurveMapping falloff_curve(void);
	inline Array<float, 3> center(void);
	inline void center(float values[3]);
	inline Array<float, 16> matrix_inverse(void);
	inline void matrix_inverse(float values[16]);
	inline Object object(void);
	inline std::string subtarget(void);
	inline void subtarget(const std::string& value);
	inline bool use_falloff_uniform(void);
	inline void use_falloff_uniform(bool value);
	inline std::string vertex_group(void);
	inline void vertex_group(const std::string& value);

};

/**************** Soft Body Modifier ****************/

class SoftBodyModifier : public Modifier {
public:
	SoftBodyModifier(const PointerRNA &ptr_arg) :
		Modifier(ptr_arg)
		{}

	inline SoftBodySettings settings(void);
	inline PointCache point_cache(void);

};

/**************** Boolean Modifier ****************/

class BooleanModifier : public Modifier {
public:
	BooleanModifier(const PointerRNA &ptr_arg) :
		Modifier(ptr_arg)
		{}

	inline Object object(void);
	enum operation_enum {
		operation_INTERSECT = 0,
		operation_UNION = 1,
		operation_DIFFERENCE = 2,
	};
	inline operation_enum operation(void);
	inline void operation(operation_enum value);
	inline float double_threshold(void);
	inline void double_threshold(float value);
	enum debug_options_enum {
		debug_options_SEPARATE = 1,
		debug_options_NO_DISSOLVE = 2,
		debug_options_NO_CONNECT_REGIONS = 4,
	};
	inline debug_options_enum debug_options(void);
	inline void debug_options(debug_options_enum value);

};

/**************** Array Modifier ****************/

class ArrayModifier : public Modifier {
public:
	ArrayModifier(const PointerRNA &ptr_arg) :
		Modifier(ptr_arg)
		{}

	enum fit_type_enum {
		fit_type_FIXED_COUNT = 0,
		fit_type_FIT_LENGTH = 1,
		fit_type_FIT_CURVE = 2,
	};
	inline fit_type_enum fit_type(void);
	inline void fit_type(fit_type_enum value);
	inline int count(void);
	inline void count(int value);
	inline float fit_length(void);
	inline void fit_length(float value);
	inline Object curve(void);
	inline bool use_constant_offset(void);
	inline void use_constant_offset(bool value);
	inline Array<float, 3> constant_offset_displace(void);
	inline void constant_offset_displace(float values[3]);
	inline bool use_relative_offset(void);
	inline void use_relative_offset(bool value);
	inline Array<float, 3> relative_offset_displace(void);
	inline void relative_offset_displace(float values[3]);
	inline bool use_merge_vertices(void);
	inline void use_merge_vertices(bool value);
	inline bool use_merge_vertices_cap(void);
	inline void use_merge_vertices_cap(bool value);
	inline float merge_threshold(void);
	inline void merge_threshold(float value);
	inline bool use_object_offset(void);
	inline void use_object_offset(bool value);
	inline Object offset_object(void);
	inline Object start_cap(void);
	inline Object end_cap(void);
	inline float offset_u(void);
	inline void offset_u(float value);
	inline float offset_v(void);
	inline void offset_v(float value);

};

/**************** EdgeSplit Modifier ****************/

class EdgeSplitModifier : public Modifier {
public:
	EdgeSplitModifier(const PointerRNA &ptr_arg) :
		Modifier(ptr_arg)
		{}

	inline float split_angle(void);
	inline void split_angle(float value);
	inline bool use_edge_angle(void);
	inline void use_edge_angle(bool value);
	inline bool use_edge_sharp(void);
	inline void use_edge_sharp(bool value);

};

/**************** Displace Modifier ****************/

class DisplaceModifier : public Modifier {
public:
	DisplaceModifier(const PointerRNA &ptr_arg) :
		Modifier(ptr_arg)
		{}

	inline std::string vertex_group(void);
	inline void vertex_group(const std::string& value);
	inline float mid_level(void);
	inline void mid_level(float value);
	inline float strength(void);
	inline void strength(float value);
	enum direction_enum {
		direction_X = 0,
		direction_Y = 1,
		direction_Z = 2,
		direction_NORMAL = 3,
		direction_CUSTOM_NORMAL = 5,
		direction_RGB_TO_XYZ = 4,
	};
	inline direction_enum direction(void);
	inline void direction(direction_enum value);
	enum space_enum {
		space_LOCAL = 0,
		space_GLOBAL = 1,
	};
	inline space_enum space(void);
	inline void space(space_enum value);
	inline Texture texture(void);
	enum texture_coords_enum {
		texture_coords_LOCAL = 0,
		texture_coords_GLOBAL = 1,
		texture_coords_OBJECT = 2,
		texture_coords_UV = 3,
	};
	inline texture_coords_enum texture_coords(void);
	inline void texture_coords(texture_coords_enum value);
	inline std::string uv_layer(void);
	inline void uv_layer(const std::string& value);
	inline Object texture_coords_object(void);

};

/**************** UV Project Modifier ****************/

class UVProjectModifier : public Modifier {
public:
	UVProjectModifier(const PointerRNA &ptr_arg) :
		Modifier(ptr_arg),
		projectors(ptr_arg)
		{}

	inline std::string uv_layer(void);
	inline void uv_layer(const std::string& value);
	inline int projector_count(void);
	inline void projector_count(int value);
	COLLECTION_PROPERTY(DefaultCollectionFunctions, UVProjector, UVProjectModifier, projectors, false, true, false)
	inline float aspect_x(void);
	inline void aspect_x(float value);
	inline float aspect_y(void);
	inline void aspect_y(float value);
	inline float scale_x(void);
	inline void scale_x(float value);
	inline float scale_y(void);
	inline void scale_y(float value);

};

/**************** UVProjector ****************/

class UVProjector : public Pointer {
public:
	UVProjector(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline Object object(void);

};

/**************** Smooth Modifier ****************/

class SmoothModifier : public Modifier {
public:
	SmoothModifier(const PointerRNA &ptr_arg) :
		Modifier(ptr_arg)
		{}

	inline bool use_x(void);
	inline void use_x(bool value);
	inline bool use_y(void);
	inline void use_y(bool value);
	inline bool use_z(void);
	inline void use_z(bool value);
	inline float factor(void);
	inline void factor(float value);
	inline int iterations(void);
	inline void iterations(int value);
	inline std::string vertex_group(void);
	inline void vertex_group(const std::string& value);

};

/**************** Corrective Smooth Modifier ****************/

class CorrectiveSmoothModifier : public Modifier {
public:
	CorrectiveSmoothModifier(const PointerRNA &ptr_arg) :
		Modifier(ptr_arg)
		{}

	inline float factor(void);
	inline void factor(float value);
	inline int iterations(void);
	inline void iterations(int value);
	enum rest_source_enum {
		rest_source_ORCO = 0,
		rest_source_BIND = 1,
	};
	inline rest_source_enum rest_source(void);
	inline void rest_source(rest_source_enum value);
	enum smooth_type_enum {
		smooth_type_SIMPLE = 0,
		smooth_type_LENGTH_WEIGHTED = 1,
	};
	inline smooth_type_enum smooth_type(void);
	inline void smooth_type(smooth_type_enum value);
	inline bool invert_vertex_group(void);
	inline void invert_vertex_group(bool value);
	inline std::string vertex_group(void);
	inline void vertex_group(const std::string& value);
	inline bool is_bind(void);
	inline void is_bind(bool value);
	inline bool use_only_smooth(void);
	inline void use_only_smooth(bool value);
	inline bool use_pin_boundary(void);
	inline void use_pin_boundary(bool value);

};

/**************** Cast Modifier ****************/

class CastModifier : public Modifier {
public:
	CastModifier(const PointerRNA &ptr_arg) :
		Modifier(ptr_arg)
		{}

	enum cast_type_enum {
		cast_type_SPHERE = 0,
		cast_type_CYLINDER = 1,
		cast_type_CUBOID = 2,
	};
	inline cast_type_enum cast_type(void);
	inline void cast_type(cast_type_enum value);
	inline Object object(void);
	inline bool use_x(void);
	inline void use_x(bool value);
	inline bool use_y(void);
	inline void use_y(bool value);
	inline bool use_z(void);
	inline void use_z(bool value);
	inline bool use_radius_as_size(void);
	inline void use_radius_as_size(bool value);
	inline bool use_transform(void);
	inline void use_transform(bool value);
	inline float factor(void);
	inline void factor(float value);
	inline float radius(void);
	inline void radius(float value);
	inline float size(void);
	inline void size(float value);
	inline std::string vertex_group(void);
	inline void vertex_group(const std::string& value);

};

/**************** MeshDeform Modifier ****************/

class MeshDeformModifier : public Modifier {
public:
	MeshDeformModifier(const PointerRNA &ptr_arg) :
		Modifier(ptr_arg)
		{}

	inline Object object(void);
	inline bool is_bound(void);
	inline void is_bound(bool value);
	inline bool invert_vertex_group(void);
	inline void invert_vertex_group(bool value);
	inline std::string vertex_group(void);
	inline void vertex_group(const std::string& value);
	inline int precision(void);
	inline void precision(int value);
	inline bool use_dynamic_bind(void);
	inline void use_dynamic_bind(bool value);

};

/**************** ParticleSystem Modifier ****************/

class ParticleSystemModifier : public Modifier {
public:
	ParticleSystemModifier(const PointerRNA &ptr_arg) :
		Modifier(ptr_arg)
		{}

	inline ParticleSystem particle_system(void);

};

/**************** ParticleInstance Modifier ****************/

class ParticleInstanceModifier : public Modifier {
public:
	ParticleInstanceModifier(const PointerRNA &ptr_arg) :
		Modifier(ptr_arg)
		{}

	inline Object object(void);
	inline int particle_system_index(void);
	inline void particle_system_index(int value);
	inline ParticleSystem particle_system(void);
	enum axis_enum {
		axis_X = 0,
		axis_Y = 1,
		axis_Z = 2,
	};
	inline axis_enum axis(void);
	inline void axis(axis_enum value);
	enum space_enum {
		space_LOCAL = 1,
		space_WORLD = 0,
	};
	inline space_enum space(void);
	inline void space(space_enum value);
	inline bool use_normal(void);
	inline void use_normal(bool value);
	inline bool use_children(void);
	inline void use_children(bool value);
	inline bool use_path(void);
	inline void use_path(bool value);
	inline bool show_unborn(void);
	inline void show_unborn(bool value);
	inline bool show_alive(void);
	inline void show_alive(bool value);
	inline bool show_dead(void);
	inline void show_dead(bool value);
	inline bool use_preserve_shape(void);
	inline void use_preserve_shape(bool value);
	inline bool use_size(void);
	inline void use_size(bool value);
	inline float position(void);
	inline void position(float value);
	inline float random_position(void);
	inline void random_position(float value);
	inline float rotation(void);
	inline void rotation(float value);
	inline float random_rotation(void);
	inline void random_rotation(float value);
	inline float particle_amount(void);
	inline void particle_amount(float value);
	inline float particle_offset(void);
	inline void particle_offset(float value);
	inline std::string index_layer_name(void);
	inline void index_layer_name(const std::string& value);
	inline std::string value_layer_name(void);
	inline void value_layer_name(const std::string& value);

};

/**************** Explode Modifier ****************/

class ExplodeModifier : public Modifier {
public:
	ExplodeModifier(const PointerRNA &ptr_arg) :
		Modifier(ptr_arg)
		{}

	inline std::string vertex_group(void);
	inline void vertex_group(const std::string& value);
	inline float protect(void);
	inline void protect(float value);
	inline bool use_edge_cut(void);
	inline void use_edge_cut(bool value);
	inline bool show_unborn(void);
	inline void show_unborn(bool value);
	inline bool show_alive(void);
	inline void show_alive(bool value);
	inline bool show_dead(void);
	inline void show_dead(bool value);
	inline bool use_size(void);
	inline void use_size(bool value);
	inline std::string particle_uv(void);
	inline void particle_uv(const std::string& value);

};

/**************** Cloth Modifier ****************/

class ClothModifier : public Modifier {
public:
	ClothModifier(const PointerRNA &ptr_arg) :
		Modifier(ptr_arg)
		{}

	inline ClothSettings settings(void);
	inline ClothCollisionSettings collision_settings(void);
	inline ClothSolverResult solver_result(void);
	inline PointCache point_cache(void);
	inline Array<float, 3> hair_grid_min(void);
	inline void hair_grid_min(float values[3]);
	inline Array<float, 3> hair_grid_max(void);
	inline void hair_grid_max(float values[3]);
	inline Array<int, 3> hair_grid_resolution(void);
	inline void hair_grid_resolution(int values[3]);

};

/**************** Collision Modifier ****************/

class CollisionModifier : public Modifier {
public:
	CollisionModifier(const PointerRNA &ptr_arg) :
		Modifier(ptr_arg)
		{}

	inline CollisionSettings settings(void);

};

/**************** Bevel Modifier ****************/

class BevelModifier : public Modifier {
public:
	BevelModifier(const PointerRNA &ptr_arg) :
		Modifier(ptr_arg)
		{}

	inline float width(void);
	inline void width(float value);
	inline float width_pct(void);
	inline void width_pct(float value);
	inline int segments(void);
	inline void segments(int value);
	inline bool use_only_vertices(void);
	inline void use_only_vertices(bool value);
	enum limit_method_enum {
		limit_method_NONE = 0,
		limit_method_ANGLE = 8,
		limit_method_WEIGHT = 16,
		limit_method_VGROUP = 32,
	};
	inline limit_method_enum limit_method(void);
	inline void limit_method(limit_method_enum value);
	inline float angle_limit(void);
	inline void angle_limit(float value);
	inline std::string vertex_group(void);
	inline void vertex_group(const std::string& value);
	inline bool use_clamp_overlap(void);
	inline void use_clamp_overlap(bool value);
	enum offset_type_enum {
		offset_type_OFFSET = 0,
		offset_type_WIDTH = 1,
		offset_type_DEPTH = 2,
		offset_type_PERCENT = 3,
	};
	inline offset_type_enum offset_type(void);
	inline void offset_type(offset_type_enum value);
	inline float profile(void);
	inline void profile(float value);
	inline int material(void);
	inline void material(int value);
	inline bool loop_slide(void);
	inline void loop_slide(bool value);
	inline bool mark_seam(void);
	inline void mark_seam(bool value);
	inline bool mark_sharp(void);
	inline void mark_sharp(bool value);
	inline bool harden_normals(void);
	inline void harden_normals(bool value);
	enum face_strength_mode_enum {
		face_strength_mode_FSTR_NONE = 0,
		face_strength_mode_FSTR_NEW = 1,
		face_strength_mode_FSTR_AFFECTED = 2,
		face_strength_mode_FSTR_ALL = 3,
	};
	inline face_strength_mode_enum face_strength_mode(void);
	inline void face_strength_mode(face_strength_mode_enum value);
	enum miter_outer_enum {
		miter_outer_MITER_SHARP = 0,
		miter_outer_MITER_PATCH = 1,
		miter_outer_MITER_ARC = 2,
	};
	inline miter_outer_enum miter_outer(void);
	inline void miter_outer(miter_outer_enum value);
	enum miter_inner_enum {
		miter_inner_MITER_SHARP = 0,
		miter_inner_MITER_PATCH = 1,
		miter_inner_MITER_ARC = 2,
	};
	inline miter_inner_enum miter_inner(void);
	inline void miter_inner(miter_inner_enum value);
	inline float spread(void);
	inline void spread(float value);

};

/**************** Shrinkwrap Modifier ****************/

class ShrinkwrapModifier : public Modifier {
public:
	ShrinkwrapModifier(const PointerRNA &ptr_arg) :
		Modifier(ptr_arg)
		{}

	enum wrap_method_enum {
		wrap_method_NEAREST_SURFACEPOINT = 0,
		wrap_method_PROJECT = 1,
		wrap_method_NEAREST_VERTEX = 2,
		wrap_method_TARGET_PROJECT = 3,
	};
	inline wrap_method_enum wrap_method(void);
	inline void wrap_method(wrap_method_enum value);
	enum wrap_mode_enum {
		wrap_mode_ON_SURFACE = 0,
		wrap_mode_INSIDE = 1,
		wrap_mode_OUTSIDE = 2,
		wrap_mode_OUTSIDE_SURFACE = 3,
		wrap_mode_ABOVE_SURFACE = 4,
	};
	inline wrap_mode_enum wrap_mode(void);
	inline void wrap_mode(wrap_mode_enum value);
	enum cull_face_enum {
		cull_face_OFF = 0,
		cull_face_FRONT = 8,
		cull_face_BACK = 16,
	};
	inline cull_face_enum cull_face(void);
	inline void cull_face(cull_face_enum value);
	inline Object target(void);
	inline Object auxiliary_target(void);
	inline std::string vertex_group(void);
	inline void vertex_group(const std::string& value);
	inline float offset(void);
	inline void offset(float value);
	inline float project_limit(void);
	inline void project_limit(float value);
	inline bool use_project_x(void);
	inline void use_project_x(bool value);
	inline bool use_project_y(void);
	inline void use_project_y(bool value);
	inline bool use_project_z(void);
	inline void use_project_z(bool value);
	inline int subsurf_levels(void);
	inline void subsurf_levels(int value);
	inline bool use_negative_direction(void);
	inline void use_negative_direction(bool value);
	inline bool use_positive_direction(void);
	inline void use_positive_direction(bool value);
	inline bool use_invert_cull(void);
	inline void use_invert_cull(bool value);
	inline bool invert_vertex_group(void);
	inline void invert_vertex_group(bool value);

};

/**************** Fluid Simulation Modifier ****************/

class FluidSimulationModifier : public Modifier {
public:
	FluidSimulationModifier(const PointerRNA &ptr_arg) :
		Modifier(ptr_arg)
		{}

	inline FluidSettings settings(void);

};

/**************** Mask Modifier ****************/

class MaskModifier : public Modifier {
public:
	MaskModifier(const PointerRNA &ptr_arg) :
		Modifier(ptr_arg)
		{}

	enum mode_enum {
		mode_VERTEX_GROUP = 0,
		mode_ARMATURE = 1,
	};
	inline mode_enum mode(void);
	inline void mode(mode_enum value);
	inline Object armature(void);
	inline std::string vertex_group(void);
	inline void vertex_group(const std::string& value);
	inline bool invert_vertex_group(void);
	inline void invert_vertex_group(bool value);
	inline float threshold(void);
	inline void threshold(float value);

};

/**************** SimpleDeform Modifier ****************/

class SimpleDeformModifier : public Modifier {
public:
	SimpleDeformModifier(const PointerRNA &ptr_arg) :
		Modifier(ptr_arg)
		{}

	enum deform_method_enum {
		deform_method_TWIST = 1,
		deform_method_BEND = 2,
		deform_method_TAPER = 3,
		deform_method_STRETCH = 4,
	};
	inline deform_method_enum deform_method(void);
	inline void deform_method(deform_method_enum value);
	inline std::string vertex_group(void);
	inline void vertex_group(const std::string& value);
	enum deform_axis_enum {
		deform_axis_X = 0,
		deform_axis_Y = 1,
		deform_axis_Z = 2,
	};
	inline deform_axis_enum deform_axis(void);
	inline void deform_axis(deform_axis_enum value);
	inline Object origin(void);
	inline float factor(void);
	inline void factor(float value);
	inline float angle(void);
	inline void angle(float value);
	inline Array<float, 2> limits(void);
	inline void limits(float values[2]);
	inline bool lock_x(void);
	inline void lock_x(bool value);
	inline bool lock_y(void);
	inline void lock_y(bool value);
	inline bool lock_z(void);
	inline void lock_z(bool value);
	inline bool invert_vertex_group(void);
	inline void invert_vertex_group(bool value);

};

/**************** Warp Modifier ****************/

class WarpModifier : public Modifier {
public:
	WarpModifier(const PointerRNA &ptr_arg) :
		Modifier(ptr_arg)
		{}

	inline Object object_from(void);
	inline Object object_to(void);
	inline float strength(void);
	inline void strength(float value);
	enum falloff_type_enum {
		falloff_type_NONE = 0,
		falloff_type_CURVE = 1,
		falloff_type_SMOOTH = 3,
		falloff_type_SPHERE = 7,
		falloff_type_ROOT = 4,
		falloff_type_INVERSE_SQUARE = 8,
		falloff_type_SHARP = 2,
		falloff_type_LINEAR = 5,
		falloff_type_CONSTANT = 6,
	};
	inline falloff_type_enum falloff_type(void);
	inline void falloff_type(falloff_type_enum value);
	inline float falloff_radius(void);
	inline void falloff_radius(float value);
	inline CurveMapping falloff_curve(void);
	inline bool use_volume_preserve(void);
	inline void use_volume_preserve(bool value);
	inline std::string vertex_group(void);
	inline void vertex_group(const std::string& value);
	inline Texture texture(void);
	enum texture_coords_enum {
		texture_coords_LOCAL = 0,
		texture_coords_GLOBAL = 1,
		texture_coords_OBJECT = 2,
		texture_coords_UV = 3,
	};
	inline texture_coords_enum texture_coords(void);
	inline void texture_coords(texture_coords_enum value);
	inline std::string uv_layer(void);
	inline void uv_layer(const std::string& value);
	inline Object texture_coords_object(void);

};

/**************** Multires Modifier ****************/

class MultiresModifier : public Modifier {
public:
	MultiresModifier(const PointerRNA &ptr_arg) :
		Modifier(ptr_arg)
		{}

	enum uv_smooth_enum {
		uv_smooth_NONE = 0,
		uv_smooth_PRESERVE_CORNERS = 1,
	};
	inline uv_smooth_enum uv_smooth(void);
	inline void uv_smooth(uv_smooth_enum value);
	inline int quality(void);
	inline void quality(int value);
	enum subdivision_type_enum {
		subdivision_type_CATMULL_CLARK = 0,
		subdivision_type_SIMPLE = 1,
	};
	inline subdivision_type_enum subdivision_type(void);
	inline void subdivision_type(subdivision_type_enum value);
	inline int levels(void);
	inline void levels(int value);
	inline int sculpt_levels(void);
	inline void sculpt_levels(int value);
	inline int render_levels(void);
	inline void render_levels(int value);
	inline int total_levels(void);
	inline void total_levels(int value);
	inline bool is_external(void);
	inline void is_external(bool value);
	inline std::string filepath(void);
	inline void filepath(const std::string& value);
	inline bool show_only_control_edges(void);
	inline void show_only_control_edges(bool value);
	inline bool use_creases(void);
	inline void use_creases(bool value);

};

/**************** Surface Modifier ****************/

class SurfaceModifier : public Modifier {
public:
	SurfaceModifier(const PointerRNA &ptr_arg) :
		Modifier(ptr_arg)
		{}


};

/**************** Smoke Modifier ****************/

class SmokeModifier : public Modifier {
public:
	SmokeModifier(const PointerRNA &ptr_arg) :
		Modifier(ptr_arg)
		{}

	inline SmokeDomainSettings domain_settings(void);
	inline SmokeFlowSettings flow_settings(void);
	inline SmokeCollSettings coll_settings(void);
	enum smoke_type_enum {
		smoke_type_NONE = 0,
		smoke_type_DOMAIN = 1,
		smoke_type_FLOW = 2,
		smoke_type_COLLISION = 4,
	};
	inline smoke_type_enum smoke_type(void);
	inline void smoke_type(smoke_type_enum value);

};

/**************** Solidify Modifier ****************/

class SolidifyModifier : public Modifier {
public:
	SolidifyModifier(const PointerRNA &ptr_arg) :
		Modifier(ptr_arg)
		{}

	inline float thickness(void);
	inline void thickness(float value);
	inline float thickness_clamp(void);
	inline void thickness_clamp(float value);
	inline float thickness_vertex_group(void);
	inline void thickness_vertex_group(float value);
	inline float offset(void);
	inline void offset(float value);
	inline float edge_crease_inner(void);
	inline void edge_crease_inner(float value);
	inline float edge_crease_outer(void);
	inline void edge_crease_outer(float value);
	inline float edge_crease_rim(void);
	inline void edge_crease_rim(float value);
	inline int material_offset(void);
	inline void material_offset(int value);
	inline int material_offset_rim(void);
	inline void material_offset_rim(int value);
	inline std::string vertex_group(void);
	inline void vertex_group(const std::string& value);
	inline bool use_rim(void);
	inline void use_rim(bool value);
	inline bool use_even_offset(void);
	inline void use_even_offset(bool value);
	inline bool use_quality_normals(void);
	inline void use_quality_normals(bool value);
	inline bool invert_vertex_group(void);
	inline void invert_vertex_group(bool value);
	inline bool use_flip_normals(void);
	inline void use_flip_normals(bool value);
	inline bool use_rim_only(void);
	inline void use_rim_only(bool value);

};

/**************** Screw Modifier ****************/

class ScrewModifier : public Modifier {
public:
	ScrewModifier(const PointerRNA &ptr_arg) :
		Modifier(ptr_arg)
		{}

	inline Object object(void);
	inline int steps(void);
	inline void steps(int value);
	inline int render_steps(void);
	inline void render_steps(int value);
	inline int iterations(void);
	inline void iterations(int value);
	enum axis_enum {
		axis_X = 0,
		axis_Y = 1,
		axis_Z = 2,
	};
	inline axis_enum axis(void);
	inline void axis(axis_enum value);
	inline float angle(void);
	inline void angle(float value);
	inline float screw_offset(void);
	inline void screw_offset(float value);
	inline float merge_threshold(void);
	inline void merge_threshold(float value);
	inline bool use_normal_flip(void);
	inline void use_normal_flip(bool value);
	inline bool use_normal_calculate(void);
	inline void use_normal_calculate(bool value);
	inline bool use_object_screw_offset(void);
	inline void use_object_screw_offset(bool value);
	inline bool use_merge_vertices(void);
	inline void use_merge_vertices(bool value);
	inline bool use_smooth_shade(void);
	inline void use_smooth_shade(bool value);
	inline bool use_stretch_u(void);
	inline void use_stretch_u(bool value);
	inline bool use_stretch_v(void);
	inline void use_stretch_v(bool value);

};

/**************** UVWarp Modifier ****************/

class UVWarpModifier : public Modifier {
public:
	UVWarpModifier(const PointerRNA &ptr_arg) :
		Modifier(ptr_arg)
		{}

	enum axis_u_enum {
		axis_u_X = 0,
		axis_u_Y = 1,
		axis_u_Z = 2,
	};
	inline axis_u_enum axis_u(void);
	inline void axis_u(axis_u_enum value);
	enum axis_v_enum {
		axis_v_X = 0,
		axis_v_Y = 1,
		axis_v_Z = 2,
	};
	inline axis_v_enum axis_v(void);
	inline void axis_v(axis_v_enum value);
	inline Array<float, 2> center(void);
	inline void center(float values[2]);
	inline Object object_from(void);
	inline std::string bone_from(void);
	inline void bone_from(const std::string& value);
	inline Object object_to(void);
	inline std::string bone_to(void);
	inline void bone_to(const std::string& value);
	inline std::string vertex_group(void);
	inline void vertex_group(const std::string& value);
	inline std::string uv_layer(void);
	inline void uv_layer(const std::string& value);

};

/**************** WeightVG Edit Modifier ****************/

class VertexWeightEditModifier : public Modifier {
public:
	VertexWeightEditModifier(const PointerRNA &ptr_arg) :
		Modifier(ptr_arg)
		{}

	inline std::string vertex_group(void);
	inline void vertex_group(const std::string& value);
	enum falloff_type_enum {
		falloff_type_LINEAR = 0,
		falloff_type_CURVE = 1,
		falloff_type_SHARP = 2,
		falloff_type_SMOOTH = 3,
		falloff_type_ROOT = 4,
		falloff_type_ICON_SPHERECURVE = 7,
		falloff_type_RANDOM = 8,
		falloff_type_STEP = 9,
	};
	inline falloff_type_enum falloff_type(void);
	inline void falloff_type(falloff_type_enum value);
	inline bool use_add(void);
	inline void use_add(bool value);
	inline bool use_remove(void);
	inline void use_remove(bool value);
	inline float default_weight(void);
	inline void default_weight(float value);
	inline CurveMapping map_curve(void);
	inline float add_threshold(void);
	inline void add_threshold(float value);
	inline float remove_threshold(void);
	inline void remove_threshold(float value);
	inline float mask_constant(void);
	inline void mask_constant(float value);
	inline std::string mask_vertex_group(void);
	inline void mask_vertex_group(const std::string& value);
	inline Texture mask_texture(void);
	enum mask_tex_use_channel_enum {
		mask_tex_use_channel_INT = 1,
		mask_tex_use_channel_RED = 2,
		mask_tex_use_channel_GREEN = 3,
		mask_tex_use_channel_BLUE = 4,
		mask_tex_use_channel_HUE = 5,
		mask_tex_use_channel_SAT = 6,
		mask_tex_use_channel_VAL = 7,
		mask_tex_use_channel_ALPHA = 8,
	};
	inline mask_tex_use_channel_enum mask_tex_use_channel(void);
	inline void mask_tex_use_channel(mask_tex_use_channel_enum value);
	enum mask_tex_mapping_enum {
		mask_tex_mapping_LOCAL = 0,
		mask_tex_mapping_GLOBAL = 1,
		mask_tex_mapping_OBJECT = 2,
		mask_tex_mapping_UV = 3,
	};
	inline mask_tex_mapping_enum mask_tex_mapping(void);
	inline void mask_tex_mapping(mask_tex_mapping_enum value);
	inline std::string mask_tex_uv_layer(void);
	inline void mask_tex_uv_layer(const std::string& value);
	inline Object mask_tex_map_object(void);

};

/**************** WeightVG Mix Modifier ****************/

class VertexWeightMixModifier : public Modifier {
public:
	VertexWeightMixModifier(const PointerRNA &ptr_arg) :
		Modifier(ptr_arg)
		{}

	inline std::string vertex_group_a(void);
	inline void vertex_group_a(const std::string& value);
	inline std::string vertex_group_b(void);
	inline void vertex_group_b(const std::string& value);
	inline float default_weight_a(void);
	inline void default_weight_a(float value);
	inline float default_weight_b(void);
	inline void default_weight_b(float value);
	enum mix_mode_enum {
		mix_mode_SET = 1,
		mix_mode_ADD = 2,
		mix_mode_SUB = 3,
		mix_mode_MUL = 4,
		mix_mode_DIV = 5,
		mix_mode_DIF = 6,
		mix_mode_AVG = 7,
	};
	inline mix_mode_enum mix_mode(void);
	inline void mix_mode(mix_mode_enum value);
	enum mix_set_enum {
		mix_set_ALL = 1,
		mix_set_A = 2,
		mix_set_B = 3,
		mix_set_OR = 4,
		mix_set_AND = 5,
	};
	inline mix_set_enum mix_set(void);
	inline void mix_set(mix_set_enum value);
	inline float mask_constant(void);
	inline void mask_constant(float value);
	inline std::string mask_vertex_group(void);
	inline void mask_vertex_group(const std::string& value);
	inline Texture mask_texture(void);
	enum mask_tex_use_channel_enum {
		mask_tex_use_channel_INT = 1,
		mask_tex_use_channel_RED = 2,
		mask_tex_use_channel_GREEN = 3,
		mask_tex_use_channel_BLUE = 4,
		mask_tex_use_channel_HUE = 5,
		mask_tex_use_channel_SAT = 6,
		mask_tex_use_channel_VAL = 7,
		mask_tex_use_channel_ALPHA = 8,
	};
	inline mask_tex_use_channel_enum mask_tex_use_channel(void);
	inline void mask_tex_use_channel(mask_tex_use_channel_enum value);
	enum mask_tex_mapping_enum {
		mask_tex_mapping_LOCAL = 0,
		mask_tex_mapping_GLOBAL = 1,
		mask_tex_mapping_OBJECT = 2,
		mask_tex_mapping_UV = 3,
	};
	inline mask_tex_mapping_enum mask_tex_mapping(void);
	inline void mask_tex_mapping(mask_tex_mapping_enum value);
	inline std::string mask_tex_uv_layer(void);
	inline void mask_tex_uv_layer(const std::string& value);
	inline Object mask_tex_map_object(void);

};

/**************** WeightVG Proximity Modifier ****************/

class VertexWeightProximityModifier : public Modifier {
public:
	VertexWeightProximityModifier(const PointerRNA &ptr_arg) :
		Modifier(ptr_arg)
		{}

	inline std::string vertex_group(void);
	inline void vertex_group(const std::string& value);
	enum proximity_mode_enum {
		proximity_mode_OBJECT = 1,
		proximity_mode_GEOMETRY = 2,
	};
	inline proximity_mode_enum proximity_mode(void);
	inline void proximity_mode(proximity_mode_enum value);
	enum proximity_geometry_enum {
		proximity_geometry_VERTEX = 1,
		proximity_geometry_EDGE = 2,
		proximity_geometry_FACE = 4,
	};
	inline proximity_geometry_enum proximity_geometry(void);
	inline void proximity_geometry(proximity_geometry_enum value);
	inline Object target(void);
	inline float min_dist(void);
	inline void min_dist(float value);
	inline float max_dist(void);
	inline void max_dist(float value);
	enum falloff_type_enum {
		falloff_type_LINEAR = 0,
		falloff_type_SHARP = 2,
		falloff_type_SMOOTH = 3,
		falloff_type_ROOT = 4,
		falloff_type_ICON_SPHERECURVE = 7,
		falloff_type_RANDOM = 8,
		falloff_type_STEP = 9,
	};
	inline falloff_type_enum falloff_type(void);
	inline void falloff_type(falloff_type_enum value);
	inline float mask_constant(void);
	inline void mask_constant(float value);
	inline std::string mask_vertex_group(void);
	inline void mask_vertex_group(const std::string& value);
	inline Texture mask_texture(void);
	enum mask_tex_use_channel_enum {
		mask_tex_use_channel_INT = 1,
		mask_tex_use_channel_RED = 2,
		mask_tex_use_channel_GREEN = 3,
		mask_tex_use_channel_BLUE = 4,
		mask_tex_use_channel_HUE = 5,
		mask_tex_use_channel_SAT = 6,
		mask_tex_use_channel_VAL = 7,
		mask_tex_use_channel_ALPHA = 8,
	};
	inline mask_tex_use_channel_enum mask_tex_use_channel(void);
	inline void mask_tex_use_channel(mask_tex_use_channel_enum value);
	enum mask_tex_mapping_enum {
		mask_tex_mapping_LOCAL = 0,
		mask_tex_mapping_GLOBAL = 1,
		mask_tex_mapping_OBJECT = 2,
		mask_tex_mapping_UV = 3,
	};
	inline mask_tex_mapping_enum mask_tex_mapping(void);
	inline void mask_tex_mapping(mask_tex_mapping_enum value);
	inline std::string mask_tex_uv_layer(void);
	inline void mask_tex_uv_layer(const std::string& value);
	inline Object mask_tex_map_object(void);

};

/**************** Dynamic Paint Modifier ****************/

class DynamicPaintModifier : public Modifier {
public:
	DynamicPaintModifier(const PointerRNA &ptr_arg) :
		Modifier(ptr_arg)
		{}

	inline DynamicPaintCanvasSettings canvas_settings(void);
	inline DynamicPaintBrushSettings brush_settings(void);
	enum ui_type_enum {
		ui_type_CANVAS = 1,
		ui_type_BRUSH = 2,
	};
	inline ui_type_enum ui_type(void);
	inline void ui_type(ui_type_enum value);

};

/**************** Ocean Modifier ****************/

class OceanModifier : public Modifier {
public:
	OceanModifier(const PointerRNA &ptr_arg) :
		Modifier(ptr_arg)
		{}

	enum geometry_mode_enum {
		geometry_mode_GENERATE = 0,
		geometry_mode_DISPLACE = 1,
	};
	inline geometry_mode_enum geometry_mode(void);
	inline void geometry_mode(geometry_mode_enum value);
	inline float size(void);
	inline void size(float value);
	inline int repeat_x(void);
	inline void repeat_x(int value);
	inline int repeat_y(void);
	inline void repeat_y(int value);
	inline bool use_normals(void);
	inline void use_normals(bool value);
	inline bool use_foam(void);
	inline void use_foam(bool value);
	inline int resolution(void);
	inline void resolution(int value);
	inline int spatial_size(void);
	inline void spatial_size(int value);
	inline float wind_velocity(void);
	inline void wind_velocity(float value);
	inline float damping(void);
	inline void damping(float value);
	inline float wave_scale_min(void);
	inline void wave_scale_min(float value);
	inline float wave_alignment(void);
	inline void wave_alignment(float value);
	inline float wave_direction(void);
	inline void wave_direction(float value);
	inline float wave_scale(void);
	inline void wave_scale(float value);
	inline float depth(void);
	inline void depth(float value);
	inline float foam_coverage(void);
	inline void foam_coverage(float value);
	inline float bake_foam_fade(void);
	inline void bake_foam_fade(float value);
	inline std::string foam_layer_name(void);
	inline void foam_layer_name(const std::string& value);
	inline float choppiness(void);
	inline void choppiness(float value);
	inline float time(void);
	inline void time(float value);
	inline int random_seed(void);
	inline void random_seed(int value);
	inline int frame_start(void);
	inline void frame_start(int value);
	inline int frame_end(void);
	inline void frame_end(int value);
	inline bool is_cached(void);
	inline void is_cached(bool value);
	inline std::string filepath(void);
	inline void filepath(const std::string& value);

};

/**************** Remesh Modifier ****************/

class RemeshModifier : public Modifier {
public:
	RemeshModifier(const PointerRNA &ptr_arg) :
		Modifier(ptr_arg)
		{}

	enum mode_enum {
		mode_BLOCKS = 0,
		mode_SMOOTH = 1,
		mode_SHARP = 2,
	};
	inline mode_enum mode(void);
	inline void mode(mode_enum value);
	inline float scale(void);
	inline void scale(float value);
	inline float threshold(void);
	inline void threshold(float value);
	inline int octree_depth(void);
	inline void octree_depth(int value);
	inline float sharpness(void);
	inline void sharpness(float value);
	inline bool use_remove_disconnected(void);
	inline void use_remove_disconnected(bool value);
	inline bool use_smooth_shade(void);
	inline void use_smooth_shade(bool value);

};

/**************** Skin Modifier ****************/

class SkinModifier : public Modifier {
public:
	SkinModifier(const PointerRNA &ptr_arg) :
		Modifier(ptr_arg)
		{}

	inline float branch_smoothing(void);
	inline void branch_smoothing(float value);
	inline bool use_smooth_shade(void);
	inline void use_smooth_shade(bool value);
	inline bool use_x_symmetry(void);
	inline void use_x_symmetry(bool value);
	inline bool use_y_symmetry(void);
	inline void use_y_symmetry(bool value);
	inline bool use_z_symmetry(void);
	inline void use_z_symmetry(bool value);

};

/**************** Laplacian Smooth Modifier ****************/

class LaplacianSmoothModifier : public Modifier {
public:
	LaplacianSmoothModifier(const PointerRNA &ptr_arg) :
		Modifier(ptr_arg)
		{}

	inline bool use_x(void);
	inline void use_x(bool value);
	inline bool use_y(void);
	inline void use_y(bool value);
	inline bool use_z(void);
	inline void use_z(bool value);
	inline bool use_volume_preserve(void);
	inline void use_volume_preserve(bool value);
	inline bool use_normalized(void);
	inline void use_normalized(bool value);
	inline float lambda_factor(void);
	inline void lambda_factor(float value);
	inline float lambda_border(void);
	inline void lambda_border(float value);
	inline int iterations(void);
	inline void iterations(int value);
	inline std::string vertex_group(void);
	inline void vertex_group(const std::string& value);

};

/**************** Triangulate Modifier ****************/

class TriangulateModifier : public Modifier {
public:
	TriangulateModifier(const PointerRNA &ptr_arg) :
		Modifier(ptr_arg)
		{}

	enum quad_method_enum {
		quad_method_BEAUTY = 0,
		quad_method_FIXED = 1,
		quad_method_FIXED_ALTERNATE = 2,
		quad_method_SHORTEST_DIAGONAL = 3,
	};
	inline quad_method_enum quad_method(void);
	inline void quad_method(quad_method_enum value);
	enum ngon_method_enum {
		ngon_method_BEAUTY = 0,
		ngon_method_CLIP = 1,
	};
	inline ngon_method_enum ngon_method(void);
	inline void ngon_method(ngon_method_enum value);
	inline int min_vertices(void);
	inline void min_vertices(int value);
	inline bool keep_custom_normals(void);
	inline void keep_custom_normals(bool value);

};

/**************** Cache Modifier ****************/

class MeshCacheModifier : public Modifier {
public:
	MeshCacheModifier(const PointerRNA &ptr_arg) :
		Modifier(ptr_arg)
		{}

	enum cache_format_enum {
		cache_format_MDD = 1,
		cache_format_PC2 = 2,
	};
	inline cache_format_enum cache_format(void);
	inline void cache_format(cache_format_enum value);
	enum interpolation_enum {
		interpolation_NONE = 0,
		interpolation_LINEAR = 1,
	};
	inline interpolation_enum interpolation(void);
	inline void interpolation(interpolation_enum value);
	enum time_mode_enum {
		time_mode_FRAME = 0,
		time_mode_TIME = 1,
		time_mode_FACTOR = 2,
	};
	inline time_mode_enum time_mode(void);
	inline void time_mode(time_mode_enum value);
	enum play_mode_enum {
		play_mode_SCENE = 0,
		play_mode_CUSTOM = 1,
	};
	inline play_mode_enum play_mode(void);
	inline void play_mode(play_mode_enum value);
	enum deform_mode_enum {
		deform_mode_OVERWRITE = 0,
		deform_mode_INTEGRATE = 1,
	};
	inline deform_mode_enum deform_mode(void);
	inline void deform_mode(deform_mode_enum value);
	inline std::string filepath(void);
	inline void filepath(const std::string& value);
	inline float factor(void);
	inline void factor(float value);
	enum forward_axis_enum {
		forward_axis_POS_X = 0,
		forward_axis_POS_Y = 1,
		forward_axis_POS_Z = 2,
		forward_axis_NEG_X = 3,
		forward_axis_NEG_Y = 4,
		forward_axis_NEG_Z = 5,
	};
	inline forward_axis_enum forward_axis(void);
	inline void forward_axis(forward_axis_enum value);
	enum up_axis_enum {
		up_axis_POS_X = 0,
		up_axis_POS_Y = 1,
		up_axis_POS_Z = 2,
		up_axis_NEG_X = 3,
		up_axis_NEG_Y = 4,
		up_axis_NEG_Z = 5,
	};
	inline up_axis_enum up_axis(void);
	inline void up_axis(up_axis_enum value);
	enum flip_axis_enum {
		flip_axis_X = 1,
		flip_axis_Y = 2,
		flip_axis_Z = 4,
	};
	inline flip_axis_enum flip_axis(void);
	inline void flip_axis(flip_axis_enum value);
	inline float frame_start(void);
	inline void frame_start(float value);
	inline float frame_scale(void);
	inline void frame_scale(float value);
	inline float eval_frame(void);
	inline void eval_frame(float value);
	inline float eval_time(void);
	inline void eval_time(float value);
	inline float eval_factor(void);
	inline void eval_factor(float value);

};

/**************** Laplacian Deform Modifier ****************/

class LaplacianDeformModifier : public Modifier {
public:
	LaplacianDeformModifier(const PointerRNA &ptr_arg) :
		Modifier(ptr_arg)
		{}

	inline std::string vertex_group(void);
	inline void vertex_group(const std::string& value);
	inline int iterations(void);
	inline void iterations(int value);
	inline bool is_bind(void);
	inline void is_bind(bool value);

};

/**************** Wireframe Modifier ****************/

class WireframeModifier : public Modifier {
public:
	WireframeModifier(const PointerRNA &ptr_arg) :
		Modifier(ptr_arg)
		{}

	inline float thickness(void);
	inline void thickness(float value);
	inline float thickness_vertex_group(void);
	inline void thickness_vertex_group(float value);
	inline float offset(void);
	inline void offset(float value);
	inline bool use_replace(void);
	inline void use_replace(bool value);
	inline bool use_boundary(void);
	inline void use_boundary(bool value);
	inline bool use_even_offset(void);
	inline void use_even_offset(bool value);
	inline bool use_relative_offset(void);
	inline void use_relative_offset(bool value);
	inline bool use_crease(void);
	inline void use_crease(bool value);
	inline float crease_weight(void);
	inline void crease_weight(float value);
	inline int material_offset(void);
	inline void material_offset(int value);
	inline std::string vertex_group(void);
	inline void vertex_group(const std::string& value);
	inline bool invert_vertex_group(void);
	inline void invert_vertex_group(bool value);

};

/**************** Data Transfer Modifier ****************/

class DataTransferModifier : public Modifier {
public:
	DataTransferModifier(const PointerRNA &ptr_arg) :
		Modifier(ptr_arg)
		{}

	inline Object object(void);
	inline bool use_object_transform(void);
	inline void use_object_transform(bool value);
	inline bool use_vert_data(void);
	inline void use_vert_data(bool value);
	inline bool use_edge_data(void);
	inline void use_edge_data(bool value);
	inline bool use_loop_data(void);
	inline void use_loop_data(bool value);
	inline bool use_poly_data(void);
	inline void use_poly_data(bool value);
	enum data_types_verts_enum {
		data_types_verts_VGROUP_WEIGHTS = 1,
		data_types_verts_BEVEL_WEIGHT_VERT = 8,
	};
	inline data_types_verts_enum data_types_verts(void);
	inline void data_types_verts(data_types_verts_enum value);
	enum data_types_edges_enum {
		data_types_edges_SHARP_EDGE = 256,
		data_types_edges_SEAM = 512,
		data_types_edges_CREASE = 1024,
		data_types_edges_BEVEL_WEIGHT_EDGE = 2048,
		data_types_edges_FREESTYLE_EDGE = 4096,
	};
	inline data_types_edges_enum data_types_edges(void);
	inline void data_types_edges(data_types_edges_enum value);
	enum data_types_loops_enum {
		data_types_loops_CUSTOM_NORMAL = 131072,
		data_types_loops_VCOL = 65536,
		data_types_loops_UV = 16777216,
	};
	inline data_types_loops_enum data_types_loops(void);
	inline void data_types_loops(data_types_loops_enum value);
	enum data_types_polys_enum {
		data_types_polys_SMOOTH = 33554432,
		data_types_polys_FREESTYLE_FACE = 67108864,
	};
	inline data_types_polys_enum data_types_polys(void);
	inline void data_types_polys(data_types_polys_enum value);
	enum vert_mapping_enum {
		vert_mapping_TOPOLOGY = 251658240,
		vert_mapping_NEAREST = 16777488,
		vert_mapping_EDGE_NEAREST = 16777504,
		vert_mapping_EDGEINTERP_NEAREST = 16778528,
		vert_mapping_POLY_NEAREST = 16777600,
		vert_mapping_POLYINTERP_NEAREST = 16778624,
		vert_mapping_POLYINTERP_VNORPROJ = 16778880,
	};
	inline vert_mapping_enum vert_mapping(void);
	inline void vert_mapping(vert_mapping_enum value);
	enum edge_mapping_enum {
		edge_mapping_TOPOLOGY = 251658240,
		edge_mapping_VERT_NEAREST = 33554704,
		edge_mapping_NEAREST = 33554720,
		edge_mapping_POLY_NEAREST = 33554816,
		edge_mapping_EDGEINTERP_VNORPROJ = 33555984,
	};
	inline edge_mapping_enum edge_mapping(void);
	inline void edge_mapping(edge_mapping_enum value);
	enum loop_mapping_enum {
		loop_mapping_TOPOLOGY = 251658240,
		loop_mapping_NEAREST_NORMAL = 67111248,
		loop_mapping_NEAREST_POLYNOR = 67111312,
		loop_mapping_NEAREST_POLY = 67109248,
		loop_mapping_POLYINTERP_NEAREST = 67110272,
		loop_mapping_POLYINTERP_LNORPROJ = 67110528,
	};
	inline loop_mapping_enum loop_mapping(void);
	inline void loop_mapping(loop_mapping_enum value);
	enum poly_mapping_enum {
		poly_mapping_TOPOLOGY = 251658240,
		poly_mapping_NEAREST = 134218112,
		poly_mapping_NORMAL = 134219904,
		poly_mapping_POLYINTERP_PNORPROJ = 134219392,
	};
	inline poly_mapping_enum poly_mapping(void);
	inline void poly_mapping(poly_mapping_enum value);
	inline bool use_max_distance(void);
	inline void use_max_distance(bool value);
	inline float max_distance(void);
	inline void max_distance(float value);
	inline float ray_radius(void);
	inline void ray_radius(float value);
	inline float islands_precision(void);
	inline void islands_precision(float value);
	enum layers_vgroup_select_src_enum {
		layers_vgroup_select_src_ACTIVE = -1,
		layers_vgroup_select_src_ALL = -2,
		layers_vgroup_select_src_BONE_SELECT = -257,
		layers_vgroup_select_src_BONE_DEFORM = -258,
	};
	inline layers_vgroup_select_src_enum layers_vgroup_select_src(void);
	inline void layers_vgroup_select_src(layers_vgroup_select_src_enum value);
	enum layers_vcol_select_src_enum {
		layers_vcol_select_src_ACTIVE = -1,
		layers_vcol_select_src_ALL = -2,
		layers_vcol_select_src_BONE_SELECT = -257,
		layers_vcol_select_src_BONE_DEFORM = -258,
	};
	inline layers_vcol_select_src_enum layers_vcol_select_src(void);
	inline void layers_vcol_select_src(layers_vcol_select_src_enum value);
	enum layers_uv_select_src_enum {
		layers_uv_select_src_ACTIVE = -1,
		layers_uv_select_src_ALL = -2,
		layers_uv_select_src_BONE_SELECT = -257,
		layers_uv_select_src_BONE_DEFORM = -258,
	};
	inline layers_uv_select_src_enum layers_uv_select_src(void);
	inline void layers_uv_select_src(layers_uv_select_src_enum value);
	enum layers_vgroup_select_dst_enum {
		layers_vgroup_select_dst_ACTIVE = -1,
		layers_vgroup_select_dst_NAME = -2,
		layers_vgroup_select_dst_INDEX = -3,
	};
	inline layers_vgroup_select_dst_enum layers_vgroup_select_dst(void);
	inline void layers_vgroup_select_dst(layers_vgroup_select_dst_enum value);
	enum layers_vcol_select_dst_enum {
		layers_vcol_select_dst_ACTIVE = -1,
		layers_vcol_select_dst_NAME = -2,
		layers_vcol_select_dst_INDEX = -3,
	};
	inline layers_vcol_select_dst_enum layers_vcol_select_dst(void);
	inline void layers_vcol_select_dst(layers_vcol_select_dst_enum value);
	enum layers_uv_select_dst_enum {
		layers_uv_select_dst_ACTIVE = -1,
		layers_uv_select_dst_NAME = -2,
		layers_uv_select_dst_INDEX = -3,
	};
	inline layers_uv_select_dst_enum layers_uv_select_dst(void);
	inline void layers_uv_select_dst(layers_uv_select_dst_enum value);
	enum mix_mode_enum {
		mix_mode_REPLACE = 0,
		mix_mode_ABOVE_THRESHOLD = 1,
		mix_mode_BELOW_THRESHOLD = 2,
		mix_mode_MIX = 16,
		mix_mode_ADD = 17,
		mix_mode_SUB = 18,
		mix_mode_MUL = 19,
	};
	inline mix_mode_enum mix_mode(void);
	inline void mix_mode(mix_mode_enum value);
	inline float mix_factor(void);
	inline void mix_factor(float value);
	inline std::string vertex_group(void);
	inline void vertex_group(const std::string& value);
	inline bool invert_vertex_group(void);
	inline void invert_vertex_group(bool value);

};

/**************** Normal Edit Modifier ****************/

class NormalEditModifier : public Modifier {
public:
	NormalEditModifier(const PointerRNA &ptr_arg) :
		Modifier(ptr_arg)
		{}

	enum mode_enum {
		mode_RADIAL = 0,
		mode_DIRECTIONAL = 1,
	};
	inline mode_enum mode(void);
	inline void mode(mode_enum value);
	inline Array<float, 3> offset(void);
	inline void offset(float values[3]);
	enum mix_mode_enum {
		mix_mode_COPY = 0,
		mix_mode_ADD = 1,
		mix_mode_SUB = 2,
		mix_mode_MUL = 3,
	};
	inline mix_mode_enum mix_mode(void);
	inline void mix_mode(mix_mode_enum value);
	inline float mix_factor(void);
	inline void mix_factor(float value);
	inline float mix_limit(void);
	inline void mix_limit(float value);
	inline bool no_polynors_fix(void);
	inline void no_polynors_fix(bool value);
	inline std::string vertex_group(void);
	inline void vertex_group(const std::string& value);
	inline bool invert_vertex_group(void);
	inline void invert_vertex_group(bool value);
	inline Object target(void);
	inline bool use_direction_parallel(void);
	inline void use_direction_parallel(bool value);

};

/**************** Cache Modifier ****************/

class MeshSequenceCacheModifier : public Modifier {
public:
	MeshSequenceCacheModifier(const PointerRNA &ptr_arg) :
		Modifier(ptr_arg)
		{}

	inline CacheFile cache_file(void);
	inline std::string object_path(void);
	inline void object_path(const std::string& value);
	enum read_data_enum {
		read_data_VERT = 1,
		read_data_POLY = 2,
		read_data_UV = 4,
		read_data_COLOR = 8,
	};
	inline read_data_enum read_data(void);
	inline void read_data(read_data_enum value);

};

/**************** SurfaceDeform Modifier ****************/

class SurfaceDeformModifier : public Modifier {
public:
	SurfaceDeformModifier(const PointerRNA &ptr_arg) :
		Modifier(ptr_arg)
		{}

	inline Object target(void);
	inline float falloff(void);
	inline void falloff(float value);
	inline bool is_bound(void);
	inline void is_bound(bool value);

};

/**************** WeightedNormal Modifier ****************/

class WeightedNormalModifier : public Modifier {
public:
	WeightedNormalModifier(const PointerRNA &ptr_arg) :
		Modifier(ptr_arg)
		{}

	inline int weight(void);
	inline void weight(int value);
	enum mode_enum {
		mode_FACE_AREA = 0,
		mode_CORNER_ANGLE = 1,
		mode_FACE_AREA_WITH_ANGLE = 2,
	};
	inline mode_enum mode(void);
	inline void mode(mode_enum value);
	inline float thresh(void);
	inline void thresh(float value);
	inline bool keep_sharp(void);
	inline void keep_sharp(bool value);
	inline std::string vertex_group(void);
	inline void vertex_group(const std::string& value);
	inline bool invert_vertex_group(void);
	inline void invert_vertex_group(bool value);
	inline bool face_influence(void);
	inline void face_influence(bool value);

};

/**************** GpencilModifier ****************/

class GpencilModifier : public Pointer {
public:
	GpencilModifier(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string name(void);
	inline void name(const std::string& value);
	enum type_enum {
		type_GP_ARRAY = 5,
		type_GP_BUILD = 6,
		type_GP_MIRROR = 14,
		type_GP_SIMPLIFY = 10,
		type_GP_SUBDIV = 2,
		type_GP_ARMATURE = 15,
		type_GP_HOOK = 12,
		type_GP_LATTICE = 9,
		type_GP_NOISE = 1,
		type_GP_OFFSET = 13,
		type_GP_SMOOTH = 11,
		type_GP_THICK = 3,
		type_GP_TIME = 16,
		type_GP_COLOR = 8,
		type_GP_OPACITY = 7,
		type_GP_TINT = 4,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	inline bool show_viewport(void);
	inline void show_viewport(bool value);
	inline bool show_render(void);
	inline void show_render(bool value);
	inline bool show_in_editmode(void);
	inline void show_in_editmode(bool value);
	inline bool show_expanded(void);
	inline void show_expanded(bool value);

};

/**************** Noise Modifier ****************/

class NoiseGpencilModifier : public GpencilModifier {
public:
	NoiseGpencilModifier(const PointerRNA &ptr_arg) :
		GpencilModifier(ptr_arg)
		{}

	inline std::string layer(void);
	inline void layer(const std::string& value);
	inline std::string vertex_group(void);
	inline void vertex_group(const std::string& value);
	inline float factor(void);
	inline void factor(float value);
	inline bool random(void);
	inline void random(bool value);
	inline bool use_edit_position(void);
	inline void use_edit_position(bool value);
	inline bool use_edit_strength(void);
	inline void use_edit_strength(bool value);
	inline bool use_edit_thickness(void);
	inline void use_edit_thickness(bool value);
	inline bool use_edit_uv(void);
	inline void use_edit_uv(bool value);
	inline bool full_stroke(void);
	inline void full_stroke(bool value);
	inline bool move_extreme(void);
	inline void move_extreme(bool value);
	inline int pass_index(void);
	inline void pass_index(int value);
	inline int step(void);
	inline void step(int value);
	inline bool invert_layers(void);
	inline void invert_layers(bool value);
	inline bool invert_material_pass(void);
	inline void invert_material_pass(bool value);
	inline bool invert_vertex(void);
	inline void invert_vertex(bool value);
	inline int layer_pass(void);
	inline void layer_pass(int value);
	inline bool invert_layer_pass(void);
	inline void invert_layer_pass(bool value);

};

/**************** Smooth Modifier ****************/

class SmoothGpencilModifier : public GpencilModifier {
public:
	SmoothGpencilModifier(const PointerRNA &ptr_arg) :
		GpencilModifier(ptr_arg)
		{}

	inline std::string layer(void);
	inline void layer(const std::string& value);
	inline std::string vertex_group(void);
	inline void vertex_group(const std::string& value);
	inline float factor(void);
	inline void factor(float value);
	inline bool use_edit_position(void);
	inline void use_edit_position(bool value);
	inline bool use_edit_strength(void);
	inline void use_edit_strength(bool value);
	inline bool use_edit_thickness(void);
	inline void use_edit_thickness(bool value);
	inline bool use_edit_uv(void);
	inline void use_edit_uv(bool value);
	inline int pass_index(void);
	inline void pass_index(int value);
	inline int step(void);
	inline void step(int value);
	inline bool invert_layers(void);
	inline void invert_layers(bool value);
	inline bool invert_material_pass(void);
	inline void invert_material_pass(bool value);
	inline bool invert_vertex(void);
	inline void invert_vertex(bool value);
	inline int layer_pass(void);
	inline void layer_pass(int value);
	inline bool invert_layer_pass(void);
	inline void invert_layer_pass(bool value);

};

/**************** Subdivision Modifier ****************/

class SubdivGpencilModifier : public GpencilModifier {
public:
	SubdivGpencilModifier(const PointerRNA &ptr_arg) :
		GpencilModifier(ptr_arg)
		{}

	inline std::string layer(void);
	inline void layer(const std::string& value);
	inline int level(void);
	inline void level(int value);
	inline bool simple(void);
	inline void simple(bool value);
	inline int pass_index(void);
	inline void pass_index(int value);
	inline bool invert_layers(void);
	inline void invert_layers(bool value);
	inline bool invert_material_pass(void);
	inline void invert_material_pass(bool value);
	inline int layer_pass(void);
	inline void layer_pass(int value);
	inline bool invert_layer_pass(void);
	inline void invert_layer_pass(bool value);

};

/**************** Simplify Modifier ****************/

class SimplifyGpencilModifier : public GpencilModifier {
public:
	SimplifyGpencilModifier(const PointerRNA &ptr_arg) :
		GpencilModifier(ptr_arg)
		{}

	inline std::string layer(void);
	inline void layer(const std::string& value);
	inline float factor(void);
	inline void factor(float value);
	inline int pass_index(void);
	inline void pass_index(int value);
	inline bool invert_layers(void);
	inline void invert_layers(bool value);
	inline bool invert_material_pass(void);
	inline void invert_material_pass(bool value);
	inline int layer_pass(void);
	inline void layer_pass(int value);
	inline bool invert_layer_pass(void);
	inline void invert_layer_pass(bool value);
	enum mode_enum {
		mode_FIXED = 0,
		mode_ADAPTIVE = 1,
	};
	inline mode_enum mode(void);
	inline void mode(mode_enum value);
	inline int step(void);
	inline void step(int value);

};

/**************** Thick Modifier ****************/

class ThickGpencilModifier : public GpencilModifier {
public:
	ThickGpencilModifier(const PointerRNA &ptr_arg) :
		GpencilModifier(ptr_arg)
		{}

	inline std::string layer(void);
	inline void layer(const std::string& value);
	inline std::string vertex_group(void);
	inline void vertex_group(const std::string& value);
	inline int thickness(void);
	inline void thickness(int value);
	inline int pass_index(void);
	inline void pass_index(int value);
	inline bool invert_layers(void);
	inline void invert_layers(bool value);
	inline bool invert_material_pass(void);
	inline void invert_material_pass(bool value);
	inline bool invert_vertex(void);
	inline void invert_vertex(bool value);
	inline int layer_pass(void);
	inline void layer_pass(int value);
	inline bool invert_layer_pass(void);
	inline void invert_layer_pass(bool value);
	inline bool use_custom_curve(void);
	inline void use_custom_curve(bool value);
	inline bool normalize_thickness(void);
	inline void normalize_thickness(bool value);
	inline CurveMapping curve(void);

};

/**************** Offset Modifier ****************/

class OffsetGpencilModifier : public GpencilModifier {
public:
	OffsetGpencilModifier(const PointerRNA &ptr_arg) :
		GpencilModifier(ptr_arg)
		{}

	inline std::string layer(void);
	inline void layer(const std::string& value);
	inline std::string vertex_group(void);
	inline void vertex_group(const std::string& value);
	inline int pass_index(void);
	inline void pass_index(int value);
	inline bool invert_layers(void);
	inline void invert_layers(bool value);
	inline bool invert_material_pass(void);
	inline void invert_material_pass(bool value);
	inline bool invert_vertex(void);
	inline void invert_vertex(bool value);
	inline int layer_pass(void);
	inline void layer_pass(int value);
	inline bool invert_layer_pass(void);
	inline void invert_layer_pass(bool value);
	inline Array<float, 3> location(void);
	inline void location(float values[3]);
	inline Array<float, 3> rotation(void);
	inline void rotation(float values[3]);
	inline Array<float, 3> scale(void);
	inline void scale(float values[3]);

};

/**************** Tint Modifier ****************/

class TintGpencilModifier : public GpencilModifier {
public:
	TintGpencilModifier(const PointerRNA &ptr_arg) :
		GpencilModifier(ptr_arg)
		{}

	enum modify_color_enum {
		modify_color_BOTH = 0,
		modify_color_STROKE = 1,
		modify_color_FILL = 2,
	};
	inline modify_color_enum modify_color(void);
	inline void modify_color(modify_color_enum value);
	inline std::string layer(void);
	inline void layer(const std::string& value);
	inline Array<float, 3> color(void);
	inline void color(float values[3]);
	inline float factor(void);
	inline void factor(float value);
	inline bool create_materials(void);
	inline void create_materials(bool value);
	inline int pass_index(void);
	inline void pass_index(int value);
	inline bool invert_layers(void);
	inline void invert_layers(bool value);
	inline bool invert_material_pass(void);
	inline void invert_material_pass(bool value);
	inline int layer_pass(void);
	inline void layer_pass(int value);
	inline bool invert_layer_pass(void);
	inline void invert_layer_pass(bool value);

};

/**************** Time Offset Modifier ****************/

class TimeGpencilModifier : public GpencilModifier {
public:
	TimeGpencilModifier(const PointerRNA &ptr_arg) :
		GpencilModifier(ptr_arg)
		{}

	enum mode_enum {
		mode_NORMAL = 0,
		mode_REVERSE = 1,
		mode_FIX = 2,
	};
	inline mode_enum mode(void);
	inline void mode(mode_enum value);
	inline std::string layer(void);
	inline void layer(const std::string& value);
	inline bool invert_layers(void);
	inline void invert_layers(bool value);
	inline int layer_pass(void);
	inline void layer_pass(int value);
	inline bool invert_layer_pass(void);
	inline void invert_layer_pass(bool value);
	inline int offset(void);
	inline void offset(int value);
	inline float frame_scale(void);
	inline void frame_scale(float value);
	inline int frame_start(void);
	inline void frame_start(int value);
	inline int frame_end(void);
	inline void frame_end(int value);
	inline bool use_keep_loop(void);
	inline void use_keep_loop(bool value);
	inline bool use_custom_frame_range(void);
	inline void use_custom_frame_range(bool value);

};

/**************** Hue/Saturation Modifier ****************/

class ColorGpencilModifier : public GpencilModifier {
public:
	ColorGpencilModifier(const PointerRNA &ptr_arg) :
		GpencilModifier(ptr_arg)
		{}

	enum modify_color_enum {
		modify_color_BOTH = 0,
		modify_color_STROKE = 1,
		modify_color_FILL = 2,
	};
	inline modify_color_enum modify_color(void);
	inline void modify_color(modify_color_enum value);
	inline std::string layer(void);
	inline void layer(const std::string& value);
	inline float hue(void);
	inline void hue(float value);
	inline float saturation(void);
	inline void saturation(float value);
	inline float value(void);
	inline void value(float value);
	inline bool create_materials(void);
	inline void create_materials(bool value);
	inline int pass_index(void);
	inline void pass_index(int value);
	inline bool invert_layers(void);
	inline void invert_layers(bool value);
	inline bool invert_material_pass(void);
	inline void invert_material_pass(bool value);
	inline int layer_pass(void);
	inline void layer_pass(int value);
	inline bool invert_layer_pass(void);
	inline void invert_layer_pass(bool value);

};

/**************** Instance Modifier ****************/

class ArrayGpencilModifier : public GpencilModifier {
public:
	ArrayGpencilModifier(const PointerRNA &ptr_arg) :
		GpencilModifier(ptr_arg)
		{}

	inline std::string layer(void);
	inline void layer(const std::string& value);
	inline int pass_index(void);
	inline void pass_index(int value);
	inline int count(void);
	inline void count(int value);
	inline Object offset_object(void);
	inline Array<float, 3> offset(void);
	inline void offset(float values[3]);
	inline Array<float, 3> shift(void);
	inline void shift(float values[3]);
	inline Array<float, 3> rotation(void);
	inline void rotation(float values[3]);
	inline Array<float, 3> scale(void);
	inline void scale(float values[3]);
	inline bool random_rot(void);
	inline void random_rot(bool value);
	inline float rot_factor(void);
	inline void rot_factor(float value);
	inline bool random_scale(void);
	inline void random_scale(bool value);
	inline float scale_factor(void);
	inline void scale_factor(float value);
	inline int replace_material(void);
	inline void replace_material(int value);
	inline bool invert_layers(void);
	inline void invert_layers(bool value);
	inline bool invert_material_pass(void);
	inline void invert_material_pass(bool value);
	inline int layer_pass(void);
	inline void layer_pass(int value);
	inline bool invert_layer_pass(void);
	inline void invert_layer_pass(bool value);
	inline bool keep_on_top(void);
	inline void keep_on_top(bool value);

};

/**************** Build Modifier ****************/

class BuildGpencilModifier : public GpencilModifier {
public:
	BuildGpencilModifier(const PointerRNA &ptr_arg) :
		GpencilModifier(ptr_arg)
		{}

	enum mode_enum {
		mode_SEQUENTIAL = 0,
		mode_CONCURRENT = 1,
	};
	inline mode_enum mode(void);
	inline void mode(mode_enum value);
	enum transition_enum {
		transition_GROW = 0,
		transition_SHRINK = 1,
		transition_FADE = 2,
	};
	inline transition_enum transition(void);
	inline void transition(transition_enum value);
	inline float start_delay(void);
	inline void start_delay(float value);
	inline float length(void);
	inline void length(float value);
	enum concurrent_time_alignment_enum {
		concurrent_time_alignment_START = 0,
		concurrent_time_alignment_END = 1,
	};
	inline concurrent_time_alignment_enum concurrent_time_alignment(void);
	inline void concurrent_time_alignment(concurrent_time_alignment_enum value);
	inline bool use_restrict_frame_range(void);
	inline void use_restrict_frame_range(bool value);
	inline float frame_start(void);
	inline void frame_start(float value);
	inline float frame_end(void);
	inline void frame_end(float value);
	inline std::string layer(void);
	inline void layer(const std::string& value);
	inline bool invert_layers(void);
	inline void invert_layers(bool value);
	inline int layer_pass(void);
	inline void layer_pass(int value);
	inline bool invert_layer_pass(void);
	inline void invert_layer_pass(bool value);

};

/**************** Opacity Modifier ****************/

class OpacityGpencilModifier : public GpencilModifier {
public:
	OpacityGpencilModifier(const PointerRNA &ptr_arg) :
		GpencilModifier(ptr_arg)
		{}

	enum modify_color_enum {
		modify_color_BOTH = 0,
		modify_color_STROKE = 1,
		modify_color_FILL = 2,
	};
	inline modify_color_enum modify_color(void);
	inline void modify_color(modify_color_enum value);
	inline std::string layer(void);
	inline void layer(const std::string& value);
	inline std::string vertex_group(void);
	inline void vertex_group(const std::string& value);
	inline float factor(void);
	inline void factor(float value);
	inline bool create_materials(void);
	inline void create_materials(bool value);
	inline int pass_index(void);
	inline void pass_index(int value);
	inline bool invert_layers(void);
	inline void invert_layers(bool value);
	inline bool invert_material_pass(void);
	inline void invert_material_pass(bool value);
	inline bool invert_vertex(void);
	inline void invert_vertex(bool value);
	inline int layer_pass(void);
	inline void layer_pass(int value);
	inline bool invert_layer_pass(void);
	inline void invert_layer_pass(bool value);

};

/**************** Lattice Modifier ****************/

class LatticeGpencilModifier : public GpencilModifier {
public:
	LatticeGpencilModifier(const PointerRNA &ptr_arg) :
		GpencilModifier(ptr_arg)
		{}

	inline std::string layer(void);
	inline void layer(const std::string& value);
	inline std::string vertex_group(void);
	inline void vertex_group(const std::string& value);
	inline int pass_index(void);
	inline void pass_index(int value);
	inline bool invert_layers(void);
	inline void invert_layers(bool value);
	inline bool invert_material_pass(void);
	inline void invert_material_pass(bool value);
	inline bool invert_vertex(void);
	inline void invert_vertex(bool value);
	inline int layer_pass(void);
	inline void layer_pass(int value);
	inline bool invert_layer_pass(void);
	inline void invert_layer_pass(bool value);
	inline Object object(void);
	inline float strength(void);
	inline void strength(float value);

};

/**************** Mirror Modifier ****************/

class MirrorGpencilModifier : public GpencilModifier {
public:
	MirrorGpencilModifier(const PointerRNA &ptr_arg) :
		GpencilModifier(ptr_arg)
		{}

	inline std::string layer(void);
	inline void layer(const std::string& value);
	inline int pass_index(void);
	inline void pass_index(int value);
	inline bool invert_layers(void);
	inline void invert_layers(bool value);
	inline bool invert_material_pass(void);
	inline void invert_material_pass(bool value);
	inline int layer_pass(void);
	inline void layer_pass(int value);
	inline bool invert_layer_pass(void);
	inline void invert_layer_pass(bool value);
	inline Object object(void);
	inline bool use_clip(void);
	inline void use_clip(bool value);
	inline bool x_axis(void);
	inline void x_axis(bool value);
	inline bool y_axis(void);
	inline void y_axis(bool value);
	inline bool z_axis(void);
	inline void z_axis(bool value);

};

/**************** Hook Modifier ****************/

class HookGpencilModifier : public GpencilModifier {
public:
	HookGpencilModifier(const PointerRNA &ptr_arg) :
		GpencilModifier(ptr_arg)
		{}

	inline Object object(void);
	inline std::string subtarget(void);
	inline void subtarget(const std::string& value);
	inline std::string layer(void);
	inline void layer(const std::string& value);
	inline std::string vertex_group(void);
	inline void vertex_group(const std::string& value);
	inline int pass_index(void);
	inline void pass_index(int value);
	inline bool invert_layers(void);
	inline void invert_layers(bool value);
	inline bool invert_material_pass(void);
	inline void invert_material_pass(bool value);
	inline bool invert_vertex(void);
	inline void invert_vertex(bool value);
	inline int layer_pass(void);
	inline void layer_pass(int value);
	inline bool invert_layer_pass(void);
	inline void invert_layer_pass(bool value);
	inline float strength(void);
	inline void strength(float value);
	enum falloff_type_enum {
		falloff_type_NONE = 0,
		falloff_type_CURVE = 1,
		falloff_type_SMOOTH = 3,
		falloff_type_SPHERE = 7,
		falloff_type_ROOT = 4,
		falloff_type_INVERSE_SQUARE = 8,
		falloff_type_SHARP = 2,
		falloff_type_LINEAR = 5,
		falloff_type_CONSTANT = 6,
	};
	inline falloff_type_enum falloff_type(void);
	inline void falloff_type(falloff_type_enum value);
	inline float falloff_radius(void);
	inline void falloff_radius(float value);
	inline CurveMapping falloff_curve(void);
	inline Array<float, 3> center(void);
	inline void center(float values[3]);
	inline Array<float, 16> matrix_inverse(void);
	inline void matrix_inverse(float values[16]);
	inline bool use_falloff_uniform(void);
	inline void use_falloff_uniform(bool value);

};

/**************** Armature Modifier ****************/

class ArmatureGpencilModifier : public GpencilModifier {
public:
	ArmatureGpencilModifier(const PointerRNA &ptr_arg) :
		GpencilModifier(ptr_arg)
		{}

	inline Object object(void);
	inline bool use_bone_envelopes(void);
	inline void use_bone_envelopes(bool value);
	inline bool use_vertex_groups(void);
	inline void use_vertex_groups(bool value);
	inline bool use_deform_preserve_volume(void);
	inline void use_deform_preserve_volume(bool value);
	inline std::string vertex_group(void);
	inline void vertex_group(const std::string& value);
	inline bool invert_vertex_group(void);
	inline void invert_vertex_group(bool value);

};

/**************** ShaderFx ****************/

class ShaderFx : public Pointer {
public:
	ShaderFx(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string name(void);
	inline void name(const std::string& value);
	enum type_enum {
		type_FX_BLUR = 1,
		type_FX_COLORIZE = 8,
		type_FX_FLIP = 2,
		type_FX_GLOW = 10,
		type_FX_LIGHT = 3,
		type_FX_PIXEL = 4,
		type_FX_RIM = 7,
		type_FX_SHADOW = 9,
		type_FX_SWIRL = 5,
		type_FX_WAVE = 6,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	inline bool show_viewport(void);
	inline void show_viewport(bool value);
	inline bool show_render(void);
	inline void show_render(bool value);
	inline bool show_in_editmode(void);
	inline void show_in_editmode(bool value);
	inline bool show_expanded(void);
	inline void show_expanded(bool value);

};

/**************** Gaussian Blur Effect ****************/

class ShaderFxBlur : public ShaderFx {
public:
	ShaderFxBlur(const PointerRNA &ptr_arg) :
		ShaderFx(ptr_arg)
		{}

	inline Array<int, 2> factor(void);
	inline void factor(int values[2]);
	inline int samples(void);
	inline void samples(int value);
	inline float coc(void);
	inline void coc(float value);
	inline bool use_dof_mode(void);
	inline void use_dof_mode(bool value);

};

/**************** Colorize Effect ****************/

class ShaderFxColorize : public ShaderFx {
public:
	ShaderFxColorize(const PointerRNA &ptr_arg) :
		ShaderFx(ptr_arg)
		{}

	inline float factor(void);
	inline void factor(float value);
	inline Array<float, 4> low_color(void);
	inline void low_color(float values[4]);
	inline Array<float, 4> high_color(void);
	inline void high_color(float values[4]);
	enum mode_enum {
		mode_GRAYSCALE = 0,
		mode_SEPIA = 1,
		mode_DUOTONE = 2,
		mode_TRANSPARENT = 4,
		mode_CUSTOM = 3,
	};
	inline mode_enum mode(void);
	inline void mode(mode_enum value);

};

/**************** Wave Deformation Effect ****************/

class ShaderFxWave : public ShaderFx {
public:
	ShaderFxWave(const PointerRNA &ptr_arg) :
		ShaderFx(ptr_arg)
		{}

	enum orientation_enum {
		orientation_HORIZONTAL = 0,
		orientation_VERTICAL = 1,
	};
	inline orientation_enum orientation(void);
	inline void orientation(orientation_enum value);
	inline float amplitude(void);
	inline void amplitude(float value);
	inline float period(void);
	inline void period(float value);
	inline float phase(void);
	inline void phase(float value);

};

/**************** Pixelate Effect ****************/

class ShaderFxPixel : public ShaderFx {
public:
	ShaderFxPixel(const PointerRNA &ptr_arg) :
		ShaderFx(ptr_arg)
		{}

	inline Array<int, 2> size(void);
	inline void size(int values[2]);
	inline Array<float, 4> color(void);
	inline void color(float values[4]);
	inline bool use_lines(void);
	inline void use_lines(bool value);

};

/**************** Rim Effect ****************/

class ShaderFxRim : public ShaderFx {
public:
	ShaderFxRim(const PointerRNA &ptr_arg) :
		ShaderFx(ptr_arg)
		{}

	inline Array<int, 2> offset(void);
	inline void offset(int values[2]);
	inline Array<float, 3> rim_color(void);
	inline void rim_color(float values[3]);
	inline Array<float, 3> mask_color(void);
	inline void mask_color(float values[3]);
	enum mode_enum {
		mode_NORMAL = 0,
		mode_OVERLAY = 1,
		mode_ADD = 2,
		mode_SUBTRACT = 3,
		mode_MULTIPLY = 4,
		mode_DIVIDE = 5,
	};
	inline mode_enum mode(void);
	inline void mode(mode_enum value);
	inline Array<int, 2> blur(void);
	inline void blur(int values[2]);
	inline int samples(void);
	inline void samples(int value);

};

/**************** Shadow Effect ****************/

class ShaderFxShadow : public ShaderFx {
public:
	ShaderFxShadow(const PointerRNA &ptr_arg) :
		ShaderFx(ptr_arg)
		{}

	inline Object object(void);
	inline Array<int, 2> offset(void);
	inline void offset(int values[2]);
	inline Array<float, 2> scale(void);
	inline void scale(float values[2]);
	inline Array<float, 4> shadow_color(void);
	inline void shadow_color(float values[4]);
	enum orientation_enum {
		orientation_HORIZONTAL = 0,
		orientation_VERTICAL = 1,
	};
	inline orientation_enum orientation(void);
	inline void orientation(orientation_enum value);
	inline float amplitude(void);
	inline void amplitude(float value);
	inline float period(void);
	inline void period(float value);
	inline float phase(void);
	inline void phase(float value);
	inline float rotation(void);
	inline void rotation(float value);
	inline Array<int, 2> blur(void);
	inline void blur(int values[2]);
	inline int samples(void);
	inline void samples(int value);
	inline bool use_object(void);
	inline void use_object(bool value);
	inline bool use_wave(void);
	inline void use_wave(bool value);

};

/**************** Glow Effect ****************/

class ShaderFxGlow : public ShaderFx {
public:
	ShaderFxGlow(const PointerRNA &ptr_arg) :
		ShaderFx(ptr_arg)
		{}

	inline Array<float, 3> glow_color(void);
	inline void glow_color(float values[3]);
	inline Array<float, 3> select_color(void);
	inline void select_color(float values[3]);
	enum mode_enum {
		mode_LUMINANCE = 0,
		mode_COLOR = 1,
	};
	inline mode_enum mode(void);
	inline void mode(mode_enum value);
	inline float threshold(void);
	inline void threshold(float value);
	inline int radius(void);
	inline void radius(int value);
	inline int samples(void);
	inline void samples(int value);
	inline bool use_alpha_mode(void);
	inline void use_alpha_mode(bool value);

};

/**************** Swirl Effect ****************/

class ShaderFxSwirl : public ShaderFx {
public:
	ShaderFxSwirl(const PointerRNA &ptr_arg) :
		ShaderFx(ptr_arg)
		{}

	inline int radius(void);
	inline void radius(int value);
	inline float angle(void);
	inline void angle(float value);
	inline bool use_transparent(void);
	inline void use_transparent(bool value);
	inline Object object(void);

};

/**************** Flip Effect ****************/

class ShaderFxFlip : public ShaderFx {
public:
	ShaderFxFlip(const PointerRNA &ptr_arg) :
		ShaderFx(ptr_arg)
		{}

	inline bool flip_horizontal(void);
	inline void flip_horizontal(bool value);
	inline bool flip_vertical(void);
	inline void flip_vertical(bool value);

};

/**************** Light Effect ****************/

class ShaderFxLight : public ShaderFx {
public:
	ShaderFxLight(const PointerRNA &ptr_arg) :
		ShaderFx(ptr_arg)
		{}

	inline float energy(void);
	inline void energy(float value);
	inline float ambient(void);
	inline void ambient(float value);
	inline Object object(void);

};

/**************** NLA Track ****************/

class NlaTrack : public Pointer {
public:
	NlaTrack(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		strips(ptr_arg)
		{}

	inline Struct rna_type(void);
	COLLECTION_PROPERTY(NlaStrips, NlaStrip, NlaTrack, strips, false, true, true)
	inline std::string name(void);
	inline void name(const std::string& value);
	inline bool active(void);
	inline void active(bool value);
	inline bool is_solo(void);
	inline void is_solo(bool value);
	inline bool select(void);
	inline void select(bool value);
	inline bool mute(void);
	inline void mute(bool value);
	inline bool lock(void);
	inline void lock(bool value);

};

/**************** NLA Strip ****************/

class NlaStrip : public Pointer {
public:
	NlaStrip(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		fcurves(ptr_arg),
		modifiers(ptr_arg),
		strips(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string name(void);
	inline void name(const std::string& value);
	enum type_enum {
		type_CLIP = 0,
		type_TRANSITION = 1,
		type_META = 2,
		type_SOUND = 3,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	enum extrapolation_enum {
		extrapolation_NOTHING = 2,
		extrapolation_HOLD = 0,
		extrapolation_HOLD_FORWARD = 1,
	};
	inline extrapolation_enum extrapolation(void);
	inline void extrapolation(extrapolation_enum value);
	enum blend_type_enum {
		blend_type_REPLACE = 0,
		blend_type_COMBINE = 4,
		blend_type_ADD = 1,
		blend_type_SUBTRACT = 2,
		blend_type_MULTIPLY = 3,
	};
	inline blend_type_enum blend_type(void);
	inline void blend_type(blend_type_enum value);
	inline float frame_start(void);
	inline void frame_start(float value);
	inline float frame_end(void);
	inline void frame_end(float value);
	inline float blend_in(void);
	inline void blend_in(float value);
	inline float blend_out(void);
	inline void blend_out(float value);
	inline bool use_auto_blend(void);
	inline void use_auto_blend(bool value);
	inline Action action(void);
	inline float action_frame_start(void);
	inline void action_frame_start(float value);
	inline float action_frame_end(void);
	inline void action_frame_end(float value);
	inline float repeat(void);
	inline void repeat(float value);
	inline float scale(void);
	inline void scale(float value);
	COLLECTION_PROPERTY(NlaStripFCurves, FCurve, NlaStrip, fcurves, false, true, false)
	COLLECTION_PROPERTY(DefaultCollectionFunctions, FModifier, NlaStrip, modifiers, false, true, false)
	COLLECTION_PROPERTY(DefaultCollectionFunctions, NlaStrip, NlaStrip, strips, false, true, true)
	inline float influence(void);
	inline void influence(float value);
	inline float strip_time(void);
	inline void strip_time(float value);
	inline bool use_animated_influence(void);
	inline void use_animated_influence(bool value);
	inline bool use_animated_time(void);
	inline void use_animated_time(bool value);
	inline bool use_animated_time_cyclic(void);
	inline void use_animated_time_cyclic(bool value);
	inline bool active(void);
	inline void active(bool value);
	inline bool select(void);
	inline void select(bool value);
	inline bool mute(void);
	inline void mute(bool value);
	inline bool use_reverse(void);
	inline void use_reverse(bool value);
	inline bool use_sync_length(void);
	inline void use_sync_length(bool value);

};

/**************** Node Socket ****************/

class NodeSocket : public Pointer {
public:
	NodeSocket(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string name(void);
	inline void name(const std::string& value);
	inline std::string identifier(void);
	inline void identifier(const std::string& value);
	inline bool is_output(void);
	inline void is_output(bool value);
	inline bool hide(void);
	inline void hide(bool value);
	inline bool enabled(void);
	inline void enabled(bool value);
	inline int link_limit(void);
	inline void link_limit(int value);
	inline bool is_linked(void);
	inline void is_linked(bool value);
	inline bool show_expanded(void);
	inline void show_expanded(bool value);
	inline bool hide_value(void);
	inline void hide_value(bool value);
	inline Node node(void);
	enum type_enum {
		type_CUSTOM = -1,
		type_VALUE = 0,
		type_INT = 6,
		type_BOOLEAN = 4,
		type_VECTOR = 1,
		type_STRING = 7,
		type_RGBA = 2,
		type_SHADER = 3,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	enum draw_shape_enum {
		draw_shape_CIRCLE = 0,
		draw_shape_SQUARE = 1,
		draw_shape_DIAMOND = 2,
	};
	inline draw_shape_enum draw_shape(void);
	inline void draw_shape(draw_shape_enum value);
	inline std::string bl_idname(void);
	inline void bl_idname(const std::string& value);

};

/**************** Node Socket Template ****************/

class NodeSocketInterface : public Pointer {
public:
	NodeSocketInterface(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string name(void);
	inline void name(const std::string& value);
	inline std::string identifier(void);
	inline void identifier(const std::string& value);
	inline bool is_output(void);
	inline void is_output(bool value);
	inline std::string bl_socket_idname(void);
	inline void bl_socket_idname(const std::string& value);

};

/**************** Node ****************/

class Node : public Pointer {
public:
	Node(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		inputs(ptr_arg),
		outputs(ptr_arg),
		internal_links(ptr_arg)
		{}

	inline Struct rna_type(void);
	enum type_enum {
		type_CUSTOM = -1,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	inline Array<float, 2> location(void);
	inline void location(float values[2]);
	inline float width(void);
	inline void width(float value);
	inline float width_hidden(void);
	inline void width_hidden(float value);
	inline float height(void);
	inline void height(float value);
	inline Array<float, 2> dimensions(void);
	inline void dimensions(float values[2]);
	inline std::string name(void);
	inline void name(const std::string& value);
	inline std::string label(void);
	inline void label(const std::string& value);
	COLLECTION_PROPERTY(NodeInputs, NodeSocket, Node, inputs, false, true, true)
	COLLECTION_PROPERTY(NodeOutputs, NodeSocket, Node, outputs, false, true, true)
	COLLECTION_PROPERTY(DefaultCollectionFunctions, NodeLink, Node, internal_links, false, true, false)
	inline Node parent(void);
	inline bool use_custom_color(void);
	inline void use_custom_color(bool value);
	inline Array<float, 3> color(void);
	inline void color(float values[3]);
	inline bool select(void);
	inline void select(bool value);
	inline bool show_options(void);
	inline void show_options(bool value);
	inline bool show_preview(void);
	inline void show_preview(bool value);
	inline bool hide(void);
	inline void hide(bool value);
	inline bool mute(void);
	inline void mute(bool value);
	inline bool show_texture(void);
	inline void show_texture(bool value);
	inline std::string bl_idname(void);
	inline void bl_idname(const std::string& value);
	inline std::string bl_label(void);
	inline void bl_label(const std::string& value);
	inline std::string bl_description(void);
	inline void bl_description(const std::string& value);
	enum bl_icon_enum {
		bl_icon_NONE = 0,
		bl_icon_QUESTION = 1,
		bl_icon_ERROR = 2,
		bl_icon_CANCEL = 3,
		bl_icon_TRIA_RIGHT = 4,
		bl_icon_TRIA_DOWN = 5,
		bl_icon_TRIA_LEFT = 6,
		bl_icon_TRIA_UP = 7,
		bl_icon_ARROW_LEFTRIGHT = 8,
		bl_icon_PLUS = 9,
		bl_icon_DISCLOSURE_TRI_RIGHT = 10,
		bl_icon_DISCLOSURE_TRI_DOWN = 11,
		bl_icon_RADIOBUT_OFF = 12,
		bl_icon_RADIOBUT_ON = 13,
		bl_icon_MENU_PANEL = 14,
		bl_icon_BLENDER = 15,
		bl_icon_GRIP = 16,
		bl_icon_DOT = 17,
		bl_icon_COLLAPSEMENU = 18,
		bl_icon_X = 19,
		bl_icon_DUPLICATE = 20,
		bl_icon_TRASH = 21,
		bl_icon_NODE = 24,
		bl_icon_NODE_SEL = 25,
		bl_icon_WINDOW = 26,
		bl_icon_WORKSPACE = 27,
		bl_icon_RIGHTARROW_THIN = 28,
		bl_icon_BORDERMOVE = 29,
		bl_icon_VIEWZOOM = 30,
		bl_icon_ADD = 31,
		bl_icon_REMOVE = 32,
		bl_icon_PANEL_CLOSE = 33,
		bl_icon_COPY_ID = 34,
		bl_icon_EYEDROPPER = 35,
		bl_icon_AUTO = 37,
		bl_icon_CHECKBOX_DEHLT = 38,
		bl_icon_CHECKBOX_HLT = 39,
		bl_icon_UNLOCKED = 40,
		bl_icon_LOCKED = 41,
		bl_icon_UNPINNED = 42,
		bl_icon_PINNED = 43,
		bl_icon_SCREEN_BACK = 44,
		bl_icon_RIGHTARROW = 45,
		bl_icon_DOWNARROW_HLT = 46,
		bl_icon_PLUGIN = 51,
		bl_icon_HELP = 52,
		bl_icon_GHOST_ENABLED = 53,
		bl_icon_COLOR = 54,
		bl_icon_UNLINKED = 55,
		bl_icon_LINKED = 56,
		bl_icon_HAND = 57,
		bl_icon_ZOOM_ALL = 58,
		bl_icon_ZOOM_SELECTED = 59,
		bl_icon_ZOOM_PREVIOUS = 60,
		bl_icon_ZOOM_IN = 61,
		bl_icon_ZOOM_OUT = 62,
		bl_icon_DRIVER_DISTANCE = 63,
		bl_icon_DRIVER_ROTATIONAL_DIFFERENCE = 64,
		bl_icon_DRIVER_TRANSFORM = 65,
		bl_icon_FREEZE = 66,
		bl_icon_STYLUS_PRESSURE = 67,
		bl_icon_GHOST_DISABLED = 68,
		bl_icon_FILE_NEW = 69,
		bl_icon_FILE_TICK = 70,
		bl_icon_QUIT = 71,
		bl_icon_URL = 72,
		bl_icon_RECOVER_LAST = 73,
		bl_icon_THREE_DOTS = 74,
		bl_icon_FULLSCREEN_ENTER = 75,
		bl_icon_FULLSCREEN_EXIT = 76,
		bl_icon_LIGHT = 78,
		bl_icon_MATERIAL = 79,
		bl_icon_TEXTURE = 80,
		bl_icon_ANIM = 81,
		bl_icon_WORLD = 82,
		bl_icon_SCENE = 83,
		bl_icon_OUTPUT = 84,
		bl_icon_SCRIPT = 87,
		bl_icon_PARTICLES = 88,
		bl_icon_PHYSICS = 89,
		bl_icon_SPEAKER = 90,
		bl_icon_TOOL_SETTINGS = 92,
		bl_icon_SHADERFX = 93,
		bl_icon_MODIFIER = 94,
		bl_icon_BLANK1 = 101,
		bl_icon_FAKE_USER_OFF = 102,
		bl_icon_FAKE_USER_ON = 103,
		bl_icon_VIEW3D = 104,
		bl_icon_GRAPH = 105,
		bl_icon_OUTLINER = 106,
		bl_icon_PROPERTIES = 107,
		bl_icon_FILEBROWSER = 108,
		bl_icon_IMAGE = 109,
		bl_icon_INFO = 110,
		bl_icon_SEQUENCE = 111,
		bl_icon_TEXT = 112,
		bl_icon_SOUND = 114,
		bl_icon_ACTION = 115,
		bl_icon_NLA = 116,
		bl_icon_PREFERENCES = 117,
		bl_icon_TIME = 118,
		bl_icon_NODETREE = 119,
		bl_icon_CONSOLE = 121,
		bl_icon_TRACKER = 123,
		bl_icon_ASSET_MANAGER = 124,
		bl_icon_NODE_COMPOSITING = 125,
		bl_icon_NODE_TEXTURE = 126,
		bl_icon_NODE_MATERIAL = 127,
		bl_icon_UV = 128,
		bl_icon_OBJECT_DATAMODE = 130,
		bl_icon_EDITMODE_HLT = 131,
		bl_icon_UV_DATA = 132,
		bl_icon_VPAINT_HLT = 133,
		bl_icon_TPAINT_HLT = 134,
		bl_icon_WPAINT_HLT = 135,
		bl_icon_SCULPTMODE_HLT = 136,
		bl_icon_POSE_HLT = 137,
		bl_icon_PARTICLEMODE = 138,
		bl_icon_TRACKING = 146,
		bl_icon_TRACKING_BACKWARDS = 147,
		bl_icon_TRACKING_FORWARDS = 148,
		bl_icon_TRACKING_BACKWARDS_SINGLE = 149,
		bl_icon_TRACKING_FORWARDS_SINGLE = 150,
		bl_icon_TRACKING_CLEAR_BACKWARDS = 151,
		bl_icon_TRACKING_CLEAR_FORWARDS = 152,
		bl_icon_TRACKING_REFINE_BACKWARDS = 153,
		bl_icon_TRACKING_REFINE_FORWARDS = 154,
		bl_icon_SCENE_DATA = 156,
		bl_icon_RENDERLAYERS = 157,
		bl_icon_WORLD_DATA = 158,
		bl_icon_OBJECT_DATA = 159,
		bl_icon_MESH_DATA = 160,
		bl_icon_CURVE_DATA = 161,
		bl_icon_META_DATA = 162,
		bl_icon_LATTICE_DATA = 163,
		bl_icon_LIGHT_DATA = 164,
		bl_icon_MATERIAL_DATA = 165,
		bl_icon_TEXTURE_DATA = 166,
		bl_icon_ANIM_DATA = 167,
		bl_icon_CAMERA_DATA = 168,
		bl_icon_PARTICLE_DATA = 169,
		bl_icon_LIBRARY_DATA_DIRECT = 170,
		bl_icon_GROUP = 171,
		bl_icon_ARMATURE_DATA = 172,
		bl_icon_COMMUNITY = 173,
		bl_icon_BONE_DATA = 174,
		bl_icon_CONSTRAINT = 175,
		bl_icon_SHAPEKEY_DATA = 176,
		bl_icon_CONSTRAINT_BONE = 177,
		bl_icon_CAMERA_STEREO = 178,
		bl_icon_PACKAGE = 179,
		bl_icon_UGLYPACKAGE = 180,
		bl_icon_EXPERIMENTAL = 181,
		bl_icon_BRUSH_DATA = 182,
		bl_icon_IMAGE_DATA = 183,
		bl_icon_FILE = 184,
		bl_icon_FCURVE = 185,
		bl_icon_FONT_DATA = 186,
		bl_icon_RENDER_RESULT = 187,
		bl_icon_SURFACE_DATA = 188,
		bl_icon_EMPTY_DATA = 189,
		bl_icon_PRESET = 190,
		bl_icon_RENDER_ANIMATION = 191,
		bl_icon_RENDER_STILL = 192,
		bl_icon_LIBRARY_DATA_BROKEN = 193,
		bl_icon_BOIDS = 194,
		bl_icon_STRANDS = 195,
		bl_icon_LIBRARY_DATA_INDIRECT = 196,
		bl_icon_GREASEPENCIL = 197,
		bl_icon_LINE_DATA = 198,
		bl_icon_LIBRARY_DATA_OVERRIDE = 199,
		bl_icon_GROUP_BONE = 200,
		bl_icon_GROUP_VERTEX = 201,
		bl_icon_GROUP_VCOL = 202,
		bl_icon_GROUP_UVS = 203,
		bl_icon_FACE_MAPS = 204,
		bl_icon_RNA = 206,
		bl_icon_RNA_ADD = 207,
		bl_icon_MOUSE_LMB = 208,
		bl_icon_MOUSE_MMB = 209,
		bl_icon_MOUSE_RMB = 210,
		bl_icon_MOUSE_MOVE = 211,
		bl_icon_MOUSE_LMB_DRAG = 212,
		bl_icon_MOUSE_MMB_DRAG = 213,
		bl_icon_MOUSE_RMB_DRAG = 214,
		bl_icon_PRESET_NEW = 216,
		bl_icon_DECORATE = 218,
		bl_icon_DECORATE_KEYFRAME = 219,
		bl_icon_DECORATE_ANIMATE = 220,
		bl_icon_DECORATE_DRIVER = 221,
		bl_icon_DECORATE_LINKED = 222,
		bl_icon_DECORATE_LIBRARY_OVERRIDE = 223,
		bl_icon_DECORATE_UNLOCKED = 224,
		bl_icon_DECORATE_LOCKED = 225,
		bl_icon_DECORATE_OVERRIDE = 226,
		bl_icon_TRACKER_DATA = 228,
		bl_icon_HEART = 229,
		bl_icon_ORPHAN_DATA = 230,
		bl_icon_USER = 231,
		bl_icon_SYSTEM = 232,
		bl_icon_SETTINGS = 233,
		bl_icon_OUTLINER_OB_EMPTY = 234,
		bl_icon_OUTLINER_OB_MESH = 235,
		bl_icon_OUTLINER_OB_CURVE = 236,
		bl_icon_OUTLINER_OB_LATTICE = 237,
		bl_icon_OUTLINER_OB_META = 238,
		bl_icon_OUTLINER_OB_LIGHT = 239,
		bl_icon_OUTLINER_OB_CAMERA = 240,
		bl_icon_OUTLINER_OB_ARMATURE = 241,
		bl_icon_OUTLINER_OB_FONT = 242,
		bl_icon_OUTLINER_OB_SURFACE = 243,
		bl_icon_OUTLINER_OB_SPEAKER = 244,
		bl_icon_OUTLINER_OB_FORCE_FIELD = 245,
		bl_icon_OUTLINER_OB_GROUP_INSTANCE = 246,
		bl_icon_OUTLINER_OB_GREASEPENCIL = 247,
		bl_icon_OUTLINER_OB_LIGHTPROBE = 248,
		bl_icon_OUTLINER_OB_IMAGE = 249,
		bl_icon_RESTRICT_COLOR_OFF = 251,
		bl_icon_RESTRICT_COLOR_ON = 252,
		bl_icon_HIDE_ON = 253,
		bl_icon_HIDE_OFF = 254,
		bl_icon_RESTRICT_SELECT_ON = 255,
		bl_icon_RESTRICT_SELECT_OFF = 256,
		bl_icon_RESTRICT_RENDER_ON = 257,
		bl_icon_RESTRICT_RENDER_OFF = 258,
		bl_icon_OUTLINER_DATA_EMPTY = 260,
		bl_icon_OUTLINER_DATA_MESH = 261,
		bl_icon_OUTLINER_DATA_CURVE = 262,
		bl_icon_OUTLINER_DATA_LATTICE = 263,
		bl_icon_OUTLINER_DATA_META = 264,
		bl_icon_OUTLINER_DATA_LIGHT = 265,
		bl_icon_OUTLINER_DATA_CAMERA = 266,
		bl_icon_OUTLINER_DATA_ARMATURE = 267,
		bl_icon_OUTLINER_DATA_FONT = 268,
		bl_icon_OUTLINER_DATA_SURFACE = 269,
		bl_icon_OUTLINER_DATA_SPEAKER = 270,
		bl_icon_OUTLINER_DATA_GREASEPENCIL = 273,
		bl_icon_GP_SELECT_POINTS = 274,
		bl_icon_GP_SELECT_STROKES = 275,
		bl_icon_GP_MULTIFRAME_EDITING = 276,
		bl_icon_GP_ONLY_SELECTED = 277,
		bl_icon_GP_SELECT_BETWEEN_STROKES = 278,
		bl_icon_MODIFIER_OFF = 279,
		bl_icon_MODIFIER_ON = 280,
		bl_icon_ONIONSKIN_OFF = 281,
		bl_icon_ONIONSKIN_ON = 282,
		bl_icon_RESTRICT_VIEW_ON = 283,
		bl_icon_RESTRICT_VIEW_OFF = 284,
		bl_icon_MESH_PLANE = 286,
		bl_icon_MESH_CUBE = 287,
		bl_icon_MESH_CIRCLE = 288,
		bl_icon_MESH_UVSPHERE = 289,
		bl_icon_MESH_ICOSPHERE = 290,
		bl_icon_MESH_GRID = 291,
		bl_icon_MESH_MONKEY = 292,
		bl_icon_MESH_CYLINDER = 293,
		bl_icon_MESH_TORUS = 294,
		bl_icon_MESH_CONE = 295,
		bl_icon_MESH_CAPSULE = 296,
		bl_icon_EMPTY_SINGLE_ARROW = 297,
		bl_icon_LIGHT_POINT = 298,
		bl_icon_LIGHT_SUN = 299,
		bl_icon_LIGHT_SPOT = 300,
		bl_icon_LIGHT_HEMI = 301,
		bl_icon_LIGHT_AREA = 302,
		bl_icon_CUBE = 303,
		bl_icon_SPHERE = 304,
		bl_icon_CONE = 305,
		bl_icon_META_PLANE = 306,
		bl_icon_META_CUBE = 307,
		bl_icon_META_BALL = 308,
		bl_icon_META_ELLIPSOID = 309,
		bl_icon_META_CAPSULE = 310,
		bl_icon_SURFACE_NCURVE = 312,
		bl_icon_SURFACE_NCIRCLE = 313,
		bl_icon_SURFACE_NSURFACE = 314,
		bl_icon_SURFACE_NCYLINDER = 315,
		bl_icon_SURFACE_NSPHERE = 316,
		bl_icon_SURFACE_NTORUS = 317,
		bl_icon_EMPTY_AXIS = 318,
		bl_icon_STROKE = 319,
		bl_icon_EMPTY_ARROWS = 320,
		bl_icon_CURVE_BEZCURVE = 321,
		bl_icon_CURVE_BEZCIRCLE = 322,
		bl_icon_CURVE_NCURVE = 323,
		bl_icon_CURVE_NCIRCLE = 324,
		bl_icon_CURVE_PATH = 325,
		bl_icon_LIGHTPROBE_CUBEMAP = 326,
		bl_icon_LIGHTPROBE_PLANAR = 327,
		bl_icon_LIGHTPROBE_GRID = 328,
		bl_icon_COLOR_RED = 331,
		bl_icon_COLOR_GREEN = 332,
		bl_icon_COLOR_BLUE = 333,
		bl_icon_TRIA_RIGHT_BAR = 334,
		bl_icon_TRIA_DOWN_BAR = 335,
		bl_icon_TRIA_LEFT_BAR = 336,
		bl_icon_TRIA_UP_BAR = 337,
		bl_icon_FORCE_FORCE = 338,
		bl_icon_FORCE_WIND = 339,
		bl_icon_FORCE_VORTEX = 340,
		bl_icon_FORCE_MAGNETIC = 341,
		bl_icon_FORCE_HARMONIC = 342,
		bl_icon_FORCE_CHARGE = 343,
		bl_icon_FORCE_LENNARDJONES = 344,
		bl_icon_FORCE_TEXTURE = 345,
		bl_icon_FORCE_CURVE = 346,
		bl_icon_FORCE_BOID = 347,
		bl_icon_FORCE_TURBULENCE = 348,
		bl_icon_FORCE_DRAG = 349,
		bl_icon_FORCE_SMOKEFLOW = 350,
		bl_icon_IMAGE_PLANE = 361,
		bl_icon_IMAGE_BACKGROUND = 362,
		bl_icon_IMAGE_REFERENCE = 363,
		bl_icon_NODE_INSERT_ON = 367,
		bl_icon_NODE_INSERT_OFF = 368,
		bl_icon_NODE_TOP = 369,
		bl_icon_NODE_SIDE = 370,
		bl_icon_NODE_CORNER = 371,
		bl_icon_ALIGN_LEFT = 390,
		bl_icon_ALIGN_CENTER = 391,
		bl_icon_ALIGN_RIGHT = 392,
		bl_icon_ALIGN_JUSTIFY = 393,
		bl_icon_ALIGN_FLUSH = 394,
		bl_icon_ALIGN_TOP = 395,
		bl_icon_ALIGN_MIDDLE = 396,
		bl_icon_ALIGN_BOTTOM = 397,
		bl_icon_BOLD = 398,
		bl_icon_ITALIC = 399,
		bl_icon_UNDERLINE = 400,
		bl_icon_SMALL_CAPS = 401,
		bl_icon_MODIFIER_DATA = 442,
		bl_icon_MOD_WAVE = 443,
		bl_icon_MOD_BUILD = 444,
		bl_icon_MOD_DECIM = 445,
		bl_icon_MOD_MIRROR = 446,
		bl_icon_MOD_SOFT = 447,
		bl_icon_MOD_SUBSURF = 448,
		bl_icon_HOOK = 449,
		bl_icon_MOD_PHYSICS = 450,
		bl_icon_MOD_PARTICLES = 451,
		bl_icon_MOD_BOOLEAN = 452,
		bl_icon_MOD_EDGESPLIT = 453,
		bl_icon_MOD_ARRAY = 454,
		bl_icon_MOD_UVPROJECT = 455,
		bl_icon_MOD_DISPLACE = 456,
		bl_icon_MOD_CURVE = 457,
		bl_icon_MOD_LATTICE = 458,
		bl_icon_MOD_TINT = 459,
		bl_icon_MOD_ARMATURE = 460,
		bl_icon_MOD_SHRINKWRAP = 461,
		bl_icon_MOD_CAST = 462,
		bl_icon_MOD_MESHDEFORM = 463,
		bl_icon_MOD_BEVEL = 464,
		bl_icon_MOD_SMOOTH = 465,
		bl_icon_MOD_SIMPLEDEFORM = 466,
		bl_icon_MOD_MASK = 467,
		bl_icon_MOD_CLOTH = 468,
		bl_icon_MOD_EXPLODE = 469,
		bl_icon_MOD_FLUIDSIM = 470,
		bl_icon_MOD_MULTIRES = 471,
		bl_icon_MOD_SMOKE = 472,
		bl_icon_MOD_SOLIDIFY = 473,
		bl_icon_MOD_SCREW = 474,
		bl_icon_MOD_VERTEX_WEIGHT = 475,
		bl_icon_MOD_DYNAMICPAINT = 476,
		bl_icon_MOD_REMESH = 477,
		bl_icon_MOD_OCEAN = 478,
		bl_icon_MOD_WARP = 479,
		bl_icon_MOD_SKIN = 480,
		bl_icon_MOD_TRIANGULATE = 481,
		bl_icon_MOD_WIREFRAME = 482,
		bl_icon_MOD_DATA_TRANSFER = 483,
		bl_icon_MOD_NORMALEDIT = 484,
		bl_icon_MOD_PARTICLE_INSTANCE = 485,
		bl_icon_MOD_HUE_SATURATION = 486,
		bl_icon_MOD_NOISE = 487,
		bl_icon_MOD_OFFSET = 488,
		bl_icon_MOD_SIMPLIFY = 489,
		bl_icon_MOD_THICKNESS = 490,
		bl_icon_MOD_INSTANCE = 491,
		bl_icon_MOD_TIME = 492,
		bl_icon_MOD_OPACITY = 493,
		bl_icon_REC = 494,
		bl_icon_PLAY = 495,
		bl_icon_FF = 496,
		bl_icon_REW = 497,
		bl_icon_PAUSE = 498,
		bl_icon_PREV_KEYFRAME = 499,
		bl_icon_NEXT_KEYFRAME = 500,
		bl_icon_PLAY_SOUND = 501,
		bl_icon_PLAY_REVERSE = 502,
		bl_icon_PREVIEW_RANGE = 503,
		bl_icon_ACTION_TWEAK = 504,
		bl_icon_PMARKER_ACT = 505,
		bl_icon_PMARKER_SEL = 506,
		bl_icon_PMARKER = 507,
		bl_icon_MARKER_HLT = 508,
		bl_icon_MARKER = 509,
		bl_icon_KEYFRAME_HLT = 510,
		bl_icon_KEYFRAME = 511,
		bl_icon_KEYINGSET = 512,
		bl_icon_KEY_DEHLT = 513,
		bl_icon_KEY_HLT = 514,
		bl_icon_MUTE_IPO_OFF = 515,
		bl_icon_MUTE_IPO_ON = 516,
		bl_icon_VISIBLE_IPO_OFF = 517,
		bl_icon_VISIBLE_IPO_ON = 518,
		bl_icon_DRIVER = 519,
		bl_icon_SOLO_OFF = 520,
		bl_icon_SOLO_ON = 521,
		bl_icon_FRAME_PREV = 522,
		bl_icon_FRAME_NEXT = 523,
		bl_icon_NLA_PUSHDOWN = 524,
		bl_icon_IPO_CONSTANT = 525,
		bl_icon_IPO_LINEAR = 526,
		bl_icon_IPO_BEZIER = 527,
		bl_icon_IPO_SINE = 528,
		bl_icon_IPO_QUAD = 529,
		bl_icon_IPO_CUBIC = 530,
		bl_icon_IPO_QUART = 531,
		bl_icon_IPO_QUINT = 532,
		bl_icon_IPO_EXPO = 533,
		bl_icon_IPO_CIRC = 534,
		bl_icon_IPO_BOUNCE = 535,
		bl_icon_IPO_ELASTIC = 536,
		bl_icon_IPO_BACK = 537,
		bl_icon_IPO_EASE_IN = 538,
		bl_icon_IPO_EASE_OUT = 539,
		bl_icon_IPO_EASE_IN_OUT = 540,
		bl_icon_NORMALIZE_FCURVES = 541,
		bl_icon_VERTEXSEL = 546,
		bl_icon_EDGESEL = 547,
		bl_icon_FACESEL = 548,
		bl_icon_PIVOT_BOUNDBOX = 551,
		bl_icon_PIVOT_CURSOR = 552,
		bl_icon_PIVOT_INDIVIDUAL = 553,
		bl_icon_PIVOT_MEDIAN = 554,
		bl_icon_PIVOT_ACTIVE = 555,
		bl_icon_CENTER_ONLY = 556,
		bl_icon_ROOTCURVE = 557,
		bl_icon_SMOOTHCURVE = 558,
		bl_icon_SPHERECURVE = 559,
		bl_icon_INVERSESQUARECURVE = 560,
		bl_icon_SHARPCURVE = 561,
		bl_icon_LINCURVE = 562,
		bl_icon_NOCURVE = 563,
		bl_icon_RNDCURVE = 564,
		bl_icon_PROP_OFF = 565,
		bl_icon_PROP_ON = 566,
		bl_icon_PROP_CON = 567,
		bl_icon_PROP_PROJECTED = 568,
		bl_icon_PARTICLE_POINT = 569,
		bl_icon_PARTICLE_TIP = 570,
		bl_icon_PARTICLE_PATH = 571,
		bl_icon_SNAP_OFF = 576,
		bl_icon_SNAP_ON = 577,
		bl_icon_SNAP_NORMAL = 578,
		bl_icon_SNAP_GRID = 579,
		bl_icon_SNAP_VERTEX = 580,
		bl_icon_SNAP_EDGE = 581,
		bl_icon_SNAP_FACE = 582,
		bl_icon_SNAP_VOLUME = 583,
		bl_icon_SNAP_INCREMENT = 584,
		bl_icon_STICKY_UVS_LOC = 585,
		bl_icon_STICKY_UVS_DISABLE = 586,
		bl_icon_STICKY_UVS_VERT = 587,
		bl_icon_CLIPUV_DEHLT = 588,
		bl_icon_CLIPUV_HLT = 589,
		bl_icon_SNAP_PEEL_OBJECT = 590,
		bl_icon_GRID = 591,
		bl_icon_OBJECT_ORIGIN = 592,
		bl_icon_ORIENTATION_GLOBAL = 593,
		bl_icon_ORIENTATION_GIMBAL = 594,
		bl_icon_ORIENTATION_LOCAL = 595,
		bl_icon_ORIENTATION_NORMAL = 596,
		bl_icon_ORIENTATION_VIEW = 597,
		bl_icon_COPYDOWN = 598,
		bl_icon_PASTEDOWN = 599,
		bl_icon_PASTEFLIPUP = 600,
		bl_icon_PASTEFLIPDOWN = 601,
		bl_icon_VIS_SEL_11 = 602,
		bl_icon_VIS_SEL_10 = 603,
		bl_icon_VIS_SEL_01 = 604,
		bl_icon_VIS_SEL_00 = 605,
		bl_icon_AUTOMERGE_ON = 607,
		bl_icon_AUTOMERGE_OFF = 608,
		bl_icon_UV_VERTEXSEL = 610,
		bl_icon_UV_EDGESEL = 611,
		bl_icon_UV_FACESEL = 612,
		bl_icon_UV_ISLANDSEL = 613,
		bl_icon_UV_SYNC_SELECT = 614,
		bl_icon_ORIENTATION_CURSOR = 620,
		bl_icon_NORMALS_VERTEX = 621,
		bl_icon_NORMALS_FACE = 622,
		bl_icon_NORMALS_VERTEX_FACE = 623,
		bl_icon_SHADING_BBOX = 624,
		bl_icon_SHADING_WIRE = 625,
		bl_icon_SHADING_SOLID = 626,
		bl_icon_SHADING_RENDERED = 627,
		bl_icon_SHADING_TEXTURE = 628,
		bl_icon_OVERLAY = 629,
		bl_icon_XRAY = 630,
		bl_icon_LOCKVIEW_OFF = 633,
		bl_icon_LOCKVIEW_ON = 634,
		bl_icon_AXIS_SIDE = 636,
		bl_icon_AXIS_FRONT = 637,
		bl_icon_AXIS_TOP = 638,
		bl_icon_NDOF_DOM = 639,
		bl_icon_NDOF_TURN = 640,
		bl_icon_NDOF_FLY = 641,
		bl_icon_NDOF_TRANS = 642,
		bl_icon_LAYER_USED = 643,
		bl_icon_LAYER_ACTIVE = 644,
		bl_icon_SORTALPHA = 676,
		bl_icon_SORTBYEXT = 677,
		bl_icon_SORTTIME = 678,
		bl_icon_SORTSIZE = 679,
		bl_icon_SHORTDISPLAY = 680,
		bl_icon_LONGDISPLAY = 681,
		bl_icon_IMGDISPLAY = 683,
		bl_icon_BOOKMARKS = 686,
		bl_icon_FONTPREVIEW = 687,
		bl_icon_FILTER = 688,
		bl_icon_NEWFOLDER = 689,
		bl_icon_FILE_PARENT = 691,
		bl_icon_FILE_REFRESH = 692,
		bl_icon_FILE_FOLDER = 693,
		bl_icon_FILE_BLANK = 694,
		bl_icon_FILE_BLEND = 695,
		bl_icon_FILE_IMAGE = 696,
		bl_icon_FILE_MOVIE = 697,
		bl_icon_FILE_SCRIPT = 698,
		bl_icon_FILE_SOUND = 699,
		bl_icon_FILE_FONT = 700,
		bl_icon_FILE_TEXT = 701,
		bl_icon_SORT_DESC = 702,
		bl_icon_SORT_ASC = 703,
		bl_icon_LINK_BLEND = 704,
		bl_icon_APPEND_BLEND = 705,
		bl_icon_IMPORT = 706,
		bl_icon_EXPORT = 707,
		bl_icon_LOOP_BACK = 715,
		bl_icon_LOOP_FORWARDS = 716,
		bl_icon_BACK = 717,
		bl_icon_FORWARD = 718,
		bl_icon_FILE_VOLUME = 722,
		bl_icon_ALEMBIC = 723,
		bl_icon_VOLUME = 724,
		bl_icon_FILE_HIDDEN = 725,
		bl_icon_FILE_BACKUP = 726,
		bl_icon_DISK_DRIVE = 727,
		bl_icon_MATPLANE = 728,
		bl_icon_MATSPHERE = 729,
		bl_icon_MATCUBE = 730,
		bl_icon_MONKEY = 731,
		bl_icon_HAIR = 732,
		bl_icon_ALIASED = 733,
		bl_icon_ANTIALIASED = 734,
		bl_icon_MAT_SPHERE_SKY = 735,
		bl_icon_MATSHADERBALL = 736,
		bl_icon_MATCLOTH = 737,
		bl_icon_MATFLUID = 738,
		bl_icon_WORDWRAP_OFF = 740,
		bl_icon_WORDWRAP_ON = 741,
		bl_icon_SYNTAX_OFF = 742,
		bl_icon_SYNTAX_ON = 743,
		bl_icon_LINENUMBERS_OFF = 744,
		bl_icon_LINENUMBERS_ON = 745,
		bl_icon_SCRIPTPLUGINS = 746,
		bl_icon_SEQ_SEQUENCER = 754,
		bl_icon_SEQ_PREVIEW = 755,
		bl_icon_SEQ_LUMA_WAVEFORM = 756,
		bl_icon_SEQ_CHROMA_SCOPE = 757,
		bl_icon_SEQ_HISTOGRAM = 758,
		bl_icon_SEQ_SPLITVIEW = 759,
		bl_icon_IMAGE_RGB = 763,
		bl_icon_IMAGE_RGB_ALPHA = 764,
		bl_icon_IMAGE_ALPHA = 765,
		bl_icon_IMAGE_ZDEPTH = 766,
		bl_icon_VIEW_PERSPECTIVE = 775,
		bl_icon_VIEW_ORTHO = 776,
		bl_icon_VIEW_CAMERA = 777,
		bl_icon_VIEW_PAN = 778,
		bl_icon_VIEW_ZOOM = 779,
		bl_icon_BRUSH_BLOB = 780,
		bl_icon_BRUSH_BLUR = 781,
		bl_icon_BRUSH_CLAY = 782,
		bl_icon_BRUSH_CLAY_STRIPS = 783,
		bl_icon_BRUSH_CLONE = 784,
		bl_icon_BRUSH_CREASE = 785,
		bl_icon_BRUSH_FILL = 786,
		bl_icon_BRUSH_FLATTEN = 787,
		bl_icon_BRUSH_GRAB = 788,
		bl_icon_BRUSH_INFLATE = 789,
		bl_icon_BRUSH_LAYER = 790,
		bl_icon_BRUSH_MASK = 791,
		bl_icon_BRUSH_MIX = 792,
		bl_icon_BRUSH_NUDGE = 793,
		bl_icon_BRUSH_PINCH = 794,
		bl_icon_BRUSH_SCRAPE = 795,
		bl_icon_BRUSH_SCULPT_DRAW = 796,
		bl_icon_BRUSH_SMEAR = 797,
		bl_icon_BRUSH_SMOOTH = 798,
		bl_icon_BRUSH_SNAKE_HOOK = 799,
		bl_icon_BRUSH_SOFTEN = 800,
		bl_icon_BRUSH_TEXDRAW = 801,
		bl_icon_BRUSH_TEXFILL = 802,
		bl_icon_BRUSH_TEXMASK = 803,
		bl_icon_BRUSH_THUMB = 804,
		bl_icon_BRUSH_ROTATE = 805,
		bl_icon_GPBRUSH_SMOOTH = 806,
		bl_icon_GPBRUSH_THICKNESS = 807,
		bl_icon_GPBRUSH_STRENGTH = 808,
		bl_icon_GPBRUSH_GRAB = 809,
		bl_icon_GPBRUSH_PUSH = 810,
		bl_icon_GPBRUSH_TWIST = 811,
		bl_icon_GPBRUSH_PINCH = 812,
		bl_icon_GPBRUSH_RANDOMIZE = 813,
		bl_icon_GPBRUSH_CLONE = 814,
		bl_icon_GPBRUSH_WEIGHT = 815,
		bl_icon_GPBRUSH_PENCIL = 816,
		bl_icon_GPBRUSH_PEN = 817,
		bl_icon_GPBRUSH_INK = 818,
		bl_icon_GPBRUSH_INKNOISE = 819,
		bl_icon_GPBRUSH_BLOCK = 820,
		bl_icon_GPBRUSH_MARKER = 821,
		bl_icon_GPBRUSH_FILL = 822,
		bl_icon_GPBRUSH_ERASE_SOFT = 823,
		bl_icon_GPBRUSH_ERASE_HARD = 824,
		bl_icon_GPBRUSH_ERASE_STROKE = 825,
		bl_icon_SMALL_TRI_RIGHT_VEC = 826,
		bl_icon_KEYTYPE_KEYFRAME_VEC = 827,
		bl_icon_KEYTYPE_BREAKDOWN_VEC = 828,
		bl_icon_KEYTYPE_EXTREME_VEC = 829,
		bl_icon_KEYTYPE_JITTER_VEC = 830,
		bl_icon_KEYTYPE_MOVING_HOLD_VEC = 831,
		bl_icon_HANDLETYPE_FREE_VEC = 832,
		bl_icon_HANDLETYPE_ALIGNED_VEC = 833,
		bl_icon_HANDLETYPE_VECTOR_VEC = 834,
		bl_icon_HANDLETYPE_AUTO_VEC = 835,
		bl_icon_HANDLETYPE_AUTO_CLAMP_VEC = 836,
		bl_icon_COLORSET_01_VEC = 837,
		bl_icon_COLORSET_02_VEC = 838,
		bl_icon_COLORSET_03_VEC = 839,
		bl_icon_COLORSET_04_VEC = 840,
		bl_icon_COLORSET_05_VEC = 841,
		bl_icon_COLORSET_06_VEC = 842,
		bl_icon_COLORSET_07_VEC = 843,
		bl_icon_COLORSET_08_VEC = 844,
		bl_icon_COLORSET_09_VEC = 845,
		bl_icon_COLORSET_10_VEC = 846,
		bl_icon_COLORSET_11_VEC = 847,
		bl_icon_COLORSET_12_VEC = 848,
		bl_icon_COLORSET_13_VEC = 849,
		bl_icon_COLORSET_14_VEC = 850,
		bl_icon_COLORSET_15_VEC = 851,
		bl_icon_COLORSET_16_VEC = 852,
		bl_icon_COLORSET_17_VEC = 853,
		bl_icon_COLORSET_18_VEC = 854,
		bl_icon_COLORSET_19_VEC = 855,
		bl_icon_COLORSET_20_VEC = 856,
		bl_icon_EVENT_A = 857,
		bl_icon_EVENT_B = 858,
		bl_icon_EVENT_C = 859,
		bl_icon_EVENT_D = 860,
		bl_icon_EVENT_E = 861,
		bl_icon_EVENT_F = 862,
		bl_icon_EVENT_G = 863,
		bl_icon_EVENT_H = 864,
		bl_icon_EVENT_I = 865,
		bl_icon_EVENT_J = 866,
		bl_icon_EVENT_K = 867,
		bl_icon_EVENT_L = 868,
		bl_icon_EVENT_M = 869,
		bl_icon_EVENT_N = 870,
		bl_icon_EVENT_O = 871,
		bl_icon_EVENT_P = 872,
		bl_icon_EVENT_Q = 873,
		bl_icon_EVENT_R = 874,
		bl_icon_EVENT_S = 875,
		bl_icon_EVENT_T = 876,
		bl_icon_EVENT_U = 877,
		bl_icon_EVENT_V = 878,
		bl_icon_EVENT_W = 879,
		bl_icon_EVENT_X = 880,
		bl_icon_EVENT_Y = 881,
		bl_icon_EVENT_Z = 882,
		bl_icon_EVENT_SHIFT = 883,
		bl_icon_EVENT_CTRL = 884,
		bl_icon_EVENT_ALT = 885,
		bl_icon_EVENT_OS = 886,
		bl_icon_EVENT_F1 = 887,
		bl_icon_EVENT_F2 = 888,
		bl_icon_EVENT_F3 = 889,
		bl_icon_EVENT_F4 = 890,
		bl_icon_EVENT_F5 = 891,
		bl_icon_EVENT_F6 = 892,
		bl_icon_EVENT_F7 = 893,
		bl_icon_EVENT_F8 = 894,
		bl_icon_EVENT_F9 = 895,
		bl_icon_EVENT_F10 = 896,
		bl_icon_EVENT_F11 = 897,
		bl_icon_EVENT_F12 = 898,
		bl_icon_EVENT_ESC = 899,
		bl_icon_EVENT_TAB = 900,
		bl_icon_EVENT_PAGEUP = 901,
		bl_icon_EVENT_PAGEDOWN = 902,
		bl_icon_EVENT_RETURN = 903,
	};
	inline bl_icon_enum bl_icon(void);
	inline void bl_icon(bl_icon_enum value);
	enum bl_static_type_enum {
		bl_static_type_CUSTOM = -1,
	};
	inline bl_static_type_enum bl_static_type(void);
	inline void bl_static_type(bl_static_type_enum value);
	inline float bl_width_default(void);
	inline void bl_width_default(float value);
	inline float bl_width_min(void);
	inline void bl_width_min(float value);
	inline float bl_width_max(void);
	inline void bl_width_max(float value);
	inline float bl_height_default(void);
	inline void bl_height_default(float value);
	inline float bl_height_min(void);
	inline void bl_height_min(float value);
	inline float bl_height_max(void);
	inline void bl_height_max(float value);

	inline void socket_value_update(Context& context);
	inline bool is_registered_node_type();
};

/**************** Valid ****************/

class NodeLink : public Pointer {
public:
	NodeLink(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline bool is_valid(void);
	inline void is_valid(bool value);
	inline Node from_node(void);
	inline Node to_node(void);
	inline NodeSocket from_socket(void);
	inline NodeSocket to_socket(void);
	inline bool is_hidden(void);
	inline void is_hidden(bool value);

};

/**************** Socket Template ****************/

class NodeInternalSocketTemplate : public Pointer {
public:
	NodeInternalSocketTemplate(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string name(void);
	inline void name(const std::string& value);
	inline std::string identifier(void);
	inline void identifier(const std::string& value);
	enum type_enum {
		type_CUSTOM = -1,
		type_VALUE = 0,
		type_INT = 6,
		type_BOOLEAN = 4,
		type_VECTOR = 1,
		type_STRING = 7,
		type_RGBA = 2,
		type_SHADER = 3,
	};
	inline type_enum type(void);
	inline void type(type_enum value);

};

/**************** NodeInternal ****************/

class NodeInternal : public Node {
public:
	NodeInternal(const PointerRNA &ptr_arg) :
		Node(ptr_arg)
		{}


	inline bool poll(NodeTree& node_tree);
	inline bool poll_instance(NodeTree& node_tree);
	inline void update();
	inline void draw_buttons(Context& context, UILayout& layout);
	inline void draw_buttons_ext(Context& context, UILayout& layout);
};

/**************** Shader Node ****************/

class ShaderNode : public NodeInternal {
public:
	ShaderNode(const PointerRNA &ptr_arg) :
		NodeInternal(ptr_arg)
		{}


};

/**************** Compositor Node ****************/

class CompositorNode : public NodeInternal {
public:
	CompositorNode(const PointerRNA &ptr_arg) :
		NodeInternal(ptr_arg)
		{}


	inline void tag_need_exec();
};

/**************** Texture Node ****************/

class TextureNode : public NodeInternal {
public:
	TextureNode(const PointerRNA &ptr_arg) :
		NodeInternal(ptr_arg)
		{}


};

/**************** Node Tree ****************/

class NodeTree : public ID {
public:
	NodeTree(const PointerRNA &ptr_arg) :
		ID(ptr_arg),
		nodes(ptr_arg),
		links(ptr_arg),
		inputs(ptr_arg),
		outputs(ptr_arg)
		{}

	inline Array<float, 2> view_center(void);
	inline void view_center(float values[2]);
	inline AnimData animation_data(void);
	COLLECTION_PROPERTY(Nodes, Node, NodeTree, nodes, false, true, true)
	COLLECTION_PROPERTY(NodeLinks, NodeLink, NodeTree, links, false, true, false)
	inline GreasePencil grease_pencil(void);
	enum type_enum {
		type_SHADER = 0,
		type_TEXTURE = 2,
		type_COMPOSITING = 1,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	COLLECTION_PROPERTY(NodeTreeInputs, NodeSocketInterface, NodeTree, inputs, false, true, true)
	inline int active_input(void);
	inline void active_input(int value);
	COLLECTION_PROPERTY(NodeTreeOutputs, NodeSocketInterface, NodeTree, outputs, false, true, true)
	inline int active_output(void);
	inline void active_output(int value);
	inline std::string bl_idname(void);
	inline void bl_idname(const std::string& value);
	inline std::string bl_label(void);
	inline void bl_label(const std::string& value);
	inline std::string bl_description(void);
	inline void bl_description(const std::string& value);
	enum bl_icon_enum {
		bl_icon_NONE = 0,
		bl_icon_QUESTION = 1,
		bl_icon_ERROR = 2,
		bl_icon_CANCEL = 3,
		bl_icon_TRIA_RIGHT = 4,
		bl_icon_TRIA_DOWN = 5,
		bl_icon_TRIA_LEFT = 6,
		bl_icon_TRIA_UP = 7,
		bl_icon_ARROW_LEFTRIGHT = 8,
		bl_icon_PLUS = 9,
		bl_icon_DISCLOSURE_TRI_RIGHT = 10,
		bl_icon_DISCLOSURE_TRI_DOWN = 11,
		bl_icon_RADIOBUT_OFF = 12,
		bl_icon_RADIOBUT_ON = 13,
		bl_icon_MENU_PANEL = 14,
		bl_icon_BLENDER = 15,
		bl_icon_GRIP = 16,
		bl_icon_DOT = 17,
		bl_icon_COLLAPSEMENU = 18,
		bl_icon_X = 19,
		bl_icon_DUPLICATE = 20,
		bl_icon_TRASH = 21,
		bl_icon_NODE = 24,
		bl_icon_NODE_SEL = 25,
		bl_icon_WINDOW = 26,
		bl_icon_WORKSPACE = 27,
		bl_icon_RIGHTARROW_THIN = 28,
		bl_icon_BORDERMOVE = 29,
		bl_icon_VIEWZOOM = 30,
		bl_icon_ADD = 31,
		bl_icon_REMOVE = 32,
		bl_icon_PANEL_CLOSE = 33,
		bl_icon_COPY_ID = 34,
		bl_icon_EYEDROPPER = 35,
		bl_icon_AUTO = 37,
		bl_icon_CHECKBOX_DEHLT = 38,
		bl_icon_CHECKBOX_HLT = 39,
		bl_icon_UNLOCKED = 40,
		bl_icon_LOCKED = 41,
		bl_icon_UNPINNED = 42,
		bl_icon_PINNED = 43,
		bl_icon_SCREEN_BACK = 44,
		bl_icon_RIGHTARROW = 45,
		bl_icon_DOWNARROW_HLT = 46,
		bl_icon_PLUGIN = 51,
		bl_icon_HELP = 52,
		bl_icon_GHOST_ENABLED = 53,
		bl_icon_COLOR = 54,
		bl_icon_UNLINKED = 55,
		bl_icon_LINKED = 56,
		bl_icon_HAND = 57,
		bl_icon_ZOOM_ALL = 58,
		bl_icon_ZOOM_SELECTED = 59,
		bl_icon_ZOOM_PREVIOUS = 60,
		bl_icon_ZOOM_IN = 61,
		bl_icon_ZOOM_OUT = 62,
		bl_icon_DRIVER_DISTANCE = 63,
		bl_icon_DRIVER_ROTATIONAL_DIFFERENCE = 64,
		bl_icon_DRIVER_TRANSFORM = 65,
		bl_icon_FREEZE = 66,
		bl_icon_STYLUS_PRESSURE = 67,
		bl_icon_GHOST_DISABLED = 68,
		bl_icon_FILE_NEW = 69,
		bl_icon_FILE_TICK = 70,
		bl_icon_QUIT = 71,
		bl_icon_URL = 72,
		bl_icon_RECOVER_LAST = 73,
		bl_icon_THREE_DOTS = 74,
		bl_icon_FULLSCREEN_ENTER = 75,
		bl_icon_FULLSCREEN_EXIT = 76,
		bl_icon_LIGHT = 78,
		bl_icon_MATERIAL = 79,
		bl_icon_TEXTURE = 80,
		bl_icon_ANIM = 81,
		bl_icon_WORLD = 82,
		bl_icon_SCENE = 83,
		bl_icon_OUTPUT = 84,
		bl_icon_SCRIPT = 87,
		bl_icon_PARTICLES = 88,
		bl_icon_PHYSICS = 89,
		bl_icon_SPEAKER = 90,
		bl_icon_TOOL_SETTINGS = 92,
		bl_icon_SHADERFX = 93,
		bl_icon_MODIFIER = 94,
		bl_icon_BLANK1 = 101,
		bl_icon_FAKE_USER_OFF = 102,
		bl_icon_FAKE_USER_ON = 103,
		bl_icon_VIEW3D = 104,
		bl_icon_GRAPH = 105,
		bl_icon_OUTLINER = 106,
		bl_icon_PROPERTIES = 107,
		bl_icon_FILEBROWSER = 108,
		bl_icon_IMAGE = 109,
		bl_icon_INFO = 110,
		bl_icon_SEQUENCE = 111,
		bl_icon_TEXT = 112,
		bl_icon_SOUND = 114,
		bl_icon_ACTION = 115,
		bl_icon_NLA = 116,
		bl_icon_PREFERENCES = 117,
		bl_icon_TIME = 118,
		bl_icon_NODETREE = 119,
		bl_icon_CONSOLE = 121,
		bl_icon_TRACKER = 123,
		bl_icon_ASSET_MANAGER = 124,
		bl_icon_NODE_COMPOSITING = 125,
		bl_icon_NODE_TEXTURE = 126,
		bl_icon_NODE_MATERIAL = 127,
		bl_icon_UV = 128,
		bl_icon_OBJECT_DATAMODE = 130,
		bl_icon_EDITMODE_HLT = 131,
		bl_icon_UV_DATA = 132,
		bl_icon_VPAINT_HLT = 133,
		bl_icon_TPAINT_HLT = 134,
		bl_icon_WPAINT_HLT = 135,
		bl_icon_SCULPTMODE_HLT = 136,
		bl_icon_POSE_HLT = 137,
		bl_icon_PARTICLEMODE = 138,
		bl_icon_TRACKING = 146,
		bl_icon_TRACKING_BACKWARDS = 147,
		bl_icon_TRACKING_FORWARDS = 148,
		bl_icon_TRACKING_BACKWARDS_SINGLE = 149,
		bl_icon_TRACKING_FORWARDS_SINGLE = 150,
		bl_icon_TRACKING_CLEAR_BACKWARDS = 151,
		bl_icon_TRACKING_CLEAR_FORWARDS = 152,
		bl_icon_TRACKING_REFINE_BACKWARDS = 153,
		bl_icon_TRACKING_REFINE_FORWARDS = 154,
		bl_icon_SCENE_DATA = 156,
		bl_icon_RENDERLAYERS = 157,
		bl_icon_WORLD_DATA = 158,
		bl_icon_OBJECT_DATA = 159,
		bl_icon_MESH_DATA = 160,
		bl_icon_CURVE_DATA = 161,
		bl_icon_META_DATA = 162,
		bl_icon_LATTICE_DATA = 163,
		bl_icon_LIGHT_DATA = 164,
		bl_icon_MATERIAL_DATA = 165,
		bl_icon_TEXTURE_DATA = 166,
		bl_icon_ANIM_DATA = 167,
		bl_icon_CAMERA_DATA = 168,
		bl_icon_PARTICLE_DATA = 169,
		bl_icon_LIBRARY_DATA_DIRECT = 170,
		bl_icon_GROUP = 171,
		bl_icon_ARMATURE_DATA = 172,
		bl_icon_COMMUNITY = 173,
		bl_icon_BONE_DATA = 174,
		bl_icon_CONSTRAINT = 175,
		bl_icon_SHAPEKEY_DATA = 176,
		bl_icon_CONSTRAINT_BONE = 177,
		bl_icon_CAMERA_STEREO = 178,
		bl_icon_PACKAGE = 179,
		bl_icon_UGLYPACKAGE = 180,
		bl_icon_EXPERIMENTAL = 181,
		bl_icon_BRUSH_DATA = 182,
		bl_icon_IMAGE_DATA = 183,
		bl_icon_FILE = 184,
		bl_icon_FCURVE = 185,
		bl_icon_FONT_DATA = 186,
		bl_icon_RENDER_RESULT = 187,
		bl_icon_SURFACE_DATA = 188,
		bl_icon_EMPTY_DATA = 189,
		bl_icon_PRESET = 190,
		bl_icon_RENDER_ANIMATION = 191,
		bl_icon_RENDER_STILL = 192,
		bl_icon_LIBRARY_DATA_BROKEN = 193,
		bl_icon_BOIDS = 194,
		bl_icon_STRANDS = 195,
		bl_icon_LIBRARY_DATA_INDIRECT = 196,
		bl_icon_GREASEPENCIL = 197,
		bl_icon_LINE_DATA = 198,
		bl_icon_LIBRARY_DATA_OVERRIDE = 199,
		bl_icon_GROUP_BONE = 200,
		bl_icon_GROUP_VERTEX = 201,
		bl_icon_GROUP_VCOL = 202,
		bl_icon_GROUP_UVS = 203,
		bl_icon_FACE_MAPS = 204,
		bl_icon_RNA = 206,
		bl_icon_RNA_ADD = 207,
		bl_icon_MOUSE_LMB = 208,
		bl_icon_MOUSE_MMB = 209,
		bl_icon_MOUSE_RMB = 210,
		bl_icon_MOUSE_MOVE = 211,
		bl_icon_MOUSE_LMB_DRAG = 212,
		bl_icon_MOUSE_MMB_DRAG = 213,
		bl_icon_MOUSE_RMB_DRAG = 214,
		bl_icon_PRESET_NEW = 216,
		bl_icon_DECORATE = 218,
		bl_icon_DECORATE_KEYFRAME = 219,
		bl_icon_DECORATE_ANIMATE = 220,
		bl_icon_DECORATE_DRIVER = 221,
		bl_icon_DECORATE_LINKED = 222,
		bl_icon_DECORATE_LIBRARY_OVERRIDE = 223,
		bl_icon_DECORATE_UNLOCKED = 224,
		bl_icon_DECORATE_LOCKED = 225,
		bl_icon_DECORATE_OVERRIDE = 226,
		bl_icon_TRACKER_DATA = 228,
		bl_icon_HEART = 229,
		bl_icon_ORPHAN_DATA = 230,
		bl_icon_USER = 231,
		bl_icon_SYSTEM = 232,
		bl_icon_SETTINGS = 233,
		bl_icon_OUTLINER_OB_EMPTY = 234,
		bl_icon_OUTLINER_OB_MESH = 235,
		bl_icon_OUTLINER_OB_CURVE = 236,
		bl_icon_OUTLINER_OB_LATTICE = 237,
		bl_icon_OUTLINER_OB_META = 238,
		bl_icon_OUTLINER_OB_LIGHT = 239,
		bl_icon_OUTLINER_OB_CAMERA = 240,
		bl_icon_OUTLINER_OB_ARMATURE = 241,
		bl_icon_OUTLINER_OB_FONT = 242,
		bl_icon_OUTLINER_OB_SURFACE = 243,
		bl_icon_OUTLINER_OB_SPEAKER = 244,
		bl_icon_OUTLINER_OB_FORCE_FIELD = 245,
		bl_icon_OUTLINER_OB_GROUP_INSTANCE = 246,
		bl_icon_OUTLINER_OB_GREASEPENCIL = 247,
		bl_icon_OUTLINER_OB_LIGHTPROBE = 248,
		bl_icon_OUTLINER_OB_IMAGE = 249,
		bl_icon_RESTRICT_COLOR_OFF = 251,
		bl_icon_RESTRICT_COLOR_ON = 252,
		bl_icon_HIDE_ON = 253,
		bl_icon_HIDE_OFF = 254,
		bl_icon_RESTRICT_SELECT_ON = 255,
		bl_icon_RESTRICT_SELECT_OFF = 256,
		bl_icon_RESTRICT_RENDER_ON = 257,
		bl_icon_RESTRICT_RENDER_OFF = 258,
		bl_icon_OUTLINER_DATA_EMPTY = 260,
		bl_icon_OUTLINER_DATA_MESH = 261,
		bl_icon_OUTLINER_DATA_CURVE = 262,
		bl_icon_OUTLINER_DATA_LATTICE = 263,
		bl_icon_OUTLINER_DATA_META = 264,
		bl_icon_OUTLINER_DATA_LIGHT = 265,
		bl_icon_OUTLINER_DATA_CAMERA = 266,
		bl_icon_OUTLINER_DATA_ARMATURE = 267,
		bl_icon_OUTLINER_DATA_FONT = 268,
		bl_icon_OUTLINER_DATA_SURFACE = 269,
		bl_icon_OUTLINER_DATA_SPEAKER = 270,
		bl_icon_OUTLINER_DATA_GREASEPENCIL = 273,
		bl_icon_GP_SELECT_POINTS = 274,
		bl_icon_GP_SELECT_STROKES = 275,
		bl_icon_GP_MULTIFRAME_EDITING = 276,
		bl_icon_GP_ONLY_SELECTED = 277,
		bl_icon_GP_SELECT_BETWEEN_STROKES = 278,
		bl_icon_MODIFIER_OFF = 279,
		bl_icon_MODIFIER_ON = 280,
		bl_icon_ONIONSKIN_OFF = 281,
		bl_icon_ONIONSKIN_ON = 282,
		bl_icon_RESTRICT_VIEW_ON = 283,
		bl_icon_RESTRICT_VIEW_OFF = 284,
		bl_icon_MESH_PLANE = 286,
		bl_icon_MESH_CUBE = 287,
		bl_icon_MESH_CIRCLE = 288,
		bl_icon_MESH_UVSPHERE = 289,
		bl_icon_MESH_ICOSPHERE = 290,
		bl_icon_MESH_GRID = 291,
		bl_icon_MESH_MONKEY = 292,
		bl_icon_MESH_CYLINDER = 293,
		bl_icon_MESH_TORUS = 294,
		bl_icon_MESH_CONE = 295,
		bl_icon_MESH_CAPSULE = 296,
		bl_icon_EMPTY_SINGLE_ARROW = 297,
		bl_icon_LIGHT_POINT = 298,
		bl_icon_LIGHT_SUN = 299,
		bl_icon_LIGHT_SPOT = 300,
		bl_icon_LIGHT_HEMI = 301,
		bl_icon_LIGHT_AREA = 302,
		bl_icon_CUBE = 303,
		bl_icon_SPHERE = 304,
		bl_icon_CONE = 305,
		bl_icon_META_PLANE = 306,
		bl_icon_META_CUBE = 307,
		bl_icon_META_BALL = 308,
		bl_icon_META_ELLIPSOID = 309,
		bl_icon_META_CAPSULE = 310,
		bl_icon_SURFACE_NCURVE = 312,
		bl_icon_SURFACE_NCIRCLE = 313,
		bl_icon_SURFACE_NSURFACE = 314,
		bl_icon_SURFACE_NCYLINDER = 315,
		bl_icon_SURFACE_NSPHERE = 316,
		bl_icon_SURFACE_NTORUS = 317,
		bl_icon_EMPTY_AXIS = 318,
		bl_icon_STROKE = 319,
		bl_icon_EMPTY_ARROWS = 320,
		bl_icon_CURVE_BEZCURVE = 321,
		bl_icon_CURVE_BEZCIRCLE = 322,
		bl_icon_CURVE_NCURVE = 323,
		bl_icon_CURVE_NCIRCLE = 324,
		bl_icon_CURVE_PATH = 325,
		bl_icon_LIGHTPROBE_CUBEMAP = 326,
		bl_icon_LIGHTPROBE_PLANAR = 327,
		bl_icon_LIGHTPROBE_GRID = 328,
		bl_icon_COLOR_RED = 331,
		bl_icon_COLOR_GREEN = 332,
		bl_icon_COLOR_BLUE = 333,
		bl_icon_TRIA_RIGHT_BAR = 334,
		bl_icon_TRIA_DOWN_BAR = 335,
		bl_icon_TRIA_LEFT_BAR = 336,
		bl_icon_TRIA_UP_BAR = 337,
		bl_icon_FORCE_FORCE = 338,
		bl_icon_FORCE_WIND = 339,
		bl_icon_FORCE_VORTEX = 340,
		bl_icon_FORCE_MAGNETIC = 341,
		bl_icon_FORCE_HARMONIC = 342,
		bl_icon_FORCE_CHARGE = 343,
		bl_icon_FORCE_LENNARDJONES = 344,
		bl_icon_FORCE_TEXTURE = 345,
		bl_icon_FORCE_CURVE = 346,
		bl_icon_FORCE_BOID = 347,
		bl_icon_FORCE_TURBULENCE = 348,
		bl_icon_FORCE_DRAG = 349,
		bl_icon_FORCE_SMOKEFLOW = 350,
		bl_icon_IMAGE_PLANE = 361,
		bl_icon_IMAGE_BACKGROUND = 362,
		bl_icon_IMAGE_REFERENCE = 363,
		bl_icon_NODE_INSERT_ON = 367,
		bl_icon_NODE_INSERT_OFF = 368,
		bl_icon_NODE_TOP = 369,
		bl_icon_NODE_SIDE = 370,
		bl_icon_NODE_CORNER = 371,
		bl_icon_ALIGN_LEFT = 390,
		bl_icon_ALIGN_CENTER = 391,
		bl_icon_ALIGN_RIGHT = 392,
		bl_icon_ALIGN_JUSTIFY = 393,
		bl_icon_ALIGN_FLUSH = 394,
		bl_icon_ALIGN_TOP = 395,
		bl_icon_ALIGN_MIDDLE = 396,
		bl_icon_ALIGN_BOTTOM = 397,
		bl_icon_BOLD = 398,
		bl_icon_ITALIC = 399,
		bl_icon_UNDERLINE = 400,
		bl_icon_SMALL_CAPS = 401,
		bl_icon_MODIFIER_DATA = 442,
		bl_icon_MOD_WAVE = 443,
		bl_icon_MOD_BUILD = 444,
		bl_icon_MOD_DECIM = 445,
		bl_icon_MOD_MIRROR = 446,
		bl_icon_MOD_SOFT = 447,
		bl_icon_MOD_SUBSURF = 448,
		bl_icon_HOOK = 449,
		bl_icon_MOD_PHYSICS = 450,
		bl_icon_MOD_PARTICLES = 451,
		bl_icon_MOD_BOOLEAN = 452,
		bl_icon_MOD_EDGESPLIT = 453,
		bl_icon_MOD_ARRAY = 454,
		bl_icon_MOD_UVPROJECT = 455,
		bl_icon_MOD_DISPLACE = 456,
		bl_icon_MOD_CURVE = 457,
		bl_icon_MOD_LATTICE = 458,
		bl_icon_MOD_TINT = 459,
		bl_icon_MOD_ARMATURE = 460,
		bl_icon_MOD_SHRINKWRAP = 461,
		bl_icon_MOD_CAST = 462,
		bl_icon_MOD_MESHDEFORM = 463,
		bl_icon_MOD_BEVEL = 464,
		bl_icon_MOD_SMOOTH = 465,
		bl_icon_MOD_SIMPLEDEFORM = 466,
		bl_icon_MOD_MASK = 467,
		bl_icon_MOD_CLOTH = 468,
		bl_icon_MOD_EXPLODE = 469,
		bl_icon_MOD_FLUIDSIM = 470,
		bl_icon_MOD_MULTIRES = 471,
		bl_icon_MOD_SMOKE = 472,
		bl_icon_MOD_SOLIDIFY = 473,
		bl_icon_MOD_SCREW = 474,
		bl_icon_MOD_VERTEX_WEIGHT = 475,
		bl_icon_MOD_DYNAMICPAINT = 476,
		bl_icon_MOD_REMESH = 477,
		bl_icon_MOD_OCEAN = 478,
		bl_icon_MOD_WARP = 479,
		bl_icon_MOD_SKIN = 480,
		bl_icon_MOD_TRIANGULATE = 481,
		bl_icon_MOD_WIREFRAME = 482,
		bl_icon_MOD_DATA_TRANSFER = 483,
		bl_icon_MOD_NORMALEDIT = 484,
		bl_icon_MOD_PARTICLE_INSTANCE = 485,
		bl_icon_MOD_HUE_SATURATION = 486,
		bl_icon_MOD_NOISE = 487,
		bl_icon_MOD_OFFSET = 488,
		bl_icon_MOD_SIMPLIFY = 489,
		bl_icon_MOD_THICKNESS = 490,
		bl_icon_MOD_INSTANCE = 491,
		bl_icon_MOD_TIME = 492,
		bl_icon_MOD_OPACITY = 493,
		bl_icon_REC = 494,
		bl_icon_PLAY = 495,
		bl_icon_FF = 496,
		bl_icon_REW = 497,
		bl_icon_PAUSE = 498,
		bl_icon_PREV_KEYFRAME = 499,
		bl_icon_NEXT_KEYFRAME = 500,
		bl_icon_PLAY_SOUND = 501,
		bl_icon_PLAY_REVERSE = 502,
		bl_icon_PREVIEW_RANGE = 503,
		bl_icon_ACTION_TWEAK = 504,
		bl_icon_PMARKER_ACT = 505,
		bl_icon_PMARKER_SEL = 506,
		bl_icon_PMARKER = 507,
		bl_icon_MARKER_HLT = 508,
		bl_icon_MARKER = 509,
		bl_icon_KEYFRAME_HLT = 510,
		bl_icon_KEYFRAME = 511,
		bl_icon_KEYINGSET = 512,
		bl_icon_KEY_DEHLT = 513,
		bl_icon_KEY_HLT = 514,
		bl_icon_MUTE_IPO_OFF = 515,
		bl_icon_MUTE_IPO_ON = 516,
		bl_icon_VISIBLE_IPO_OFF = 517,
		bl_icon_VISIBLE_IPO_ON = 518,
		bl_icon_DRIVER = 519,
		bl_icon_SOLO_OFF = 520,
		bl_icon_SOLO_ON = 521,
		bl_icon_FRAME_PREV = 522,
		bl_icon_FRAME_NEXT = 523,
		bl_icon_NLA_PUSHDOWN = 524,
		bl_icon_IPO_CONSTANT = 525,
		bl_icon_IPO_LINEAR = 526,
		bl_icon_IPO_BEZIER = 527,
		bl_icon_IPO_SINE = 528,
		bl_icon_IPO_QUAD = 529,
		bl_icon_IPO_CUBIC = 530,
		bl_icon_IPO_QUART = 531,
		bl_icon_IPO_QUINT = 532,
		bl_icon_IPO_EXPO = 533,
		bl_icon_IPO_CIRC = 534,
		bl_icon_IPO_BOUNCE = 535,
		bl_icon_IPO_ELASTIC = 536,
		bl_icon_IPO_BACK = 537,
		bl_icon_IPO_EASE_IN = 538,
		bl_icon_IPO_EASE_OUT = 539,
		bl_icon_IPO_EASE_IN_OUT = 540,
		bl_icon_NORMALIZE_FCURVES = 541,
		bl_icon_VERTEXSEL = 546,
		bl_icon_EDGESEL = 547,
		bl_icon_FACESEL = 548,
		bl_icon_PIVOT_BOUNDBOX = 551,
		bl_icon_PIVOT_CURSOR = 552,
		bl_icon_PIVOT_INDIVIDUAL = 553,
		bl_icon_PIVOT_MEDIAN = 554,
		bl_icon_PIVOT_ACTIVE = 555,
		bl_icon_CENTER_ONLY = 556,
		bl_icon_ROOTCURVE = 557,
		bl_icon_SMOOTHCURVE = 558,
		bl_icon_SPHERECURVE = 559,
		bl_icon_INVERSESQUARECURVE = 560,
		bl_icon_SHARPCURVE = 561,
		bl_icon_LINCURVE = 562,
		bl_icon_NOCURVE = 563,
		bl_icon_RNDCURVE = 564,
		bl_icon_PROP_OFF = 565,
		bl_icon_PROP_ON = 566,
		bl_icon_PROP_CON = 567,
		bl_icon_PROP_PROJECTED = 568,
		bl_icon_PARTICLE_POINT = 569,
		bl_icon_PARTICLE_TIP = 570,
		bl_icon_PARTICLE_PATH = 571,
		bl_icon_SNAP_OFF = 576,
		bl_icon_SNAP_ON = 577,
		bl_icon_SNAP_NORMAL = 578,
		bl_icon_SNAP_GRID = 579,
		bl_icon_SNAP_VERTEX = 580,
		bl_icon_SNAP_EDGE = 581,
		bl_icon_SNAP_FACE = 582,
		bl_icon_SNAP_VOLUME = 583,
		bl_icon_SNAP_INCREMENT = 584,
		bl_icon_STICKY_UVS_LOC = 585,
		bl_icon_STICKY_UVS_DISABLE = 586,
		bl_icon_STICKY_UVS_VERT = 587,
		bl_icon_CLIPUV_DEHLT = 588,
		bl_icon_CLIPUV_HLT = 589,
		bl_icon_SNAP_PEEL_OBJECT = 590,
		bl_icon_GRID = 591,
		bl_icon_OBJECT_ORIGIN = 592,
		bl_icon_ORIENTATION_GLOBAL = 593,
		bl_icon_ORIENTATION_GIMBAL = 594,
		bl_icon_ORIENTATION_LOCAL = 595,
		bl_icon_ORIENTATION_NORMAL = 596,
		bl_icon_ORIENTATION_VIEW = 597,
		bl_icon_COPYDOWN = 598,
		bl_icon_PASTEDOWN = 599,
		bl_icon_PASTEFLIPUP = 600,
		bl_icon_PASTEFLIPDOWN = 601,
		bl_icon_VIS_SEL_11 = 602,
		bl_icon_VIS_SEL_10 = 603,
		bl_icon_VIS_SEL_01 = 604,
		bl_icon_VIS_SEL_00 = 605,
		bl_icon_AUTOMERGE_ON = 607,
		bl_icon_AUTOMERGE_OFF = 608,
		bl_icon_UV_VERTEXSEL = 610,
		bl_icon_UV_EDGESEL = 611,
		bl_icon_UV_FACESEL = 612,
		bl_icon_UV_ISLANDSEL = 613,
		bl_icon_UV_SYNC_SELECT = 614,
		bl_icon_ORIENTATION_CURSOR = 620,
		bl_icon_NORMALS_VERTEX = 621,
		bl_icon_NORMALS_FACE = 622,
		bl_icon_NORMALS_VERTEX_FACE = 623,
		bl_icon_SHADING_BBOX = 624,
		bl_icon_SHADING_WIRE = 625,
		bl_icon_SHADING_SOLID = 626,
		bl_icon_SHADING_RENDERED = 627,
		bl_icon_SHADING_TEXTURE = 628,
		bl_icon_OVERLAY = 629,
		bl_icon_XRAY = 630,
		bl_icon_LOCKVIEW_OFF = 633,
		bl_icon_LOCKVIEW_ON = 634,
		bl_icon_AXIS_SIDE = 636,
		bl_icon_AXIS_FRONT = 637,
		bl_icon_AXIS_TOP = 638,
		bl_icon_NDOF_DOM = 639,
		bl_icon_NDOF_TURN = 640,
		bl_icon_NDOF_FLY = 641,
		bl_icon_NDOF_TRANS = 642,
		bl_icon_LAYER_USED = 643,
		bl_icon_LAYER_ACTIVE = 644,
		bl_icon_SORTALPHA = 676,
		bl_icon_SORTBYEXT = 677,
		bl_icon_SORTTIME = 678,
		bl_icon_SORTSIZE = 679,
		bl_icon_SHORTDISPLAY = 680,
		bl_icon_LONGDISPLAY = 681,
		bl_icon_IMGDISPLAY = 683,
		bl_icon_BOOKMARKS = 686,
		bl_icon_FONTPREVIEW = 687,
		bl_icon_FILTER = 688,
		bl_icon_NEWFOLDER = 689,
		bl_icon_FILE_PARENT = 691,
		bl_icon_FILE_REFRESH = 692,
		bl_icon_FILE_FOLDER = 693,
		bl_icon_FILE_BLANK = 694,
		bl_icon_FILE_BLEND = 695,
		bl_icon_FILE_IMAGE = 696,
		bl_icon_FILE_MOVIE = 697,
		bl_icon_FILE_SCRIPT = 698,
		bl_icon_FILE_SOUND = 699,
		bl_icon_FILE_FONT = 700,
		bl_icon_FILE_TEXT = 701,
		bl_icon_SORT_DESC = 702,
		bl_icon_SORT_ASC = 703,
		bl_icon_LINK_BLEND = 704,
		bl_icon_APPEND_BLEND = 705,
		bl_icon_IMPORT = 706,
		bl_icon_EXPORT = 707,
		bl_icon_LOOP_BACK = 715,
		bl_icon_LOOP_FORWARDS = 716,
		bl_icon_BACK = 717,
		bl_icon_FORWARD = 718,
		bl_icon_FILE_VOLUME = 722,
		bl_icon_ALEMBIC = 723,
		bl_icon_VOLUME = 724,
		bl_icon_FILE_HIDDEN = 725,
		bl_icon_FILE_BACKUP = 726,
		bl_icon_DISK_DRIVE = 727,
		bl_icon_MATPLANE = 728,
		bl_icon_MATSPHERE = 729,
		bl_icon_MATCUBE = 730,
		bl_icon_MONKEY = 731,
		bl_icon_HAIR = 732,
		bl_icon_ALIASED = 733,
		bl_icon_ANTIALIASED = 734,
		bl_icon_MAT_SPHERE_SKY = 735,
		bl_icon_MATSHADERBALL = 736,
		bl_icon_MATCLOTH = 737,
		bl_icon_MATFLUID = 738,
		bl_icon_WORDWRAP_OFF = 740,
		bl_icon_WORDWRAP_ON = 741,
		bl_icon_SYNTAX_OFF = 742,
		bl_icon_SYNTAX_ON = 743,
		bl_icon_LINENUMBERS_OFF = 744,
		bl_icon_LINENUMBERS_ON = 745,
		bl_icon_SCRIPTPLUGINS = 746,
		bl_icon_SEQ_SEQUENCER = 754,
		bl_icon_SEQ_PREVIEW = 755,
		bl_icon_SEQ_LUMA_WAVEFORM = 756,
		bl_icon_SEQ_CHROMA_SCOPE = 757,
		bl_icon_SEQ_HISTOGRAM = 758,
		bl_icon_SEQ_SPLITVIEW = 759,
		bl_icon_IMAGE_RGB = 763,
		bl_icon_IMAGE_RGB_ALPHA = 764,
		bl_icon_IMAGE_ALPHA = 765,
		bl_icon_IMAGE_ZDEPTH = 766,
		bl_icon_VIEW_PERSPECTIVE = 775,
		bl_icon_VIEW_ORTHO = 776,
		bl_icon_VIEW_CAMERA = 777,
		bl_icon_VIEW_PAN = 778,
		bl_icon_VIEW_ZOOM = 779,
		bl_icon_BRUSH_BLOB = 780,
		bl_icon_BRUSH_BLUR = 781,
		bl_icon_BRUSH_CLAY = 782,
		bl_icon_BRUSH_CLAY_STRIPS = 783,
		bl_icon_BRUSH_CLONE = 784,
		bl_icon_BRUSH_CREASE = 785,
		bl_icon_BRUSH_FILL = 786,
		bl_icon_BRUSH_FLATTEN = 787,
		bl_icon_BRUSH_GRAB = 788,
		bl_icon_BRUSH_INFLATE = 789,
		bl_icon_BRUSH_LAYER = 790,
		bl_icon_BRUSH_MASK = 791,
		bl_icon_BRUSH_MIX = 792,
		bl_icon_BRUSH_NUDGE = 793,
		bl_icon_BRUSH_PINCH = 794,
		bl_icon_BRUSH_SCRAPE = 795,
		bl_icon_BRUSH_SCULPT_DRAW = 796,
		bl_icon_BRUSH_SMEAR = 797,
		bl_icon_BRUSH_SMOOTH = 798,
		bl_icon_BRUSH_SNAKE_HOOK = 799,
		bl_icon_BRUSH_SOFTEN = 800,
		bl_icon_BRUSH_TEXDRAW = 801,
		bl_icon_BRUSH_TEXFILL = 802,
		bl_icon_BRUSH_TEXMASK = 803,
		bl_icon_BRUSH_THUMB = 804,
		bl_icon_BRUSH_ROTATE = 805,
		bl_icon_GPBRUSH_SMOOTH = 806,
		bl_icon_GPBRUSH_THICKNESS = 807,
		bl_icon_GPBRUSH_STRENGTH = 808,
		bl_icon_GPBRUSH_GRAB = 809,
		bl_icon_GPBRUSH_PUSH = 810,
		bl_icon_GPBRUSH_TWIST = 811,
		bl_icon_GPBRUSH_PINCH = 812,
		bl_icon_GPBRUSH_RANDOMIZE = 813,
		bl_icon_GPBRUSH_CLONE = 814,
		bl_icon_GPBRUSH_WEIGHT = 815,
		bl_icon_GPBRUSH_PENCIL = 816,
		bl_icon_GPBRUSH_PEN = 817,
		bl_icon_GPBRUSH_INK = 818,
		bl_icon_GPBRUSH_INKNOISE = 819,
		bl_icon_GPBRUSH_BLOCK = 820,
		bl_icon_GPBRUSH_MARKER = 821,
		bl_icon_GPBRUSH_FILL = 822,
		bl_icon_GPBRUSH_ERASE_SOFT = 823,
		bl_icon_GPBRUSH_ERASE_HARD = 824,
		bl_icon_GPBRUSH_ERASE_STROKE = 825,
		bl_icon_SMALL_TRI_RIGHT_VEC = 826,
		bl_icon_KEYTYPE_KEYFRAME_VEC = 827,
		bl_icon_KEYTYPE_BREAKDOWN_VEC = 828,
		bl_icon_KEYTYPE_EXTREME_VEC = 829,
		bl_icon_KEYTYPE_JITTER_VEC = 830,
		bl_icon_KEYTYPE_MOVING_HOLD_VEC = 831,
		bl_icon_HANDLETYPE_FREE_VEC = 832,
		bl_icon_HANDLETYPE_ALIGNED_VEC = 833,
		bl_icon_HANDLETYPE_VECTOR_VEC = 834,
		bl_icon_HANDLETYPE_AUTO_VEC = 835,
		bl_icon_HANDLETYPE_AUTO_CLAMP_VEC = 836,
		bl_icon_COLORSET_01_VEC = 837,
		bl_icon_COLORSET_02_VEC = 838,
		bl_icon_COLORSET_03_VEC = 839,
		bl_icon_COLORSET_04_VEC = 840,
		bl_icon_COLORSET_05_VEC = 841,
		bl_icon_COLORSET_06_VEC = 842,
		bl_icon_COLORSET_07_VEC = 843,
		bl_icon_COLORSET_08_VEC = 844,
		bl_icon_COLORSET_09_VEC = 845,
		bl_icon_COLORSET_10_VEC = 846,
		bl_icon_COLORSET_11_VEC = 847,
		bl_icon_COLORSET_12_VEC = 848,
		bl_icon_COLORSET_13_VEC = 849,
		bl_icon_COLORSET_14_VEC = 850,
		bl_icon_COLORSET_15_VEC = 851,
		bl_icon_COLORSET_16_VEC = 852,
		bl_icon_COLORSET_17_VEC = 853,
		bl_icon_COLORSET_18_VEC = 854,
		bl_icon_COLORSET_19_VEC = 855,
		bl_icon_COLORSET_20_VEC = 856,
		bl_icon_EVENT_A = 857,
		bl_icon_EVENT_B = 858,
		bl_icon_EVENT_C = 859,
		bl_icon_EVENT_D = 860,
		bl_icon_EVENT_E = 861,
		bl_icon_EVENT_F = 862,
		bl_icon_EVENT_G = 863,
		bl_icon_EVENT_H = 864,
		bl_icon_EVENT_I = 865,
		bl_icon_EVENT_J = 866,
		bl_icon_EVENT_K = 867,
		bl_icon_EVENT_L = 868,
		bl_icon_EVENT_M = 869,
		bl_icon_EVENT_N = 870,
		bl_icon_EVENT_O = 871,
		bl_icon_EVENT_P = 872,
		bl_icon_EVENT_Q = 873,
		bl_icon_EVENT_R = 874,
		bl_icon_EVENT_S = 875,
		bl_icon_EVENT_T = 876,
		bl_icon_EVENT_U = 877,
		bl_icon_EVENT_V = 878,
		bl_icon_EVENT_W = 879,
		bl_icon_EVENT_X = 880,
		bl_icon_EVENT_Y = 881,
		bl_icon_EVENT_Z = 882,
		bl_icon_EVENT_SHIFT = 883,
		bl_icon_EVENT_CTRL = 884,
		bl_icon_EVENT_ALT = 885,
		bl_icon_EVENT_OS = 886,
		bl_icon_EVENT_F1 = 887,
		bl_icon_EVENT_F2 = 888,
		bl_icon_EVENT_F3 = 889,
		bl_icon_EVENT_F4 = 890,
		bl_icon_EVENT_F5 = 891,
		bl_icon_EVENT_F6 = 892,
		bl_icon_EVENT_F7 = 893,
		bl_icon_EVENT_F8 = 894,
		bl_icon_EVENT_F9 = 895,
		bl_icon_EVENT_F10 = 896,
		bl_icon_EVENT_F11 = 897,
		bl_icon_EVENT_F12 = 898,
		bl_icon_EVENT_ESC = 899,
		bl_icon_EVENT_TAB = 900,
		bl_icon_EVENT_PAGEUP = 901,
		bl_icon_EVENT_PAGEDOWN = 902,
		bl_icon_EVENT_RETURN = 903,
	};
	inline bl_icon_enum bl_icon(void);
	inline void bl_icon(bl_icon_enum value);

	inline void interface_update(Context& context);
};

/**************** NodeSocketStandard ****************/

class NodeSocketStandard : public NodeSocket {
public:
	NodeSocketStandard(const PointerRNA &ptr_arg) :
		NodeSocket(ptr_arg)
		{}


	inline void draw(Context& context, UILayout& layout, Node& node, const char * text);
	inline void draw_color(Context& context, Node& node, float color[4]);
};

/**************** NodeSocketInterfaceStandard ****************/

class NodeSocketInterfaceStandard : public NodeSocketInterface {
public:
	NodeSocketInterfaceStandard(const PointerRNA &ptr_arg) :
		NodeSocketInterface(ptr_arg)
		{}

	enum type_enum {
		type_CUSTOM = -1,
		type_VALUE = 0,
		type_INT = 6,
		type_BOOLEAN = 4,
		type_VECTOR = 1,
		type_STRING = 7,
		type_RGBA = 2,
		type_SHADER = 3,
	};
	inline type_enum type(void);
	inline void type(type_enum value);

	inline void draw(Context& context, UILayout& layout);
	inline void draw_color(Context& context, float color[4]);
};

/**************** Float Node Socket ****************/

class NodeSocketFloat : public NodeSocketStandard {
public:
	NodeSocketFloat(const PointerRNA &ptr_arg) :
		NodeSocketStandard(ptr_arg)
		{}

	inline float default_value(void);
	inline void default_value(float value);

};

/**************** Float Node Socket Interface ****************/

class NodeSocketInterfaceFloat : public NodeSocketInterfaceStandard {
public:
	NodeSocketInterfaceFloat(const PointerRNA &ptr_arg) :
		NodeSocketInterfaceStandard(ptr_arg)
		{}

	inline float default_value(void);
	inline void default_value(float value);
	inline float min_value(void);
	inline void min_value(float value);
	inline float max_value(void);
	inline void max_value(float value);

};

/**************** Float Node Socket ****************/

class NodeSocketFloatUnsigned : public NodeSocketStandard {
public:
	NodeSocketFloatUnsigned(const PointerRNA &ptr_arg) :
		NodeSocketStandard(ptr_arg)
		{}

	inline float default_value(void);
	inline void default_value(float value);

};

/**************** Float Node Socket Interface ****************/

class NodeSocketInterfaceFloatUnsigned : public NodeSocketInterfaceStandard {
public:
	NodeSocketInterfaceFloatUnsigned(const PointerRNA &ptr_arg) :
		NodeSocketInterfaceStandard(ptr_arg)
		{}

	inline float default_value(void);
	inline void default_value(float value);
	inline float min_value(void);
	inline void min_value(float value);
	inline float max_value(void);
	inline void max_value(float value);

};

/**************** Float Node Socket ****************/

class NodeSocketFloatPercentage : public NodeSocketStandard {
public:
	NodeSocketFloatPercentage(const PointerRNA &ptr_arg) :
		NodeSocketStandard(ptr_arg)
		{}

	inline float default_value(void);
	inline void default_value(float value);

};

/**************** Float Node Socket Interface ****************/

class NodeSocketInterfaceFloatPercentage : public NodeSocketInterfaceStandard {
public:
	NodeSocketInterfaceFloatPercentage(const PointerRNA &ptr_arg) :
		NodeSocketInterfaceStandard(ptr_arg)
		{}

	inline float default_value(void);
	inline void default_value(float value);
	inline float min_value(void);
	inline void min_value(float value);
	inline float max_value(void);
	inline void max_value(float value);

};

/**************** Float Node Socket ****************/

class NodeSocketFloatFactor : public NodeSocketStandard {
public:
	NodeSocketFloatFactor(const PointerRNA &ptr_arg) :
		NodeSocketStandard(ptr_arg)
		{}

	inline float default_value(void);
	inline void default_value(float value);

};

/**************** Float Node Socket Interface ****************/

class NodeSocketInterfaceFloatFactor : public NodeSocketInterfaceStandard {
public:
	NodeSocketInterfaceFloatFactor(const PointerRNA &ptr_arg) :
		NodeSocketInterfaceStandard(ptr_arg)
		{}

	inline float default_value(void);
	inline void default_value(float value);
	inline float min_value(void);
	inline void min_value(float value);
	inline float max_value(void);
	inline void max_value(float value);

};

/**************** Float Node Socket ****************/

class NodeSocketFloatAngle : public NodeSocketStandard {
public:
	NodeSocketFloatAngle(const PointerRNA &ptr_arg) :
		NodeSocketStandard(ptr_arg)
		{}

	inline float default_value(void);
	inline void default_value(float value);

};

/**************** Float Node Socket Interface ****************/

class NodeSocketInterfaceFloatAngle : public NodeSocketInterfaceStandard {
public:
	NodeSocketInterfaceFloatAngle(const PointerRNA &ptr_arg) :
		NodeSocketInterfaceStandard(ptr_arg)
		{}

	inline float default_value(void);
	inline void default_value(float value);
	inline float min_value(void);
	inline void min_value(float value);
	inline float max_value(void);
	inline void max_value(float value);

};

/**************** Float Node Socket ****************/

class NodeSocketFloatTime : public NodeSocketStandard {
public:
	NodeSocketFloatTime(const PointerRNA &ptr_arg) :
		NodeSocketStandard(ptr_arg)
		{}

	inline float default_value(void);
	inline void default_value(float value);

};

/**************** Float Node Socket Interface ****************/

class NodeSocketInterfaceFloatTime : public NodeSocketInterfaceStandard {
public:
	NodeSocketInterfaceFloatTime(const PointerRNA &ptr_arg) :
		NodeSocketInterfaceStandard(ptr_arg)
		{}

	inline float default_value(void);
	inline void default_value(float value);
	inline float min_value(void);
	inline void min_value(float value);
	inline float max_value(void);
	inline void max_value(float value);

};

/**************** Integer Node Socket ****************/

class NodeSocketInt : public NodeSocketStandard {
public:
	NodeSocketInt(const PointerRNA &ptr_arg) :
		NodeSocketStandard(ptr_arg)
		{}

	inline int default_value(void);
	inline void default_value(int value);

};

/**************** Integer Node Socket Interface ****************/

class NodeSocketInterfaceInt : public NodeSocketInterfaceStandard {
public:
	NodeSocketInterfaceInt(const PointerRNA &ptr_arg) :
		NodeSocketInterfaceStandard(ptr_arg)
		{}

	inline int default_value(void);
	inline void default_value(int value);
	inline int min_value(void);
	inline void min_value(int value);
	inline int max_value(void);
	inline void max_value(int value);

};

/**************** Integer Node Socket ****************/

class NodeSocketIntUnsigned : public NodeSocketStandard {
public:
	NodeSocketIntUnsigned(const PointerRNA &ptr_arg) :
		NodeSocketStandard(ptr_arg)
		{}

	inline int default_value(void);
	inline void default_value(int value);

};

/**************** Integer Node Socket Interface ****************/

class NodeSocketInterfaceIntUnsigned : public NodeSocketInterfaceStandard {
public:
	NodeSocketInterfaceIntUnsigned(const PointerRNA &ptr_arg) :
		NodeSocketInterfaceStandard(ptr_arg)
		{}

	inline int default_value(void);
	inline void default_value(int value);
	inline int min_value(void);
	inline void min_value(int value);
	inline int max_value(void);
	inline void max_value(int value);

};

/**************** Integer Node Socket ****************/

class NodeSocketIntPercentage : public NodeSocketStandard {
public:
	NodeSocketIntPercentage(const PointerRNA &ptr_arg) :
		NodeSocketStandard(ptr_arg)
		{}

	inline int default_value(void);
	inline void default_value(int value);

};

/**************** Integer Node Socket Interface ****************/

class NodeSocketInterfaceIntPercentage : public NodeSocketInterfaceStandard {
public:
	NodeSocketInterfaceIntPercentage(const PointerRNA &ptr_arg) :
		NodeSocketInterfaceStandard(ptr_arg)
		{}

	inline int default_value(void);
	inline void default_value(int value);
	inline int min_value(void);
	inline void min_value(int value);
	inline int max_value(void);
	inline void max_value(int value);

};

/**************** Integer Node Socket ****************/

class NodeSocketIntFactor : public NodeSocketStandard {
public:
	NodeSocketIntFactor(const PointerRNA &ptr_arg) :
		NodeSocketStandard(ptr_arg)
		{}

	inline int default_value(void);
	inline void default_value(int value);

};

/**************** Integer Node Socket Interface ****************/

class NodeSocketInterfaceIntFactor : public NodeSocketInterfaceStandard {
public:
	NodeSocketInterfaceIntFactor(const PointerRNA &ptr_arg) :
		NodeSocketInterfaceStandard(ptr_arg)
		{}

	inline int default_value(void);
	inline void default_value(int value);
	inline int min_value(void);
	inline void min_value(int value);
	inline int max_value(void);
	inline void max_value(int value);

};

/**************** Boolean Node Socket ****************/

class NodeSocketBool : public NodeSocketStandard {
public:
	NodeSocketBool(const PointerRNA &ptr_arg) :
		NodeSocketStandard(ptr_arg)
		{}

	inline bool default_value(void);
	inline void default_value(bool value);

};

/**************** Boolean Node Socket Interface ****************/

class NodeSocketInterfaceBool : public NodeSocketInterfaceStandard {
public:
	NodeSocketInterfaceBool(const PointerRNA &ptr_arg) :
		NodeSocketInterfaceStandard(ptr_arg)
		{}

	inline bool default_value(void);
	inline void default_value(bool value);

};

/**************** Vector Node Socket ****************/

class NodeSocketVector : public NodeSocketStandard {
public:
	NodeSocketVector(const PointerRNA &ptr_arg) :
		NodeSocketStandard(ptr_arg)
		{}

	inline Array<float, 3> default_value(void);
	inline void default_value(float values[3]);

};

/**************** Vector Node Socket Interface ****************/

class NodeSocketInterfaceVector : public NodeSocketInterfaceStandard {
public:
	NodeSocketInterfaceVector(const PointerRNA &ptr_arg) :
		NodeSocketInterfaceStandard(ptr_arg)
		{}

	inline Array<float, 3> default_value(void);
	inline void default_value(float values[3]);
	inline float min_value(void);
	inline void min_value(float value);
	inline float max_value(void);
	inline void max_value(float value);

};

/**************** Vector Node Socket ****************/

class NodeSocketVectorTranslation : public NodeSocketStandard {
public:
	NodeSocketVectorTranslation(const PointerRNA &ptr_arg) :
		NodeSocketStandard(ptr_arg)
		{}

	inline Array<float, 3> default_value(void);
	inline void default_value(float values[3]);

};

/**************** Vector Node Socket Interface ****************/

class NodeSocketInterfaceVectorTranslation : public NodeSocketInterfaceStandard {
public:
	NodeSocketInterfaceVectorTranslation(const PointerRNA &ptr_arg) :
		NodeSocketInterfaceStandard(ptr_arg)
		{}

	inline Array<float, 3> default_value(void);
	inline void default_value(float values[3]);
	inline float min_value(void);
	inline void min_value(float value);
	inline float max_value(void);
	inline void max_value(float value);

};

/**************** Vector Node Socket ****************/

class NodeSocketVectorDirection : public NodeSocketStandard {
public:
	NodeSocketVectorDirection(const PointerRNA &ptr_arg) :
		NodeSocketStandard(ptr_arg)
		{}

	inline Array<float, 3> default_value(void);
	inline void default_value(float values[3]);

};

/**************** Vector Node Socket Interface ****************/

class NodeSocketInterfaceVectorDirection : public NodeSocketInterfaceStandard {
public:
	NodeSocketInterfaceVectorDirection(const PointerRNA &ptr_arg) :
		NodeSocketInterfaceStandard(ptr_arg)
		{}

	inline Array<float, 3> default_value(void);
	inline void default_value(float values[3]);
	inline float min_value(void);
	inline void min_value(float value);
	inline float max_value(void);
	inline void max_value(float value);

};

/**************** Vector Node Socket ****************/

class NodeSocketVectorVelocity : public NodeSocketStandard {
public:
	NodeSocketVectorVelocity(const PointerRNA &ptr_arg) :
		NodeSocketStandard(ptr_arg)
		{}

	inline Array<float, 3> default_value(void);
	inline void default_value(float values[3]);

};

/**************** Vector Node Socket Interface ****************/

class NodeSocketInterfaceVectorVelocity : public NodeSocketInterfaceStandard {
public:
	NodeSocketInterfaceVectorVelocity(const PointerRNA &ptr_arg) :
		NodeSocketInterfaceStandard(ptr_arg)
		{}

	inline Array<float, 3> default_value(void);
	inline void default_value(float values[3]);
	inline float min_value(void);
	inline void min_value(float value);
	inline float max_value(void);
	inline void max_value(float value);

};

/**************** Vector Node Socket ****************/

class NodeSocketVectorAcceleration : public NodeSocketStandard {
public:
	NodeSocketVectorAcceleration(const PointerRNA &ptr_arg) :
		NodeSocketStandard(ptr_arg)
		{}

	inline Array<float, 3> default_value(void);
	inline void default_value(float values[3]);

};

/**************** Vector Node Socket Interface ****************/

class NodeSocketInterfaceVectorAcceleration : public NodeSocketInterfaceStandard {
public:
	NodeSocketInterfaceVectorAcceleration(const PointerRNA &ptr_arg) :
		NodeSocketInterfaceStandard(ptr_arg)
		{}

	inline Array<float, 3> default_value(void);
	inline void default_value(float values[3]);
	inline float min_value(void);
	inline void min_value(float value);
	inline float max_value(void);
	inline void max_value(float value);

};

/**************** Vector Node Socket ****************/

class NodeSocketVectorEuler : public NodeSocketStandard {
public:
	NodeSocketVectorEuler(const PointerRNA &ptr_arg) :
		NodeSocketStandard(ptr_arg)
		{}

	inline Array<float, 3> default_value(void);
	inline void default_value(float values[3]);

};

/**************** Vector Node Socket Interface ****************/

class NodeSocketInterfaceVectorEuler : public NodeSocketInterfaceStandard {
public:
	NodeSocketInterfaceVectorEuler(const PointerRNA &ptr_arg) :
		NodeSocketInterfaceStandard(ptr_arg)
		{}

	inline Array<float, 3> default_value(void);
	inline void default_value(float values[3]);
	inline float min_value(void);
	inline void min_value(float value);
	inline float max_value(void);
	inline void max_value(float value);

};

/**************** Vector Node Socket ****************/

class NodeSocketVectorXYZ : public NodeSocketStandard {
public:
	NodeSocketVectorXYZ(const PointerRNA &ptr_arg) :
		NodeSocketStandard(ptr_arg)
		{}

	inline Array<float, 3> default_value(void);
	inline void default_value(float values[3]);

};

/**************** Vector Node Socket Interface ****************/

class NodeSocketInterfaceVectorXYZ : public NodeSocketInterfaceStandard {
public:
	NodeSocketInterfaceVectorXYZ(const PointerRNA &ptr_arg) :
		NodeSocketInterfaceStandard(ptr_arg)
		{}

	inline Array<float, 3> default_value(void);
	inline void default_value(float values[3]);
	inline float min_value(void);
	inline void min_value(float value);
	inline float max_value(void);
	inline void max_value(float value);

};

/**************** Color Node Socket ****************/

class NodeSocketColor : public NodeSocketStandard {
public:
	NodeSocketColor(const PointerRNA &ptr_arg) :
		NodeSocketStandard(ptr_arg)
		{}

	inline Array<float, 4> default_value(void);
	inline void default_value(float values[4]);

};

/**************** Color Node Socket Interface ****************/

class NodeSocketInterfaceColor : public NodeSocketInterfaceStandard {
public:
	NodeSocketInterfaceColor(const PointerRNA &ptr_arg) :
		NodeSocketInterfaceStandard(ptr_arg)
		{}

	inline Array<float, 4> default_value(void);
	inline void default_value(float values[4]);

};

/**************** String Node Socket ****************/

class NodeSocketString : public NodeSocketStandard {
public:
	NodeSocketString(const PointerRNA &ptr_arg) :
		NodeSocketStandard(ptr_arg)
		{}

	inline std::string default_value(void);
	inline void default_value(const std::string& value);

};

/**************** String Node Socket Interface ****************/

class NodeSocketInterfaceString : public NodeSocketInterfaceStandard {
public:
	NodeSocketInterfaceString(const PointerRNA &ptr_arg) :
		NodeSocketInterfaceStandard(ptr_arg)
		{}

	inline std::string default_value(void);
	inline void default_value(const std::string& value);

};

/**************** Shader Node Socket ****************/

class NodeSocketShader : public NodeSocketStandard {
public:
	NodeSocketShader(const PointerRNA &ptr_arg) :
		NodeSocketStandard(ptr_arg)
		{}


};

/**************** Shader Node Socket Interface ****************/

class NodeSocketInterfaceShader : public NodeSocketInterfaceStandard {
public:
	NodeSocketInterfaceShader(const PointerRNA &ptr_arg) :
		NodeSocketInterfaceStandard(ptr_arg)
		{}


};

/**************** Virtual Node Socket ****************/

class NodeSocketVirtual : public NodeSocketStandard {
public:
	NodeSocketVirtual(const PointerRNA &ptr_arg) :
		NodeSocketStandard(ptr_arg)
		{}


};

/**************** Compositor Node Tree ****************/

class CompositorNodeTree : public NodeTree {
public:
	CompositorNodeTree(const PointerRNA &ptr_arg) :
		NodeTree(ptr_arg)
		{}

	enum render_quality_enum {
		render_quality_HIGH = 0,
		render_quality_MEDIUM = 1,
		render_quality_LOW = 2,
	};
	inline render_quality_enum render_quality(void);
	inline void render_quality(render_quality_enum value);
	enum edit_quality_enum {
		edit_quality_HIGH = 0,
		edit_quality_MEDIUM = 1,
		edit_quality_LOW = 2,
	};
	inline edit_quality_enum edit_quality(void);
	inline void edit_quality(edit_quality_enum value);
	enum chunk_size_enum {
		chunk_size_32 = 32,
		chunk_size_64 = 64,
		chunk_size_128 = 128,
		chunk_size_256 = 256,
		chunk_size_512 = 512,
		chunk_size_1024 = 1024,
	};
	inline chunk_size_enum chunk_size(void);
	inline void chunk_size(chunk_size_enum value);
	inline bool use_opencl(void);
	inline void use_opencl(bool value);
	inline bool use_groupnode_buffer(void);
	inline void use_groupnode_buffer(bool value);
	inline bool use_two_pass(void);
	inline void use_two_pass(bool value);
	inline bool use_viewer_border(void);
	inline void use_viewer_border(bool value);

};

/**************** Shader Node Tree ****************/

class ShaderNodeTree : public NodeTree {
public:
	ShaderNodeTree(const PointerRNA &ptr_arg) :
		NodeTree(ptr_arg)
		{}


	inline ShaderNode get_output_node(int target);
};

/**************** Texture Node Tree ****************/

class TextureNodeTree : public NodeTree {
public:
	TextureNodeTree(const PointerRNA &ptr_arg) :
		NodeTree(ptr_arg)
		{}


};

/**************** Frame ****************/

class NodeFrame : public NodeInternal {
public:
	NodeFrame(const PointerRNA &ptr_arg) :
		NodeInternal(ptr_arg)
		{}

	inline Text text(void);
	inline bool shrink(void);
	inline void shrink(bool value);
	inline int label_size(void);
	inline void label_size(int value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Group ****************/

class NodeGroup : public NodeInternal {
public:
	NodeGroup(const PointerRNA &ptr_arg) :
		NodeInternal(ptr_arg)
		{}

	inline NodeTree node_tree(void);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Group Input ****************/

class NodeGroupInput : public NodeInternal {
public:
	NodeGroupInput(const PointerRNA &ptr_arg) :
		NodeInternal(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Group Output ****************/

class NodeGroupOutput : public NodeInternal {
public:
	NodeGroupOutput(const PointerRNA &ptr_arg) :
		NodeInternal(ptr_arg)
		{}

	inline bool is_active_output(void);
	inline void is_active_output(bool value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Reroute ****************/

class NodeReroute : public NodeInternal {
public:
	NodeReroute(const PointerRNA &ptr_arg) :
		NodeInternal(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** RGB ****************/

class ShaderNodeRGB : public ShaderNode {
public:
	ShaderNodeRGB(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Value ****************/

class ShaderNodeValue : public ShaderNode {
public:
	ShaderNodeValue(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** MixRGB ****************/

class ShaderNodeMixRGB : public ShaderNode {
public:
	ShaderNodeMixRGB(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}

	enum blend_type_enum {
		blend_type_MIX = 0,
		blend_type_DARKEN = 7,
		blend_type_MULTIPLY = 2,
		blend_type_BURN = 11,
		blend_type_LIGHTEN = 8,
		blend_type_SCREEN = 4,
		blend_type_DODGE = 10,
		blend_type_ADD = 1,
		blend_type_OVERLAY = 9,
		blend_type_SOFT_LIGHT = 16,
		blend_type_LINEAR_LIGHT = 17,
		blend_type_DIFFERENCE = 6,
		blend_type_SUBTRACT = 3,
		blend_type_DIVIDE = 5,
		blend_type_HUE = 12,
		blend_type_SATURATION = 13,
		blend_type_COLOR = 15,
		blend_type_VALUE = 14,
	};
	inline blend_type_enum blend_type(void);
	inline void blend_type(blend_type_enum value);
	inline bool use_alpha(void);
	inline void use_alpha(bool value);
	inline bool use_clamp(void);
	inline void use_clamp(bool value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** ColorRamp ****************/

class ShaderNodeValToRGB : public ShaderNode {
public:
	ShaderNodeValToRGB(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}

	inline ColorRamp color_ramp(void);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** RGB to BW ****************/

class ShaderNodeRGBToBW : public ShaderNode {
public:
	ShaderNodeRGBToBW(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Shader to RGB ****************/

class ShaderNodeShaderToRGB : public ShaderNode {
public:
	ShaderNodeShaderToRGB(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Normal ****************/

class ShaderNodeNormal : public ShaderNode {
public:
	ShaderNodeNormal(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Gamma ****************/

class ShaderNodeGamma : public ShaderNode {
public:
	ShaderNodeGamma(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Bright Contrast ****************/

class ShaderNodeBrightContrast : public ShaderNode {
public:
	ShaderNodeBrightContrast(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Mapping ****************/

class ShaderNodeMapping : public ShaderNode {
public:
	ShaderNodeMapping(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}

	enum vector_type_enum {
		vector_type_TEXTURE = 1,
		vector_type_POINT = 0,
		vector_type_VECTOR = 2,
		vector_type_NORMAL = 3,
	};
	inline vector_type_enum vector_type(void);
	inline void vector_type(vector_type_enum value);
	inline Array<float, 3> translation(void);
	inline void translation(float values[3]);
	inline Array<float, 3> rotation(void);
	inline void rotation(float values[3]);
	inline Array<float, 3> scale(void);
	inline void scale(float values[3]);
	inline Array<float, 3> min(void);
	inline void min(float values[3]);
	inline Array<float, 3> max(void);
	inline void max(float values[3]);
	inline bool use_min(void);
	inline void use_min(bool value);
	inline bool use_max(void);
	inline void use_max(bool value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Vector Curves ****************/

class ShaderNodeVectorCurve : public ShaderNode {
public:
	ShaderNodeVectorCurve(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}

	inline CurveMapping mapping(void);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** RGB Curves ****************/

class ShaderNodeRGBCurve : public ShaderNode {
public:
	ShaderNodeRGBCurve(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}

	inline CurveMapping mapping(void);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Camera Data ****************/

class ShaderNodeCameraData : public ShaderNode {
public:
	ShaderNodeCameraData(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Math ****************/

class ShaderNodeMath : public ShaderNode {
public:
	ShaderNodeMath(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}

	enum operation_enum {
		operation_ADD = 0,
		operation_SUBTRACT = 1,
		operation_MULTIPLY = 2,
		operation_DIVIDE = 3,
		operation_POWER = 10,
		operation_LOGARITHM = 11,
		operation_SQRT = 23,
		operation_ABSOLUTE = 18,
		operation_MINIMUM = 12,
		operation_MAXIMUM = 13,
		operation_LESS_THAN = 15,
		operation_GREATER_THAN = 16,
		operation_ROUND = 14,
		operation_FLOOR = 20,
		operation_CEIL = 21,
		operation_FRACT = 22,
		operation_MODULO = 17,
		operation_SINE = 4,
		operation_COSINE = 5,
		operation_TANGENT = 6,
		operation_ARCSINE = 7,
		operation_ARCCOSINE = 8,
		operation_ARCTANGENT = 9,
		operation_ARCTAN2 = 19,
	};
	inline operation_enum operation(void);
	inline void operation(operation_enum value);
	inline bool use_clamp(void);
	inline void use_clamp(bool value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Vector Math ****************/

class ShaderNodeVectorMath : public ShaderNode {
public:
	ShaderNodeVectorMath(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}

	enum operation_enum {
		operation_ADD = 0,
		operation_SUBTRACT = 1,
		operation_AVERAGE = 2,
		operation_DOT_PRODUCT = 3,
		operation_CROSS_PRODUCT = 4,
		operation_NORMALIZE = 5,
	};
	inline operation_enum operation(void);
	inline void operation(operation_enum value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Squeeze Value ****************/

class ShaderNodeSqueeze : public ShaderNode {
public:
	ShaderNodeSqueeze(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Invert ****************/

class ShaderNodeInvert : public ShaderNode {
public:
	ShaderNodeInvert(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Separate RGB ****************/

class ShaderNodeSeparateRGB : public ShaderNode {
public:
	ShaderNodeSeparateRGB(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Combine RGB ****************/

class ShaderNodeCombineRGB : public ShaderNode {
public:
	ShaderNodeCombineRGB(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Hue/Saturation ****************/

class ShaderNodeHueSaturation : public ShaderNode {
public:
	ShaderNodeHueSaturation(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Material Output ****************/

class ShaderNodeOutputMaterial : public ShaderNode {
public:
	ShaderNodeOutputMaterial(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}

	inline bool is_active_output(void);
	inline void is_active_output(bool value);
	enum target_enum {
		target_ALL = 0,
		target_EEVEE = 1,
		target_CYCLES = 2,
	};
	inline target_enum target(void);
	inline void target(target_enum value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Specular ****************/

class ShaderNodeEeveeSpecular : public ShaderNode {
public:
	ShaderNodeEeveeSpecular(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Light Output ****************/

class ShaderNodeOutputLight : public ShaderNode {
public:
	ShaderNodeOutputLight(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}

	inline bool is_active_output(void);
	inline void is_active_output(bool value);
	enum target_enum {
		target_ALL = 0,
		target_EEVEE = 1,
		target_CYCLES = 2,
	};
	inline target_enum target(void);
	inline void target(target_enum value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** World Output ****************/

class ShaderNodeOutputWorld : public ShaderNode {
public:
	ShaderNodeOutputWorld(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}

	inline bool is_active_output(void);
	inline void is_active_output(bool value);
	enum target_enum {
		target_ALL = 0,
		target_EEVEE = 1,
		target_CYCLES = 2,
	};
	inline target_enum target(void);
	inline void target(target_enum value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Line Style Output ****************/

class ShaderNodeOutputLineStyle : public ShaderNode {
public:
	ShaderNodeOutputLineStyle(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}

	inline bool is_active_output(void);
	inline void is_active_output(bool value);
	enum target_enum {
		target_ALL = 0,
		target_EEVEE = 1,
		target_CYCLES = 2,
	};
	inline target_enum target(void);
	inline void target(target_enum value);
	enum blend_type_enum {
		blend_type_MIX = 0,
		blend_type_DARKEN = 7,
		blend_type_MULTIPLY = 2,
		blend_type_BURN = 11,
		blend_type_LIGHTEN = 8,
		blend_type_SCREEN = 4,
		blend_type_DODGE = 10,
		blend_type_ADD = 1,
		blend_type_OVERLAY = 9,
		blend_type_SOFT_LIGHT = 16,
		blend_type_LINEAR_LIGHT = 17,
		blend_type_DIFFERENCE = 6,
		blend_type_SUBTRACT = 3,
		blend_type_DIVIDE = 5,
		blend_type_HUE = 12,
		blend_type_SATURATION = 13,
		blend_type_COLOR = 15,
		blend_type_VALUE = 14,
	};
	inline blend_type_enum blend_type(void);
	inline void blend_type(blend_type_enum value);
	inline bool use_alpha(void);
	inline void use_alpha(bool value);
	inline bool use_clamp(void);
	inline void use_clamp(bool value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Fresnel ****************/

class ShaderNodeFresnel : public ShaderNode {
public:
	ShaderNodeFresnel(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Layer Weight ****************/

class ShaderNodeLayerWeight : public ShaderNode {
public:
	ShaderNodeLayerWeight(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Mix Shader ****************/

class ShaderNodeMixShader : public ShaderNode {
public:
	ShaderNodeMixShader(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Add Shader ****************/

class ShaderNodeAddShader : public ShaderNode {
public:
	ShaderNodeAddShader(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Attribute ****************/

class ShaderNodeAttribute : public ShaderNode {
public:
	ShaderNodeAttribute(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}

	inline std::string attribute_name(void);
	inline void attribute_name(const std::string& value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Ambient Occlusion ****************/

class ShaderNodeAmbientOcclusion : public ShaderNode {
public:
	ShaderNodeAmbientOcclusion(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}

	inline int samples(void);
	inline void samples(int value);
	inline bool inside(void);
	inline void inside(bool value);
	inline bool only_local(void);
	inline void only_local(bool value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Background ****************/

class ShaderNodeBackground : public ShaderNode {
public:
	ShaderNodeBackground(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Holdout ****************/

class ShaderNodeHoldout : public ShaderNode {
public:
	ShaderNodeHoldout(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Anisotropic BSDF ****************/

class ShaderNodeBsdfAnisotropic : public ShaderNode {
public:
	ShaderNodeBsdfAnisotropic(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}

	enum distribution_enum {
		distribution_BECKMANN = 0,
		distribution_GGX = 2,
		distribution_MULTI_GGX = 4,
		distribution_ASHIKHMIN_SHIRLEY = 3,
	};
	inline distribution_enum distribution(void);
	inline void distribution(distribution_enum value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Diffuse BSDF ****************/

class ShaderNodeBsdfDiffuse : public ShaderNode {
public:
	ShaderNodeBsdfDiffuse(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Principled BSDF ****************/

class ShaderNodeBsdfPrincipled : public ShaderNode {
public:
	ShaderNodeBsdfPrincipled(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}

	enum distribution_enum {
		distribution_GGX = 2,
		distribution_MULTI_GGX = 4,
	};
	inline distribution_enum distribution(void);
	inline void distribution(distribution_enum value);
	enum subsurface_method_enum {
		subsurface_method_BURLEY = 3,
		subsurface_method_RANDOM_WALK = 4,
	};
	inline subsurface_method_enum subsurface_method(void);
	inline void subsurface_method(subsurface_method_enum value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Glossy BSDF ****************/

class ShaderNodeBsdfGlossy : public ShaderNode {
public:
	ShaderNodeBsdfGlossy(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}

	enum distribution_enum {
		distribution_SHARP = 1,
		distribution_BECKMANN = 0,
		distribution_GGX = 2,
		distribution_ASHIKHMIN_SHIRLEY = 3,
		distribution_MULTI_GGX = 4,
	};
	inline distribution_enum distribution(void);
	inline void distribution(distribution_enum value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Glass BSDF ****************/

class ShaderNodeBsdfGlass : public ShaderNode {
public:
	ShaderNodeBsdfGlass(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}

	enum distribution_enum {
		distribution_SHARP = 1,
		distribution_BECKMANN = 0,
		distribution_GGX = 2,
		distribution_MULTI_GGX = 4,
	};
	inline distribution_enum distribution(void);
	inline void distribution(distribution_enum value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Refraction BSDF ****************/

class ShaderNodeBsdfRefraction : public ShaderNode {
public:
	ShaderNodeBsdfRefraction(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}

	enum distribution_enum {
		distribution_SHARP = 1,
		distribution_BECKMANN = 0,
		distribution_GGX = 2,
	};
	inline distribution_enum distribution(void);
	inline void distribution(distribution_enum value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Translucent BSDF ****************/

class ShaderNodeBsdfTranslucent : public ShaderNode {
public:
	ShaderNodeBsdfTranslucent(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Transparent BSDF ****************/

class ShaderNodeBsdfTransparent : public ShaderNode {
public:
	ShaderNodeBsdfTransparent(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Velvet BSDF ****************/

class ShaderNodeBsdfVelvet : public ShaderNode {
public:
	ShaderNodeBsdfVelvet(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Toon BSDF ****************/

class ShaderNodeBsdfToon : public ShaderNode {
public:
	ShaderNodeBsdfToon(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}

	enum component_enum {
		component_DIFFUSE = 0,
		component_GLOSSY = 1,
	};
	inline component_enum component(void);
	inline void component(component_enum value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Hair BSDF ****************/

class ShaderNodeBsdfHair : public ShaderNode {
public:
	ShaderNodeBsdfHair(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}

	enum component_enum {
		component_Reflection = 0,
		component_Transmission = 1,
	};
	inline component_enum component(void);
	inline void component(component_enum value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Principled Hair BSDF ****************/

class ShaderNodeBsdfHairPrincipled : public ShaderNode {
public:
	ShaderNodeBsdfHairPrincipled(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}

	enum parametrization_enum {
		parametrization_ABSORPTION = 2,
		parametrization_MELANIN = 1,
		parametrization_COLOR = 0,
	};
	inline parametrization_enum parametrization(void);
	inline void parametrization(parametrization_enum value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Subsurface Scattering ****************/

class ShaderNodeSubsurfaceScattering : public ShaderNode {
public:
	ShaderNodeSubsurfaceScattering(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}

	enum falloff_enum {
		falloff_CUBIC = 1,
		falloff_GAUSSIAN = 2,
		falloff_BURLEY = 3,
		falloff_RANDOM_WALK = 4,
	};
	inline falloff_enum falloff(void);
	inline void falloff(falloff_enum value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Volume Absorption ****************/

class ShaderNodeVolumeAbsorption : public ShaderNode {
public:
	ShaderNodeVolumeAbsorption(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Volume Scatter ****************/

class ShaderNodeVolumeScatter : public ShaderNode {
public:
	ShaderNodeVolumeScatter(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Principled Volume ****************/

class ShaderNodeVolumePrincipled : public ShaderNode {
public:
	ShaderNodeVolumePrincipled(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Emission ****************/

class ShaderNodeEmission : public ShaderNode {
public:
	ShaderNodeEmission(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Geometry ****************/

class ShaderNodeNewGeometry : public ShaderNode {
public:
	ShaderNodeNewGeometry(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Light Path ****************/

class ShaderNodeLightPath : public ShaderNode {
public:
	ShaderNodeLightPath(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Light Falloff ****************/

class ShaderNodeLightFalloff : public ShaderNode {
public:
	ShaderNodeLightFalloff(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Object Info ****************/

class ShaderNodeObjectInfo : public ShaderNode {
public:
	ShaderNodeObjectInfo(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Particle Info ****************/

class ShaderNodeParticleInfo : public ShaderNode {
public:
	ShaderNodeParticleInfo(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Hair Info ****************/

class ShaderNodeHairInfo : public ShaderNode {
public:
	ShaderNodeHairInfo(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Wireframe ****************/

class ShaderNodeWireframe : public ShaderNode {
public:
	ShaderNodeWireframe(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}

	inline bool use_pixel_size(void);
	inline void use_pixel_size(bool value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Wavelength ****************/

class ShaderNodeWavelength : public ShaderNode {
public:
	ShaderNodeWavelength(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Blackbody ****************/

class ShaderNodeBlackbody : public ShaderNode {
public:
	ShaderNodeBlackbody(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Bump ****************/

class ShaderNodeBump : public ShaderNode {
public:
	ShaderNodeBump(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}

	inline bool invert(void);
	inline void invert(bool value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Normal Map ****************/

class ShaderNodeNormalMap : public ShaderNode {
public:
	ShaderNodeNormalMap(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}

	enum space_enum {
		space_TANGENT = 0,
		space_OBJECT = 1,
		space_WORLD = 2,
		space_BLENDER_OBJECT = 3,
		space_BLENDER_WORLD = 4,
	};
	inline space_enum space(void);
	inline void space(space_enum value);
	inline std::string uv_map(void);
	inline void uv_map(const std::string& value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Tangent ****************/

class ShaderNodeTangent : public ShaderNode {
public:
	ShaderNodeTangent(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}

	enum direction_type_enum {
		direction_type_RADIAL = 0,
		direction_type_UV_MAP = 1,
	};
	inline direction_type_enum direction_type(void);
	inline void direction_type(direction_type_enum value);
	enum axis_enum {
		axis_X = 0,
		axis_Y = 1,
		axis_Z = 2,
	};
	inline axis_enum axis(void);
	inline void axis(axis_enum value);
	inline std::string uv_map(void);
	inline void uv_map(const std::string& value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Script ****************/

class ShaderNodeScript : public ShaderNode {
public:
	ShaderNodeScript(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}

	inline Text script(void);
	inline std::string filepath(void);
	inline void filepath(const std::string& value);
	enum mode_enum {
		mode_INTERNAL = 0,
		mode_EXTERNAL = 1,
	};
	inline mode_enum mode(void);
	inline void mode(mode_enum value);
	inline bool use_auto_update(void);
	inline void use_auto_update(bool value);
	inline std::string bytecode(void);
	inline void bytecode(const std::string& value);
	inline std::string bytecode_hash(void);
	inline void bytecode_hash(const std::string& value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Image Texture ****************/

class ShaderNodeTexImage : public ShaderNode {
public:
	ShaderNodeTexImage(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}

	inline Image image(void);
	inline TexMapping texture_mapping(void);
	inline ColorMapping color_mapping(void);
	enum color_space_enum {
		color_space_COLOR = 1,
		color_space_NONE = 0,
	};
	inline color_space_enum color_space(void);
	inline void color_space(color_space_enum value);
	enum projection_enum {
		projection_FLAT = 0,
		projection_BOX = 1,
		projection_SPHERE = 2,
		projection_TUBE = 3,
	};
	inline projection_enum projection(void);
	inline void projection(projection_enum value);
	enum interpolation_enum {
		interpolation_Linear = 0,
		interpolation_Closest = 1,
		interpolation_Cubic = 2,
		interpolation_Smart = 3,
	};
	inline interpolation_enum interpolation(void);
	inline void interpolation(interpolation_enum value);
	inline float projection_blend(void);
	inline void projection_blend(float value);
	enum extension_enum {
		extension_REPEAT = 0,
		extension_EXTEND = 1,
		extension_CLIP = 2,
	};
	inline extension_enum extension(void);
	inline void extension(extension_enum value);
	inline ImageUser image_user(void);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Environment Texture ****************/

class ShaderNodeTexEnvironment : public ShaderNode {
public:
	ShaderNodeTexEnvironment(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}

	inline Image image(void);
	inline TexMapping texture_mapping(void);
	inline ColorMapping color_mapping(void);
	enum color_space_enum {
		color_space_COLOR = 1,
		color_space_NONE = 0,
	};
	inline color_space_enum color_space(void);
	inline void color_space(color_space_enum value);
	enum projection_enum {
		projection_EQUIRECTANGULAR = 0,
		projection_MIRROR_BALL = 1,
	};
	inline projection_enum projection(void);
	inline void projection(projection_enum value);
	enum interpolation_enum {
		interpolation_Linear = 0,
		interpolation_Closest = 1,
		interpolation_Cubic = 2,
		interpolation_Smart = 3,
	};
	inline interpolation_enum interpolation(void);
	inline void interpolation(interpolation_enum value);
	inline ImageUser image_user(void);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Sky Texture ****************/

class ShaderNodeTexSky : public ShaderNode {
public:
	ShaderNodeTexSky(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}

	inline TexMapping texture_mapping(void);
	inline ColorMapping color_mapping(void);
	enum sky_type_enum {
		sky_type_PREETHAM = 0,
		sky_type_HOSEK_WILKIE = 1,
	};
	inline sky_type_enum sky_type(void);
	inline void sky_type(sky_type_enum value);
	inline Array<float, 3> sun_direction(void);
	inline void sun_direction(float values[3]);
	inline float turbidity(void);
	inline void turbidity(float value);
	inline float ground_albedo(void);
	inline void ground_albedo(float value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Gradient Texture ****************/

class ShaderNodeTexGradient : public ShaderNode {
public:
	ShaderNodeTexGradient(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}

	inline TexMapping texture_mapping(void);
	inline ColorMapping color_mapping(void);
	enum gradient_type_enum {
		gradient_type_LINEAR = 0,
		gradient_type_QUADRATIC = 1,
		gradient_type_EASING = 2,
		gradient_type_DIAGONAL = 3,
		gradient_type_SPHERICAL = 6,
		gradient_type_QUADRATIC_SPHERE = 5,
		gradient_type_RADIAL = 4,
	};
	inline gradient_type_enum gradient_type(void);
	inline void gradient_type(gradient_type_enum value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Noise Texture ****************/

class ShaderNodeTexNoise : public ShaderNode {
public:
	ShaderNodeTexNoise(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}

	inline TexMapping texture_mapping(void);
	inline ColorMapping color_mapping(void);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Magic Texture ****************/

class ShaderNodeTexMagic : public ShaderNode {
public:
	ShaderNodeTexMagic(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}

	inline TexMapping texture_mapping(void);
	inline ColorMapping color_mapping(void);
	inline int turbulence_depth(void);
	inline void turbulence_depth(int value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Wave Texture ****************/

class ShaderNodeTexWave : public ShaderNode {
public:
	ShaderNodeTexWave(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}

	inline TexMapping texture_mapping(void);
	inline ColorMapping color_mapping(void);
	enum wave_type_enum {
		wave_type_BANDS = 0,
		wave_type_RINGS = 1,
	};
	inline wave_type_enum wave_type(void);
	inline void wave_type(wave_type_enum value);
	enum wave_profile_enum {
		wave_profile_SIN = 0,
		wave_profile_SAW = 1,
	};
	inline wave_profile_enum wave_profile(void);
	inline void wave_profile(wave_profile_enum value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Musgrave Texture ****************/

class ShaderNodeTexMusgrave : public ShaderNode {
public:
	ShaderNodeTexMusgrave(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}

	inline TexMapping texture_mapping(void);
	inline ColorMapping color_mapping(void);
	enum musgrave_type_enum {
		musgrave_type_MULTIFRACTAL = 0,
		musgrave_type_RIDGED_MULTIFRACTAL = 3,
		musgrave_type_HYBRID_MULTIFRACTAL = 2,
		musgrave_type_FBM = 1,
		musgrave_type_HETERO_TERRAIN = 4,
	};
	inline musgrave_type_enum musgrave_type(void);
	inline void musgrave_type(musgrave_type_enum value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Voronoi Texture ****************/

class ShaderNodeTexVoronoi : public ShaderNode {
public:
	ShaderNodeTexVoronoi(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}

	inline TexMapping texture_mapping(void);
	inline ColorMapping color_mapping(void);
	enum coloring_enum {
		coloring_INTENSITY = 0,
		coloring_CELLS = 1,
	};
	inline coloring_enum coloring(void);
	inline void coloring(coloring_enum value);
	enum distance_enum {
		distance_DISTANCE = 0,
		distance_MANHATTAN = 1,
		distance_CHEBYCHEV = 2,
		distance_MINKOWSKI = 3,
	};
	inline distance_enum distance(void);
	inline void distance(distance_enum value);
	enum feature_enum {
		feature_F1 = 0,
		feature_F2 = 1,
		feature_F3 = 2,
		feature_F4 = 3,
		feature_F2F1 = 4,
	};
	inline feature_enum feature(void);
	inline void feature(feature_enum value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Checker Texture ****************/

class ShaderNodeTexChecker : public ShaderNode {
public:
	ShaderNodeTexChecker(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}

	inline TexMapping texture_mapping(void);
	inline ColorMapping color_mapping(void);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Brick Texture ****************/

class ShaderNodeTexBrick : public ShaderNode {
public:
	ShaderNodeTexBrick(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}

	inline TexMapping texture_mapping(void);
	inline ColorMapping color_mapping(void);
	inline int offset_frequency(void);
	inline void offset_frequency(int value);
	inline int squash_frequency(void);
	inline void squash_frequency(int value);
	inline float offset(void);
	inline void offset(float value);
	inline float squash(void);
	inline void squash(float value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Point Density ****************/

class ShaderNodeTexPointDensity : public ShaderNode {
public:
	ShaderNodeTexPointDensity(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}

	inline Object object(void);
	enum point_source_enum {
		point_source_PARTICLE_SYSTEM = 0,
		point_source_OBJECT = 1,
	};
	inline point_source_enum point_source(void);
	inline void point_source(point_source_enum value);
	inline ParticleSystem particle_system(void);
	inline int resolution(void);
	inline void resolution(int value);
	inline float radius(void);
	inline void radius(float value);
	enum space_enum {
		space_OBJECT = 0,
		space_WORLD = 1,
	};
	inline space_enum space(void);
	inline void space(space_enum value);
	enum interpolation_enum {
		interpolation_Closest = 1,
		interpolation_Linear = 0,
		interpolation_Cubic = 2,
	};
	inline interpolation_enum interpolation(void);
	inline void interpolation(interpolation_enum value);
	enum particle_color_source_enum {
		particle_color_source_PARTICLE_AGE = 1,
		particle_color_source_PARTICLE_SPEED = 2,
		particle_color_source_PARTICLE_VELOCITY = 3,
	};
	inline particle_color_source_enum particle_color_source(void);
	inline void particle_color_source(particle_color_source_enum value);
	enum vertex_color_source_enum {
		vertex_color_source_VERTEX_COLOR = 0,
		vertex_color_source_VERTEX_WEIGHT = 1,
		vertex_color_source_VERTEX_NORMAL = 2,
	};
	inline vertex_color_source_enum vertex_color_source(void);
	inline void vertex_color_source(vertex_color_source_enum value);
	inline std::string vertex_attribute_name(void);
	inline void vertex_attribute_name(const std::string& value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
	inline void cache_point_density(Depsgraph& depsgraph);
	inline void calc_point_density(Depsgraph& depsgraph, int *rgba_values_len, float **rgba_values);
	inline void calc_point_density_minmax(Depsgraph& depsgraph, float min[3], float max[3]);
};

/**************** Texture Coordinate ****************/

class ShaderNodeTexCoord : public ShaderNode {
public:
	ShaderNodeTexCoord(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}

	inline Object object(void);
	inline bool from_instancer(void);
	inline void from_instancer(bool value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Vector Transform ****************/

class ShaderNodeVectorTransform : public ShaderNode {
public:
	ShaderNodeVectorTransform(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}

	enum vector_type_enum {
		vector_type_POINT = 1,
		vector_type_VECTOR = 0,
		vector_type_NORMAL = 2,
	};
	inline vector_type_enum vector_type(void);
	inline void vector_type(vector_type_enum value);
	enum convert_from_enum {
		convert_from_WORLD = 0,
		convert_from_OBJECT = 1,
		convert_from_CAMERA = 2,
	};
	inline convert_from_enum convert_from(void);
	inline void convert_from(convert_from_enum value);
	enum convert_to_enum {
		convert_to_WORLD = 0,
		convert_to_OBJECT = 1,
		convert_to_CAMERA = 2,
	};
	inline convert_to_enum convert_to(void);
	inline void convert_to(convert_to_enum value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Separate HSV ****************/

class ShaderNodeSeparateHSV : public ShaderNode {
public:
	ShaderNodeSeparateHSV(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Combine HSV ****************/

class ShaderNodeCombineHSV : public ShaderNode {
public:
	ShaderNodeCombineHSV(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** UV Map ****************/

class ShaderNodeUVMap : public ShaderNode {
public:
	ShaderNodeUVMap(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}

	inline bool from_instancer(void);
	inline void from_instancer(bool value);
	inline std::string uv_map(void);
	inline void uv_map(const std::string& value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** UV Along Stroke ****************/

class ShaderNodeUVAlongStroke : public ShaderNode {
public:
	ShaderNodeUVAlongStroke(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}

	inline bool use_tips(void);
	inline void use_tips(bool value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Separate XYZ ****************/

class ShaderNodeSeparateXYZ : public ShaderNode {
public:
	ShaderNodeSeparateXYZ(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Combine XYZ ****************/

class ShaderNodeCombineXYZ : public ShaderNode {
public:
	ShaderNodeCombineXYZ(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Bevel ****************/

class ShaderNodeBevel : public ShaderNode {
public:
	ShaderNodeBevel(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}

	inline int samples(void);
	inline void samples(int value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Displacement ****************/

class ShaderNodeDisplacement : public ShaderNode {
public:
	ShaderNodeDisplacement(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}

	enum space_enum {
		space_OBJECT = 1,
		space_WORLD = 2,
	};
	inline space_enum space(void);
	inline void space(space_enum value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Vector Displacement ****************/

class ShaderNodeVectorDisplacement : public ShaderNode {
public:
	ShaderNodeVectorDisplacement(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}

	enum space_enum {
		space_TANGENT = 0,
		space_OBJECT = 1,
		space_WORLD = 2,
	};
	inline space_enum space(void);
	inline void space(space_enum value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** IES Texture ****************/

class ShaderNodeTexIES : public ShaderNode {
public:
	ShaderNodeTexIES(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}

	inline Text ies(void);
	inline std::string filepath(void);
	inline void filepath(const std::string& value);
	enum mode_enum {
		mode_INTERNAL = 0,
		mode_EXTERNAL = 1,
	};
	inline mode_enum mode(void);
	inline void mode(mode_enum value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Viewer ****************/

class CompositorNodeViewer : public CompositorNode {
public:
	CompositorNodeViewer(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	enum tile_order_enum {
		tile_order_CENTEROUT = 0,
		tile_order_RANDOM = 1,
		tile_order_BOTTOMUP = 2,
		tile_order_RULE_OF_THIRDS = 3,
	};
	inline tile_order_enum tile_order(void);
	inline void tile_order(tile_order_enum value);
	inline float center_x(void);
	inline void center_x(float value);
	inline float center_y(void);
	inline void center_y(float value);
	inline bool use_alpha(void);
	inline void use_alpha(bool value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** RGB ****************/

class CompositorNodeRGB : public CompositorNode {
public:
	CompositorNodeRGB(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Value ****************/

class CompositorNodeValue : public CompositorNode {
public:
	CompositorNodeValue(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Mix ****************/

class CompositorNodeMixRGB : public CompositorNode {
public:
	CompositorNodeMixRGB(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	enum blend_type_enum {
		blend_type_MIX = 0,
		blend_type_DARKEN = 7,
		blend_type_MULTIPLY = 2,
		blend_type_BURN = 11,
		blend_type_LIGHTEN = 8,
		blend_type_SCREEN = 4,
		blend_type_DODGE = 10,
		blend_type_ADD = 1,
		blend_type_OVERLAY = 9,
		blend_type_SOFT_LIGHT = 16,
		blend_type_LINEAR_LIGHT = 17,
		blend_type_DIFFERENCE = 6,
		blend_type_SUBTRACT = 3,
		blend_type_DIVIDE = 5,
		blend_type_HUE = 12,
		blend_type_SATURATION = 13,
		blend_type_COLOR = 15,
		blend_type_VALUE = 14,
	};
	inline blend_type_enum blend_type(void);
	inline void blend_type(blend_type_enum value);
	inline bool use_alpha(void);
	inline void use_alpha(bool value);
	inline bool use_clamp(void);
	inline void use_clamp(bool value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** ColorRamp ****************/

class CompositorNodeValToRGB : public CompositorNode {
public:
	CompositorNodeValToRGB(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	inline ColorRamp color_ramp(void);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** RGB to BW ****************/

class CompositorNodeRGBToBW : public CompositorNode {
public:
	CompositorNodeRGBToBW(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Normal ****************/

class CompositorNodeNormal : public CompositorNode {
public:
	CompositorNodeNormal(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Vector Curves ****************/

class CompositorNodeCurveVec : public CompositorNode {
public:
	CompositorNodeCurveVec(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	inline CurveMapping mapping(void);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** RGB Curves ****************/

class CompositorNodeCurveRGB : public CompositorNode {
public:
	CompositorNodeCurveRGB(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	inline CurveMapping mapping(void);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Alpha Over ****************/

class CompositorNodeAlphaOver : public CompositorNode {
public:
	CompositorNodeAlphaOver(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	inline bool use_premultiply(void);
	inline void use_premultiply(bool value);
	inline float premul(void);
	inline void premul(float value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Blur ****************/

class CompositorNodeBlur : public CompositorNode {
public:
	CompositorNodeBlur(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	inline bool use_variable_size(void);
	inline void use_variable_size(bool value);
	inline bool use_extended_bounds(void);
	inline void use_extended_bounds(bool value);
	inline int size_x(void);
	inline void size_x(int value);
	inline int size_y(void);
	inline void size_y(int value);
	inline bool use_relative(void);
	inline void use_relative(bool value);
	enum aspect_correction_enum {
		aspect_correction_NONE = 0,
		aspect_correction_Y = 1,
		aspect_correction_X = 2,
	};
	inline aspect_correction_enum aspect_correction(void);
	inline void aspect_correction(aspect_correction_enum value);
	inline float factor(void);
	inline void factor(float value);
	inline float factor_x(void);
	inline void factor_x(float value);
	inline float factor_y(void);
	inline void factor_y(float value);
	enum filter_type_enum {
		filter_type_FLAT = 0,
		filter_type_TENT = 1,
		filter_type_QUAD = 2,
		filter_type_CUBIC = 3,
		filter_type_GAUSS = 5,
		filter_type_FAST_GAUSS = 7,
		filter_type_CATROM = 4,
		filter_type_MITCH = 6,
	};
	inline filter_type_enum filter_type(void);
	inline void filter_type(filter_type_enum value);
	inline bool use_bokeh(void);
	inline void use_bokeh(bool value);
	inline bool use_gamma_correction(void);
	inline void use_gamma_correction(bool value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Filter ****************/

class CompositorNodeFilter : public CompositorNode {
public:
	CompositorNodeFilter(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	enum filter_type_enum {
		filter_type_SOFTEN = 0,
		filter_type_SHARPEN = 1,
		filter_type_LAPLACE = 2,
		filter_type_SOBEL = 3,
		filter_type_PREWITT = 4,
		filter_type_KIRSCH = 5,
		filter_type_SHADOW = 6,
	};
	inline filter_type_enum filter_type(void);
	inline void filter_type(filter_type_enum value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Map Value ****************/

class CompositorNodeMapValue : public CompositorNode {
public:
	CompositorNodeMapValue(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	inline Array<float, 1> offset(void);
	inline void offset(float values[1]);
	inline Array<float, 1> size(void);
	inline void size(float values[1]);
	inline bool use_min(void);
	inline void use_min(bool value);
	inline bool use_max(void);
	inline void use_max(bool value);
	inline Array<float, 1> min(void);
	inline void min(float values[1]);
	inline Array<float, 1> max(void);
	inline void max(float values[1]);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Map Range ****************/

class CompositorNodeMapRange : public CompositorNode {
public:
	CompositorNodeMapRange(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	inline bool use_clamp(void);
	inline void use_clamp(bool value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Time ****************/

class CompositorNodeTime : public CompositorNode {
public:
	CompositorNodeTime(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	inline CurveMapping curve(void);
	inline int frame_start(void);
	inline void frame_start(int value);
	inline int frame_end(void);
	inline void frame_end(int value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Vector Blur ****************/

class CompositorNodeVecBlur : public CompositorNode {
public:
	CompositorNodeVecBlur(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	inline int samples(void);
	inline void samples(int value);
	inline int speed_min(void);
	inline void speed_min(int value);
	inline int speed_max(void);
	inline void speed_max(int value);
	inline float factor(void);
	inline void factor(float value);
	inline bool use_curved(void);
	inline void use_curved(bool value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Separate RGBA ****************/

class CompositorNodeSepRGBA : public CompositorNode {
public:
	CompositorNodeSepRGBA(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Separate HSVA ****************/

class CompositorNodeSepHSVA : public CompositorNode {
public:
	CompositorNodeSepHSVA(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Set Alpha ****************/

class CompositorNodeSetAlpha : public CompositorNode {
public:
	CompositorNodeSetAlpha(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Hue Saturation Value ****************/

class CompositorNodeHueSat : public CompositorNode {
public:
	CompositorNodeHueSat(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Image ****************/

class CompositorNodeImage : public CompositorNode {
public:
	CompositorNodeImage(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	inline Image image(void);
	inline bool use_straight_alpha_output(void);
	inline void use_straight_alpha_output(bool value);
	inline int frame_duration(void);
	inline void frame_duration(int value);
	inline int frame_start(void);
	inline void frame_start(int value);
	inline int frame_offset(void);
	inline void frame_offset(int value);
	inline bool use_cyclic(void);
	inline void use_cyclic(bool value);
	inline bool use_auto_refresh(void);
	inline void use_auto_refresh(bool value);
	enum layer_enum {
		layer_PLACEHOLDER = 0,
	};
	inline layer_enum layer(void);
	inline void layer(layer_enum value);
	inline bool has_layers(void);
	inline void has_layers(bool value);
	enum view_enum {
		view_ALL = 0,
	};
	inline view_enum view(void);
	inline void view(view_enum value);
	inline bool has_views(void);
	inline void has_views(bool value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Render Layers ****************/

class CompositorNodeRLayers : public CompositorNode {
public:
	CompositorNodeRLayers(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	inline Scene scene(void);
	enum layer_enum {
		layer_PLACEHOLDER = 0,
	};
	inline layer_enum layer(void);
	inline void layer(layer_enum value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Composite ****************/

class CompositorNodeComposite : public CompositorNode {
public:
	CompositorNodeComposite(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	inline bool use_alpha(void);
	inline void use_alpha(bool value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** File Output ****************/

class CompositorNodeOutputFile : public CompositorNode {
public:
	CompositorNodeOutputFile(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg),
		file_slots(ptr_arg),
		layer_slots(ptr_arg)
		{}

	inline std::string base_path(void);
	inline void base_path(const std::string& value);
	inline int active_input_index(void);
	inline void active_input_index(int value);
	inline ImageFormatSettings format(void);
	COLLECTION_PROPERTY(CompositorNodeOutputFileFileSlots, NodeOutputFileSlotFile, CompositorNodeOutputFile, file_slots, false, false, false)
	COLLECTION_PROPERTY(CompositorNodeOutputFileLayerSlots, NodeOutputFileSlotLayer, CompositorNodeOutputFile, layer_slots, false, false, false)

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Texture ****************/

class CompositorNodeTexture : public CompositorNode {
public:
	CompositorNodeTexture(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	inline Texture texture(void);
	inline int node_output(void);
	inline void node_output(int value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Translate ****************/

class CompositorNodeTranslate : public CompositorNode {
public:
	CompositorNodeTranslate(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	inline bool use_relative(void);
	inline void use_relative(bool value);
	enum wrap_axis_enum {
		wrap_axis_NONE = 0,
		wrap_axis_XAXIS = 1,
		wrap_axis_YAXIS = 2,
		wrap_axis_BOTH = 3,
	};
	inline wrap_axis_enum wrap_axis(void);
	inline void wrap_axis(wrap_axis_enum value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Z Combine ****************/

class CompositorNodeZcombine : public CompositorNode {
public:
	CompositorNodeZcombine(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	inline bool use_alpha(void);
	inline void use_alpha(bool value);
	inline bool use_antialias_z(void);
	inline void use_antialias_z(bool value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Combine RGBA ****************/

class CompositorNodeCombRGBA : public CompositorNode {
public:
	CompositorNodeCombRGBA(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Dilate/Erode ****************/

class CompositorNodeDilateErode : public CompositorNode {
public:
	CompositorNodeDilateErode(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	enum mode_enum {
		mode_STEP = 0,
		mode_THRESHOLD = 1,
		mode_DISTANCE = 2,
		mode_FEATHER = 3,
	};
	inline mode_enum mode(void);
	inline void mode(mode_enum value);
	inline int distance(void);
	inline void distance(int value);
	inline float edge(void);
	inline void edge(float value);
	enum falloff_enum {
		falloff_SMOOTH = 0,
		falloff_SPHERE = 1,
		falloff_ROOT = 2,
		falloff_INVERSE_SQUARE = 7,
		falloff_SHARP = 3,
		falloff_LINEAR = 4,
	};
	inline falloff_enum falloff(void);
	inline void falloff(falloff_enum value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Inpaint ****************/

class CompositorNodeInpaint : public CompositorNode {
public:
	CompositorNodeInpaint(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	inline int distance(void);
	inline void distance(int value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Despeckle ****************/

class CompositorNodeDespeckle : public CompositorNode {
public:
	CompositorNodeDespeckle(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	inline float threshold(void);
	inline void threshold(float value);
	inline float threshold_neighbor(void);
	inline void threshold_neighbor(float value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Rotate ****************/

class CompositorNodeRotate : public CompositorNode {
public:
	CompositorNodeRotate(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	enum filter_type_enum {
		filter_type_NEAREST = 0,
		filter_type_BILINEAR = 1,
		filter_type_BICUBIC = 2,
	};
	inline filter_type_enum filter_type(void);
	inline void filter_type(filter_type_enum value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Scale ****************/

class CompositorNodeScale : public CompositorNode {
public:
	CompositorNodeScale(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	enum space_enum {
		space_RELATIVE = 0,
		space_ABSOLUTE = 1,
		space_SCENE_SIZE = 2,
		space_RENDER_SIZE = 3,
	};
	inline space_enum space(void);
	inline void space(space_enum value);
	enum frame_method_enum {
		frame_method_STRETCH = 0,
		frame_method_FIT = 1,
		frame_method_CROP = 3,
	};
	inline frame_method_enum frame_method(void);
	inline void frame_method(frame_method_enum value);
	inline float offset_x(void);
	inline void offset_x(float value);
	inline float offset_y(void);
	inline void offset_y(float value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Separate YCbCrA ****************/

class CompositorNodeSepYCCA : public CompositorNode {
public:
	CompositorNodeSepYCCA(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	enum mode_enum {
		mode_ITUBT601 = 0,
		mode_ITUBT709 = 1,
		mode_JFIF = 2,
	};
	inline mode_enum mode(void);
	inline void mode(mode_enum value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Combine YCbCrA ****************/

class CompositorNodeCombYCCA : public CompositorNode {
public:
	CompositorNodeCombYCCA(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	enum mode_enum {
		mode_ITUBT601 = 0,
		mode_ITUBT709 = 1,
		mode_JFIF = 2,
	};
	inline mode_enum mode(void);
	inline void mode(mode_enum value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Separate YUVA ****************/

class CompositorNodeSepYUVA : public CompositorNode {
public:
	CompositorNodeSepYUVA(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Combine YUVA ****************/

class CompositorNodeCombYUVA : public CompositorNode {
public:
	CompositorNodeCombYUVA(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Difference Key ****************/

class CompositorNodeDiffMatte : public CompositorNode {
public:
	CompositorNodeDiffMatte(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	inline float tolerance(void);
	inline void tolerance(float value);
	inline float falloff(void);
	inline void falloff(float value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Color Spill ****************/

class CompositorNodeColorSpill : public CompositorNode {
public:
	CompositorNodeColorSpill(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	enum channel_enum {
		channel_R = 1,
		channel_G = 2,
		channel_B = 3,
	};
	inline channel_enum channel(void);
	inline void channel(channel_enum value);
	enum limit_method_enum {
		limit_method_SIMPLE = 0,
		limit_method_AVERAGE = 1,
	};
	inline limit_method_enum limit_method(void);
	inline void limit_method(limit_method_enum value);
	enum limit_channel_enum {
		limit_channel_R = 0,
		limit_channel_G = 1,
		limit_channel_B = 2,
	};
	inline limit_channel_enum limit_channel(void);
	inline void limit_channel(limit_channel_enum value);
	inline float ratio(void);
	inline void ratio(float value);
	inline bool use_unspill(void);
	inline void use_unspill(bool value);
	inline float unspill_red(void);
	inline void unspill_red(float value);
	inline float unspill_green(void);
	inline void unspill_green(float value);
	inline float unspill_blue(void);
	inline void unspill_blue(float value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Chroma Key ****************/

class CompositorNodeChromaMatte : public CompositorNode {
public:
	CompositorNodeChromaMatte(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	inline float tolerance(void);
	inline void tolerance(float value);
	inline float threshold(void);
	inline void threshold(float value);
	inline float lift(void);
	inline void lift(float value);
	inline float gain(void);
	inline void gain(float value);
	inline float shadow_adjust(void);
	inline void shadow_adjust(float value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Channel Key ****************/

class CompositorNodeChannelMatte : public CompositorNode {
public:
	CompositorNodeChannelMatte(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	enum color_space_enum {
		color_space_RGB = 1,
		color_space_HSV = 2,
		color_space_YUV = 3,
		color_space_YCC = 4,
	};
	inline color_space_enum color_space(void);
	inline void color_space(color_space_enum value);
	enum matte_channel_enum {
		matte_channel_R = 1,
		matte_channel_G = 2,
		matte_channel_B = 3,
	};
	inline matte_channel_enum matte_channel(void);
	inline void matte_channel(matte_channel_enum value);
	enum limit_method_enum {
		limit_method_SINGLE = 0,
		limit_method_MAX = 1,
	};
	inline limit_method_enum limit_method(void);
	inline void limit_method(limit_method_enum value);
	enum limit_channel_enum {
		limit_channel_R = 1,
		limit_channel_G = 2,
		limit_channel_B = 3,
	};
	inline limit_channel_enum limit_channel(void);
	inline void limit_channel(limit_channel_enum value);
	inline float limit_max(void);
	inline void limit_max(float value);
	inline float limit_min(void);
	inline void limit_min(float value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Flip ****************/

class CompositorNodeFlip : public CompositorNode {
public:
	CompositorNodeFlip(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	enum axis_enum {
		axis_X = 0,
		axis_Y = 1,
		axis_XY = 2,
	};
	inline axis_enum axis(void);
	inline void axis(axis_enum value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Split Viewer ****************/

class CompositorNodeSplitViewer : public CompositorNode {
public:
	CompositorNodeSplitViewer(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	enum axis_enum {
		axis_X = 0,
		axis_Y = 1,
	};
	inline axis_enum axis(void);
	inline void axis(axis_enum value);
	inline int factor(void);
	inline void factor(int value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Map UV ****************/

class CompositorNodeMapUV : public CompositorNode {
public:
	CompositorNodeMapUV(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	inline int alpha(void);
	inline void alpha(int value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** ID Mask ****************/

class CompositorNodeIDMask : public CompositorNode {
public:
	CompositorNodeIDMask(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	inline int index(void);
	inline void index(int value);
	inline bool use_antialiasing(void);
	inline void use_antialiasing(bool value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Double Edge Mask ****************/

class CompositorNodeDoubleEdgeMask : public CompositorNode {
public:
	CompositorNodeDoubleEdgeMask(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	enum inner_mode_enum {
		inner_mode_ALL = 0,
		inner_mode_ADJACENT_ONLY = 1,
	};
	inline inner_mode_enum inner_mode(void);
	inline void inner_mode(inner_mode_enum value);
	enum edge_mode_enum {
		edge_mode_BLEED_OUT = 0,
		edge_mode_KEEP_IN = 1,
	};
	inline edge_mode_enum edge_mode(void);
	inline void edge_mode(edge_mode_enum value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Defocus ****************/

class CompositorNodeDefocus : public CompositorNode {
public:
	CompositorNodeDefocus(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	inline Scene scene(void);
	enum bokeh_enum {
		bokeh_OCTAGON = 8,
		bokeh_HEPTAGON = 7,
		bokeh_HEXAGON = 6,
		bokeh_PENTAGON = 5,
		bokeh_SQUARE = 4,
		bokeh_TRIANGLE = 3,
		bokeh_CIRCLE = 0,
	};
	inline bokeh_enum bokeh(void);
	inline void bokeh(bokeh_enum value);
	inline float angle(void);
	inline void angle(float value);
	inline bool use_gamma_correction(void);
	inline void use_gamma_correction(bool value);
	inline float f_stop(void);
	inline void f_stop(float value);
	inline float blur_max(void);
	inline void blur_max(float value);
	inline float threshold(void);
	inline void threshold(float value);
	inline bool use_preview(void);
	inline void use_preview(bool value);
	inline bool use_zbuffer(void);
	inline void use_zbuffer(bool value);
	inline float z_scale(void);
	inline void z_scale(float value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Displace ****************/

class CompositorNodeDisplace : public CompositorNode {
public:
	CompositorNodeDisplace(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Combine HSVA ****************/

class CompositorNodeCombHSVA : public CompositorNode {
public:
	CompositorNodeCombHSVA(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Math ****************/

class CompositorNodeMath : public CompositorNode {
public:
	CompositorNodeMath(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	enum operation_enum {
		operation_ADD = 0,
		operation_SUBTRACT = 1,
		operation_MULTIPLY = 2,
		operation_DIVIDE = 3,
		operation_POWER = 10,
		operation_LOGARITHM = 11,
		operation_SQRT = 23,
		operation_ABSOLUTE = 18,
		operation_MINIMUM = 12,
		operation_MAXIMUM = 13,
		operation_LESS_THAN = 15,
		operation_GREATER_THAN = 16,
		operation_ROUND = 14,
		operation_FLOOR = 20,
		operation_CEIL = 21,
		operation_FRACT = 22,
		operation_MODULO = 17,
		operation_SINE = 4,
		operation_COSINE = 5,
		operation_TANGENT = 6,
		operation_ARCSINE = 7,
		operation_ARCCOSINE = 8,
		operation_ARCTANGENT = 9,
		operation_ARCTAN2 = 19,
	};
	inline operation_enum operation(void);
	inline void operation(operation_enum value);
	inline bool use_clamp(void);
	inline void use_clamp(bool value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Luminance Key ****************/

class CompositorNodeLumaMatte : public CompositorNode {
public:
	CompositorNodeLumaMatte(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	inline float limit_max(void);
	inline void limit_max(float value);
	inline float limit_min(void);
	inline void limit_min(float value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Bright/Contrast ****************/

class CompositorNodeBrightContrast : public CompositorNode {
public:
	CompositorNodeBrightContrast(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	inline bool use_premultiply(void);
	inline void use_premultiply(bool value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Gamma ****************/

class CompositorNodeGamma : public CompositorNode {
public:
	CompositorNodeGamma(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Invert ****************/

class CompositorNodeInvert : public CompositorNode {
public:
	CompositorNodeInvert(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	inline bool invert_rgb(void);
	inline void invert_rgb(bool value);
	inline bool invert_alpha(void);
	inline void invert_alpha(bool value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Normalize ****************/

class CompositorNodeNormalize : public CompositorNode {
public:
	CompositorNodeNormalize(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Crop ****************/

class CompositorNodeCrop : public CompositorNode {
public:
	CompositorNodeCrop(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	inline bool use_crop_size(void);
	inline void use_crop_size(bool value);
	inline bool relative(void);
	inline void relative(bool value);
	inline int min_x(void);
	inline void min_x(int value);
	inline int max_x(void);
	inline void max_x(int value);
	inline int min_y(void);
	inline void min_y(int value);
	inline int max_y(void);
	inline void max_y(int value);
	inline float rel_min_x(void);
	inline void rel_min_x(float value);
	inline float rel_max_x(void);
	inline void rel_max_x(float value);
	inline float rel_min_y(void);
	inline void rel_min_y(float value);
	inline float rel_max_y(void);
	inline void rel_max_y(float value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Directional Blur ****************/

class CompositorNodeDBlur : public CompositorNode {
public:
	CompositorNodeDBlur(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	inline int iterations(void);
	inline void iterations(int value);
	inline bool use_wrap(void);
	inline void use_wrap(bool value);
	inline float center_x(void);
	inline void center_x(float value);
	inline float center_y(void);
	inline void center_y(float value);
	inline float distance(void);
	inline void distance(float value);
	inline float angle(void);
	inline void angle(float value);
	inline float spin(void);
	inline void spin(float value);
	inline float zoom(void);
	inline void zoom(float value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Bilateral Blur ****************/

class CompositorNodeBilateralblur : public CompositorNode {
public:
	CompositorNodeBilateralblur(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	inline int iterations(void);
	inline void iterations(int value);
	inline float sigma_color(void);
	inline void sigma_color(float value);
	inline float sigma_space(void);
	inline void sigma_space(float value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Alpha Convert ****************/

class CompositorNodePremulKey : public CompositorNode {
public:
	CompositorNodePremulKey(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	enum mapping_enum {
		mapping_STRAIGHT_TO_PREMUL = 0,
		mapping_PREMUL_TO_STRAIGHT = 1,
	};
	inline mapping_enum mapping(void);
	inline void mapping(mapping_enum value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Glare ****************/

class CompositorNodeGlare : public CompositorNode {
public:
	CompositorNodeGlare(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	enum glare_type_enum {
		glare_type_GHOSTS = 3,
		glare_type_STREAKS = 2,
		glare_type_FOG_GLOW = 1,
		glare_type_SIMPLE_STAR = 0,
	};
	inline glare_type_enum glare_type(void);
	inline void glare_type(glare_type_enum value);
	enum quality_enum {
		quality_HIGH = 0,
		quality_MEDIUM = 1,
		quality_LOW = 2,
	};
	inline quality_enum quality(void);
	inline void quality(quality_enum value);
	inline int iterations(void);
	inline void iterations(int value);
	inline float color_modulation(void);
	inline void color_modulation(float value);
	inline float mix(void);
	inline void mix(float value);
	inline float threshold(void);
	inline void threshold(float value);
	inline int streaks(void);
	inline void streaks(int value);
	inline float angle_offset(void);
	inline void angle_offset(float value);
	inline float fade(void);
	inline void fade(float value);
	inline bool use_rotate_45(void);
	inline void use_rotate_45(bool value);
	inline int size(void);
	inline void size(int value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Tonemap ****************/

class CompositorNodeTonemap : public CompositorNode {
public:
	CompositorNodeTonemap(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	enum tonemap_type_enum {
		tonemap_type_RD_PHOTORECEPTOR = 1,
		tonemap_type_RH_SIMPLE = 0,
	};
	inline tonemap_type_enum tonemap_type(void);
	inline void tonemap_type(tonemap_type_enum value);
	inline float key(void);
	inline void key(float value);
	inline float offset(void);
	inline void offset(float value);
	inline float gamma(void);
	inline void gamma(float value);
	inline float intensity(void);
	inline void intensity(float value);
	inline float contrast(void);
	inline void contrast(float value);
	inline float adaptation(void);
	inline void adaptation(float value);
	inline float correction(void);
	inline void correction(float value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Lens Distortion ****************/

class CompositorNodeLensdist : public CompositorNode {
public:
	CompositorNodeLensdist(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	inline bool use_projector(void);
	inline void use_projector(bool value);
	inline bool use_jitter(void);
	inline void use_jitter(bool value);
	inline bool use_fit(void);
	inline void use_fit(bool value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Levels ****************/

class CompositorNodeLevels : public CompositorNode {
public:
	CompositorNodeLevels(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	enum channel_enum {
		channel_COMBINED_RGB = 1,
		channel_RED = 2,
		channel_GREEN = 3,
		channel_BLUE = 4,
		channel_LUMINANCE = 5,
	};
	inline channel_enum channel(void);
	inline void channel(channel_enum value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Color Key ****************/

class CompositorNodeColorMatte : public CompositorNode {
public:
	CompositorNodeColorMatte(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	inline float color_hue(void);
	inline void color_hue(float value);
	inline float color_saturation(void);
	inline void color_saturation(float value);
	inline float color_value(void);
	inline void color_value(float value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Distance Key ****************/

class CompositorNodeDistanceMatte : public CompositorNode {
public:
	CompositorNodeDistanceMatte(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	enum channel_enum {
		channel_RGB = 1,
		channel_YCC = 2,
	};
	inline channel_enum channel(void);
	inline void channel(channel_enum value);
	inline float tolerance(void);
	inline void tolerance(float value);
	inline float falloff(void);
	inline void falloff(float value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Color Balance ****************/

class CompositorNodeColorBalance : public CompositorNode {
public:
	CompositorNodeColorBalance(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	enum correction_method_enum {
		correction_method_LIFT_GAMMA_GAIN = 0,
		correction_method_OFFSET_POWER_SLOPE = 1,
	};
	inline correction_method_enum correction_method(void);
	inline void correction_method(correction_method_enum value);
	inline Array<float, 3> lift(void);
	inline void lift(float values[3]);
	inline Array<float, 3> gamma(void);
	inline void gamma(float values[3]);
	inline Array<float, 3> gain(void);
	inline void gain(float values[3]);
	inline Array<float, 3> offset(void);
	inline void offset(float values[3]);
	inline Array<float, 3> power(void);
	inline void power(float values[3]);
	inline Array<float, 3> slope(void);
	inline void slope(float values[3]);
	inline float offset_basis(void);
	inline void offset_basis(float value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Hue Correct ****************/

class CompositorNodeHueCorrect : public CompositorNode {
public:
	CompositorNodeHueCorrect(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	inline CurveMapping mapping(void);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Movie Clip ****************/

class CompositorNodeMovieClip : public CompositorNode {
public:
	CompositorNodeMovieClip(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	inline MovieClip clip(void);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Transform ****************/

class CompositorNodeTransform : public CompositorNode {
public:
	CompositorNodeTransform(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	enum filter_type_enum {
		filter_type_NEAREST = 0,
		filter_type_BILINEAR = 1,
		filter_type_BICUBIC = 2,
	};
	inline filter_type_enum filter_type(void);
	inline void filter_type(filter_type_enum value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Stabilize 2D ****************/

class CompositorNodeStabilize : public CompositorNode {
public:
	CompositorNodeStabilize(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	inline MovieClip clip(void);
	enum filter_type_enum {
		filter_type_NEAREST = 0,
		filter_type_BILINEAR = 1,
		filter_type_BICUBIC = 2,
	};
	inline filter_type_enum filter_type(void);
	inline void filter_type(filter_type_enum value);
	inline bool invert(void);
	inline void invert(bool value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Movie Distortion ****************/

class CompositorNodeMovieDistortion : public CompositorNode {
public:
	CompositorNodeMovieDistortion(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	inline MovieClip clip(void);
	enum distortion_type_enum {
		distortion_type_UNDISTORT = 0,
		distortion_type_DISTORT = 1,
	};
	inline distortion_type_enum distortion_type(void);
	inline void distortion_type(distortion_type_enum value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Box Mask ****************/

class CompositorNodeBoxMask : public CompositorNode {
public:
	CompositorNodeBoxMask(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	enum mask_type_enum {
		mask_type_ADD = 0,
		mask_type_SUBTRACT = 1,
		mask_type_MULTIPLY = 2,
		mask_type_NOT = 3,
	};
	inline mask_type_enum mask_type(void);
	inline void mask_type(mask_type_enum value);
	inline float x(void);
	inline void x(float value);
	inline float y(void);
	inline void y(float value);
	inline float width(void);
	inline void width(float value);
	inline float height(void);
	inline void height(float value);
	inline float rotation(void);
	inline void rotation(float value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Ellipse Mask ****************/

class CompositorNodeEllipseMask : public CompositorNode {
public:
	CompositorNodeEllipseMask(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	enum mask_type_enum {
		mask_type_ADD = 0,
		mask_type_SUBTRACT = 1,
		mask_type_MULTIPLY = 2,
		mask_type_NOT = 3,
	};
	inline mask_type_enum mask_type(void);
	inline void mask_type(mask_type_enum value);
	inline float x(void);
	inline void x(float value);
	inline float y(void);
	inline void y(float value);
	inline float width(void);
	inline void width(float value);
	inline float height(void);
	inline void height(float value);
	inline float rotation(void);
	inline void rotation(float value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Bokeh Image ****************/

class CompositorNodeBokehImage : public CompositorNode {
public:
	CompositorNodeBokehImage(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	inline float angle(void);
	inline void angle(float value);
	inline int flaps(void);
	inline void flaps(int value);
	inline float rounding(void);
	inline void rounding(float value);
	inline float catadioptric(void);
	inline void catadioptric(float value);
	inline float shift(void);
	inline void shift(float value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Bokeh Blur ****************/

class CompositorNodeBokehBlur : public CompositorNode {
public:
	CompositorNodeBokehBlur(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	inline bool use_variable_size(void);
	inline void use_variable_size(bool value);
	inline bool use_extended_bounds(void);
	inline void use_extended_bounds(bool value);
	inline float blur_max(void);
	inline void blur_max(float value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Switch ****************/

class CompositorNodeSwitch : public CompositorNode {
public:
	CompositorNodeSwitch(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	inline bool check(void);
	inline void check(bool value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** View Switch ****************/

class CompositorNodeSwitchView : public CompositorNode {
public:
	CompositorNodeSwitchView(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Color Correction ****************/

class CompositorNodeColorCorrection : public CompositorNode {
public:
	CompositorNodeColorCorrection(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	inline bool red(void);
	inline void red(bool value);
	inline bool green(void);
	inline void green(bool value);
	inline bool blue(void);
	inline void blue(bool value);
	inline float midtones_start(void);
	inline void midtones_start(float value);
	inline float midtones_end(void);
	inline void midtones_end(float value);
	inline float master_saturation(void);
	inline void master_saturation(float value);
	inline float master_contrast(void);
	inline void master_contrast(float value);
	inline float master_gamma(void);
	inline void master_gamma(float value);
	inline float master_gain(void);
	inline void master_gain(float value);
	inline float master_lift(void);
	inline void master_lift(float value);
	inline float shadows_saturation(void);
	inline void shadows_saturation(float value);
	inline float shadows_contrast(void);
	inline void shadows_contrast(float value);
	inline float shadows_gamma(void);
	inline void shadows_gamma(float value);
	inline float shadows_gain(void);
	inline void shadows_gain(float value);
	inline float shadows_lift(void);
	inline void shadows_lift(float value);
	inline float midtones_saturation(void);
	inline void midtones_saturation(float value);
	inline float midtones_contrast(void);
	inline void midtones_contrast(float value);
	inline float midtones_gamma(void);
	inline void midtones_gamma(float value);
	inline float midtones_gain(void);
	inline void midtones_gain(float value);
	inline float midtones_lift(void);
	inline void midtones_lift(float value);
	inline float highlights_saturation(void);
	inline void highlights_saturation(float value);
	inline float highlights_contrast(void);
	inline void highlights_contrast(float value);
	inline float highlights_gamma(void);
	inline void highlights_gamma(float value);
	inline float highlights_gain(void);
	inline void highlights_gain(float value);
	inline float highlights_lift(void);
	inline void highlights_lift(float value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Mask ****************/

class CompositorNodeMask : public CompositorNode {
public:
	CompositorNodeMask(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	inline Mask mask(void);
	inline bool use_feather(void);
	inline void use_feather(bool value);
	inline bool use_motion_blur(void);
	inline void use_motion_blur(bool value);
	inline int motion_blur_samples(void);
	inline void motion_blur_samples(int value);
	inline float motion_blur_shutter(void);
	inline void motion_blur_shutter(float value);
	enum size_source_enum {
		size_source_SCENE = 0,
		size_source_FIXED = 256,
		size_source_FIXED_SCENE = 512,
	};
	inline size_source_enum size_source(void);
	inline void size_source(size_source_enum value);
	inline int size_x(void);
	inline void size_x(int value);
	inline int size_y(void);
	inline void size_y(int value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Keying Screen ****************/

class CompositorNodeKeyingScreen : public CompositorNode {
public:
	CompositorNodeKeyingScreen(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	inline MovieClip clip(void);
	inline std::string tracking_object(void);
	inline void tracking_object(const std::string& value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Keying ****************/

class CompositorNodeKeying : public CompositorNode {
public:
	CompositorNodeKeying(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	inline float screen_balance(void);
	inline void screen_balance(float value);
	inline float despill_factor(void);
	inline void despill_factor(float value);
	inline float despill_balance(void);
	inline void despill_balance(float value);
	inline float clip_black(void);
	inline void clip_black(float value);
	inline float clip_white(void);
	inline void clip_white(float value);
	inline int blur_pre(void);
	inline void blur_pre(int value);
	inline int blur_post(void);
	inline void blur_post(int value);
	inline int dilate_distance(void);
	inline void dilate_distance(int value);
	inline int edge_kernel_radius(void);
	inline void edge_kernel_radius(int value);
	inline float edge_kernel_tolerance(void);
	inline void edge_kernel_tolerance(float value);
	enum feather_falloff_enum {
		feather_falloff_SMOOTH = 0,
		feather_falloff_SPHERE = 1,
		feather_falloff_ROOT = 2,
		feather_falloff_INVERSE_SQUARE = 7,
		feather_falloff_SHARP = 3,
		feather_falloff_LINEAR = 4,
	};
	inline feather_falloff_enum feather_falloff(void);
	inline void feather_falloff(feather_falloff_enum value);
	inline int feather_distance(void);
	inline void feather_distance(int value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Track Position ****************/

class CompositorNodeTrackPos : public CompositorNode {
public:
	CompositorNodeTrackPos(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	inline MovieClip clip(void);
	enum position_enum {
		position_ABSOLUTE = 0,
		position_RELATIVE_START = 1,
		position_RELATIVE_FRAME = 2,
		position_ABSOLUTE_FRAME = 3,
	};
	inline position_enum position(void);
	inline void position(position_enum value);
	inline int frame_relative(void);
	inline void frame_relative(int value);
	inline std::string tracking_object(void);
	inline void tracking_object(const std::string& value);
	inline std::string track_name(void);
	inline void track_name(const std::string& value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Pixelate ****************/

class CompositorNodePixelate : public CompositorNode {
public:
	CompositorNodePixelate(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Plane Track Deform ****************/

class CompositorNodePlaneTrackDeform : public CompositorNode {
public:
	CompositorNodePlaneTrackDeform(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	inline MovieClip clip(void);
	inline std::string tracking_object(void);
	inline void tracking_object(const std::string& value);
	inline std::string plane_track_name(void);
	inline void plane_track_name(const std::string& value);
	inline bool use_motion_blur(void);
	inline void use_motion_blur(bool value);
	inline int motion_blur_samples(void);
	inline void motion_blur_samples(int value);
	inline float motion_blur_shutter(void);
	inline void motion_blur_shutter(float value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Corner Pin ****************/

class CompositorNodeCornerPin : public CompositorNode {
public:
	CompositorNodeCornerPin(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Sun Beams ****************/

class CompositorNodeSunBeams : public CompositorNode {
public:
	CompositorNodeSunBeams(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	inline Array<float, 2> source(void);
	inline void source(float values[2]);
	inline float ray_length(void);
	inline void ray_length(float value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Cryptomatte ****************/

class CompositorNodeCryptomatte : public CompositorNode {
public:
	CompositorNodeCryptomatte(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	inline std::string matte_id(void);
	inline void matte_id(const std::string& value);
	inline Array<float, 3> add(void);
	inline void add(float values[3]);
	inline Array<float, 3> remove(void);
	inline void remove(float values[3]);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Output ****************/

class TextureNodeOutput : public TextureNode {
public:
	TextureNodeOutput(const PointerRNA &ptr_arg) :
		TextureNode(ptr_arg)
		{}

	inline std::string filepath(void);
	inline void filepath(const std::string& value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Checker ****************/

class TextureNodeChecker : public TextureNode {
public:
	TextureNodeChecker(const PointerRNA &ptr_arg) :
		TextureNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Texture ****************/

class TextureNodeTexture : public TextureNode {
public:
	TextureNodeTexture(const PointerRNA &ptr_arg) :
		TextureNode(ptr_arg)
		{}

	inline Texture texture(void);
	inline int node_output(void);
	inline void node_output(int value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Bricks ****************/

class TextureNodeBricks : public TextureNode {
public:
	TextureNodeBricks(const PointerRNA &ptr_arg) :
		TextureNode(ptr_arg)
		{}

	inline float offset(void);
	inline void offset(float value);
	inline int offset_frequency(void);
	inline void offset_frequency(int value);
	inline float squash(void);
	inline void squash(float value);
	inline int squash_frequency(void);
	inline void squash_frequency(int value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Math ****************/

class TextureNodeMath : public TextureNode {
public:
	TextureNodeMath(const PointerRNA &ptr_arg) :
		TextureNode(ptr_arg)
		{}

	enum operation_enum {
		operation_ADD = 0,
		operation_SUBTRACT = 1,
		operation_MULTIPLY = 2,
		operation_DIVIDE = 3,
		operation_POWER = 10,
		operation_LOGARITHM = 11,
		operation_SQRT = 23,
		operation_ABSOLUTE = 18,
		operation_MINIMUM = 12,
		operation_MAXIMUM = 13,
		operation_LESS_THAN = 15,
		operation_GREATER_THAN = 16,
		operation_ROUND = 14,
		operation_FLOOR = 20,
		operation_CEIL = 21,
		operation_FRACT = 22,
		operation_MODULO = 17,
		operation_SINE = 4,
		operation_COSINE = 5,
		operation_TANGENT = 6,
		operation_ARCSINE = 7,
		operation_ARCCOSINE = 8,
		operation_ARCTANGENT = 9,
		operation_ARCTAN2 = 19,
	};
	inline operation_enum operation(void);
	inline void operation(operation_enum value);
	inline bool use_clamp(void);
	inline void use_clamp(bool value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Mix RGB ****************/

class TextureNodeMixRGB : public TextureNode {
public:
	TextureNodeMixRGB(const PointerRNA &ptr_arg) :
		TextureNode(ptr_arg)
		{}

	enum blend_type_enum {
		blend_type_MIX = 0,
		blend_type_DARKEN = 7,
		blend_type_MULTIPLY = 2,
		blend_type_BURN = 11,
		blend_type_LIGHTEN = 8,
		blend_type_SCREEN = 4,
		blend_type_DODGE = 10,
		blend_type_ADD = 1,
		blend_type_OVERLAY = 9,
		blend_type_SOFT_LIGHT = 16,
		blend_type_LINEAR_LIGHT = 17,
		blend_type_DIFFERENCE = 6,
		blend_type_SUBTRACT = 3,
		blend_type_DIVIDE = 5,
		blend_type_HUE = 12,
		blend_type_SATURATION = 13,
		blend_type_COLOR = 15,
		blend_type_VALUE = 14,
	};
	inline blend_type_enum blend_type(void);
	inline void blend_type(blend_type_enum value);
	inline bool use_alpha(void);
	inline void use_alpha(bool value);
	inline bool use_clamp(void);
	inline void use_clamp(bool value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** RGB to BW ****************/

class TextureNodeRGBToBW : public TextureNode {
public:
	TextureNodeRGBToBW(const PointerRNA &ptr_arg) :
		TextureNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** ColorRamp ****************/

class TextureNodeValToRGB : public TextureNode {
public:
	TextureNodeValToRGB(const PointerRNA &ptr_arg) :
		TextureNode(ptr_arg)
		{}

	inline ColorRamp color_ramp(void);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Image ****************/

class TextureNodeImage : public TextureNode {
public:
	TextureNodeImage(const PointerRNA &ptr_arg) :
		TextureNode(ptr_arg)
		{}

	inline Image image(void);
	inline ImageUser image_user(void);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** RGB Curves ****************/

class TextureNodeCurveRGB : public TextureNode {
public:
	TextureNodeCurveRGB(const PointerRNA &ptr_arg) :
		TextureNode(ptr_arg)
		{}

	inline CurveMapping mapping(void);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Invert ****************/

class TextureNodeInvert : public TextureNode {
public:
	TextureNodeInvert(const PointerRNA &ptr_arg) :
		TextureNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Hue/Saturation ****************/

class TextureNodeHueSaturation : public TextureNode {
public:
	TextureNodeHueSaturation(const PointerRNA &ptr_arg) :
		TextureNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Curve Time ****************/

class TextureNodeCurveTime : public TextureNode {
public:
	TextureNodeCurveTime(const PointerRNA &ptr_arg) :
		TextureNode(ptr_arg)
		{}

	inline CurveMapping curve(void);
	inline int frame_start(void);
	inline void frame_start(int value);
	inline int frame_end(void);
	inline void frame_end(int value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Rotate ****************/

class TextureNodeRotate : public TextureNode {
public:
	TextureNodeRotate(const PointerRNA &ptr_arg) :
		TextureNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Viewer ****************/

class TextureNodeViewer : public TextureNode {
public:
	TextureNodeViewer(const PointerRNA &ptr_arg) :
		TextureNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Translate ****************/

class TextureNodeTranslate : public TextureNode {
public:
	TextureNodeTranslate(const PointerRNA &ptr_arg) :
		TextureNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Coordinates ****************/

class TextureNodeCoordinates : public TextureNode {
public:
	TextureNodeCoordinates(const PointerRNA &ptr_arg) :
		TextureNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Distance ****************/

class TextureNodeDistance : public TextureNode {
public:
	TextureNodeDistance(const PointerRNA &ptr_arg) :
		TextureNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Combine RGBA ****************/

class TextureNodeCompose : public TextureNode {
public:
	TextureNodeCompose(const PointerRNA &ptr_arg) :
		TextureNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Separate RGBA ****************/

class TextureNodeDecompose : public TextureNode {
public:
	TextureNodeDecompose(const PointerRNA &ptr_arg) :
		TextureNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Value to Normal ****************/

class TextureNodeValToNor : public TextureNode {
public:
	TextureNodeValToNor(const PointerRNA &ptr_arg) :
		TextureNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Scale ****************/

class TextureNodeScale : public TextureNode {
public:
	TextureNodeScale(const PointerRNA &ptr_arg) :
		TextureNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** At ****************/

class TextureNodeAt : public TextureNode {
public:
	TextureNodeAt(const PointerRNA &ptr_arg) :
		TextureNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Voronoi ****************/

class TextureNodeTexVoronoi : public TextureNode {
public:
	TextureNodeTexVoronoi(const PointerRNA &ptr_arg) :
		TextureNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Blend ****************/

class TextureNodeTexBlend : public TextureNode {
public:
	TextureNodeTexBlend(const PointerRNA &ptr_arg) :
		TextureNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Magic ****************/

class TextureNodeTexMagic : public TextureNode {
public:
	TextureNodeTexMagic(const PointerRNA &ptr_arg) :
		TextureNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Marble ****************/

class TextureNodeTexMarble : public TextureNode {
public:
	TextureNodeTexMarble(const PointerRNA &ptr_arg) :
		TextureNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Clouds ****************/

class TextureNodeTexClouds : public TextureNode {
public:
	TextureNodeTexClouds(const PointerRNA &ptr_arg) :
		TextureNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Wood ****************/

class TextureNodeTexWood : public TextureNode {
public:
	TextureNodeTexWood(const PointerRNA &ptr_arg) :
		TextureNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Musgrave ****************/

class TextureNodeTexMusgrave : public TextureNode {
public:
	TextureNodeTexMusgrave(const PointerRNA &ptr_arg) :
		TextureNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Noise ****************/

class TextureNodeTexNoise : public TextureNode {
public:
	TextureNodeTexNoise(const PointerRNA &ptr_arg) :
		TextureNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Stucci ****************/

class TextureNodeTexStucci : public TextureNode {
public:
	TextureNodeTexStucci(const PointerRNA &ptr_arg) :
		TextureNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Distorted Noise ****************/

class TextureNodeTexDistNoise : public TextureNode {
public:
	TextureNodeTexDistNoise(const PointerRNA &ptr_arg) :
		TextureNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Group ****************/

class ShaderNodeGroup : public ShaderNode {
public:
	ShaderNodeGroup(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}

	inline NodeTree node_tree(void);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Group ****************/

class CompositorNodeGroup : public CompositorNode {
public:
	CompositorNodeGroup(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	inline NodeTree node_tree(void);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Group ****************/

class TextureNodeGroup : public TextureNode {
public:
	TextureNodeGroup(const PointerRNA &ptr_arg) :
		TextureNode(ptr_arg)
		{}

	inline NodeTree node_tree(void);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Shader Custom Group ****************/

class ShaderNodeCustomGroup : public ShaderNode {
public:
	ShaderNodeCustomGroup(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}

	inline NodeTree node_tree(void);

};

/**************** Compositor Custom Group ****************/

class CompositorNodeCustomGroup : public CompositorNode {
public:
	CompositorNodeCustomGroup(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	inline NodeTree node_tree(void);

};

/**************** Custom Group ****************/

class NodeCustomGroup : public Node {
public:
	NodeCustomGroup(const PointerRNA &ptr_arg) :
		Node(ptr_arg)
		{}

	inline NodeTree node_tree(void);

};

/**************** Output File Slot ****************/

class NodeOutputFileSlotFile : public Pointer {
public:
	NodeOutputFileSlotFile(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline bool use_node_format(void);
	inline void use_node_format(bool value);
	inline ImageFormatSettings format(void);
	inline std::string path(void);
	inline void path(const std::string& value);

};

/**************** Output File Layer Slot ****************/

class NodeOutputFileSlotLayer : public Pointer {
public:
	NodeOutputFileSlotLayer(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string name(void);
	inline void name(const std::string& value);

};

/**************** Node Instance Hash ****************/

class NodeInstanceHash : public Pointer {
public:
	NodeInstanceHash(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

};

/**************** Object ****************/

class Object : public ID {
public:
	Object(const PointerRNA &ptr_arg) :
		ID(ptr_arg),
		material_slots(ptr_arg),
		modifiers(ptr_arg),
		grease_pencil_modifiers(ptr_arg),
		shader_effects(ptr_arg),
		constraints(ptr_arg),
		vertex_groups(ptr_arg),
		face_maps(ptr_arg),
		particle_systems(ptr_arg)
		{}

	inline ID data(void);
	enum type_enum {
		type_MESH = 1,
		type_CURVE = 2,
		type_SURFACE = 3,
		type_META = 5,
		type_FONT = 4,
		type_ARMATURE = 25,
		type_LATTICE = 22,
		type_EMPTY = 0,
		type_GPENCIL = 26,
		type_CAMERA = 11,
		type_LIGHT = 10,
		type_SPEAKER = 12,
		type_LIGHT_PROBE = 13,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	enum mode_enum {
		mode_OBJECT = 0,
		mode_EDIT = 1,
		mode_POSE = 64,
		mode_SCULPT = 2,
		mode_VERTEX_PAINT = 4,
		mode_WEIGHT_PAINT = 8,
		mode_TEXTURE_PAINT = 16,
		mode_PARTICLE_EDIT = 32,
		mode_EDIT_GPENCIL = 128,
		mode_SCULPT_GPENCIL = 512,
		mode_PAINT_GPENCIL = 256,
		mode_WEIGHT_GPENCIL = 1024,
	};
	inline mode_enum mode(void);
	inline void mode(mode_enum value);
	inline Array<float, 24> bound_box(void);
	inline void bound_box(float values[24]);
	inline Object parent(void);
	enum parent_type_enum {
		parent_type_OBJECT = 0,
		parent_type_ARMATURE = 4,
		parent_type_LATTICE = 4,
		parent_type_VERTEX = 5,
		parent_type_VERTEX_3 = 6,
		parent_type_BONE = 7,
	};
	inline parent_type_enum parent_type(void);
	inline void parent_type(parent_type_enum value);
	inline Array<int, 3> parent_vertices(void);
	inline void parent_vertices(int values[3]);
	inline std::string parent_bone(void);
	inline void parent_bone(const std::string& value);
	enum track_axis_enum {
		track_axis_POS_X = 0,
		track_axis_POS_Y = 1,
		track_axis_POS_Z = 2,
		track_axis_NEG_X = 3,
		track_axis_NEG_Y = 4,
		track_axis_NEG_Z = 5,
	};
	inline track_axis_enum track_axis(void);
	inline void track_axis(track_axis_enum value);
	enum up_axis_enum {
		up_axis_X = 0,
		up_axis_Y = 1,
		up_axis_Z = 2,
	};
	inline up_axis_enum up_axis(void);
	inline void up_axis(up_axis_enum value);
	inline Object proxy(void);
	inline Object proxy_collection(void);
	COLLECTION_PROPERTY(DefaultCollectionFunctions, MaterialSlot, Object, material_slots, true, true, true)
	inline Material active_material(void);
	inline int active_material_index(void);
	inline void active_material_index(int value);
	inline Array<float, 3> location(void);
	inline void location(float values[3]);
	inline Array<float, 4> rotation_quaternion(void);
	inline void rotation_quaternion(float values[4]);
	inline Array<float, 4> rotation_axis_angle(void);
	inline void rotation_axis_angle(float values[4]);
	inline Array<float, 3> rotation_euler(void);
	inline void rotation_euler(float values[3]);
	enum rotation_mode_enum {
		rotation_mode_QUATERNION = 0,
		rotation_mode_XYZ = 1,
		rotation_mode_XZY = 2,
		rotation_mode_YXZ = 3,
		rotation_mode_YZX = 4,
		rotation_mode_ZXY = 5,
		rotation_mode_ZYX = 6,
		rotation_mode_AXIS_ANGLE = -1,
	};
	inline rotation_mode_enum rotation_mode(void);
	inline void rotation_mode(rotation_mode_enum value);
	inline Array<float, 3> scale(void);
	inline void scale(float values[3]);
	inline Array<float, 3> dimensions(void);
	inline void dimensions(float values[3]);
	inline Array<float, 3> delta_location(void);
	inline void delta_location(float values[3]);
	inline Array<float, 3> delta_rotation_euler(void);
	inline void delta_rotation_euler(float values[3]);
	inline Array<float, 4> delta_rotation_quaternion(void);
	inline void delta_rotation_quaternion(float values[4]);
	inline Array<float, 3> delta_scale(void);
	inline void delta_scale(float values[3]);
	inline Array<bool, 3> lock_location(void);
	inline void lock_location(bool values[3]);
	inline Array<bool, 3> lock_rotation(void);
	inline void lock_rotation(bool values[3]);
	inline bool lock_rotation_w(void);
	inline void lock_rotation_w(bool value);
	inline bool lock_rotations_4d(void);
	inline void lock_rotations_4d(bool value);
	inline Array<bool, 3> lock_scale(void);
	inline void lock_scale(bool values[3]);
	inline Array<float, 16> matrix_world(void);
	inline void matrix_world(float values[16]);
	inline Array<float, 16> matrix_local(void);
	inline void matrix_local(float values[16]);
	inline Array<float, 16> matrix_basis(void);
	inline void matrix_basis(float values[16]);
	inline Array<float, 16> matrix_parent_inverse(void);
	inline void matrix_parent_inverse(float values[16]);
	COLLECTION_PROPERTY(ObjectModifiers, Modifier, Object, modifiers, false, true, true)
	COLLECTION_PROPERTY(ObjectGpencilModifiers, GpencilModifier, Object, grease_pencil_modifiers, false, true, true)
	COLLECTION_PROPERTY(ObjectShaderFx, ShaderFx, Object, shader_effects, false, true, true)
	COLLECTION_PROPERTY(ObjectConstraints, Constraint, Object, constraints, false, true, true)
	COLLECTION_PROPERTY(VertexGroups, VertexGroup, Object, vertex_groups, false, true, true)
	COLLECTION_PROPERTY(FaceMaps, FaceMap, Object, face_maps, false, true, true)
	enum empty_display_type_enum {
		empty_display_type_PLAIN_AXES = 2,
		empty_display_type_ARROWS = 1,
		empty_display_type_SINGLE_ARROW = 4,
		empty_display_type_CIRCLE = 3,
		empty_display_type_CUBE = 5,
		empty_display_type_SPHERE = 6,
		empty_display_type_CONE = 7,
		empty_display_type_IMAGE = 8,
	};
	inline empty_display_type_enum empty_display_type(void);
	inline void empty_display_type(empty_display_type_enum value);
	inline float empty_display_size(void);
	inline void empty_display_size(float value);
	inline Array<float, 2> empty_image_offset(void);
	inline void empty_image_offset(float values[2]);
	inline ImageUser image_user(void);
	enum empty_image_depth_enum {
		empty_image_depth_DEFAULT = 0,
		empty_image_depth_FRONT = 1,
		empty_image_depth_BACK = 2,
	};
	inline empty_image_depth_enum empty_image_depth(void);
	inline void empty_image_depth(empty_image_depth_enum value);
	inline bool show_empty_image_perspective(void);
	inline void show_empty_image_perspective(bool value);
	inline bool show_empty_image_orthographic(void);
	inline void show_empty_image_orthographic(bool value);
	inline bool use_empty_image_alpha(void);
	inline void use_empty_image_alpha(bool value);
	enum empty_image_side_enum {
		empty_image_side_DOUBLE_SIDED = 0,
		empty_image_side_FRONT = 4,
		empty_image_side_BACK = 8,
	};
	inline empty_image_side_enum empty_image_side(void);
	inline void empty_image_side(empty_image_side_enum value);
	inline int pass_index(void);
	inline void pass_index(int value);
	inline Array<float, 4> color(void);
	inline void color(float values[4]);
	inline FieldSettings field(void);
	inline CollisionSettings collision(void);
	inline SoftBodySettings soft_body(void);
	COLLECTION_PROPERTY(ParticleSystems, ParticleSystem, Object, particle_systems, false, true, true)
	inline RigidBodyObject rigid_body(void);
	inline RigidBodyConstraint rigid_body_constraint(void);
	inline bool hide_viewport(void);
	inline void hide_viewport(bool value);
	inline bool hide_select(void);
	inline void hide_select(bool value);
	inline bool hide_render(void);
	inline void hide_render(bool value);
	inline bool show_instancer_for_render(void);
	inline void show_instancer_for_render(bool value);
	inline bool show_instancer_for_viewport(void);
	inline void show_instancer_for_viewport(bool value);
	inline AnimData animation_data(void);
	inline AnimViz animation_visualization(void);
	inline MotionPath motion_path(void);
	enum instance_type_enum {
		instance_type_NONE = 0,
		instance_type_VERTS = 16,
		instance_type_FACES = 512,
		instance_type_COLLECTION = 256,
	};
	inline instance_type_enum instance_type(void);
	inline void instance_type(instance_type_enum value);
	inline bool use_instance_vertices_rotation(void);
	inline void use_instance_vertices_rotation(bool value);
	inline bool use_instance_faces_scale(void);
	inline void use_instance_faces_scale(bool value);
	inline float instance_faces_scale(void);
	inline void instance_faces_scale(float value);
	inline Collection instance_collection(void);
	inline bool is_instancer(void);
	inline void is_instancer(bool value);
	enum display_type_enum {
		display_type_BOUNDS = 1,
		display_type_WIRE = 2,
		display_type_SOLID = 3,
		display_type_TEXTURED = 5,
	};
	inline display_type_enum display_type(void);
	inline void display_type(display_type_enum value);
	inline bool show_bounds(void);
	inline void show_bounds(bool value);
	enum display_bounds_type_enum {
		display_bounds_type_BOX = 0,
		display_bounds_type_SPHERE = 1,
		display_bounds_type_CYLINDER = 2,
		display_bounds_type_CONE = 3,
		display_bounds_type_CAPSULE = 7,
	};
	inline display_bounds_type_enum display_bounds_type(void);
	inline void display_bounds_type(display_bounds_type_enum value);
	inline bool show_name(void);
	inline void show_name(bool value);
	inline bool show_axis(void);
	inline void show_axis(bool value);
	inline bool show_texture_space(void);
	inline void show_texture_space(bool value);
	inline bool show_wire(void);
	inline void show_wire(bool value);
	inline bool show_all_edges(void);
	inline void show_all_edges(bool value);
	inline bool show_transparent(void);
	inline void show_transparent(bool value);
	inline bool show_in_front(void);
	inline void show_in_front(bool value);
	inline GreasePencil grease_pencil(void);
	inline Action pose_library(void);
	inline Pose pose(void);
	inline bool show_only_shape_key(void);
	inline void show_only_shape_key(bool value);
	inline bool use_shape_key_edit_mode(void);
	inline void use_shape_key_edit_mode(bool value);
	inline ShapeKey active_shape_key(void);
	inline int active_shape_key_index(void);
	inline void active_shape_key_index(int value);
	inline bool use_dynamic_topology_sculpting(void);
	inline void use_dynamic_topology_sculpting(bool value);
	inline bool is_from_instancer(void);
	inline void is_from_instancer(bool value);
	inline bool is_from_set(void);
	inline void is_from_set(bool value);
	inline ObjectDisplay display(void);

	inline bool select_get(Context C, ViewLayer& view_layer);
	inline void select_set(Context C, bool state, ViewLayer& view_layer);
	inline bool hide_get(Context C, ViewLayer& view_layer);
	inline void hide_set(Context C, bool state, ViewLayer& view_layer);
	inline bool visible_get(Context C, ViewLayer& view_layer, SpaceView3D& viewport);
	inline bool holdout_get(Context C, ViewLayer& view_layer);
	inline bool indirect_only_get(Context C, ViewLayer& view_layer);
	inline bool local_view_get(SpaceView3D& viewport);
	inline void local_view_set(SpaceView3D& viewport, bool state);
	inline void convert_space(PoseBone& pose_bone, float matrix[16], float matrix_return[16], int from_space, int to_space);
	inline void calc_matrix_camera(Depsgraph& depsgraph, float result[16], int x, int y, float scale_x, float scale_y);
	inline void camera_fit_coords(Depsgraph& depsgraph, int coordinates_len, float *coordinates, float coord_return[3], float *scale_return);
	inline Mesh to_mesh(Context C, Depsgraph& depsgraph, bool apply_modifiers, bool calc_undeformed);
	inline Object find_armature();
	inline ShapeKey shape_key_add(Context C, const char * name, bool from_mix);
	inline void shape_key_remove(void *main, ShapeKey& key);
	inline void ray_cast(Context C, float origin[3], float direction[3], float distance, Depsgraph& depsgraph, bool *result, float location[3], float normal[3], int *index);
	inline void closest_point_on_mesh(Context C, float origin[3], float distance, Depsgraph& depsgraph, bool *result, float location[3], float normal[3], int *index);
	inline bool is_modified(Scene& scene, int settings);
	inline bool is_deform_modified(Scene& scene, int settings);
	inline bool update_from_editmode(void *main);
	inline void cache_release();
};

/**************** Vertex Group ****************/

class VertexGroup : public Pointer {
public:
	VertexGroup(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string name(void);
	inline void name(const std::string& value);
	inline bool lock_weight(void);
	inline void lock_weight(bool value);
	inline int index(void);
	inline void index(int value);

	inline void add(int index_len, int *index, float weight, int type);
	inline void remove(int index_len, int *index);
	inline float weight(int index);
};

/**************** Face Map ****************/

class FaceMap : public Pointer {
public:
	FaceMap(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string name(void);
	inline void name(const std::string& value);
	inline bool select(void);
	inline void select(bool value);
	inline int index(void);
	inline void index(int value);

	inline void add(int index_len, int *index);
	inline void remove(int index_len, int *index);
};

/**************** Material Slot ****************/

class MaterialSlot : public Pointer {
public:
	MaterialSlot(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	enum link_enum {
		link_OBJECT = 1,
		link_DATA = 0,
	};
	inline link_enum link(void);
	inline void link(link_enum value);
	inline Material material(void);
	inline std::string name(void);
	inline void name(const std::string& value);

};

/**************** Object Display ****************/

class ObjectDisplay : public Pointer {
public:
	ObjectDisplay(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline bool show_shadows(void);
	inline void show_shadows(bool value);

};

/**************** Active Point Cache ****************/

class PointCache : public Pointer {
public:
	PointCache(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		point_caches(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline int frame_start(void);
	inline void frame_start(int value);
	inline int frame_end(void);
	inline void frame_end(int value);
	inline int frame_step(void);
	inline void frame_step(int value);
	inline int index(void);
	inline void index(int value);
	enum compression_enum {
		compression_NO = 0,
		compression_LIGHT = 1,
		compression_HEAVY = 2,
	};
	inline compression_enum compression(void);
	inline void compression(compression_enum value);
	inline bool is_baked(void);
	inline void is_baked(bool value);
	inline bool is_baking(void);
	inline void is_baking(bool value);
	inline bool use_disk_cache(void);
	inline void use_disk_cache(bool value);
	inline bool is_outdated(void);
	inline void is_outdated(bool value);
	inline bool is_frame_skip(void);
	inline void is_frame_skip(bool value);
	inline std::string name(void);
	inline void name(const std::string& value);
	inline std::string filepath(void);
	inline void filepath(const std::string& value);
	inline std::string info(void);
	inline void info(const std::string& value);
	inline bool use_external(void);
	inline void use_external(bool value);
	inline bool use_library_path(void);
	inline void use_library_path(bool value);
	COLLECTION_PROPERTY(PointCaches, PointCacheItem, PointCache, point_caches, false, false, false)

};

/**************** Point Cache ****************/

class PointCacheItem : public Pointer {
public:
	PointCacheItem(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline int frame_start(void);
	inline void frame_start(int value);
	inline int frame_end(void);
	inline void frame_end(int value);
	inline int frame_step(void);
	inline void frame_step(int value);
	inline int index(void);
	inline void index(int value);
	enum compression_enum {
		compression_NO = 0,
		compression_LIGHT = 1,
		compression_HEAVY = 2,
	};
	inline compression_enum compression(void);
	inline void compression(compression_enum value);
	inline bool is_baked(void);
	inline void is_baked(bool value);
	inline bool is_baking(void);
	inline void is_baking(bool value);
	inline bool use_disk_cache(void);
	inline void use_disk_cache(bool value);
	inline bool is_outdated(void);
	inline void is_outdated(bool value);
	inline bool is_frame_skip(void);
	inline void is_frame_skip(bool value);
	inline std::string name(void);
	inline void name(const std::string& value);
	inline std::string filepath(void);
	inline void filepath(const std::string& value);
	inline std::string info(void);
	inline void info(const std::string& value);
	inline bool use_external(void);
	inline void use_external(bool value);
	inline bool use_library_path(void);
	inline void use_library_path(bool value);

};

/**************** Collision Settings ****************/

class CollisionSettings : public Pointer {
public:
	CollisionSettings(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline bool use(void);
	inline void use(bool value);
	inline float damping_factor(void);
	inline void damping_factor(float value);
	inline float damping_random(void);
	inline void damping_random(float value);
	inline float friction_factor(void);
	inline void friction_factor(float value);
	inline float friction_random(void);
	inline void friction_random(float value);
	inline float permeability(void);
	inline void permeability(float value);
	inline bool use_particle_kill(void);
	inline void use_particle_kill(bool value);
	inline float stickiness(void);
	inline void stickiness(float value);
	inline float thickness_inner(void);
	inline void thickness_inner(float value);
	inline float thickness_outer(void);
	inline void thickness_outer(float value);
	inline float damping(void);
	inline void damping(float value);
	inline float absorption(void);
	inline void absorption(float value);
	inline float cloth_friction(void);
	inline void cloth_friction(float value);
	inline bool use_culling(void);
	inline void use_culling(bool value);
	inline bool use_normal(void);
	inline void use_normal(bool value);

};

/**************** Effector Weights ****************/

class EffectorWeights : public Pointer {
public:
	EffectorWeights(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline bool apply_to_hair_growing(void);
	inline void apply_to_hair_growing(bool value);
	inline Collection collection(void);
	inline float gravity(void);
	inline void gravity(float value);
	inline float all(void);
	inline void all(float value);
	inline float force(void);
	inline void force(float value);
	inline float vortex(void);
	inline void vortex(float value);
	inline float magnetic(void);
	inline void magnetic(float value);
	inline float wind(void);
	inline void wind(float value);
	inline float curve_guide(void);
	inline void curve_guide(float value);
	inline float texture(void);
	inline void texture(float value);
	inline float harmonic(void);
	inline void harmonic(float value);
	inline float charge(void);
	inline void charge(float value);
	inline float lennardjones(void);
	inline void lennardjones(float value);
	inline float boid(void);
	inline void boid(float value);
	inline float turbulence(void);
	inline void turbulence(float value);
	inline float drag(void);
	inline void drag(float value);
	inline float smokeflow(void);
	inline void smokeflow(float value);

};

/**************** Field Settings ****************/

class FieldSettings : public Pointer {
public:
	FieldSettings(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	enum type_enum {
		type_NONE = 0,
		type_FORCE = 1,
		type_WIND = 4,
		type_VORTEX = 2,
		type_MAGNET = 3,
		type_HARMONIC = 7,
		type_CHARGE = 8,
		type_LENNARDJ = 9,
		type_TEXTURE = 6,
		type_GUIDE = 5,
		type_BOID = 10,
		type_TURBULENCE = 11,
		type_DRAG = 12,
		type_SMOKE_FLOW = 13,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	enum shape_enum {
		shape_POINT = 0,
		shape_LINE = 4,
		shape_PLANE = 1,
		shape_SURFACE = 2,
		shape_POINTS = 3,
	};
	inline shape_enum shape(void);
	inline void shape(shape_enum value);
	enum falloff_type_enum {
		falloff_type_SPHERE = 0,
		falloff_type_TUBE = 1,
		falloff_type_CONE = 2,
	};
	inline falloff_type_enum falloff_type(void);
	inline void falloff_type(falloff_type_enum value);
	enum texture_mode_enum {
		texture_mode_RGB = 0,
		texture_mode_GRADIENT = 1,
		texture_mode_CURL = 2,
	};
	inline texture_mode_enum texture_mode(void);
	inline void texture_mode(texture_mode_enum value);
	enum z_direction_enum {
		z_direction_BOTH = 0,
		z_direction_POSITIVE = 1,
		z_direction_NEGATIVE = 2,
	};
	inline z_direction_enum z_direction(void);
	inline void z_direction(z_direction_enum value);
	inline float strength(void);
	inline void strength(float value);
	inline float linear_drag(void);
	inline void linear_drag(float value);
	inline float harmonic_damping(void);
	inline void harmonic_damping(float value);
	inline float quadratic_drag(void);
	inline void quadratic_drag(float value);
	inline float flow(void);
	inline void flow(float value);
	inline float inflow(void);
	inline void inflow(float value);
	inline float size(void);
	inline void size(float value);
	inline float rest_length(void);
	inline void rest_length(float value);
	inline float falloff_power(void);
	inline void falloff_power(float value);
	inline float distance_min(void);
	inline void distance_min(float value);
	inline float distance_max(void);
	inline void distance_max(float value);
	inline float radial_min(void);
	inline void radial_min(float value);
	inline float radial_max(void);
	inline void radial_max(float value);
	inline float radial_falloff(void);
	inline void radial_falloff(float value);
	inline float texture_nabla(void);
	inline void texture_nabla(float value);
	inline float noise(void);
	inline void noise(float value);
	inline int seed(void);
	inline void seed(int value);
	inline bool use_min_distance(void);
	inline void use_min_distance(bool value);
	inline bool use_max_distance(void);
	inline void use_max_distance(bool value);
	inline bool use_radial_min(void);
	inline void use_radial_min(bool value);
	inline bool use_radial_max(void);
	inline void use_radial_max(bool value);
	inline bool use_object_coords(void);
	inline void use_object_coords(bool value);
	inline bool use_global_coords(void);
	inline void use_global_coords(bool value);
	inline bool use_2d_force(void);
	inline void use_2d_force(bool value);
	inline bool use_root_coords(void);
	inline void use_root_coords(bool value);
	inline bool apply_to_location(void);
	inline void apply_to_location(bool value);
	inline bool apply_to_rotation(void);
	inline void apply_to_rotation(bool value);
	inline bool use_absorption(void);
	inline void use_absorption(bool value);
	inline bool use_multiple_springs(void);
	inline void use_multiple_springs(bool value);
	inline bool use_smoke_density(void);
	inline void use_smoke_density(bool value);
	inline bool use_gravity_falloff(void);
	inline void use_gravity_falloff(bool value);
	inline Texture texture(void);
	inline Object source_object(void);
	inline float guide_minimum(void);
	inline void guide_minimum(float value);
	inline float guide_free(void);
	inline void guide_free(float value);
	inline bool use_guide_path_add(void);
	inline void use_guide_path_add(bool value);
	inline bool use_guide_path_weight(void);
	inline void use_guide_path_weight(bool value);
	inline float guide_clump_amount(void);
	inline void guide_clump_amount(float value);
	inline float guide_clump_shape(void);
	inline void guide_clump_shape(float value);
	enum guide_kink_type_enum {
		guide_kink_type_NONE = 0,
		guide_kink_type_CURL = 1,
		guide_kink_type_RADIAL = 2,
		guide_kink_type_WAVE = 3,
		guide_kink_type_BRAID = 4,
		guide_kink_type_ROTATION = 5,
		guide_kink_type_ROLL = 6,
	};
	inline guide_kink_type_enum guide_kink_type(void);
	inline void guide_kink_type(guide_kink_type_enum value);
	enum guide_kink_axis_enum {
		guide_kink_axis_X = 0,
		guide_kink_axis_Y = 1,
		guide_kink_axis_Z = 2,
	};
	inline guide_kink_axis_enum guide_kink_axis(void);
	inline void guide_kink_axis(guide_kink_axis_enum value);
	inline float guide_kink_frequency(void);
	inline void guide_kink_frequency(float value);
	inline float guide_kink_shape(void);
	inline void guide_kink_shape(float value);
	inline float guide_kink_amplitude(void);
	inline void guide_kink_amplitude(float value);

};

/**************** Soft Body Settings ****************/

class SoftBodySettings : public Pointer {
public:
	SoftBodySettings(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline float friction(void);
	inline void friction(float value);
	inline float mass(void);
	inline void mass(float value);
	inline std::string vertex_group_mass(void);
	inline void vertex_group_mass(const std::string& value);
	inline float gravity(void);
	inline void gravity(float value);
	inline float speed(void);
	inline void speed(float value);
	inline std::string vertex_group_goal(void);
	inline void vertex_group_goal(const std::string& value);
	inline float goal_min(void);
	inline void goal_min(float value);
	inline float goal_max(void);
	inline void goal_max(float value);
	inline float goal_default(void);
	inline void goal_default(float value);
	inline float goal_spring(void);
	inline void goal_spring(float value);
	inline float goal_friction(void);
	inline void goal_friction(float value);
	inline float pull(void);
	inline void pull(float value);
	inline float push(void);
	inline void push(float value);
	inline float damping(void);
	inline void damping(float value);
	inline int spring_length(void);
	inline void spring_length(int value);
	inline int aero(void);
	inline void aero(int value);
	inline int plastic(void);
	inline void plastic(int value);
	inline float bend(void);
	inline void bend(float value);
	inline float shear(void);
	inline void shear(float value);
	inline std::string vertex_group_spring(void);
	inline void vertex_group_spring(const std::string& value);
	enum collision_type_enum {
		collision_type_MANUAL = 0,
		collision_type_AVERAGE = 1,
		collision_type_MINIMAL = 2,
		collision_type_MAXIMAL = 3,
		collision_type_MINMAX = 4,
	};
	inline collision_type_enum collision_type(void);
	inline void collision_type(collision_type_enum value);
	inline float ball_size(void);
	inline void ball_size(float value);
	inline float ball_stiff(void);
	inline void ball_stiff(float value);
	inline float ball_damp(void);
	inline void ball_damp(float value);
	inline float error_threshold(void);
	inline void error_threshold(float value);
	inline int step_min(void);
	inline void step_min(int value);
	inline int step_max(void);
	inline void step_max(int value);
	inline int choke(void);
	inline void choke(int value);
	inline int fuzzy(void);
	inline void fuzzy(int value);
	inline bool use_auto_step(void);
	inline void use_auto_step(bool value);
	inline bool use_diagnose(void);
	inline void use_diagnose(bool value);
	inline bool use_estimate_matrix(void);
	inline void use_estimate_matrix(bool value);
	inline Array<float, 3> location_mass_center(void);
	inline void location_mass_center(float values[3]);
	inline Array<float, 9> rotation_estimate(void);
	inline void rotation_estimate(float values[9]);
	inline Array<float, 9> scale_estimate(void);
	inline void scale_estimate(float values[9]);
	inline bool use_goal(void);
	inline void use_goal(bool value);
	inline bool use_edges(void);
	inline void use_edges(bool value);
	inline bool use_stiff_quads(void);
	inline void use_stiff_quads(bool value);
	inline bool use_edge_collision(void);
	inline void use_edge_collision(bool value);
	inline bool use_face_collision(void);
	inline void use_face_collision(bool value);
	enum aerodynamics_type_enum {
		aerodynamics_type_SIMPLE = 0,
		aerodynamics_type_LIFT_FORCE = 1,
	};
	inline aerodynamics_type_enum aerodynamics_type(void);
	inline void aerodynamics_type(aerodynamics_type_enum value);
	inline bool use_self_collision(void);
	inline void use_self_collision(bool value);
	inline Collection collision_collection(void);
	inline EffectorWeights effector_weights(void);

};

/**************** Dependency Graph Object Instance ****************/

class DepsgraphObjectInstance : public Pointer {
public:
	DepsgraphObjectInstance(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline Object object(void);
	inline bool show_self(void);
	inline void show_self(bool value);
	inline bool show_particles(void);
	inline void show_particles(bool value);
	inline bool is_instance(void);
	inline void is_instance(bool value);
	inline Object instance_object(void);
	inline Object parent(void);
	inline ParticleSystem particle_system(void);
	inline Array<int, 16> persistent_id(void);
	inline void persistent_id(int values[16]);
	inline int random_id(void);
	inline void random_id(int value);
	inline Array<float, 16> matrix_world(void);
	inline void matrix_world(float values[16]);
	inline Array<float, 3> orco(void);
	inline void orco(float values[3]);
	inline Array<float, 2> uv(void);
	inline void uv(float values[2]);

};

/**************** Dependency Graph Update ****************/

class DepsgraphUpdate : public Pointer {
public:
	DepsgraphUpdate(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline ID id(void);
	inline bool is_updated_transform(void);
	inline void is_updated_transform(bool value);
	inline bool is_updated_geometry(void);
	inline void is_updated_geometry(bool value);

};

/**************** Dependency Graph ****************/

class Depsgraph : public Pointer {
public:
	Depsgraph(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		ids(ptr_arg),
		objects(ptr_arg),
		object_instances(ptr_arg),
		updates(ptr_arg)
		{}

	inline Struct rna_type(void);
	enum mode_enum {
		mode_VIEWPORT = 0,
		mode_RENDER = 1,
	};
	inline mode_enum mode(void);
	inline void mode(mode_enum value);
	inline Scene scene(void);
	inline ViewLayer view_layer(void);
	inline Scene scene_eval(void);
	inline ViewLayer view_layer_eval(void);
	COLLECTION_PROPERTY(DefaultCollectionFunctions, ID, Depsgraph, ids, false, false, false)
	COLLECTION_PROPERTY(DefaultCollectionFunctions, Object, Depsgraph, objects, false, false, false)
	COLLECTION_PROPERTY(DefaultCollectionFunctions, DepsgraphObjectInstance, Depsgraph, object_instances, false, false, false)
	COLLECTION_PROPERTY(DefaultCollectionFunctions, DepsgraphUpdate, Depsgraph, updates, false, false, false)

	inline void debug_relations_graphviz(const char * filename);
	inline void debug_stats_gnuplot(const char * filename, const char * output_filename);
	inline void debug_tag_update();
	inline void debug_stats(char * result);
	inline ID id_eval_get(ID& id);
	inline bool id_type_updated(int id_type);
};

/**************** Packed File ****************/

class PackedFile : public Pointer {
public:
	PackedFile(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline int size(void);
	inline void size(int value);
	inline std::string data(void);
	inline void data(const std::string& value);

};

/**************** Palette Color ****************/

class PaletteColor : public Pointer {
public:
	PaletteColor(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline Array<float, 3> color(void);
	inline void color(float values[3]);
	inline float strength(void);
	inline void strength(float value);
	inline float weight(void);
	inline void weight(float value);

};

/**************** Palette ****************/

class Palette : public ID {
public:
	Palette(const PointerRNA &ptr_arg) :
		ID(ptr_arg),
		colors(ptr_arg)
		{}

	COLLECTION_PROPERTY(PaletteColors, PaletteColor, Palette, colors, false, true, false)

};

/**************** Particle Target ****************/

class ParticleTarget : public Pointer {
public:
	ParticleTarget(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string name(void);
	inline void name(const std::string& value);
	inline Object object(void);
	inline int system(void);
	inline void system(int value);
	inline float time(void);
	inline void time(float value);
	inline float duration(void);
	inline void duration(float value);
	inline bool is_valid(void);
	inline void is_valid(bool value);
	enum alliance_enum {
		alliance_FRIEND = 1,
		alliance_NEUTRAL = 0,
		alliance_ENEMY = 2,
	};
	inline alliance_enum alliance(void);
	inline void alliance(alliance_enum value);

};

/**************** SPH Fluid Settings ****************/

class SPHFluidSettings : public Pointer {
public:
	SPHFluidSettings(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	enum solver_enum {
		solver_DDR = 0,
		solver_CLASSICAL = 1,
	};
	inline solver_enum solver(void);
	inline void solver(solver_enum value);
	inline float spring_force(void);
	inline void spring_force(float value);
	inline float fluid_radius(void);
	inline void fluid_radius(float value);
	inline float rest_length(void);
	inline void rest_length(float value);
	inline bool use_viscoelastic_springs(void);
	inline void use_viscoelastic_springs(bool value);
	inline bool use_initial_rest_length(void);
	inline void use_initial_rest_length(bool value);
	inline float plasticity(void);
	inline void plasticity(float value);
	inline float yield_ratio(void);
	inline void yield_ratio(float value);
	inline int spring_frames(void);
	inline void spring_frames(int value);
	inline float linear_viscosity(void);
	inline void linear_viscosity(float value);
	inline float stiff_viscosity(void);
	inline void stiff_viscosity(float value);
	inline float stiffness(void);
	inline void stiffness(float value);
	inline float repulsion(void);
	inline void repulsion(float value);
	inline float rest_density(void);
	inline void rest_density(float value);
	inline float buoyancy(void);
	inline void buoyancy(float value);
	inline bool use_factor_repulsion(void);
	inline void use_factor_repulsion(bool value);
	inline bool use_factor_density(void);
	inline void use_factor_density(bool value);
	inline bool use_factor_radius(void);
	inline void use_factor_radius(bool value);
	inline bool use_factor_stiff_viscosity(void);
	inline void use_factor_stiff_viscosity(bool value);
	inline bool use_factor_rest_length(void);
	inline void use_factor_rest_length(bool value);

};

/**************** Particle Hair Key ****************/

class ParticleHairKey : public Pointer {
public:
	ParticleHairKey(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline float time(void);
	inline void time(float value);
	inline float weight(void);
	inline void weight(float value);
	inline Array<float, 3> co(void);
	inline void co(float values[3]);
	inline Array<float, 3> co_local(void);
	inline void co_local(float values[3]);

	inline void co_object(Object& object, ParticleSystemModifier& modifier, Particle& particle, float co[3]);
};

/**************** Particle Key ****************/

class ParticleKey : public Pointer {
public:
	ParticleKey(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline Array<float, 3> location(void);
	inline void location(float values[3]);
	inline Array<float, 3> velocity(void);
	inline void velocity(float values[3]);
	inline Array<float, 4> rotation(void);
	inline void rotation(float values[4]);
	inline Array<float, 3> angular_velocity(void);
	inline void angular_velocity(float values[3]);
	inline float time(void);
	inline void time(float value);

};

/**************** Child Particle ****************/

class ChildParticle : public Pointer {
public:
	ChildParticle(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

};

/**************** Particle ****************/

class Particle : public Pointer {
public:
	Particle(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		hair_keys(ptr_arg),
		particle_keys(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline Array<float, 3> location(void);
	inline void location(float values[3]);
	inline Array<float, 3> velocity(void);
	inline void velocity(float values[3]);
	inline Array<float, 3> angular_velocity(void);
	inline void angular_velocity(float values[3]);
	inline Array<float, 4> rotation(void);
	inline void rotation(float values[4]);
	inline Array<float, 3> prev_location(void);
	inline void prev_location(float values[3]);
	inline Array<float, 3> prev_velocity(void);
	inline void prev_velocity(float values[3]);
	inline Array<float, 3> prev_angular_velocity(void);
	inline void prev_angular_velocity(float values[3]);
	inline Array<float, 4> prev_rotation(void);
	inline void prev_rotation(float values[4]);
	COLLECTION_PROPERTY(DefaultCollectionFunctions, ParticleHairKey, Particle, hair_keys, true, true, false)
	COLLECTION_PROPERTY(DefaultCollectionFunctions, ParticleKey, Particle, particle_keys, true, true, false)
	inline float birth_time(void);
	inline void birth_time(float value);
	inline float lifetime(void);
	inline void lifetime(float value);
	inline float die_time(void);
	inline void die_time(float value);
	inline float size(void);
	inline void size(float value);
	inline bool is_exist(void);
	inline void is_exist(bool value);
	inline bool is_visible(void);
	inline void is_visible(bool value);
	enum alive_state_enum {
		alive_state_DEAD = 1,
		alive_state_UNBORN = 2,
		alive_state_ALIVE = 3,
		alive_state_DYING = 4,
	};
	inline alive_state_enum alive_state(void);
	inline void alive_state(alive_state_enum value);

	inline void uv_on_emitter(ParticleSystemModifier& modifier, float uv[2]);
};

/**************** Particle Dupliobject Weight ****************/

class ParticleDupliWeight : public Pointer {
public:
	ParticleDupliWeight(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string name(void);
	inline void name(const std::string& value);
	inline int count(void);
	inline void count(int value);

};

/**************** Particle System ****************/

class ParticleSystem : public Pointer {
public:
	ParticleSystem(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		particles(ptr_arg),
		child_particles(ptr_arg),
		targets(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string name(void);
	inline void name(const std::string& value);
	inline ParticleSettings settings(void);
	COLLECTION_PROPERTY(DefaultCollectionFunctions, Particle, ParticleSystem, particles, true, true, false)
	COLLECTION_PROPERTY(DefaultCollectionFunctions, ChildParticle, ParticleSystem, child_particles, true, true, false)
	inline int seed(void);
	inline void seed(int value);
	inline int child_seed(void);
	inline void child_seed(int value);
	inline bool is_global_hair(void);
	inline void is_global_hair(bool value);
	inline bool use_hair_dynamics(void);
	inline void use_hair_dynamics(bool value);
	inline ClothModifier cloth(void);
	inline Object reactor_target_object(void);
	inline int reactor_target_particle_system(void);
	inline void reactor_target_particle_system(int value);
	inline bool use_keyed_timing(void);
	inline void use_keyed_timing(bool value);
	COLLECTION_PROPERTY(DefaultCollectionFunctions, ParticleTarget, ParticleSystem, targets, false, true, true)
	inline ParticleTarget active_particle_target(void);
	inline int active_particle_target_index(void);
	inline void active_particle_target_index(int value);
	inline std::string vertex_group_density(void);
	inline void vertex_group_density(const std::string& value);
	inline bool invert_vertex_group_density(void);
	inline void invert_vertex_group_density(bool value);
	inline std::string vertex_group_velocity(void);
	inline void vertex_group_velocity(const std::string& value);
	inline bool invert_vertex_group_velocity(void);
	inline void invert_vertex_group_velocity(bool value);
	inline std::string vertex_group_length(void);
	inline void vertex_group_length(const std::string& value);
	inline bool invert_vertex_group_length(void);
	inline void invert_vertex_group_length(bool value);
	inline std::string vertex_group_clump(void);
	inline void vertex_group_clump(const std::string& value);
	inline bool invert_vertex_group_clump(void);
	inline void invert_vertex_group_clump(bool value);
	inline std::string vertex_group_kink(void);
	inline void vertex_group_kink(const std::string& value);
	inline bool invert_vertex_group_kink(void);
	inline void invert_vertex_group_kink(bool value);
	inline std::string vertex_group_roughness_1(void);
	inline void vertex_group_roughness_1(const std::string& value);
	inline bool invert_vertex_group_roughness_1(void);
	inline void invert_vertex_group_roughness_1(bool value);
	inline std::string vertex_group_roughness_2(void);
	inline void vertex_group_roughness_2(const std::string& value);
	inline bool invert_vertex_group_roughness_2(void);
	inline void invert_vertex_group_roughness_2(bool value);
	inline std::string vertex_group_roughness_end(void);
	inline void vertex_group_roughness_end(const std::string& value);
	inline bool invert_vertex_group_roughness_end(void);
	inline void invert_vertex_group_roughness_end(bool value);
	inline std::string vertex_group_size(void);
	inline void vertex_group_size(const std::string& value);
	inline bool invert_vertex_group_size(void);
	inline void invert_vertex_group_size(bool value);
	inline std::string vertex_group_tangent(void);
	inline void vertex_group_tangent(const std::string& value);
	inline bool invert_vertex_group_tangent(void);
	inline void invert_vertex_group_tangent(bool value);
	inline std::string vertex_group_rotation(void);
	inline void vertex_group_rotation(const std::string& value);
	inline bool invert_vertex_group_rotation(void);
	inline void invert_vertex_group_rotation(bool value);
	inline std::string vertex_group_field(void);
	inline void vertex_group_field(const std::string& value);
	inline bool invert_vertex_group_field(void);
	inline void invert_vertex_group_field(bool value);
	inline std::string vertex_group_twist(void);
	inline void vertex_group_twist(const std::string& value);
	inline bool invert_vertex_group_twist(void);
	inline void invert_vertex_group_twist(bool value);
	inline PointCache point_cache(void);
	inline bool has_multiple_caches(void);
	inline void has_multiple_caches(bool value);
	inline Object parent(void);
	inline bool is_editable(void);
	inline void is_editable(bool value);
	inline bool is_edited(void);
	inline void is_edited(bool value);
	inline float dt_frac(void);
	inline void dt_frac(float value);

	inline void co_hair(Object& object, int particle_no, int step, float co[3]);
	inline void uv_on_emitter(ParticleSystemModifier& modifier, Particle& particle, int particle_no, int uv_no, float uv[2]);
	inline void mcol_on_emitter(ParticleSystemModifier& modifier, Particle& particle, int particle_no, int vcol_no, float mcol[3]);
};

/**************** Particle Settings Texture Slot ****************/

class ParticleSettingsTextureSlot : public TextureSlot {
public:
	ParticleSettingsTextureSlot(const PointerRNA &ptr_arg) :
		TextureSlot(ptr_arg)
		{}

	enum texture_coords_enum {
		texture_coords_GLOBAL = 8,
		texture_coords_OBJECT = 32,
		texture_coords_UV = 16,
		texture_coords_ORCO = 1,
		texture_coords_STRAND = 8192,
	};
	inline texture_coords_enum texture_coords(void);
	inline void texture_coords(texture_coords_enum value);
	inline Object object(void);
	inline std::string uv_layer(void);
	inline void uv_layer(const std::string& value);
	enum mapping_x_enum {
		mapping_x_NONE = 0,
		mapping_x_X = 1,
		mapping_x_Y = 2,
		mapping_x_Z = 3,
	};
	inline mapping_x_enum mapping_x(void);
	inline void mapping_x(mapping_x_enum value);
	enum mapping_y_enum {
		mapping_y_NONE = 0,
		mapping_y_X = 1,
		mapping_y_Y = 2,
		mapping_y_Z = 3,
	};
	inline mapping_y_enum mapping_y(void);
	inline void mapping_y(mapping_y_enum value);
	enum mapping_z_enum {
		mapping_z_NONE = 0,
		mapping_z_X = 1,
		mapping_z_Y = 2,
		mapping_z_Z = 3,
	};
	inline mapping_z_enum mapping_z(void);
	inline void mapping_z(mapping_z_enum value);
	enum mapping_enum {
		mapping_FLAT = 0,
		mapping_CUBE = 1,
		mapping_TUBE = 2,
		mapping_SPHERE = 3,
	};
	inline mapping_enum mapping(void);
	inline void mapping(mapping_enum value);
	inline bool use_map_time(void);
	inline void use_map_time(bool value);
	inline bool use_map_life(void);
	inline void use_map_life(bool value);
	inline bool use_map_density(void);
	inline void use_map_density(bool value);
	inline bool use_map_size(void);
	inline void use_map_size(bool value);
	inline bool use_map_velocity(void);
	inline void use_map_velocity(bool value);
	inline bool use_map_field(void);
	inline void use_map_field(bool value);
	inline bool use_map_gravity(void);
	inline void use_map_gravity(bool value);
	inline bool use_map_damp(void);
	inline void use_map_damp(bool value);
	inline bool use_map_clump(void);
	inline void use_map_clump(bool value);
	inline bool use_map_kink_amp(void);
	inline void use_map_kink_amp(bool value);
	inline bool use_map_kink_freq(void);
	inline void use_map_kink_freq(bool value);
	inline bool use_map_rough(void);
	inline void use_map_rough(bool value);
	inline bool use_map_length(void);
	inline void use_map_length(bool value);
	inline bool use_map_twist(void);
	inline void use_map_twist(bool value);
	inline float time_factor(void);
	inline void time_factor(float value);
	inline float life_factor(void);
	inline void life_factor(float value);
	inline float density_factor(void);
	inline void density_factor(float value);
	inline float size_factor(void);
	inline void size_factor(float value);
	inline float velocity_factor(void);
	inline void velocity_factor(float value);
	inline float field_factor(void);
	inline void field_factor(float value);
	inline float gravity_factor(void);
	inline void gravity_factor(float value);
	inline float damp_factor(void);
	inline void damp_factor(float value);
	inline float length_factor(void);
	inline void length_factor(float value);
	inline float clump_factor(void);
	inline void clump_factor(float value);
	inline float kink_amp_factor(void);
	inline void kink_amp_factor(float value);
	inline float kink_freq_factor(void);
	inline void kink_freq_factor(float value);
	inline float rough_factor(void);
	inline void rough_factor(float value);
	inline float twist_factor(void);
	inline void twist_factor(float value);

};

/**************** Particle Settings ****************/

class ParticleSettings : public ID {
public:
	ParticleSettings(const PointerRNA &ptr_arg) :
		ID(ptr_arg),
		texture_slots(ptr_arg),
		instance_weights(ptr_arg)
		{}

	COLLECTION_PROPERTY(ParticleSettingsTextureSlots, ParticleSettingsTextureSlot, ParticleSettings, texture_slots, false, false, false)
	inline Texture active_texture(void);
	inline int active_texture_index(void);
	inline void active_texture_index(int value);
	inline bool is_fluid(void);
	inline void is_fluid(bool value);
	inline bool use_react_start_end(void);
	inline void use_react_start_end(bool value);
	inline bool use_react_multiple(void);
	inline void use_react_multiple(bool value);
	inline bool use_regrow_hair(void);
	inline void use_regrow_hair(bool value);
	inline bool show_unborn(void);
	inline void show_unborn(bool value);
	inline bool use_dead(void);
	inline void use_dead(bool value);
	inline bool use_emit_random(void);
	inline void use_emit_random(bool value);
	inline bool use_even_distribution(void);
	inline void use_even_distribution(bool value);
	inline bool use_die_on_collision(void);
	inline void use_die_on_collision(bool value);
	inline bool use_size_deflect(void);
	inline void use_size_deflect(bool value);
	inline bool use_rotations(void);
	inline void use_rotations(bool value);
	inline bool use_dynamic_rotation(void);
	inline void use_dynamic_rotation(bool value);
	inline bool use_multiply_size_mass(void);
	inline void use_multiply_size_mass(bool value);
	inline bool use_advanced_hair(void);
	inline void use_advanced_hair(bool value);
	inline bool lock_boids_to_surface(void);
	inline void lock_boids_to_surface(bool value);
	inline bool use_hair_bspline(void);
	inline void use_hair_bspline(bool value);
	inline bool invert_grid(void);
	inline void invert_grid(bool value);
	inline bool hexagonal_grid(void);
	inline void hexagonal_grid(bool value);
	inline bool apply_effector_to_children(void);
	inline void apply_effector_to_children(bool value);
	inline bool create_long_hair_children(void);
	inline void create_long_hair_children(bool value);
	inline bool apply_guide_to_children(void);
	inline void apply_guide_to_children(bool value);
	inline bool use_self_effect(void);
	inline void use_self_effect(bool value);
	enum type_enum {
		type_EMITTER = 0,
		type_HAIR = 2,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	enum emit_from_enum {
		emit_from_VERT = 0,
		emit_from_FACE = 1,
		emit_from_VOLUME = 2,
	};
	inline emit_from_enum emit_from(void);
	inline void emit_from(emit_from_enum value);
	enum distribution_enum {
		distribution_JIT = 0,
		distribution_RAND = 1,
		distribution_GRID = 2,
	};
	inline distribution_enum distribution(void);
	inline void distribution(distribution_enum value);
	enum physics_type_enum {
		physics_type_NO = 0,
		physics_type_NEWTON = 1,
		physics_type_KEYED = 2,
		physics_type_BOIDS = 3,
		physics_type_FLUID = 4,
	};
	inline physics_type_enum physics_type(void);
	inline void physics_type(physics_type_enum value);
	enum rotation_mode_enum {
		rotation_mode_NONE = 0,
		rotation_mode_NOR = 1,
		rotation_mode_NOR_TAN = 9,
		rotation_mode_VEL = 2,
		rotation_mode_GLOB_X = 3,
		rotation_mode_GLOB_Y = 4,
		rotation_mode_GLOB_Z = 5,
		rotation_mode_OB_X = 6,
		rotation_mode_OB_Y = 7,
		rotation_mode_OB_Z = 8,
	};
	inline rotation_mode_enum rotation_mode(void);
	inline void rotation_mode(rotation_mode_enum value);
	enum angular_velocity_mode_enum {
		angular_velocity_mode_NONE = 0,
		angular_velocity_mode_VELOCITY = 1,
		angular_velocity_mode_HORIZONTAL = 3,
		angular_velocity_mode_VERTICAL = 4,
		angular_velocity_mode_GLOBAL_X = 5,
		angular_velocity_mode_GLOBAL_Y = 6,
		angular_velocity_mode_GLOBAL_Z = 7,
		angular_velocity_mode_RAND = 2,
	};
	inline angular_velocity_mode_enum angular_velocity_mode(void);
	inline void angular_velocity_mode(angular_velocity_mode_enum value);
	enum react_event_enum {
		react_event_DEATH = 0,
		react_event_COLLIDE = 1,
		react_event_NEAR = 2,
	};
	inline react_event_enum react_event(void);
	inline void react_event(react_event_enum value);
	inline bool show_guide_hairs(void);
	inline void show_guide_hairs(bool value);
	inline bool show_hair_grid(void);
	inline void show_hair_grid(bool value);
	inline bool show_velocity(void);
	inline void show_velocity(bool value);
	inline bool show_size(void);
	inline void show_size(bool value);
	inline bool show_health(void);
	inline void show_health(bool value);
	inline bool use_absolute_path_time(void);
	inline void use_absolute_path_time(bool value);
	inline bool use_parent_particles(void);
	inline void use_parent_particles(bool value);
	inline bool show_number(void);
	inline void show_number(bool value);
	inline bool use_collection_pick_random(void);
	inline void use_collection_pick_random(bool value);
	inline bool use_collection_count(void);
	inline void use_collection_count(bool value);
	inline bool use_global_instance(void);
	inline void use_global_instance(bool value);
	inline bool use_rotation_instance(void);
	inline void use_rotation_instance(bool value);
	inline bool use_scale_instance(void);
	inline void use_scale_instance(bool value);
	inline bool use_render_adaptive(void);
	inline void use_render_adaptive(bool value);
	inline bool use_velocity_length(void);
	inline void use_velocity_length(bool value);
	inline bool use_whole_collection(void);
	inline void use_whole_collection(bool value);
	inline bool use_strand_primitive(void);
	inline void use_strand_primitive(bool value);
	enum display_method_enum {
		display_method_NONE = 0,
		display_method_RENDER = 10,
		display_method_DOT = 1,
		display_method_CIRC = 2,
		display_method_CROSS = 3,
		display_method_AXIS = 4,
	};
	inline display_method_enum display_method(void);
	inline void display_method(display_method_enum value);
	enum render_type_enum {
		render_type_NONE = 0,
		render_type_HALO = 1,
		render_type_LINE = 5,
		render_type_PATH = 6,
		render_type_OBJECT = 7,
		render_type_COLLECTION = 8,
	};
	inline render_type_enum render_type(void);
	inline void render_type(render_type_enum value);
	enum display_color_enum {
		display_color_NONE = 0,
		display_color_MATERIAL = 1,
		display_color_VELOCITY = 2,
		display_color_ACCELERATION = 3,
	};
	inline display_color_enum display_color(void);
	inline void display_color(display_color_enum value);
	inline float display_size(void);
	inline void display_size(float value);
	enum child_type_enum {
		child_type_NONE = 0,
		child_type_SIMPLE = 1,
		child_type_INTERPOLATED = 2,
	};
	inline child_type_enum child_type(void);
	inline void child_type(child_type_enum value);
	inline int display_step(void);
	inline void display_step(int value);
	inline int render_step(void);
	inline void render_step(int value);
	inline int hair_step(void);
	inline void hair_step(int value);
	inline float bending_random(void);
	inline void bending_random(float value);
	inline int keys_step(void);
	inline void keys_step(int value);
	inline int adaptive_angle(void);
	inline void adaptive_angle(int value);
	inline int adaptive_pixel(void);
	inline void adaptive_pixel(int value);
	inline int display_percentage(void);
	inline void display_percentage(int value);
	inline int material(void);
	inline void material(int value);
	enum material_slot_enum {
		material_slot_DUMMY = 0,
	};
	inline material_slot_enum material_slot(void);
	inline void material_slot(material_slot_enum value);
	enum integrator_enum {
		integrator_EULER = 0,
		integrator_VERLET = 3,
		integrator_MIDPOINT = 1,
		integrator_RK4 = 2,
	};
	inline integrator_enum integrator(void);
	inline void integrator(integrator_enum value);
	enum kink_enum {
		kink_NO = 0,
		kink_CURL = 1,
		kink_RADIAL = 2,
		kink_WAVE = 3,
		kink_BRAID = 4,
		kink_SPIRAL = 5,
	};
	inline kink_enum kink(void);
	inline void kink(kink_enum value);
	enum kink_axis_enum {
		kink_axis_X = 0,
		kink_axis_Y = 1,
		kink_axis_Z = 2,
	};
	inline kink_axis_enum kink_axis(void);
	inline void kink_axis(kink_axis_enum value);
	inline float color_maximum(void);
	inline void color_maximum(float value);
	inline float frame_start(void);
	inline void frame_start(float value);
	inline float frame_end(void);
	inline void frame_end(float value);
	inline float lifetime(void);
	inline void lifetime(float value);
	inline float lifetime_random(void);
	inline void lifetime_random(float value);
	inline float time_tweak(void);
	inline void time_tweak(float value);
	inline float timestep(void);
	inline void timestep(float value);
	inline bool use_adaptive_subframes(void);
	inline void use_adaptive_subframes(bool value);
	inline int subframes(void);
	inline void subframes(int value);
	inline float courant_target(void);
	inline void courant_target(float value);
	inline float jitter_factor(void);
	inline void jitter_factor(float value);
	inline float effect_hair(void);
	inline void effect_hair(float value);
	inline int count(void);
	inline void count(int value);
	inline int userjit(void);
	inline void userjit(int value);
	inline int grid_resolution(void);
	inline void grid_resolution(int value);
	inline float grid_random(void);
	inline void grid_random(float value);
	inline int effector_amount(void);
	inline void effector_amount(int value);
	inline float normal_factor(void);
	inline void normal_factor(float value);
	inline float object_factor(void);
	inline void object_factor(float value);
	inline float factor_random(void);
	inline void factor_random(float value);
	inline float particle_factor(void);
	inline void particle_factor(float value);
	inline float tangent_factor(void);
	inline void tangent_factor(float value);
	inline float tangent_phase(void);
	inline void tangent_phase(float value);
	inline float reactor_factor(void);
	inline void reactor_factor(float value);
	inline Array<float, 3> object_align_factor(void);
	inline void object_align_factor(float values[3]);
	inline float angular_velocity_factor(void);
	inline void angular_velocity_factor(float value);
	inline float phase_factor(void);
	inline void phase_factor(float value);
	inline float rotation_factor_random(void);
	inline void rotation_factor_random(float value);
	inline float phase_factor_random(void);
	inline void phase_factor_random(float value);
	inline float hair_length(void);
	inline void hair_length(float value);
	inline float mass(void);
	inline void mass(float value);
	inline float particle_size(void);
	inline void particle_size(float value);
	inline float size_random(void);
	inline void size_random(float value);
	inline Collection collision_collection(void);
	inline float drag_factor(void);
	inline void drag_factor(float value);
	inline float brownian_factor(void);
	inline void brownian_factor(float value);
	inline float damping(void);
	inline void damping(float value);
	inline float length_random(void);
	inline void length_random(float value);
	inline int child_nbr(void);
	inline void child_nbr(int value);
	inline int rendered_child_count(void);
	inline void rendered_child_count(int value);
	inline float virtual_parents(void);
	inline void virtual_parents(float value);
	inline float child_size(void);
	inline void child_size(float value);
	inline float child_size_random(void);
	inline void child_size_random(float value);
	inline float child_radius(void);
	inline void child_radius(float value);
	inline float child_roundness(void);
	inline void child_roundness(float value);
	inline float clump_factor(void);
	inline void clump_factor(float value);
	inline float clump_shape(void);
	inline void clump_shape(float value);
	inline bool use_clump_curve(void);
	inline void use_clump_curve(bool value);
	inline CurveMapping clump_curve(void);
	inline bool use_clump_noise(void);
	inline void use_clump_noise(bool value);
	inline float clump_noise_size(void);
	inline void clump_noise_size(float value);
	inline float kink_amplitude(void);
	inline void kink_amplitude(float value);
	inline float kink_amplitude_clump(void);
	inline void kink_amplitude_clump(float value);
	inline float kink_amplitude_random(void);
	inline void kink_amplitude_random(float value);
	inline float kink_frequency(void);
	inline void kink_frequency(float value);
	inline float kink_shape(void);
	inline void kink_shape(float value);
	inline float kink_flat(void);
	inline void kink_flat(float value);
	inline int kink_extra_steps(void);
	inline void kink_extra_steps(int value);
	inline float kink_axis_random(void);
	inline void kink_axis_random(float value);
	inline float roughness_1(void);
	inline void roughness_1(float value);
	inline float roughness_1_size(void);
	inline void roughness_1_size(float value);
	inline float roughness_2(void);
	inline void roughness_2(float value);
	inline float roughness_2_size(void);
	inline void roughness_2_size(float value);
	inline float roughness_2_threshold(void);
	inline void roughness_2_threshold(float value);
	inline float roughness_endpoint(void);
	inline void roughness_endpoint(float value);
	inline float roughness_end_shape(void);
	inline void roughness_end_shape(float value);
	inline bool use_roughness_curve(void);
	inline void use_roughness_curve(bool value);
	inline CurveMapping roughness_curve(void);
	inline float child_length(void);
	inline void child_length(float value);
	inline float child_length_threshold(void);
	inline void child_length_threshold(float value);
	inline float child_parting_factor(void);
	inline void child_parting_factor(float value);
	inline float child_parting_min(void);
	inline void child_parting_min(float value);
	inline float child_parting_max(void);
	inline void child_parting_max(float value);
	inline float branch_threshold(void);
	inline void branch_threshold(float value);
	inline float line_length_tail(void);
	inline void line_length_tail(float value);
	inline float line_length_head(void);
	inline void line_length_head(float value);
	inline float path_start(void);
	inline void path_start(float value);
	inline float path_end(void);
	inline void path_end(float value);
	inline int trail_count(void);
	inline void trail_count(int value);
	inline int keyed_loops(void);
	inline void keyed_loops(int value);
	inline bool use_modifier_stack(void);
	inline void use_modifier_stack(bool value);
	inline Collection instance_collection(void);
	COLLECTION_PROPERTY(DefaultCollectionFunctions, ParticleDupliWeight, ParticleSettings, instance_weights, false, true, true)
	inline ParticleDupliWeight active_instanceweight(void);
	inline int active_instanceweight_index(void);
	inline void active_instanceweight_index(int value);
	inline Object instance_object(void);
	inline BoidSettings boids(void);
	inline SPHFluidSettings fluid(void);
	inline EffectorWeights effector_weights(void);
	inline AnimData animation_data(void);
	inline FieldSettings force_field_1(void);
	inline FieldSettings force_field_2(void);
	inline float twist(void);
	inline void twist(float value);
	inline bool use_twist_curve(void);
	inline void use_twist_curve(bool value);
	inline CurveMapping twist_curve(void);
	inline bool use_close_tip(void);
	inline void use_close_tip(bool value);
	inline float shape(void);
	inline void shape(float value);
	inline float root_radius(void);
	inline void root_radius(float value);
	inline float tip_radius(void);
	inline void tip_radius(float value);
	inline float radius_scale(void);
	inline void radius_scale(float value);

};

/**************** Pose ****************/

class Pose : public Pointer {
public:
	Pose(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		bones(ptr_arg),
		bone_groups(ptr_arg)
		{}

	inline Struct rna_type(void);
	COLLECTION_PROPERTY(DefaultCollectionFunctions, PoseBone, Pose, bones, false, true, true)
	COLLECTION_PROPERTY(BoneGroups, BoneGroup, Pose, bone_groups, false, true, true)
	enum ik_solver_enum {
		ik_solver_LEGACY = 0,
		ik_solver_ITASC = 1,
	};
	inline ik_solver_enum ik_solver(void);
	inline void ik_solver(ik_solver_enum value);
	inline IKParam ik_param(void);
	inline AnimViz animation_visualization(void);

};

/**************** Pose Bone ****************/

class PoseBone : public Pointer {
public:
	PoseBone(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		constraints(ptr_arg)
		{}

	inline Struct rna_type(void);
	COLLECTION_PROPERTY(PoseBoneConstraints, Constraint, PoseBone, constraints, false, true, true)
	inline std::string name(void);
	inline void name(const std::string& value);
	inline MotionPath motion_path(void);
	inline Bone bone(void);
	inline PoseBone parent(void);
	inline PoseBone child(void);
	inline Array<float, 3> location(void);
	inline void location(float values[3]);
	inline Array<float, 3> scale(void);
	inline void scale(float values[3]);
	inline Array<float, 4> rotation_quaternion(void);
	inline void rotation_quaternion(float values[4]);
	inline Array<float, 4> rotation_axis_angle(void);
	inline void rotation_axis_angle(float values[4]);
	inline Array<float, 3> rotation_euler(void);
	inline void rotation_euler(float values[3]);
	enum rotation_mode_enum {
		rotation_mode_QUATERNION = 0,
		rotation_mode_XYZ = 1,
		rotation_mode_XZY = 2,
		rotation_mode_YXZ = 3,
		rotation_mode_YZX = 4,
		rotation_mode_ZXY = 5,
		rotation_mode_ZYX = 6,
		rotation_mode_AXIS_ANGLE = -1,
	};
	inline rotation_mode_enum rotation_mode(void);
	inline void rotation_mode(rotation_mode_enum value);
	inline float bbone_rollin(void);
	inline void bbone_rollin(float value);
	inline float bbone_rollout(void);
	inline void bbone_rollout(float value);
	inline float bbone_curveinx(void);
	inline void bbone_curveinx(float value);
	inline float bbone_curveiny(void);
	inline void bbone_curveiny(float value);
	inline float bbone_curveoutx(void);
	inline void bbone_curveoutx(float value);
	inline float bbone_curveouty(void);
	inline void bbone_curveouty(float value);
	inline float bbone_easein(void);
	inline void bbone_easein(float value);
	inline float bbone_easeout(void);
	inline void bbone_easeout(float value);
	inline float bbone_scalein(void);
	inline void bbone_scalein(float value);
	inline float bbone_scaleout(void);
	inline void bbone_scaleout(float value);
	inline PoseBone bbone_custom_handle_start(void);
	inline PoseBone bbone_custom_handle_end(void);
	inline Array<float, 16> matrix_channel(void);
	inline void matrix_channel(float values[16]);
	inline Array<float, 16> matrix_basis(void);
	inline void matrix_basis(float values[16]);
	inline Array<float, 16> matrix(void);
	inline void matrix(float values[16]);
	inline Array<float, 3> head(void);
	inline void head(float values[3]);
	inline Array<float, 3> tail(void);
	inline void tail(float values[3]);
	inline bool is_in_ik_chain(void);
	inline void is_in_ik_chain(bool value);
	inline bool lock_ik_x(void);
	inline void lock_ik_x(bool value);
	inline bool lock_ik_y(void);
	inline void lock_ik_y(bool value);
	inline bool lock_ik_z(void);
	inline void lock_ik_z(bool value);
	inline bool use_ik_limit_x(void);
	inline void use_ik_limit_x(bool value);
	inline bool use_ik_limit_y(void);
	inline void use_ik_limit_y(bool value);
	inline bool use_ik_limit_z(void);
	inline void use_ik_limit_z(bool value);
	inline bool use_ik_rotation_control(void);
	inline void use_ik_rotation_control(bool value);
	inline bool use_ik_linear_control(void);
	inline void use_ik_linear_control(bool value);
	inline float ik_min_x(void);
	inline void ik_min_x(float value);
	inline float ik_max_x(void);
	inline void ik_max_x(float value);
	inline float ik_min_y(void);
	inline void ik_min_y(float value);
	inline float ik_max_y(void);
	inline void ik_max_y(float value);
	inline float ik_min_z(void);
	inline void ik_min_z(float value);
	inline float ik_max_z(void);
	inline void ik_max_z(float value);
	inline float ik_stiffness_x(void);
	inline void ik_stiffness_x(float value);
	inline float ik_stiffness_y(void);
	inline void ik_stiffness_y(float value);
	inline float ik_stiffness_z(void);
	inline void ik_stiffness_z(float value);
	inline float ik_stretch(void);
	inline void ik_stretch(float value);
	inline float ik_rotation_weight(void);
	inline void ik_rotation_weight(float value);
	inline float ik_linear_weight(void);
	inline void ik_linear_weight(float value);
	inline Object custom_shape(void);
	inline float custom_shape_scale(void);
	inline void custom_shape_scale(float value);
	inline bool use_custom_shape_bone_size(void);
	inline void use_custom_shape_bone_size(bool value);
	inline PoseBone custom_shape_transform(void);
	inline int bone_group_index(void);
	inline void bone_group_index(int value);
	inline BoneGroup bone_group(void);
	inline Array<bool, 3> lock_location(void);
	inline void lock_location(bool values[3]);
	inline Array<bool, 3> lock_rotation(void);
	inline void lock_rotation(bool values[3]);
	inline bool lock_rotation_w(void);
	inline void lock_rotation_w(bool value);
	inline bool lock_rotations_4d(void);
	inline void lock_rotations_4d(bool value);
	inline Array<bool, 3> lock_scale(void);
	inline void lock_scale(bool values[3]);

	inline float evaluate_envelope(float point[3]);
	inline void bbone_segment_matrix(float matrix_return[16], int index, bool rest);
	inline void compute_bbone_handles(float handle1[3], float *roll1, float handle2[3], float *roll2, bool rest, bool ease, bool offsets);
};

/**************** IKParam ****************/

class IKParam : public Pointer {
public:
	IKParam(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	enum ik_solver_enum {
		ik_solver_LEGACY = 0,
		ik_solver_ITASC = 1,
	};
	inline ik_solver_enum ik_solver(void);
	inline void ik_solver(ik_solver_enum value);

};

/**************** bItasc ****************/

class Itasc : public IKParam {
public:
	Itasc(const PointerRNA &ptr_arg) :
		IKParam(ptr_arg)
		{}

	inline float precision(void);
	inline void precision(float value);
	inline int iterations(void);
	inline void iterations(int value);
	inline int step_count(void);
	inline void step_count(int value);
	enum mode_enum {
		mode_ANIMATION = 0,
		mode_SIMULATION = 8,
	};
	inline mode_enum mode(void);
	inline void mode(mode_enum value);
	enum reiteration_method_enum {
		reiteration_method_NEVER = 0,
		reiteration_method_INITIAL = 2,
		reiteration_method_ALWAYS = 6,
	};
	inline reiteration_method_enum reiteration_method(void);
	inline void reiteration_method(reiteration_method_enum value);
	inline bool use_auto_step(void);
	inline void use_auto_step(bool value);
	inline float step_min(void);
	inline void step_min(float value);
	inline float step_max(void);
	inline void step_max(float value);
	inline float feedback(void);
	inline void feedback(float value);
	inline float velocity_max(void);
	inline void velocity_max(float value);
	enum solver_enum {
		solver_SDLS = 0,
		solver_DLS = 1,
	};
	inline solver_enum solver(void);
	inline void solver(solver_enum value);
	inline float damping_max(void);
	inline void damping_max(float value);
	inline float damping_epsilon(void);
	inline void damping_epsilon(float value);

};

/**************** Bone Group ****************/

class BoneGroup : public Pointer {
public:
	BoneGroup(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string name(void);
	inline void name(const std::string& value);
	enum color_set_enum {
		color_set_DEFAULT = 0,
		color_set_THEME01 = 1,
		color_set_THEME02 = 2,
		color_set_THEME03 = 3,
		color_set_THEME04 = 4,
		color_set_THEME05 = 5,
		color_set_THEME06 = 6,
		color_set_THEME07 = 7,
		color_set_THEME08 = 8,
		color_set_THEME09 = 9,
		color_set_THEME10 = 10,
		color_set_THEME11 = 11,
		color_set_THEME12 = 12,
		color_set_THEME13 = 13,
		color_set_THEME14 = 14,
		color_set_THEME15 = 15,
		color_set_THEME16 = 16,
		color_set_THEME17 = 17,
		color_set_THEME18 = 18,
		color_set_THEME19 = 19,
		color_set_THEME20 = 20,
		color_set_CUSTOM = -1,
	};
	inline color_set_enum color_set(void);
	inline void color_set(color_set_enum value);
	inline bool is_custom_color_set(void);
	inline void is_custom_color_set(bool value);
	inline ThemeBoneColorSet colors(void);

};

/**************** LightProbe ****************/

class LightProbe : public ID {
public:
	LightProbe(const PointerRNA &ptr_arg) :
		ID(ptr_arg)
		{}

	enum type_enum {
		type_CUBEMAP = 0,
		type_PLANAR = 1,
		type_GRID = 2,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	inline float clip_start(void);
	inline void clip_start(float value);
	inline float clip_end(void);
	inline void clip_end(float value);
	inline bool show_clip(void);
	inline void show_clip(bool value);
	enum influence_type_enum {
		influence_type_ELIPSOID = 0,
		influence_type_BOX = 1,
	};
	inline influence_type_enum influence_type(void);
	inline void influence_type(influence_type_enum value);
	inline bool show_influence(void);
	inline void show_influence(bool value);
	inline float influence_distance(void);
	inline void influence_distance(float value);
	inline float falloff(void);
	inline void falloff(float value);
	inline bool use_custom_parallax(void);
	inline void use_custom_parallax(bool value);
	inline bool show_parallax(void);
	inline void show_parallax(bool value);
	enum parallax_type_enum {
		parallax_type_ELIPSOID = 0,
		parallax_type_BOX = 1,
	};
	inline parallax_type_enum parallax_type(void);
	inline void parallax_type(parallax_type_enum value);
	inline float parallax_distance(void);
	inline void parallax_distance(float value);
	inline int grid_resolution_x(void);
	inline void grid_resolution_x(int value);
	inline int grid_resolution_y(void);
	inline void grid_resolution_y(int value);
	inline int grid_resolution_z(void);
	inline void grid_resolution_z(int value);
	inline float visibility_buffer_bias(void);
	inline void visibility_buffer_bias(float value);
	inline float visibility_bleed_bias(void);
	inline void visibility_bleed_bias(float value);
	inline float visibility_blur(void);
	inline void visibility_blur(float value);
	inline float intensity(void);
	inline void intensity(float value);
	inline Collection visibility_collection(void);
	inline bool invert_visibility_collection(void);
	inline void invert_visibility_collection(bool value);
	inline bool show_data(void);
	inline void show_data(bool value);
	inline AnimData animation_data(void);

};

/**************** Render Engine ****************/

class RenderEngine : public Pointer {
public:
	RenderEngine(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline bool is_animation(void);
	inline void is_animation(bool value);
	inline bool is_preview(void);
	inline void is_preview(bool value);
	inline Object camera_override(void);
	inline Array<bool, 20> layer_override(void);
	inline void layer_override(bool values[20]);
	inline int tile_x(void);
	inline void tile_x(int value);
	inline int tile_y(void);
	inline void tile_y(int value);
	inline int resolution_x(void);
	inline void resolution_x(int value);
	inline int resolution_y(void);
	inline void resolution_y(int value);
	inline RenderSettings render(void);
	inline bool use_highlight_tiles(void);
	inline void use_highlight_tiles(bool value);
	inline std::string bl_idname(void);
	inline void bl_idname(const std::string& value);
	inline std::string bl_label(void);
	inline void bl_label(const std::string& value);
	inline bool bl_use_preview(void);
	inline void bl_use_preview(bool value);
	inline bool bl_use_texture_preview(void);
	inline void bl_use_texture_preview(bool value);
	inline bool bl_use_postprocess(void);
	inline void bl_use_postprocess(bool value);
	inline bool bl_use_shading_nodes(void);
	inline void bl_use_shading_nodes(bool value);
	inline bool bl_use_shading_nodes_custom(void);
	inline void bl_use_shading_nodes_custom(bool value);
	inline bool bl_use_exclude_layers(void);
	inline void bl_use_exclude_layers(bool value);
	inline bool bl_use_save_buffers(void);
	inline void bl_use_save_buffers(bool value);
	inline bool bl_use_spherical_stereo(void);
	inline void bl_use_spherical_stereo(bool value);

	inline void tag_redraw();
	inline void tag_update();
	inline RenderResult begin_result(int x, int y, int w, int h, const char * layer, const char * view);
	inline void update_result(RenderResult& result);
	inline void end_result(RenderResult& result, bool cancel, bool highlight, bool do_merge_results);
	inline void add_pass(const char * name, int channels, const char * chan_id, const char * layer);
	inline RenderResult get_result();
	inline bool test_break();
	inline const char * active_view_get();
	inline void active_view_set(const char * view);
	inline float camera_shift_x(Object& camera, bool use_spherical_stereo);
	inline void camera_model_matrix(Object& camera, bool use_spherical_stereo, float r_model_matrix[16]);
	inline bool use_spherical_stereo(Object& camera);
	inline void update_stats(const char * stats, const char * info);
	inline void frame_set(int frame, float subframe);
	inline void update_progress(float progress);
	inline void update_memory_stats(float memory_used, float memory_peak);
	inline void report(int type, const char * message);
	inline void error_set(const char * message);
	inline void bind_display_space_shader(Scene& scene);
	inline void unbind_display_space_shader();
	inline bool support_display_space_shader(Scene& scene);
	inline int get_preview_pixel_size(Scene& scene);
	inline void free_blender_memory();
	inline void register_pass(Scene& scene, ViewLayer& view_layer, const char * name, int channels, const char * chanid, int type);
};

/**************** Render Result ****************/

class RenderResult : public Pointer {
public:
	RenderResult(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		layers(ptr_arg),
		views(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline int resolution_x(void);
	inline void resolution_x(int value);
	inline int resolution_y(void);
	inline void resolution_y(int value);
	COLLECTION_PROPERTY(DefaultCollectionFunctions, RenderLayer, RenderResult, layers, false, false, false)
	COLLECTION_PROPERTY(DefaultCollectionFunctions, RenderView, RenderResult, views, false, false, false)

	inline void load_from_file(const char * filename);
	inline void stamp_data_add_field(const char * field, const char * value);
};

/**************** Render View ****************/

class RenderView : public Pointer {
public:
	RenderView(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string name(void);
	inline void name(const std::string& value);

};

/**************** Render Layer ****************/

class RenderLayer : public Pointer {
public:
	RenderLayer(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		passes(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string name(void);
	inline void name(const std::string& value);
	inline bool use_zmask(void);
	inline void use_zmask(bool value);
	inline bool invert_zmask(void);
	inline void invert_zmask(bool value);
	inline bool use_all_z(void);
	inline void use_all_z(bool value);
	inline bool use_solid(void);
	inline void use_solid(bool value);
	inline bool use_halo(void);
	inline void use_halo(bool value);
	inline bool use_ztransp(void);
	inline void use_ztransp(bool value);
	inline bool use_sky(void);
	inline void use_sky(bool value);
	inline bool use_ao(void);
	inline void use_ao(bool value);
	inline bool use_edge_enhance(void);
	inline void use_edge_enhance(bool value);
	inline bool use_strand(void);
	inline void use_strand(bool value);
	inline bool use_pass_combined(void);
	inline void use_pass_combined(bool value);
	inline bool use_pass_z(void);
	inline void use_pass_z(bool value);
	inline bool use_pass_vector(void);
	inline void use_pass_vector(bool value);
	inline bool use_pass_normal(void);
	inline void use_pass_normal(bool value);
	inline bool use_pass_uv(void);
	inline void use_pass_uv(bool value);
	inline bool use_pass_mist(void);
	inline void use_pass_mist(bool value);
	inline bool use_pass_object_index(void);
	inline void use_pass_object_index(bool value);
	inline bool use_pass_material_index(void);
	inline void use_pass_material_index(bool value);
	inline bool use_pass_shadow(void);
	inline void use_pass_shadow(bool value);
	inline bool use_pass_ambient_occlusion(void);
	inline void use_pass_ambient_occlusion(bool value);
	inline bool use_pass_emit(void);
	inline void use_pass_emit(bool value);
	inline bool use_pass_environment(void);
	inline void use_pass_environment(bool value);
	inline bool use_pass_diffuse_direct(void);
	inline void use_pass_diffuse_direct(bool value);
	inline bool use_pass_diffuse_indirect(void);
	inline void use_pass_diffuse_indirect(bool value);
	inline bool use_pass_diffuse_color(void);
	inline void use_pass_diffuse_color(bool value);
	inline bool use_pass_glossy_direct(void);
	inline void use_pass_glossy_direct(bool value);
	inline bool use_pass_glossy_indirect(void);
	inline void use_pass_glossy_indirect(bool value);
	inline bool use_pass_glossy_color(void);
	inline void use_pass_glossy_color(bool value);
	inline bool use_pass_transmission_direct(void);
	inline void use_pass_transmission_direct(bool value);
	inline bool use_pass_transmission_indirect(void);
	inline void use_pass_transmission_indirect(bool value);
	inline bool use_pass_transmission_color(void);
	inline void use_pass_transmission_color(bool value);
	inline bool use_pass_subsurface_direct(void);
	inline void use_pass_subsurface_direct(bool value);
	inline bool use_pass_subsurface_indirect(void);
	inline void use_pass_subsurface_indirect(bool value);
	inline bool use_pass_subsurface_color(void);
	inline void use_pass_subsurface_color(bool value);
	COLLECTION_PROPERTY(RenderPasses, RenderPass, RenderLayer, passes, false, false, false)

	inline void load_from_file(const char * filename, int x, int y);
};

/**************** Render Pass ****************/

class RenderPass : public Pointer {
public:
	RenderPass(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string fullname(void);
	inline void fullname(const std::string& value);
	inline std::string name(void);
	inline void name(const std::string& value);
	inline std::string channel_id(void);
	inline void channel_id(const std::string& value);
	inline int channels(void);
	inline void channels(int value);
	inline DynamicArray<float> rect(void);
	inline void rect(float values[]);
	inline int view_id(void);
	inline void view_id(int value);

};

/**************** Bake Pixel ****************/

class BakePixel : public Pointer {
public:
	BakePixel(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline int primitive_id(void);
	inline void primitive_id(int value);
	inline int object_id(void);
	inline void object_id(int value);
	inline Array<float, 2> uv(void);
	inline void uv(float values[2]);
	inline float du_dx(void);
	inline void du_dx(float value);
	inline float du_dy(void);
	inline void du_dy(float value);
	inline float dv_dx(void);
	inline void dv_dx(float value);
	inline float dv_dy(void);
	inline void dv_dy(float value);
	inline BakePixel next(void);

};

/**************** Rigid Body World ****************/

class RigidBodyWorld : public Pointer {
public:
	RigidBodyWorld(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline Collection collection(void);
	inline Collection constraints(void);
	inline bool enabled(void);
	inline void enabled(bool value);
	inline float time_scale(void);
	inline void time_scale(float value);
	inline int steps_per_second(void);
	inline void steps_per_second(int value);
	inline int solver_iterations(void);
	inline void solver_iterations(int value);
	inline bool use_split_impulse(void);
	inline void use_split_impulse(bool value);
	inline PointCache point_cache(void);
	inline EffectorWeights effector_weights(void);

	inline void convex_sweep_test(Object& object, float start[3], float end[3], float object_location[3], float hitpoint[3], float normal[3], int *has_hit);
};

/**************** Rigid Body Object ****************/

class RigidBodyObject : public Pointer {
public:
	RigidBodyObject(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	enum type_enum {
		type_ACTIVE = 0,
		type_PASSIVE = 1,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	enum mesh_source_enum {
		mesh_source_BASE = 0,
		mesh_source_DEFORM = 1,
		mesh_source_FINAL = 2,
	};
	inline mesh_source_enum mesh_source(void);
	inline void mesh_source(mesh_source_enum value);
	inline bool enabled(void);
	inline void enabled(bool value);
	enum collision_shape_enum {
		collision_shape_BOX = 0,
		collision_shape_SPHERE = 1,
		collision_shape_CAPSULE = 2,
		collision_shape_CYLINDER = 3,
		collision_shape_CONE = 4,
		collision_shape_CONVEX_HULL = 5,
		collision_shape_MESH = 6,
	};
	inline collision_shape_enum collision_shape(void);
	inline void collision_shape(collision_shape_enum value);
	inline bool kinematic(void);
	inline void kinematic(bool value);
	inline bool use_deform(void);
	inline void use_deform(bool value);
	inline float mass(void);
	inline void mass(float value);
	inline bool use_deactivation(void);
	inline void use_deactivation(bool value);
	inline bool use_start_deactivated(void);
	inline void use_start_deactivated(bool value);
	inline float deactivate_linear_velocity(void);
	inline void deactivate_linear_velocity(float value);
	inline float deactivate_angular_velocity(void);
	inline void deactivate_angular_velocity(float value);
	inline float linear_damping(void);
	inline void linear_damping(float value);
	inline float angular_damping(void);
	inline void angular_damping(float value);
	inline float friction(void);
	inline void friction(float value);
	inline float restitution(void);
	inline void restitution(float value);
	inline bool use_margin(void);
	inline void use_margin(bool value);
	inline float collision_margin(void);
	inline void collision_margin(float value);
	inline Array<bool, 20> collision_collections(void);
	inline void collision_collections(bool values[20]);

};

/**************** Rigid Body Constraint ****************/

class RigidBodyConstraint : public Pointer {
public:
	RigidBodyConstraint(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	enum type_enum {
		type_FIXED = 8,
		type_POINT = 0,
		type_HINGE = 1,
		type_SLIDER = 3,
		type_PISTON = 9,
		type_GENERIC = 5,
		type_GENERIC_SPRING = 6,
		type_MOTOR = 11,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	enum spring_type_enum {
		spring_type_SPRING1 = 0,
		spring_type_SPRING2 = 1,
	};
	inline spring_type_enum spring_type(void);
	inline void spring_type(spring_type_enum value);
	inline bool enabled(void);
	inline void enabled(bool value);
	inline bool disable_collisions(void);
	inline void disable_collisions(bool value);
	inline Object object1(void);
	inline Object object2(void);
	inline bool use_breaking(void);
	inline void use_breaking(bool value);
	inline float breaking_threshold(void);
	inline void breaking_threshold(float value);
	inline bool use_override_solver_iterations(void);
	inline void use_override_solver_iterations(bool value);
	inline int solver_iterations(void);
	inline void solver_iterations(int value);
	inline bool use_limit_lin_x(void);
	inline void use_limit_lin_x(bool value);
	inline bool use_limit_lin_y(void);
	inline void use_limit_lin_y(bool value);
	inline bool use_limit_lin_z(void);
	inline void use_limit_lin_z(bool value);
	inline bool use_limit_ang_x(void);
	inline void use_limit_ang_x(bool value);
	inline bool use_limit_ang_y(void);
	inline void use_limit_ang_y(bool value);
	inline bool use_limit_ang_z(void);
	inline void use_limit_ang_z(bool value);
	inline bool use_spring_x(void);
	inline void use_spring_x(bool value);
	inline bool use_spring_y(void);
	inline void use_spring_y(bool value);
	inline bool use_spring_z(void);
	inline void use_spring_z(bool value);
	inline bool use_spring_ang_x(void);
	inline void use_spring_ang_x(bool value);
	inline bool use_spring_ang_y(void);
	inline void use_spring_ang_y(bool value);
	inline bool use_spring_ang_z(void);
	inline void use_spring_ang_z(bool value);
	inline bool use_motor_lin(void);
	inline void use_motor_lin(bool value);
	inline bool use_motor_ang(void);
	inline void use_motor_ang(bool value);
	inline float limit_lin_x_lower(void);
	inline void limit_lin_x_lower(float value);
	inline float limit_lin_x_upper(void);
	inline void limit_lin_x_upper(float value);
	inline float limit_lin_y_lower(void);
	inline void limit_lin_y_lower(float value);
	inline float limit_lin_y_upper(void);
	inline void limit_lin_y_upper(float value);
	inline float limit_lin_z_lower(void);
	inline void limit_lin_z_lower(float value);
	inline float limit_lin_z_upper(void);
	inline void limit_lin_z_upper(float value);
	inline float limit_ang_x_lower(void);
	inline void limit_ang_x_lower(float value);
	inline float limit_ang_x_upper(void);
	inline void limit_ang_x_upper(float value);
	inline float limit_ang_y_lower(void);
	inline void limit_ang_y_lower(float value);
	inline float limit_ang_y_upper(void);
	inline void limit_ang_y_upper(float value);
	inline float limit_ang_z_lower(void);
	inline void limit_ang_z_lower(float value);
	inline float limit_ang_z_upper(void);
	inline void limit_ang_z_upper(float value);
	inline float spring_stiffness_x(void);
	inline void spring_stiffness_x(float value);
	inline float spring_stiffness_y(void);
	inline void spring_stiffness_y(float value);
	inline float spring_stiffness_z(void);
	inline void spring_stiffness_z(float value);
	inline float spring_stiffness_ang_x(void);
	inline void spring_stiffness_ang_x(float value);
	inline float spring_stiffness_ang_y(void);
	inline void spring_stiffness_ang_y(float value);
	inline float spring_stiffness_ang_z(void);
	inline void spring_stiffness_ang_z(float value);
	inline float spring_damping_x(void);
	inline void spring_damping_x(float value);
	inline float spring_damping_y(void);
	inline void spring_damping_y(float value);
	inline float spring_damping_z(void);
	inline void spring_damping_z(float value);
	inline float spring_damping_ang_x(void);
	inline void spring_damping_ang_x(float value);
	inline float spring_damping_ang_y(void);
	inline void spring_damping_ang_y(float value);
	inline float spring_damping_ang_z(void);
	inline void spring_damping_ang_z(float value);
	inline float motor_lin_target_velocity(void);
	inline void motor_lin_target_velocity(float value);
	inline float motor_lin_max_impulse(void);
	inline void motor_lin_max_impulse(float value);
	inline float motor_ang_target_velocity(void);
	inline void motor_ang_target_velocity(float value);
	inline float motor_ang_max_impulse(void);
	inline void motor_ang_max_impulse(float value);

};

/**************** Scene ****************/

class Scene : public ID {
public:
	Scene(const PointerRNA &ptr_arg) :
		ID(ptr_arg),
		objects(ptr_arg),
		keying_sets(ptr_arg),
		keying_sets_all(ptr_arg),
		timeline_markers(ptr_arg),
		transform_orientation_slots(ptr_arg),
		view_layers(ptr_arg)
		{}

	inline Object camera(void);
	inline Scene background_set(void);
	inline World world(void);
	COLLECTION_PROPERTY(SceneObjects, Object, Scene, objects, false, false, false)
	inline int frame_current(void);
	inline void frame_current(int value);
	inline float frame_subframe(void);
	inline void frame_subframe(float value);
	inline float frame_float(void);
	inline void frame_float(float value);
	inline int frame_start(void);
	inline void frame_start(int value);
	inline int frame_end(void);
	inline void frame_end(int value);
	inline int frame_step(void);
	inline void frame_step(int value);
	inline float frame_current_final(void);
	inline void frame_current_final(float value);
	inline bool lock_frame_selection_to_range(void);
	inline void lock_frame_selection_to_range(bool value);
	inline bool use_preview_range(void);
	inline void use_preview_range(bool value);
	inline int frame_preview_start(void);
	inline void frame_preview_start(int value);
	inline int frame_preview_end(void);
	inline void frame_preview_end(int value);
	inline bool show_subframe(void);
	inline void show_subframe(bool value);
	inline bool show_keys_from_selected_only(void);
	inline void show_keys_from_selected_only(bool value);
	inline std::string use_stamp_note(void);
	inline void use_stamp_note(const std::string& value);
	inline AnimData animation_data(void);
	inline bool is_nla_tweakmode(void);
	inline void is_nla_tweakmode(bool value);
	enum sync_mode_enum {
		sync_mode_NONE = 0,
		sync_mode_FRAME_DROP = 8,
		sync_mode_AUDIO_SYNC = 2,
	};
	inline sync_mode_enum sync_mode(void);
	inline void sync_mode(sync_mode_enum value);
	inline NodeTree node_tree(void);
	inline bool use_nodes(void);
	inline void use_nodes(bool value);
	inline SequenceEditor sequence_editor(void);
	COLLECTION_PROPERTY(KeyingSets, KeyingSet, Scene, keying_sets, false, true, true)
	COLLECTION_PROPERTY(KeyingSetsAll, KeyingSet, Scene, keying_sets_all, false, false, false)
	inline RigidBodyWorld rigidbody_world(void);
	inline ToolSettings tool_settings(void);
	inline UnitSettings unit_settings(void);
	inline Array<float, 3> gravity(void);
	inline void gravity(float values[3]);
	inline bool use_gravity(void);
	inline void use_gravity(bool value);
	inline RenderSettings render(void);
	inline DisplaySafeAreas safe_areas(void);
	COLLECTION_PROPERTY(TimelineMarkers, TimelineMarker, Scene, timeline_markers, false, true, true)
	COLLECTION_PROPERTY(DefaultCollectionFunctions, TransformOrientationSlot, Scene, transform_orientation_slots, true, false, false)
	inline View3DCursor cursor(void);
	inline bool use_audio(void);
	inline void use_audio(bool value);
	inline bool use_audio_scrub(void);
	inline void use_audio_scrub(bool value);
	inline float audio_doppler_speed(void);
	inline void audio_doppler_speed(float value);
	inline float audio_doppler_factor(void);
	inline void audio_doppler_factor(float value);
	enum audio_distance_model_enum {
		audio_distance_model_NONE = 0,
		audio_distance_model_INVERSE = 1,
		audio_distance_model_INVERSE_CLAMPED = 2,
		audio_distance_model_LINEAR = 3,
		audio_distance_model_LINEAR_CLAMPED = 4,
		audio_distance_model_EXPONENT = 5,
		audio_distance_model_EXPONENT_CLAMPED = 6,
	};
	inline audio_distance_model_enum audio_distance_model(void);
	inline void audio_distance_model(audio_distance_model_enum value);
	inline float audio_volume(void);
	inline void audio_volume(float value);
	inline GreasePencil grease_pencil(void);
	inline MovieClip active_clip(void);
	inline ColorManagedViewSettings view_settings(void);
	inline ColorManagedDisplaySettings display_settings(void);
	inline ColorManagedSequencerColorspaceSettings sequencer_colorspace_settings(void);
	COLLECTION_PROPERTY(ViewLayers, ViewLayer, Scene, view_layers, false, true, true)
	inline Collection collection(void);
	inline SceneDisplay display(void);
	inline SceneEEVEE eevee(void);

	inline const char * statistics(void *main, ViewLayer& view_layer);
	inline void frame_set(void *main, int frame, float subframe);
	inline void update(void *main);
	inline void uvedit_aspect(Object& object, float result[2]);
	inline void ray_cast(void *main, ViewLayer& view_layer, float origin[3], float direction[3], float distance, bool *result, float location[3], float normal[3], int *index, Object *object, float matrix[16]);
	inline SequenceEditor sequence_editor_create();
	inline void sequence_editor_clear();
};

/**************** Tool Settings ****************/

class ToolSettings : public Pointer {
public:
	ToolSettings(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline Sculpt sculpt(void);
	inline bool use_auto_normalize(void);
	inline void use_auto_normalize(bool value);
	inline bool use_multipaint(void);
	inline void use_multipaint(bool value);
	enum vertex_group_user_enum {
		vertex_group_user_NONE = 0,
		vertex_group_user_ACTIVE = 1,
		vertex_group_user_ALL = 2,
	};
	inline vertex_group_user_enum vertex_group_user(void);
	inline void vertex_group_user(vertex_group_user_enum value);
	enum vertex_group_subset_enum {
		vertex_group_subset_ALL = 0,
		vertex_group_subset_BONE_DEFORM = 3,
		vertex_group_subset_OTHER_DEFORM = 4,
	};
	inline vertex_group_subset_enum vertex_group_subset(void);
	inline void vertex_group_subset(vertex_group_subset_enum value);
	inline VertexPaint vertex_paint(void);
	inline VertexPaint weight_paint(void);
	inline ImagePaint image_paint(void);
	inline UvSculpt uv_sculpt(void);
	inline GpPaint gpencil_paint(void);
	inline ParticleEdit particle_edit(void);
	inline bool use_uv_sculpt(void);
	inline void use_uv_sculpt(bool value);
	inline bool uv_sculpt_lock_borders(void);
	inline void uv_sculpt_lock_borders(bool value);
	inline bool uv_sculpt_all_islands(void);
	inline void uv_sculpt_all_islands(bool value);
	enum uv_sculpt_tool_enum {
		uv_sculpt_tool_PINCH = 1,
		uv_sculpt_tool_RELAX = 2,
		uv_sculpt_tool_GRAB = 3,
	};
	inline uv_sculpt_tool_enum uv_sculpt_tool(void);
	inline void uv_sculpt_tool(uv_sculpt_tool_enum value);
	enum uv_relax_method_enum {
		uv_relax_method_LAPLACIAN = 1,
		uv_relax_method_HC = 2,
	};
	inline uv_relax_method_enum uv_relax_method(void);
	inline void uv_relax_method(uv_relax_method_enum value);
	inline bool lock_object_mode(void);
	inline void lock_object_mode(bool value);
	enum proportional_edit_enum {
		proportional_edit_DISABLED = 0,
		proportional_edit_ENABLED = 1,
		proportional_edit_PROJECTED = 3,
		proportional_edit_CONNECTED = 2,
	};
	inline proportional_edit_enum proportional_edit(void);
	inline void proportional_edit(proportional_edit_enum value);
	inline bool use_proportional_edit_objects(void);
	inline void use_proportional_edit_objects(bool value);
	inline bool use_proportional_edit_mask(void);
	inline void use_proportional_edit_mask(bool value);
	inline bool use_proportional_action(void);
	inline void use_proportional_action(bool value);
	inline bool use_proportional_fcurve(void);
	inline void use_proportional_fcurve(bool value);
	inline bool lock_markers(void);
	inline void lock_markers(bool value);
	enum proportional_edit_falloff_enum {
		proportional_edit_falloff_SMOOTH = 0,
		proportional_edit_falloff_SPHERE = 1,
		proportional_edit_falloff_ROOT = 2,
		proportional_edit_falloff_INVERSE_SQUARE = 7,
		proportional_edit_falloff_SHARP = 3,
		proportional_edit_falloff_LINEAR = 4,
		proportional_edit_falloff_CONSTANT = 5,
		proportional_edit_falloff_RANDOM = 6,
	};
	inline proportional_edit_falloff_enum proportional_edit_falloff(void);
	inline void proportional_edit_falloff(proportional_edit_falloff_enum value);
	inline float proportional_size(void);
	inline void proportional_size(float value);
	inline float double_threshold(void);
	inline void double_threshold(float value);
	enum transform_pivot_point_enum {
		transform_pivot_point_BOUNDING_BOX_CENTER = 0,
		transform_pivot_point_CURSOR = 1,
		transform_pivot_point_INDIVIDUAL_ORIGINS = 2,
		transform_pivot_point_MEDIAN_POINT = 3,
		transform_pivot_point_ACTIVE_ELEMENT = 4,
	};
	inline transform_pivot_point_enum transform_pivot_point(void);
	inline void transform_pivot_point(transform_pivot_point_enum value);
	inline bool use_transform_pivot_point_align(void);
	inline void use_transform_pivot_point_align(bool value);
	inline bool use_mesh_automerge(void);
	inline void use_mesh_automerge(bool value);
	inline bool use_snap(void);
	inline void use_snap(bool value);
	inline bool use_snap_align_rotation(void);
	inline void use_snap_align_rotation(bool value);
	inline bool use_snap_grid_absolute(void);
	inline void use_snap_grid_absolute(bool value);
	enum snap_elements_enum {
		snap_elements_INCREMENT = 16,
		snap_elements_VERTEX = 1,
		snap_elements_EDGE = 2,
		snap_elements_FACE = 4,
		snap_elements_VOLUME = 8,
	};
	inline snap_elements_enum snap_elements(void);
	inline void snap_elements(snap_elements_enum value);
	enum snap_node_element_enum {
		snap_node_element_GRID = 32,
		snap_node_element_NODE_X = 64,
		snap_node_element_NODE_Y = 128,
		snap_node_element_NODE_XY = 192,
	};
	inline snap_node_element_enum snap_node_element(void);
	inline void snap_node_element(snap_node_element_enum value);
	enum snap_uv_element_enum {
		snap_uv_element_INCREMENT = 16,
		snap_uv_element_VERTEX = 1,
	};
	inline snap_uv_element_enum snap_uv_element(void);
	inline void snap_uv_element(snap_uv_element_enum value);
	enum snap_target_enum {
		snap_target_CLOSEST = 0,
		snap_target_CENTER = 1,
		snap_target_MEDIAN = 2,
		snap_target_ACTIVE = 3,
	};
	inline snap_target_enum snap_target(void);
	inline void snap_target(snap_target_enum value);
	inline bool use_snap_peel_object(void);
	inline void use_snap_peel_object(bool value);
	inline bool use_snap_project(void);
	inline void use_snap_project(bool value);
	inline bool use_snap_self(void);
	inline void use_snap_self(bool value);
	inline bool use_snap_translate(void);
	inline void use_snap_translate(bool value);
	inline bool use_snap_rotate(void);
	inline void use_snap_rotate(bool value);
	inline bool use_snap_scale(void);
	inline void use_snap_scale(bool value);
	enum use_gizmo_mode_enum {
		use_gizmo_mode_TRANSLATE = 1,
		use_gizmo_mode_ROTATE = 2,
		use_gizmo_mode_SCALE = 4,
	};
	inline use_gizmo_mode_enum use_gizmo_mode(void);
	inline void use_gizmo_mode(use_gizmo_mode_enum value);
	inline bool use_gpencil_draw_additive(void);
	inline void use_gpencil_draw_additive(bool value);
	inline bool use_gpencil_draw_onback(void);
	inline void use_gpencil_draw_onback(bool value);
	inline bool use_gpencil_thumbnail_list(void);
	inline void use_gpencil_thumbnail_list(bool value);
	inline bool use_gpencil_weight_data_add(void);
	inline void use_gpencil_weight_data_add(bool value);
	inline GPencilSculptSettings gpencil_sculpt(void);
	inline GPencilInterpolateSettings gpencil_interpolate(void);
	enum gpencil_stroke_placement_view3d_enum {
		gpencil_stroke_placement_view3d_ORIGIN = 1,
		gpencil_stroke_placement_view3d_CURSOR = 33,
		gpencil_stroke_placement_view3d_SURFACE = 5,
		gpencil_stroke_placement_view3d_STROKE = 9,
	};
	inline gpencil_stroke_placement_view3d_enum gpencil_stroke_placement_view3d(void);
	inline void gpencil_stroke_placement_view3d(gpencil_stroke_placement_view3d_enum value);
	enum gpencil_stroke_snap_mode_enum {
		gpencil_stroke_snap_mode_NONE = 0,
		gpencil_stroke_snap_mode_ENDS = 16,
		gpencil_stroke_snap_mode_FIRST = 64,
	};
	inline gpencil_stroke_snap_mode_enum gpencil_stroke_snap_mode(void);
	inline void gpencil_stroke_snap_mode(gpencil_stroke_snap_mode_enum value);
	inline bool use_gpencil_stroke_endpoints(void);
	inline void use_gpencil_stroke_endpoints(bool value);
	enum gpencil_selectmode_enum {
		gpencil_selectmode_POINT = 0,
		gpencil_selectmode_STROKE = 1,
		gpencil_selectmode_SEGMENT = 2,
	};
	inline gpencil_selectmode_enum gpencil_selectmode(void);
	inline void gpencil_selectmode(gpencil_selectmode_enum value);
	enum annotation_stroke_placement_view2d_enum {
		annotation_stroke_placement_view2d_CURSOR = 33,
		annotation_stroke_placement_view2d_VIEW = 0,
		annotation_stroke_placement_view2d_SURFACE = 5,
	};
	inline annotation_stroke_placement_view2d_enum annotation_stroke_placement_view2d(void);
	inline void annotation_stroke_placement_view2d(annotation_stroke_placement_view2d_enum value);
	enum annotation_stroke_placement_sequencer_preview_enum {
		annotation_stroke_placement_sequencer_preview_CURSOR = 33,
		annotation_stroke_placement_sequencer_preview_VIEW = 0,
		annotation_stroke_placement_sequencer_preview_SURFACE = 5,
	};
	inline annotation_stroke_placement_sequencer_preview_enum annotation_stroke_placement_sequencer_preview(void);
	inline void annotation_stroke_placement_sequencer_preview(annotation_stroke_placement_sequencer_preview_enum value);
	enum annotation_stroke_placement_image_editor_enum {
		annotation_stroke_placement_image_editor_CURSOR = 33,
		annotation_stroke_placement_image_editor_VIEW = 0,
		annotation_stroke_placement_image_editor_SURFACE = 5,
	};
	inline annotation_stroke_placement_image_editor_enum annotation_stroke_placement_image_editor(void);
	inline void annotation_stroke_placement_image_editor(annotation_stroke_placement_image_editor_enum value);
	enum annotation_stroke_placement_view3d_enum {
		annotation_stroke_placement_view3d_CURSOR = 33,
		annotation_stroke_placement_view3d_VIEW = 0,
		annotation_stroke_placement_view3d_SURFACE = 5,
	};
	inline annotation_stroke_placement_view3d_enum annotation_stroke_placement_view3d(void);
	inline void annotation_stroke_placement_view3d(annotation_stroke_placement_view3d_enum value);
	inline int annotation_thickness(void);
	inline void annotation_thickness(int value);
	inline bool use_keyframe_insert_auto(void);
	inline void use_keyframe_insert_auto(bool value);
	enum auto_keying_mode_enum {
		auto_keying_mode_ADD_REPLACE_KEYS = 2,
		auto_keying_mode_REPLACE_KEYS = 4,
	};
	inline auto_keying_mode_enum auto_keying_mode(void);
	inline void auto_keying_mode(auto_keying_mode_enum value);
	inline bool use_record_with_nla(void);
	inline void use_record_with_nla(bool value);
	inline bool use_keyframe_insert_keyingset(void);
	inline void use_keyframe_insert_keyingset(bool value);
	inline bool use_keyframe_cycle_aware(void);
	inline void use_keyframe_cycle_aware(bool value);
	enum keyframe_type_enum {
		keyframe_type_KEYFRAME = 0,
		keyframe_type_BREAKDOWN = 2,
		keyframe_type_MOVING_HOLD = 4,
		keyframe_type_EXTREME = 1,
		keyframe_type_JITTER = 3,
	};
	inline keyframe_type_enum keyframe_type(void);
	inline void keyframe_type(keyframe_type_enum value);
	enum uv_select_mode_enum {
		uv_select_mode_VERTEX = 1,
		uv_select_mode_EDGE = 2,
		uv_select_mode_FACE = 4,
		uv_select_mode_ISLAND = 8,
	};
	inline uv_select_mode_enum uv_select_mode(void);
	inline void uv_select_mode(uv_select_mode_enum value);
	inline bool use_uv_select_sync(void);
	inline void use_uv_select_sync(bool value);
	inline bool show_uv_local_view(void);
	inline void show_uv_local_view(bool value);
	inline Array<bool, 3> mesh_select_mode(void);
	inline void mesh_select_mode(bool values[3]);
	inline float vertex_group_weight(void);
	inline void vertex_group_weight(float value);
	enum edge_path_mode_enum {
		edge_path_mode_SELECT = 0,
		edge_path_mode_SEAM = 1,
		edge_path_mode_SHARP = 2,
		edge_path_mode_CREASE = 3,
		edge_path_mode_BEVEL = 4,
		edge_path_mode_FREESTYLE = 5,
	};
	inline edge_path_mode_enum edge_path_mode(void);
	inline void edge_path_mode(edge_path_mode_enum value);
	inline bool use_edge_path_live_unwrap(void);
	inline void use_edge_path_live_unwrap(bool value);
	inline Array<float, 3> normal_vector(void);
	inline void normal_vector(float values[3]);
	enum face_strength_enum {
		face_strength_Weak = -16384,
		face_strength_Medium = 0,
		face_strength_Strong = 16384,
	};
	inline face_strength_enum face_strength(void);
	inline void face_strength(face_strength_enum value);
	inline UnifiedPaintSettings unified_paint_settings(void);
	inline CurvePaintSettings curve_paint_settings(void);
	inline MeshStatVis statvis(void);

};

/**************** Grease Pencil Interpolate Settings ****************/

class GPencilInterpolateSettings : public Pointer {
public:
	GPencilInterpolateSettings(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline bool interpolate_all_layers(void);
	inline void interpolate_all_layers(bool value);
	inline bool interpolate_selected_only(void);
	inline void interpolate_selected_only(bool value);
	enum type_enum {
		type_LINEAR = 0,
		type_CUSTOM = 1,
		type_SINE = 12,
		type_QUAD = 9,
		type_CUBIC = 6,
		type_QUART = 10,
		type_QUINT = 11,
		type_EXPO = 8,
		type_CIRC = 5,
		type_BACK = 3,
		type_BOUNCE = 4,
		type_ELASTIC = 7,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	enum easing_enum {
		easing_AUTO = 0,
		easing_EASE_IN = 1,
		easing_EASE_OUT = 2,
		easing_EASE_IN_OUT = 3,
	};
	inline easing_enum easing(void);
	inline void easing(easing_enum value);
	inline float back(void);
	inline void back(float value);
	inline float amplitude(void);
	inline void amplitude(float value);
	inline float period(void);
	inline void period(float value);
	inline CurveMapping interpolation_curve(void);

};

/**************** Unified Paint Settings ****************/

class UnifiedPaintSettings : public Pointer {
public:
	UnifiedPaintSettings(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline bool use_unified_size(void);
	inline void use_unified_size(bool value);
	inline bool use_unified_strength(void);
	inline void use_unified_strength(bool value);
	inline bool use_unified_weight(void);
	inline void use_unified_weight(bool value);
	inline bool use_unified_color(void);
	inline void use_unified_color(bool value);
	inline int size(void);
	inline void size(int value);
	inline float unprojected_radius(void);
	inline void unprojected_radius(float value);
	inline float strength(void);
	inline void strength(float value);
	inline float weight(void);
	inline void weight(float value);
	inline Array<float, 3> color(void);
	inline void color(float values[3]);
	inline Array<float, 3> secondary_color(void);
	inline void secondary_color(float values[3]);
	inline bool use_pressure_size(void);
	inline void use_pressure_size(bool value);
	inline bool use_pressure_strength(void);
	inline void use_pressure_strength(bool value);
	enum use_locked_size_enum {
		use_locked_size_VIEW = 0,
		use_locked_size_SCENE = 4,
	};
	inline use_locked_size_enum use_locked_size(void);
	inline void use_locked_size(use_locked_size_enum value);

};

/**************** Curve Paint Settings ****************/

class CurvePaintSettings : public Pointer {
public:
	CurvePaintSettings(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	enum curve_type_enum {
		curve_type_POLY = 0,
		curve_type_BEZIER = 1,
	};
	inline curve_type_enum curve_type(void);
	inline void curve_type(curve_type_enum value);
	inline bool use_corners_detect(void);
	inline void use_corners_detect(bool value);
	inline bool use_pressure_radius(void);
	inline void use_pressure_radius(bool value);
	inline bool use_stroke_endpoints(void);
	inline void use_stroke_endpoints(bool value);
	inline bool use_offset_absolute(void);
	inline void use_offset_absolute(bool value);
	inline int error_threshold(void);
	inline void error_threshold(int value);
	enum fit_method_enum {
		fit_method_REFIT = 0,
		fit_method_SPLIT = 1,
	};
	inline fit_method_enum fit_method(void);
	inline void fit_method(fit_method_enum value);
	inline float corner_angle(void);
	inline void corner_angle(float value);
	inline float radius_min(void);
	inline void radius_min(float value);
	inline float radius_max(void);
	inline void radius_max(float value);
	inline float radius_taper_start(void);
	inline void radius_taper_start(float value);
	inline float radius_taper_end(void);
	inline void radius_taper_end(float value);
	inline float surface_offset(void);
	inline void surface_offset(float value);
	enum depth_mode_enum {
		depth_mode_CURSOR = 0,
		depth_mode_SURFACE = 1,
	};
	inline depth_mode_enum depth_mode(void);
	inline void depth_mode(depth_mode_enum value);
	enum surface_plane_enum {
		surface_plane_NORMAL_VIEW = 0,
		surface_plane_NORMAL_SURFACE = 1,
		surface_plane_VIEW = 2,
	};
	inline surface_plane_enum surface_plane(void);
	inline void surface_plane(surface_plane_enum value);

};

/**************** Mesh Visualize Statistics ****************/

class MeshStatVis : public Pointer {
public:
	MeshStatVis(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	enum type_enum {
		type_OVERHANG = 0,
		type_THICKNESS = 1,
		type_INTERSECT = 2,
		type_DISTORT = 3,
		type_SHARP = 4,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	inline float overhang_min(void);
	inline void overhang_min(float value);
	inline float overhang_max(void);
	inline void overhang_max(float value);
	enum overhang_axis_enum {
		overhang_axis_POS_X = 0,
		overhang_axis_POS_Y = 1,
		overhang_axis_POS_Z = 2,
		overhang_axis_NEG_X = 3,
		overhang_axis_NEG_Y = 4,
		overhang_axis_NEG_Z = 5,
	};
	inline overhang_axis_enum overhang_axis(void);
	inline void overhang_axis(overhang_axis_enum value);
	inline float thickness_min(void);
	inline void thickness_min(float value);
	inline float thickness_max(void);
	inline void thickness_max(float value);
	inline int thickness_samples(void);
	inline void thickness_samples(int value);
	inline float distort_min(void);
	inline void distort_min(float value);
	inline float distort_max(void);
	inline void distort_max(float value);
	inline float sharp_min(void);
	inline void sharp_min(float value);
	inline float sharp_max(void);
	inline void sharp_max(float value);

};

/**************** Unit Settings ****************/

class UnitSettings : public Pointer {
public:
	UnitSettings(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	enum system_enum {
		system_NONE = 0,
		system_METRIC = 1,
		system_IMPERIAL = 2,
	};
	inline system_enum system(void);
	inline void system(system_enum value);
	enum system_rotation_enum {
		system_rotation_DEGREES = 0,
		system_rotation_RADIANS = 2,
	};
	inline system_rotation_enum system_rotation(void);
	inline void system_rotation(system_rotation_enum value);
	inline float scale_length(void);
	inline void scale_length(float value);
	inline bool use_separate(void);
	inline void use_separate(bool value);
	enum length_unit_enum {
		length_unit_DEFAULT = 0,
	};
	inline length_unit_enum length_unit(void);
	inline void length_unit(length_unit_enum value);
	enum mass_unit_enum {
		mass_unit_DEFAULT = 0,
	};
	inline mass_unit_enum mass_unit(void);
	inline void mass_unit(mass_unit_enum value);
	enum time_unit_enum {
		time_unit_DEFAULT = 0,
	};
	inline time_unit_enum time_unit(void);
	inline void time_unit(time_unit_enum value);

};

/**************** Stereo Output ****************/

class Stereo3dFormat : public Pointer {
public:
	Stereo3dFormat(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	enum display_mode_enum {
		display_mode_ANAGLYPH = 0,
		display_mode_INTERLACE = 1,
		display_mode_SIDEBYSIDE = 3,
		display_mode_TOPBOTTOM = 4,
	};
	inline display_mode_enum display_mode(void);
	inline void display_mode(display_mode_enum value);
	enum anaglyph_type_enum {
		anaglyph_type_RED_CYAN = 0,
		anaglyph_type_GREEN_MAGENTA = 1,
		anaglyph_type_YELLOW_BLUE = 2,
	};
	inline anaglyph_type_enum anaglyph_type(void);
	inline void anaglyph_type(anaglyph_type_enum value);
	enum interlace_type_enum {
		interlace_type_ROW_INTERLEAVED = 0,
		interlace_type_COLUMN_INTERLEAVED = 1,
		interlace_type_CHECKERBOARD_INTERLEAVED = 2,
	};
	inline interlace_type_enum interlace_type(void);
	inline void interlace_type(interlace_type_enum value);
	inline bool use_interlace_swap(void);
	inline void use_interlace_swap(bool value);
	inline bool use_sidebyside_crosseyed(void);
	inline void use_sidebyside_crosseyed(bool value);
	inline bool use_squeezed_frame(void);
	inline void use_squeezed_frame(bool value);

};

/**************** Image Format ****************/

class ImageFormatSettings : public Pointer {
public:
	ImageFormatSettings(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	enum file_format_enum {
		file_format_BMP = 20,
		file_format_IRIS = 1,
		file_format_PNG = 17,
		file_format_JPEG = 4,
		file_format_JPEG2000 = 30,
		file_format_TARGA = 0,
		file_format_TARGA_RAW = 14,
		file_format_CINEON = 26,
		file_format_DPX = 27,
		file_format_OPEN_EXR_MULTILAYER = 28,
		file_format_OPEN_EXR = 23,
		file_format_HDR = 21,
		file_format_TIFF = 22,
		file_format_AVI_JPEG = 16,
		file_format_AVI_RAW = 15,
		file_format_FFMPEG = 24,
	};
	inline file_format_enum file_format(void);
	inline void file_format(file_format_enum value);
	enum color_mode_enum {
		color_mode_BW = 8,
		color_mode_RGB = 24,
		color_mode_RGBA = 32,
	};
	inline color_mode_enum color_mode(void);
	inline void color_mode(color_mode_enum value);
	enum color_depth_enum {
		color_depth_8 = 2,
		color_depth_10 = 4,
		color_depth_12 = 8,
		color_depth_16 = 16,
		color_depth_32 = 64,
	};
	inline color_depth_enum color_depth(void);
	inline void color_depth(color_depth_enum value);
	inline int quality(void);
	inline void quality(int value);
	inline int compression(void);
	inline void compression(int value);
	inline bool use_zbuffer(void);
	inline void use_zbuffer(bool value);
	inline bool use_preview(void);
	inline void use_preview(bool value);
	enum exr_codec_enum {
		exr_codec_NONE = 0,
		exr_codec_PXR24 = 1,
		exr_codec_ZIP = 2,
		exr_codec_PIZ = 3,
		exr_codec_RLE = 4,
		exr_codec_ZIPS = 5,
		exr_codec_B44 = 6,
		exr_codec_B44A = 7,
		exr_codec_DWAA = 8,
	};
	inline exr_codec_enum exr_codec(void);
	inline void exr_codec(exr_codec_enum value);
	inline bool use_jpeg2k_ycc(void);
	inline void use_jpeg2k_ycc(bool value);
	inline bool use_jpeg2k_cinema_preset(void);
	inline void use_jpeg2k_cinema_preset(bool value);
	inline bool use_jpeg2k_cinema_48(void);
	inline void use_jpeg2k_cinema_48(bool value);
	enum jpeg2k_codec_enum {
		jpeg2k_codec_JP2 = 0,
		jpeg2k_codec_J2K = 1,
	};
	inline jpeg2k_codec_enum jpeg2k_codec(void);
	inline void jpeg2k_codec(jpeg2k_codec_enum value);
	enum tiff_codec_enum {
		tiff_codec_NONE = 3,
		tiff_codec_DEFLATE = 0,
		tiff_codec_LZW = 1,
		tiff_codec_PACKBITS = 2,
	};
	inline tiff_codec_enum tiff_codec(void);
	inline void tiff_codec(tiff_codec_enum value);
	inline bool use_cineon_log(void);
	inline void use_cineon_log(bool value);
	inline int cineon_black(void);
	inline void cineon_black(int value);
	inline int cineon_white(void);
	inline void cineon_white(int value);
	inline float cineon_gamma(void);
	inline void cineon_gamma(float value);
	enum views_format_enum {
		views_format_INDIVIDUAL = 0,
		views_format_STEREO_3D = 1,
	};
	inline views_format_enum views_format(void);
	inline void views_format(views_format_enum value);
	inline Stereo3dFormat stereo_3d_format(void);
	inline ColorManagedViewSettings view_settings(void);
	inline ColorManagedDisplaySettings display_settings(void);

};

/**************** TransformOrientation ****************/

class TransformOrientation : public Pointer {
public:
	TransformOrientation(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline Array<float, 9> matrix(void);
	inline void matrix(float values[9]);
	inline std::string name(void);
	inline void name(const std::string& value);

};

/**************** Orientation Slot ****************/

class TransformOrientationSlot : public Pointer {
public:
	TransformOrientationSlot(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	enum type_enum {
		type_GLOBAL = 0,
		type_LOCAL = 1,
		type_NORMAL = 2,
		type_GIMBAL = 4,
		type_VIEW = 3,
		type_CURSOR = 5,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	inline TransformOrientation custom_orientation(void);
	inline bool use(void);
	inline void use(bool value);

};

/**************** 3D Cursor ****************/

class View3DCursor : public Pointer {
public:
	View3DCursor(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline Array<float, 3> location(void);
	inline void location(float values[3]);
	inline Array<float, 4> rotation_quaternion(void);
	inline void rotation_quaternion(float values[4]);
	inline Array<float, 4> rotation_axis_angle(void);
	inline void rotation_axis_angle(float values[4]);
	inline Array<float, 3> rotation_euler(void);
	inline void rotation_euler(float values[3]);
	enum rotation_mode_enum {
		rotation_mode_QUATERNION = 0,
		rotation_mode_XYZ = 1,
		rotation_mode_XZY = 2,
		rotation_mode_YXZ = 3,
		rotation_mode_YZX = 4,
		rotation_mode_ZXY = 5,
		rotation_mode_ZYX = 6,
		rotation_mode_AXIS_ANGLE = -1,
	};
	inline rotation_mode_enum rotation_mode(void);
	inline void rotation_mode(rotation_mode_enum value);

};

/**************** Selected UV Element ****************/

class SelectedUvElement : public PropertyGroup {
public:
	SelectedUvElement(const PointerRNA &ptr_arg) :
		PropertyGroup(ptr_arg)
		{}


};

/**************** Safe Areas ****************/

class DisplaySafeAreas : public Pointer {
public:
	DisplaySafeAreas(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline Array<float, 2> title(void);
	inline void title(float values[2]);
	inline Array<float, 2> action(void);
	inline void action(float values[2]);
	inline Array<float, 2> title_center(void);
	inline void title_center(float values[2]);
	inline Array<float, 2> action_center(void);
	inline void action_center(float values[2]);

};

/**************** Scene Display ****************/

class SceneDisplay : public Pointer {
public:
	SceneDisplay(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline Array<float, 3> light_direction(void);
	inline void light_direction(float values[3]);
	inline float shadow_shift(void);
	inline void shadow_shift(float value);
	inline float shadow_focus(void);
	inline void shadow_focus(float value);
	inline float matcap_ssao_distance(void);
	inline void matcap_ssao_distance(float value);
	inline float matcap_ssao_attenuation(void);
	inline void matcap_ssao_attenuation(float value);
	inline int matcap_ssao_samples(void);
	inline void matcap_ssao_samples(int value);
	inline View3DShading shading(void);

};

/**************** Scene Display ****************/

class SceneEEVEE : public Pointer {
public:
	SceneEEVEE(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline int gi_diffuse_bounces(void);
	inline void gi_diffuse_bounces(int value);
	enum gi_cubemap_resolution_enum {
		gi_cubemap_resolution_64 = 64,
		gi_cubemap_resolution_128 = 128,
		gi_cubemap_resolution_256 = 256,
		gi_cubemap_resolution_512 = 512,
		gi_cubemap_resolution_1024 = 1024,
		gi_cubemap_resolution_2048 = 2048,
		gi_cubemap_resolution_4096 = 4096,
	};
	inline gi_cubemap_resolution_enum gi_cubemap_resolution(void);
	inline void gi_cubemap_resolution(gi_cubemap_resolution_enum value);
	enum gi_visibility_resolution_enum {
		gi_visibility_resolution_8 = 8,
		gi_visibility_resolution_16 = 16,
		gi_visibility_resolution_32 = 32,
		gi_visibility_resolution_64 = 64,
	};
	inline gi_visibility_resolution_enum gi_visibility_resolution(void);
	inline void gi_visibility_resolution(gi_visibility_resolution_enum value);
	inline float gi_irradiance_smoothing(void);
	inline void gi_irradiance_smoothing(float value);
	inline float gi_glossy_clamp(void);
	inline void gi_glossy_clamp(float value);
	inline float gi_filter_quality(void);
	inline void gi_filter_quality(float value);
	inline bool gi_show_irradiance(void);
	inline void gi_show_irradiance(bool value);
	inline bool gi_show_cubemaps(void);
	inline void gi_show_cubemaps(bool value);
	inline float gi_irradiance_display_size(void);
	inline void gi_irradiance_display_size(float value);
	inline float gi_cubemap_display_size(void);
	inline void gi_cubemap_display_size(float value);
	inline bool gi_auto_bake(void);
	inline void gi_auto_bake(bool value);
	inline std::string gi_cache_info(void);
	inline void gi_cache_info(const std::string& value);
	inline int taa_samples(void);
	inline void taa_samples(int value);
	inline int taa_render_samples(void);
	inline void taa_render_samples(int value);
	inline bool use_taa_reprojection(void);
	inline void use_taa_reprojection(bool value);
	inline bool use_sss(void);
	inline void use_sss(bool value);
	inline int sss_samples(void);
	inline void sss_samples(int value);
	inline float sss_jitter_threshold(void);
	inline void sss_jitter_threshold(float value);
	inline bool use_sss_separate_albedo(void);
	inline void use_sss_separate_albedo(bool value);
	inline bool use_ssr(void);
	inline void use_ssr(bool value);
	inline bool use_ssr_refraction(void);
	inline void use_ssr_refraction(bool value);
	inline bool use_ssr_halfres(void);
	inline void use_ssr_halfres(bool value);
	inline float ssr_quality(void);
	inline void ssr_quality(float value);
	inline float ssr_max_roughness(void);
	inline void ssr_max_roughness(float value);
	inline float ssr_thickness(void);
	inline void ssr_thickness(float value);
	inline float ssr_border_fade(void);
	inline void ssr_border_fade(float value);
	inline float ssr_firefly_fac(void);
	inline void ssr_firefly_fac(float value);
	inline bool use_volumetric(void);
	inline void use_volumetric(bool value);
	inline float volumetric_start(void);
	inline void volumetric_start(float value);
	inline float volumetric_end(void);
	inline void volumetric_end(float value);
	enum volumetric_tile_size_enum {
		volumetric_tile_size_2 = 2,
		volumetric_tile_size_4 = 4,
		volumetric_tile_size_8 = 8,
		volumetric_tile_size_16 = 16,
	};
	inline volumetric_tile_size_enum volumetric_tile_size(void);
	inline void volumetric_tile_size(volumetric_tile_size_enum value);
	inline int volumetric_samples(void);
	inline void volumetric_samples(int value);
	inline float volumetric_sample_distribution(void);
	inline void volumetric_sample_distribution(float value);
	inline bool use_volumetric_lights(void);
	inline void use_volumetric_lights(bool value);
	inline float volumetric_light_clamp(void);
	inline void volumetric_light_clamp(float value);
	inline bool use_volumetric_shadows(void);
	inline void use_volumetric_shadows(bool value);
	inline int volumetric_shadow_samples(void);
	inline void volumetric_shadow_samples(int value);
	inline bool use_gtao(void);
	inline void use_gtao(bool value);
	inline bool use_gtao_bent_normals(void);
	inline void use_gtao_bent_normals(bool value);
	inline bool use_gtao_bounce(void);
	inline void use_gtao_bounce(bool value);
	inline float gtao_factor(void);
	inline void gtao_factor(float value);
	inline float gtao_quality(void);
	inline void gtao_quality(float value);
	inline float gtao_distance(void);
	inline void gtao_distance(float value);
	inline bool use_dof(void);
	inline void use_dof(bool value);
	inline float bokeh_max_size(void);
	inline void bokeh_max_size(float value);
	inline float bokeh_threshold(void);
	inline void bokeh_threshold(float value);
	inline bool use_bloom(void);
	inline void use_bloom(bool value);
	inline float bloom_threshold(void);
	inline void bloom_threshold(float value);
	inline Array<float, 3> bloom_color(void);
	inline void bloom_color(float values[3]);
	inline float bloom_knee(void);
	inline void bloom_knee(float value);
	inline float bloom_radius(void);
	inline void bloom_radius(float value);
	inline float bloom_clamp(void);
	inline void bloom_clamp(float value);
	inline float bloom_intensity(void);
	inline void bloom_intensity(float value);
	inline bool use_motion_blur(void);
	inline void use_motion_blur(bool value);
	inline int motion_blur_samples(void);
	inline void motion_blur_samples(int value);
	inline float motion_blur_shutter(void);
	inline void motion_blur_shutter(float value);
	enum shadow_method_enum {
		shadow_method_ESM = 1,
		shadow_method_VSM = 2,
	};
	inline shadow_method_enum shadow_method(void);
	inline void shadow_method(shadow_method_enum value);
	enum shadow_cube_size_enum {
		shadow_cube_size_64 = 64,
		shadow_cube_size_128 = 128,
		shadow_cube_size_256 = 256,
		shadow_cube_size_512 = 512,
		shadow_cube_size_1024 = 1024,
		shadow_cube_size_2048 = 2048,
		shadow_cube_size_4096 = 4096,
	};
	inline shadow_cube_size_enum shadow_cube_size(void);
	inline void shadow_cube_size(shadow_cube_size_enum value);
	enum shadow_cascade_size_enum {
		shadow_cascade_size_64 = 64,
		shadow_cascade_size_128 = 128,
		shadow_cascade_size_256 = 256,
		shadow_cascade_size_512 = 512,
		shadow_cascade_size_1024 = 1024,
		shadow_cascade_size_2048 = 2048,
		shadow_cascade_size_4096 = 4096,
	};
	inline shadow_cascade_size_enum shadow_cascade_size(void);
	inline void shadow_cascade_size(shadow_cascade_size_enum value);
	inline bool use_shadow_high_bitdepth(void);
	inline void use_shadow_high_bitdepth(bool value);
	inline bool use_soft_shadows(void);
	inline void use_soft_shadows(bool value);
	inline float light_threshold(void);
	inline void light_threshold(float value);
	inline bool use_overscan(void);
	inline void use_overscan(bool value);
	inline float overscan_size(void);
	inline void overscan_size(float value);

};

/**************** FFmpeg Settings ****************/

class FFmpegSettings : public Pointer {
public:
	FFmpegSettings(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	enum format_enum {
		format_MPEG1 = 0,
		format_MPEG2 = 1,
		format_MPEG4 = 2,
		format_AVI = 3,
		format_QUICKTIME = 4,
		format_DV = 5,
		format_OGG = 10,
		format_MKV = 9,
		format_FLASH = 8,
	};
	inline format_enum format(void);
	inline void format(format_enum value);
	enum codec_enum {
		codec_NONE = 0,
		codec_DNXHD = 99,
		codec_DV = 24,
		codec_FFV1 = 33,
		codec_FLASH = 21,
		codec_H264 = 27,
		codec_HUFFYUV = 25,
		codec_MPEG1 = 1,
		codec_MPEG2 = 2,
		codec_MPEG4 = 12,
		codec_PNG = 61,
		codec_QTRLE = 55,
		codec_THEORA = 30,
		codec_WEBM = 167,
	};
	inline codec_enum codec(void);
	inline void codec(codec_enum value);
	inline int video_bitrate(void);
	inline void video_bitrate(int value);
	inline int minrate(void);
	inline void minrate(int value);
	inline int maxrate(void);
	inline void maxrate(int value);
	inline int muxrate(void);
	inline void muxrate(int value);
	inline int gopsize(void);
	inline void gopsize(int value);
	inline int max_b_frames(void);
	inline void max_b_frames(int value);
	inline bool use_max_b_frames(void);
	inline void use_max_b_frames(bool value);
	inline int buffersize(void);
	inline void buffersize(int value);
	inline int packetsize(void);
	inline void packetsize(int value);
	enum constant_rate_factor_enum {
		constant_rate_factor_NONE = -1,
		constant_rate_factor_LOSSLESS = 0,
		constant_rate_factor_PERC_LOSSLESS = 17,
		constant_rate_factor_HIGH = 20,
		constant_rate_factor_MEDIUM = 23,
		constant_rate_factor_LOW = 26,
		constant_rate_factor_VERYLOW = 29,
		constant_rate_factor_LOWEST = 32,
	};
	inline constant_rate_factor_enum constant_rate_factor(void);
	inline void constant_rate_factor(constant_rate_factor_enum value);
	enum ffmpeg_preset_enum {
		ffmpeg_preset_BEST = 11,
		ffmpeg_preset_GOOD = 10,
		ffmpeg_preset_REALTIME = 12,
	};
	inline ffmpeg_preset_enum ffmpeg_preset(void);
	inline void ffmpeg_preset(ffmpeg_preset_enum value);
	inline bool use_autosplit(void);
	inline void use_autosplit(bool value);
	inline bool use_lossless_output(void);
	inline void use_lossless_output(bool value);
	enum audio_codec_enum {
		audio_codec_NONE = 0,
		audio_codec_AAC = 86018,
		audio_codec_AC3 = 86019,
		audio_codec_FLAC = 86028,
		audio_codec_MP2 = 86016,
		audio_codec_MP3 = 86017,
		audio_codec_PCM = 65536,
		audio_codec_VORBIS = 86021,
	};
	inline audio_codec_enum audio_codec(void);
	inline void audio_codec(audio_codec_enum value);
	inline int audio_bitrate(void);
	inline void audio_bitrate(int value);
	inline float audio_volume(void);
	inline void audio_volume(float value);
	inline int audio_mixrate(void);
	inline void audio_mixrate(int value);
	enum audio_channels_enum {
		audio_channels_MONO = 1,
		audio_channels_STEREO = 2,
		audio_channels_SURROUND4 = 4,
		audio_channels_SURROUND51 = 6,
		audio_channels_SURROUND71 = 8,
	};
	inline audio_channels_enum audio_channels(void);
	inline void audio_channels(audio_channels_enum value);

};

/**************** Render Data ****************/

class RenderSettings : public Pointer {
public:
	RenderSettings(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		views(ptr_arg),
		stereo_views(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline ImageFormatSettings image_settings(void);
	inline int resolution_x(void);
	inline void resolution_x(int value);
	inline int resolution_y(void);
	inline void resolution_y(int value);
	inline int resolution_percentage(void);
	inline void resolution_percentage(int value);
	inline int tile_x(void);
	inline void tile_x(int value);
	inline int tile_y(void);
	inline void tile_y(int value);
	inline int preview_start_resolution(void);
	inline void preview_start_resolution(int value);
	enum preview_pixel_size_enum {
		preview_pixel_size_AUTO = 0,
		preview_pixel_size_1 = 1,
		preview_pixel_size_2 = 2,
		preview_pixel_size_4 = 4,
		preview_pixel_size_8 = 8,
	};
	inline preview_pixel_size_enum preview_pixel_size(void);
	inline void preview_pixel_size(preview_pixel_size_enum value);
	inline float pixel_aspect_x(void);
	inline void pixel_aspect_x(float value);
	inline float pixel_aspect_y(void);
	inline void pixel_aspect_y(float value);
	inline FFmpegSettings ffmpeg(void);
	inline int fps(void);
	inline void fps(int value);
	inline float fps_base(void);
	inline void fps_base(float value);
	inline int frame_map_old(void);
	inline void frame_map_old(int value);
	inline int frame_map_new(void);
	inline void frame_map_new(int value);
	inline float dither_intensity(void);
	inline void dither_intensity(float value);
	inline float filter_size(void);
	inline void filter_size(float value);
	enum alpha_mode_enum {
		alpha_mode_SKY = 0,
		alpha_mode_TRANSPARENT = 1,
	};
	inline alpha_mode_enum alpha_mode(void);
	inline void alpha_mode(alpha_mode_enum value);
	inline bool use_antialiasing(void);
	inline void use_antialiasing(bool value);
	enum antialiasing_samples_enum {
		antialiasing_samples_5 = 5,
		antialiasing_samples_8 = 8,
		antialiasing_samples_11 = 11,
		antialiasing_samples_16 = 16,
	};
	inline antialiasing_samples_enum antialiasing_samples(void);
	inline void antialiasing_samples(antialiasing_samples_enum value);
	inline bool use_freestyle(void);
	inline void use_freestyle(bool value);
	inline int threads(void);
	inline void threads(int value);
	enum threads_mode_enum {
		threads_mode_AUTO = 0,
		threads_mode_FIXED = 524288,
	};
	inline threads_mode_enum threads_mode(void);
	inline void threads_mode(threads_mode_enum value);
	inline bool use_motion_blur(void);
	inline void use_motion_blur(bool value);
	inline float motion_blur_shutter(void);
	inline void motion_blur_shutter(float value);
	inline CurveMapping motion_blur_shutter_curve(void);
	enum hair_type_enum {
		hair_type_STRAND = 0,
		hair_type_STRIP = 1,
	};
	inline hair_type_enum hair_type(void);
	inline void hair_type(hair_type_enum value);
	inline int hair_subdiv(void);
	inline void hair_subdiv(int value);
	inline bool use_border(void);
	inline void use_border(bool value);
	inline float border_min_x(void);
	inline void border_min_x(float value);
	inline float border_min_y(void);
	inline void border_min_y(float value);
	inline float border_max_x(void);
	inline void border_max_x(float value);
	inline float border_max_y(void);
	inline void border_max_y(float value);
	inline bool use_crop_to_border(void);
	inline void use_crop_to_border(bool value);
	inline bool use_placeholder(void);
	inline void use_placeholder(bool value);
	inline bool use_overwrite(void);
	inline void use_overwrite(bool value);
	inline bool use_compositing(void);
	inline void use_compositing(bool value);
	inline bool use_sequencer(void);
	inline void use_sequencer(bool value);
	inline bool use_file_extension(void);
	inline void use_file_extension(bool value);
	inline std::string file_extension(void);
	inline void file_extension(const std::string& value);
	inline bool is_movie_format(void);
	inline void is_movie_format(bool value);
	inline bool use_save_buffers(void);
	inline void use_save_buffers(bool value);
	inline bool use_full_sample(void);
	inline void use_full_sample(bool value);
	enum display_mode_enum {
		display_mode_SCREEN = 0,
		display_mode_AREA = 1,
		display_mode_WINDOW = 2,
		display_mode_NONE = 3,
	};
	inline display_mode_enum display_mode(void);
	inline void display_mode(display_mode_enum value);
	inline bool use_lock_interface(void);
	inline void use_lock_interface(bool value);
	inline std::string filepath(void);
	inline void filepath(const std::string& value);
	inline bool use_render_cache(void);
	inline void use_render_cache(bool value);
	enum bake_type_enum {
		bake_type_NORMALS = 0,
		bake_type_DISPLACEMENT = 1,
	};
	inline bake_type_enum bake_type(void);
	inline void bake_type(bake_type_enum value);
	inline bool use_bake_selected_to_active(void);
	inline void use_bake_selected_to_active(bool value);
	inline bool use_bake_clear(void);
	inline void use_bake_clear(bool value);
	inline int bake_margin(void);
	inline void bake_margin(int value);
	inline float bake_bias(void);
	inline void bake_bias(float value);
	inline bool use_bake_multires(void);
	inline void use_bake_multires(bool value);
	inline bool use_bake_lores_mesh(void);
	inline void use_bake_lores_mesh(bool value);
	inline int bake_samples(void);
	inline void bake_samples(int value);
	inline bool use_bake_user_scale(void);
	inline void use_bake_user_scale(bool value);
	inline float bake_user_scale(void);
	inline void bake_user_scale(float value);
	inline bool use_stamp_time(void);
	inline void use_stamp_time(bool value);
	inline bool use_stamp_date(void);
	inline void use_stamp_date(bool value);
	inline bool use_stamp_frame(void);
	inline void use_stamp_frame(bool value);
	inline bool use_stamp_frame_range(void);
	inline void use_stamp_frame_range(bool value);
	inline bool use_stamp_camera(void);
	inline void use_stamp_camera(bool value);
	inline bool use_stamp_lens(void);
	inline void use_stamp_lens(bool value);
	inline bool use_stamp_scene(void);
	inline void use_stamp_scene(bool value);
	inline bool use_stamp_note(void);
	inline void use_stamp_note(bool value);
	inline bool use_stamp_marker(void);
	inline void use_stamp_marker(bool value);
	inline bool use_stamp_filename(void);
	inline void use_stamp_filename(bool value);
	inline bool use_stamp_sequencer_strip(void);
	inline void use_stamp_sequencer_strip(bool value);
	inline bool use_stamp_render_time(void);
	inline void use_stamp_render_time(bool value);
	inline std::string stamp_note_text(void);
	inline void stamp_note_text(const std::string& value);
	inline bool use_stamp(void);
	inline void use_stamp(bool value);
	inline bool use_stamp_labels(void);
	inline void use_stamp_labels(bool value);
	inline bool use_stamp_strip_meta(void);
	inline void use_stamp_strip_meta(bool value);
	inline bool use_stamp_memory(void);
	inline void use_stamp_memory(bool value);
	inline bool use_stamp_hostname(void);
	inline void use_stamp_hostname(bool value);
	inline int stamp_font_size(void);
	inline void stamp_font_size(int value);
	inline Array<float, 4> stamp_foreground(void);
	inline void stamp_foreground(float values[4]);
	inline Array<float, 4> stamp_background(void);
	inline void stamp_background(float values[4]);
	enum sequencer_gl_preview_enum {
		sequencer_gl_preview_WIREFRAME = 2,
		sequencer_gl_preview_SOLID = 3,
		sequencer_gl_preview_MATERIAL = 4,
		sequencer_gl_preview_RENDERED = 6,
	};
	inline sequencer_gl_preview_enum sequencer_gl_preview(void);
	inline void sequencer_gl_preview(sequencer_gl_preview_enum value);
	inline bool use_sequencer_gl_textured_solid(void);
	inline void use_sequencer_gl_textured_solid(bool value);
	inline bool use_sequencer_gl_dof(void);
	inline void use_sequencer_gl_dof(bool value);
	inline bool use_single_layer(void);
	inline void use_single_layer(bool value);
	COLLECTION_PROPERTY(RenderViews, SceneRenderView, RenderSettings, views, false, true, true)
	COLLECTION_PROPERTY(DefaultCollectionFunctions, SceneRenderView, RenderSettings, stereo_views, false, true, true)
	inline bool use_multiview(void);
	inline void use_multiview(bool value);
	enum views_format_enum {
		views_format_STEREO_3D = 0,
		views_format_MULTIVIEW = 1,
	};
	inline views_format_enum views_format(void);
	inline void views_format(views_format_enum value);
	enum engine_enum {
		engine_BLENDER_EEVEE = 0,
	};
	inline engine_enum engine(void);
	inline void engine(engine_enum value);
	inline bool has_multiple_engines(void);
	inline void has_multiple_engines(bool value);
	inline bool use_spherical_stereo(void);
	inline void use_spherical_stereo(bool value);
	inline bool use_simplify(void);
	inline void use_simplify(bool value);
	inline int simplify_subdivision(void);
	inline void simplify_subdivision(int value);
	inline float simplify_child_particles(void);
	inline void simplify_child_particles(float value);
	inline int simplify_subdivision_render(void);
	inline void simplify_subdivision_render(int value);
	inline float simplify_child_particles_render(void);
	inline void simplify_child_particles_render(float value);
	inline bool use_simplify_smoke_highres(void);
	inline void use_simplify_smoke_highres(bool value);
	inline bool simplify_gpencil(void);
	inline void simplify_gpencil(bool value);
	inline bool simplify_gpencil_onplay(void);
	inline void simplify_gpencil_onplay(bool value);
	inline bool simplify_gpencil_view_fill(void);
	inline void simplify_gpencil_view_fill(bool value);
	inline bool simplify_gpencil_remove_lines(void);
	inline void simplify_gpencil_remove_lines(bool value);
	inline bool simplify_gpencil_view_modifier(void);
	inline void simplify_gpencil_view_modifier(bool value);
	inline bool simplify_gpencil_shader_fx(void);
	inline void simplify_gpencil_shader_fx(bool value);
	inline bool simplify_gpencil_blend(void);
	inline void simplify_gpencil_blend(bool value);
	inline bool use_persistent_data(void);
	inline void use_persistent_data(bool value);
	enum line_thickness_mode_enum {
		line_thickness_mode_ABSOLUTE = 1,
		line_thickness_mode_RELATIVE = 2,
	};
	inline line_thickness_mode_enum line_thickness_mode(void);
	inline void line_thickness_mode(line_thickness_mode_enum value);
	inline float line_thickness(void);
	inline void line_thickness(float value);
	inline BakeSettings bake(void);

	inline void frame_path(void *main, int frame, bool preview, const char * view, char * filepath);
};

/**************** Bake Data ****************/

class BakeSettings : public Pointer {
public:
	BakeSettings(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline Object cage_object(void);
	inline std::string filepath(void);
	inline void filepath(const std::string& value);
	inline int width(void);
	inline void width(int value);
	inline int height(void);
	inline void height(int value);
	inline int margin(void);
	inline void margin(int value);
	inline float cage_extrusion(void);
	inline void cage_extrusion(float value);
	enum normal_space_enum {
		normal_space_OBJECT = 2,
		normal_space_TANGENT = 3,
	};
	inline normal_space_enum normal_space(void);
	inline void normal_space(normal_space_enum value);
	enum normal_r_enum {
		normal_r_POS_X = 0,
		normal_r_POS_Y = 1,
		normal_r_POS_Z = 2,
		normal_r_NEG_X = 3,
		normal_r_NEG_Y = 4,
		normal_r_NEG_Z = 5,
	};
	inline normal_r_enum normal_r(void);
	inline void normal_r(normal_r_enum value);
	enum normal_g_enum {
		normal_g_POS_X = 0,
		normal_g_POS_Y = 1,
		normal_g_POS_Z = 2,
		normal_g_NEG_X = 3,
		normal_g_NEG_Y = 4,
		normal_g_NEG_Z = 5,
	};
	inline normal_g_enum normal_g(void);
	inline void normal_g(normal_g_enum value);
	enum normal_b_enum {
		normal_b_POS_X = 0,
		normal_b_POS_Y = 1,
		normal_b_POS_Z = 2,
		normal_b_NEG_X = 3,
		normal_b_NEG_Y = 4,
		normal_b_NEG_Z = 5,
	};
	inline normal_b_enum normal_b(void);
	inline void normal_b(normal_b_enum value);
	inline ImageFormatSettings image_settings(void);
	enum save_mode_enum {
		save_mode_INTERNAL = 0,
		save_mode_EXTERNAL = 1,
	};
	inline save_mode_enum save_mode(void);
	inline void save_mode(save_mode_enum value);
	inline bool use_selected_to_active(void);
	inline void use_selected_to_active(bool value);
	inline bool use_clear(void);
	inline void use_clear(bool value);
	inline bool use_split_materials(void);
	inline void use_split_materials(bool value);
	inline bool use_automatic_name(void);
	inline void use_automatic_name(bool value);
	inline bool use_cage(void);
	inline void use_cage(bool value);
	inline bool use_pass_ambient_occlusion(void);
	inline void use_pass_ambient_occlusion(bool value);
	inline bool use_pass_emit(void);
	inline void use_pass_emit(bool value);
	inline bool use_pass_direct(void);
	inline void use_pass_direct(bool value);
	inline bool use_pass_indirect(void);
	inline void use_pass_indirect(bool value);
	inline bool use_pass_color(void);
	inline void use_pass_color(bool value);
	inline bool use_pass_diffuse(void);
	inline void use_pass_diffuse(bool value);
	inline bool use_pass_glossy(void);
	inline void use_pass_glossy(bool value);
	inline bool use_pass_transmission(void);
	inline void use_pass_transmission(bool value);
	inline bool use_pass_subsurface(void);
	inline void use_pass_subsurface(bool value);
	enum pass_filter_enum {
		pass_filter_NONE = 0,
		pass_filter_AO = 1,
		pass_filter_EMIT = 2,
		pass_filter_DIRECT = 64,
		pass_filter_INDIRECT = 128,
		pass_filter_COLOR = 256,
		pass_filter_DIFFUSE = 4,
		pass_filter_GLOSSY = 8,
		pass_filter_TRANSMISSION = 16,
		pass_filter_SUBSURFACE = 32,
	};
	inline pass_filter_enum pass_filter(void);
	inline void pass_filter(pass_filter_enum value);

};

/**************** GPU SSAO ****************/

class GPUSSAOSettings : public Pointer {
public:
	GPUSSAOSettings(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline float factor(void);
	inline void factor(float value);
	inline float distance_max(void);
	inline void distance_max(float value);
	inline float attenuation(void);
	inline void attenuation(float value);
	inline int samples(void);
	inline void samples(int value);
	inline Array<float, 3> color(void);
	inline void color(float values[3]);

};

/**************** GPU DOF ****************/

class GPUDOFSettings : public Pointer {
public:
	GPUDOFSettings(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline float focus_distance(void);
	inline void focus_distance(float value);
	inline float focal_length(void);
	inline void focal_length(float value);
	inline float sensor(void);
	inline void sensor(float value);
	inline float fstop(void);
	inline void fstop(float value);
	inline int blades(void);
	inline void blades(int value);
	inline float rotation(void);
	inline void rotation(float value);
	inline float ratio(void);
	inline void ratio(float value);

};

/**************** GPU FX Settings ****************/

class GPUFXSettings : public Pointer {
public:
	GPUFXSettings(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline GPUDOFSettings dof(void);
	inline bool use_dof(void);
	inline void use_dof(bool value);
	inline GPUSSAOSettings ssao(void);
	inline bool use_ssao(void);
	inline void use_ssao(bool value);

};

/**************** Scene Render View ****************/

class SceneRenderView : public Pointer {
public:
	SceneRenderView(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string name(void);
	inline void name(const std::string& value);
	inline std::string file_suffix(void);
	inline void file_suffix(const std::string& value);
	inline std::string camera_suffix(void);
	inline void camera_suffix(const std::string& value);
	inline bool use(void);
	inline void use(bool value);

};

/**************** Screen ****************/

class Screen : public ID {
public:
	Screen(const PointerRNA &ptr_arg) :
		ID(ptr_arg),
		areas(ptr_arg)
		{}

	COLLECTION_PROPERTY(DefaultCollectionFunctions, Area, Screen, areas, false, true, false)
	inline bool is_animation_playing(void);
	inline void is_animation_playing(bool value);
	inline bool show_fullscreen(void);
	inline void show_fullscreen(bool value);
	inline bool show_topbar(void);
	inline void show_topbar(bool value);
	inline bool show_statusbar(void);
	inline void show_statusbar(bool value);
	inline bool use_play_top_left_3d_editor(void);
	inline void use_play_top_left_3d_editor(bool value);
	inline bool use_play_3d_editors(void);
	inline void use_play_3d_editors(bool value);
	inline bool use_follow(void);
	inline void use_follow(bool value);
	inline bool use_play_animation_editors(void);
	inline void use_play_animation_editors(bool value);
	inline bool use_play_properties_editors(void);
	inline void use_play_properties_editors(bool value);
	inline bool use_play_image_editors(void);
	inline void use_play_image_editors(bool value);
	inline bool use_play_sequence_editors(void);
	inline void use_play_sequence_editors(bool value);
	inline bool use_play_node_editors(void);
	inline void use_play_node_editors(bool value);
	inline bool use_play_clip_editors(void);
	inline void use_play_clip_editors(bool value);

};

/**************** Area ****************/

class Area : public Pointer {
public:
	Area(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		spaces(ptr_arg),
		regions(ptr_arg)
		{}

	inline Struct rna_type(void);
	COLLECTION_PROPERTY(AreaSpaces, Space, Area, spaces, false, true, false)
	COLLECTION_PROPERTY(DefaultCollectionFunctions, Region, Area, regions, false, true, false)
	inline bool show_menus(void);
	inline void show_menus(bool value);
	enum type_enum {
		type_EMPTY = 0,
		type_VIEW_3D = 1,
		type_IMAGE_EDITOR = 6,
		type_NODE_EDITOR = 16,
		type_SEQUENCE_EDITOR = 8,
		type_CLIP_EDITOR = 20,
		type_DOPESHEET_EDITOR = 12,
		type_GRAPH_EDITOR = 2,
		type_NLA_EDITOR = 13,
		type_TEXT_EDITOR = 9,
		type_CONSOLE = 18,
		type_INFO = 7,
		type_TOPBAR = 21,
		type_STATUSBAR = 22,
		type_OUTLINER = 3,
		type_PROPERTIES = 4,
		type_FILE_BROWSER = 5,
		type_PREFERENCES = 19,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	enum ui_type_enum {
	};
	inline ui_type_enum ui_type(void);
	inline void ui_type(ui_type_enum value);
	inline int x(void);
	inline void x(int value);
	inline int y(void);
	inline void y(int value);
	inline int width(void);
	inline void width(int value);
	inline int height(void);
	inline void height(int value);

	inline void tag_redraw();
	inline void header_text_set(const char * text);
};

/**************** Region ****************/

class Region : public Pointer {
public:
	Region(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	enum type_enum {
		type_WINDOW = 0,
		type_HEADER = 1,
		type_CHANNELS = 2,
		type_TEMPORARY = 3,
		type_UI = 4,
		type_TOOLS = 5,
		type_TOOL_PROPS = 6,
		type_PREVIEW = 7,
		type_HUD = 8,
		type_NAVIGATION_BAR = 9,
		type_EXECUTE = 10,
		type_FOOTER = 11,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	inline int x(void);
	inline void x(int value);
	inline int y(void);
	inline void y(int value);
	inline int width(void);
	inline void width(int value);
	inline int height(void);
	inline void height(int value);
	inline View2D view2d(void);
	enum alignment_enum {
		alignment_NONE = 0,
		alignment_TOP = 1,
		alignment_BOTTOM = 2,
		alignment_LEFT = 3,
		alignment_RIGHT = 4,
		alignment_HORIZONTAL_SPLIT = 5,
		alignment_VERTICAL_SPLIT = 6,
		alignment_FLOAT = 7,
		alignment_QUAD_SPLIT = 8,
	};
	inline alignment_enum alignment(void);
	inline void alignment(alignment_enum value);

	inline void tag_redraw();
};

/**************** View2D ****************/

class View2D : public Pointer {
public:
	View2D(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline void region_to_view(int x, int y, float result[2]);
	inline void view_to_region(float x, float y, bool clip, int result[2]);
};

/**************** Paint Curve ****************/

class PaintCurve : public ID {
public:
	PaintCurve(const PointerRNA &ptr_arg) :
		ID(ptr_arg)
		{}


};

/**************** Paint Tool Slot ****************/

class PaintToolSlot : public Pointer {
public:
	PaintToolSlot(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline Brush brush(void);

};

/**************** Paint ****************/

class Paint : public Pointer {
public:
	Paint(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		tool_slots(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline Brush brush(void);
	COLLECTION_PROPERTY(DefaultCollectionFunctions, PaintToolSlot, Paint, tool_slots, true, true, false)
	inline Palette palette(void);
	inline bool show_brush(void);
	inline void show_brush(bool value);
	inline bool show_brush_on_surface(void);
	inline void show_brush_on_surface(bool value);
	inline bool show_low_resolution(void);
	inline void show_low_resolution(bool value);
	inline int input_samples(void);
	inline void input_samples(int value);
	inline bool use_symmetry_x(void);
	inline void use_symmetry_x(bool value);
	inline bool use_symmetry_y(void);
	inline void use_symmetry_y(bool value);
	inline bool use_symmetry_z(void);
	inline void use_symmetry_z(bool value);
	inline bool use_symmetry_feather(void);
	inline void use_symmetry_feather(bool value);
	inline CurveMapping cavity_curve(void);
	inline bool use_cavity(void);
	inline void use_cavity(bool value);
	inline Array<float, 3> tile_offset(void);
	inline void tile_offset(float values[3]);
	inline bool tile_x(void);
	inline void tile_x(bool value);
	inline bool tile_y(void);
	inline void tile_y(bool value);
	inline bool tile_z(void);
	inline void tile_z(bool value);

};

/**************** Sculpt ****************/

class Sculpt : public Paint {
public:
	Sculpt(const PointerRNA &ptr_arg) :
		Paint(ptr_arg)
		{}

	inline Array<int, 3> radial_symmetry(void);
	inline void radial_symmetry(int values[3]);
	inline bool lock_x(void);
	inline void lock_x(bool value);
	inline bool lock_y(void);
	inline void lock_y(bool value);
	inline bool lock_z(void);
	inline void lock_z(bool value);
	inline bool use_threaded(void);
	inline void use_threaded(bool value);
	inline bool use_deform_only(void);
	inline void use_deform_only(bool value);
	inline bool show_diffuse_color(void);
	inline void show_diffuse_color(bool value);
	inline bool show_mask(void);
	inline void show_mask(bool value);
	inline float detail_size(void);
	inline void detail_size(float value);
	inline float detail_percent(void);
	inline void detail_percent(float value);
	inline float constant_detail_resolution(void);
	inline void constant_detail_resolution(float value);
	inline bool use_smooth_shading(void);
	inline void use_smooth_shading(bool value);
	enum symmetrize_direction_enum {
		symmetrize_direction_NEGATIVE_X = 0,
		symmetrize_direction_POSITIVE_X = 3,
		symmetrize_direction_NEGATIVE_Y = 1,
		symmetrize_direction_POSITIVE_Y = 4,
		symmetrize_direction_NEGATIVE_Z = 2,
		symmetrize_direction_POSITIVE_Z = 5,
	};
	inline symmetrize_direction_enum symmetrize_direction(void);
	inline void symmetrize_direction(symmetrize_direction_enum value);
	enum detail_refine_method_enum {
		detail_refine_method_SUBDIVIDE = 4096,
		detail_refine_method_COLLAPSE = 2048,
		detail_refine_method_SUBDIVIDE_COLLAPSE = 6144,
	};
	inline detail_refine_method_enum detail_refine_method(void);
	inline void detail_refine_method(detail_refine_method_enum value);
	enum detail_type_method_enum {
		detail_type_method_RELATIVE = 0,
		detail_type_method_CONSTANT = 8192,
		detail_type_method_BRUSH = 16384,
		detail_type_method_MANUAL = 65536,
	};
	inline detail_type_method_enum detail_type_method(void);
	inline void detail_type_method(detail_type_method_enum value);
	inline float gravity(void);
	inline void gravity(float value);
	inline Object gravity_object(void);

};

/**************** UV Sculpting ****************/

class UvSculpt : public Paint {
public:
	UvSculpt(const PointerRNA &ptr_arg) :
		Paint(ptr_arg)
		{}


};

/**************** Grease Pencil Paint ****************/

class GpPaint : public Paint {
public:
	GpPaint(const PointerRNA &ptr_arg) :
		Paint(ptr_arg)
		{}


};

/**************** Vertex Paint ****************/

class VertexPaint : public Paint {
public:
	VertexPaint(const PointerRNA &ptr_arg) :
		Paint(ptr_arg)
		{}

	inline bool use_group_restrict(void);
	inline void use_group_restrict(bool value);
	inline Array<int, 3> radial_symmetry(void);
	inline void radial_symmetry(int values[3]);

};

/**************** Image Paint ****************/

class ImagePaint : public Paint {
public:
	ImagePaint(const PointerRNA &ptr_arg) :
		Paint(ptr_arg)
		{}

	inline bool use_occlude(void);
	inline void use_occlude(bool value);
	inline bool use_backface_culling(void);
	inline void use_backface_culling(bool value);
	inline bool use_normal_falloff(void);
	inline void use_normal_falloff(bool value);
	inline bool use_stencil_layer(void);
	inline void use_stencil_layer(bool value);
	inline bool invert_stencil(void);
	inline void invert_stencil(bool value);
	inline Image stencil_image(void);
	inline Image canvas(void);
	inline Image clone_image(void);
	inline Array<float, 3> stencil_color(void);
	inline void stencil_color(float values[3]);
	inline float dither(void);
	inline void dither(float value);
	inline bool use_clone_layer(void);
	inline void use_clone_layer(bool value);
	inline int seam_bleed(void);
	inline void seam_bleed(int value);
	inline int normal_angle(void);
	inline void normal_angle(int value);
	inline Array<int, 2> screen_grab_size(void);
	inline void screen_grab_size(int values[2]);
	enum mode_enum {
		mode_MATERIAL = 0,
		mode_IMAGE = 1,
	};
	inline mode_enum mode(void);
	inline void mode(mode_enum value);
	enum interpolation_enum {
		interpolation_LINEAR = 0,
		interpolation_CLOSEST = 1,
	};
	inline interpolation_enum interpolation(void);
	inline void interpolation(interpolation_enum value);
	inline bool missing_uvs(void);
	inline void missing_uvs(bool value);
	inline bool missing_materials(void);
	inline void missing_materials(bool value);
	inline bool missing_stencil(void);
	inline void missing_stencil(bool value);
	inline bool missing_texture(void);
	inline void missing_texture(bool value);

	inline bool detect_data();
};

/**************** Particle Edit ****************/

class ParticleEdit : public Pointer {
public:
	ParticleEdit(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	enum tool_enum {
		tool_COMB = 0,
		tool_SMOOTH = 5,
		tool_ADD = 4,
		tool_LENGTH = 2,
		tool_PUFF = 3,
		tool_CUT = 1,
		tool_WEIGHT = 6,
	};
	inline tool_enum tool(void);
	inline void tool(tool_enum value);
	enum select_mode_enum {
		select_mode_PATH = 1,
		select_mode_POINT = 2,
		select_mode_TIP = 4,
	};
	inline select_mode_enum select_mode(void);
	inline void select_mode(select_mode_enum value);
	inline bool use_preserve_length(void);
	inline void use_preserve_length(bool value);
	inline bool use_preserve_root(void);
	inline void use_preserve_root(bool value);
	inline bool use_emitter_deflect(void);
	inline void use_emitter_deflect(bool value);
	inline float emitter_distance(void);
	inline void emitter_distance(float value);
	inline bool use_fade_time(void);
	inline void use_fade_time(bool value);
	inline bool use_auto_velocity(void);
	inline void use_auto_velocity(bool value);
	inline bool show_particles(void);
	inline void show_particles(bool value);
	inline bool use_default_interpolate(void);
	inline void use_default_interpolate(bool value);
	inline int default_key_count(void);
	inline void default_key_count(int value);
	inline ParticleBrush brush(void);
	inline int display_step(void);
	inline void display_step(int value);
	inline int fade_frames(void);
	inline void fade_frames(int value);
	enum type_enum {
		type_PARTICLES = 0,
		type_SOFT_BODY = 1,
		type_CLOTH = 2,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	inline bool is_editable(void);
	inline void is_editable(bool value);
	inline bool is_hair(void);
	inline void is_hair(bool value);
	inline Object object(void);
	inline Object shape_object(void);

};

/**************** Particle Brush ****************/

class ParticleBrush : public Pointer {
public:
	ParticleBrush(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline int size(void);
	inline void size(int value);
	inline float strength(void);
	inline void strength(float value);
	inline int count(void);
	inline void count(int value);
	inline int steps(void);
	inline void steps(int value);
	enum puff_mode_enum {
		puff_mode_ADD = 0,
		puff_mode_SUB = 1,
	};
	inline puff_mode_enum puff_mode(void);
	inline void puff_mode(puff_mode_enum value);
	inline bool use_puff_volume(void);
	inline void use_puff_volume(bool value);
	enum length_mode_enum {
		length_mode_GROW = 0,
		length_mode_SHRINK = 1,
	};
	inline length_mode_enum length_mode(void);
	inline void length_mode(length_mode_enum value);
	inline CurveMapping curve(void);

};

/**************** GPencil Sculpt Guide ****************/

class GPencilSculptGuide : public Pointer {
public:
	GPencilSculptGuide(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline bool use_guide(void);
	inline void use_guide(bool value);
	inline bool use_snapping(void);
	inline void use_snapping(bool value);
	inline Object reference_object(void);
	enum reference_point_enum {
		reference_point_CURSOR = 0,
		reference_point_CUSTOM = 1,
		reference_point_OBJECT = 2,
	};
	inline reference_point_enum reference_point(void);
	inline void reference_point(reference_point_enum value);
	enum type_enum {
		type_CIRCULAR = 0,
		type_RADIAL = 1,
		type_PARALLEL = 2,
		type_GRID = 3,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	inline float angle(void);
	inline void angle(float value);
	inline float angle_snap(void);
	inline void angle_snap(float value);
	inline float spacing(void);
	inline void spacing(float value);
	inline Array<float, 3> location(void);
	inline void location(float values[3]);

};

/**************** GPencil Sculpt Settings ****************/

class GPencilSculptSettings : public Pointer {
public:
	GPencilSculptSettings(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	enum sculpt_tool_enum {
		sculpt_tool_SMOOTH = 0,
		sculpt_tool_THICKNESS = 1,
		sculpt_tool_STRENGTH = 2,
		sculpt_tool_RANDOMIZE = 7,
		sculpt_tool_GRAB = 3,
		sculpt_tool_PUSH = 4,
		sculpt_tool_TWIST = 5,
		sculpt_tool_PINCH = 6,
		sculpt_tool_CLONE = 8,
	};
	inline sculpt_tool_enum sculpt_tool(void);
	inline void sculpt_tool(sculpt_tool_enum value);
	enum weight_tool_enum {
		weight_tool_WEIGHT = 11,
	};
	inline weight_tool_enum weight_tool(void);
	inline void weight_tool(weight_tool_enum value);
	inline GPencilSculptBrush brush(void);
	inline GPencilSculptGuide guide(void);
	inline bool use_select_mask(void);
	inline void use_select_mask(bool value);
	inline bool use_edit_position(void);
	inline void use_edit_position(bool value);
	inline bool use_edit_strength(void);
	inline void use_edit_strength(bool value);
	inline bool use_edit_thickness(void);
	inline void use_edit_thickness(bool value);
	inline bool use_edit_uv(void);
	inline void use_edit_uv(bool value);
	inline bool use_multiframe_falloff(void);
	inline void use_multiframe_falloff(bool value);
	inline bool use_thickness_curve(void);
	inline void use_thickness_curve(bool value);
	inline CurveMapping multiframe_falloff_curve(void);
	inline CurveMapping thickness_primitive_curve(void);
	enum lock_axis_enum {
		lock_axis_VIEW = 0,
		lock_axis_AXIS_Y = 2,
		lock_axis_AXIS_X = 1,
		lock_axis_AXIS_Z = 3,
		lock_axis_CURSOR = 4,
	};
	inline lock_axis_enum lock_axis(void);
	inline void lock_axis(lock_axis_enum value);
	inline float intersection_threshold(void);
	inline void intersection_threshold(float value);

};

/**************** GPencil Sculpt Brush ****************/

class GPencilSculptBrush : public Pointer {
public:
	GPencilSculptBrush(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline int size(void);
	inline void size(int value);
	inline float strength(void);
	inline void strength(float value);
	inline float weight(void);
	inline void weight(float value);
	inline bool use_pressure_strength(void);
	inline void use_pressure_strength(bool value);
	inline bool use_pressure_radius(void);
	inline void use_pressure_radius(bool value);
	inline bool use_falloff(void);
	inline void use_falloff(bool value);
	inline bool use_edit_pressure(void);
	inline void use_edit_pressure(bool value);
	enum direction_enum {
		direction_ADD = 0,
		direction_SUBTRACT = 1,
	};
	inline direction_enum direction(void);
	inline void direction(direction_enum value);
	inline Array<float, 3> cursor_color_add(void);
	inline void cursor_color_add(float values[3]);
	inline Array<float, 3> cursor_color_sub(void);
	inline void cursor_color_sub(float values[3]);
	inline bool use_cursor(void);
	inline void use_cursor(bool value);

};

/**************** Sequence Color Balance Data ****************/

class SequenceColorBalanceData : public Pointer {
public:
	SequenceColorBalanceData(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline Array<float, 3> lift(void);
	inline void lift(float values[3]);
	inline Array<float, 3> gamma(void);
	inline void gamma(float values[3]);
	inline Array<float, 3> gain(void);
	inline void gain(float values[3]);
	inline bool invert_gain(void);
	inline void invert_gain(bool value);
	inline bool invert_gamma(void);
	inline void invert_gamma(bool value);
	inline bool invert_lift(void);
	inline void invert_lift(bool value);

};

/**************** Sequence Element ****************/

class SequenceElement : public Pointer {
public:
	SequenceElement(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string filename(void);
	inline void filename(const std::string& value);
	inline int orig_width(void);
	inline void orig_width(int value);
	inline int orig_height(void);
	inline void orig_height(int value);

};

/**************** Sequence Proxy ****************/

class SequenceProxy : public Pointer {
public:
	SequenceProxy(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string directory(void);
	inline void directory(const std::string& value);
	inline std::string filepath(void);
	inline void filepath(const std::string& value);
	inline bool use_overwrite(void);
	inline void use_overwrite(bool value);
	inline bool build_25(void);
	inline void build_25(bool value);
	inline bool build_50(void);
	inline void build_50(bool value);
	inline bool build_75(void);
	inline void build_75(bool value);
	inline bool build_100(void);
	inline void build_100(bool value);
	inline bool build_record_run(void);
	inline void build_record_run(bool value);
	inline bool build_free_run(void);
	inline void build_free_run(bool value);
	inline bool build_free_run_rec_date(void);
	inline void build_free_run_rec_date(bool value);
	inline int quality(void);
	inline void quality(int value);
	enum timecode_enum {
		timecode_NONE = 0,
		timecode_RECORD_RUN = 1,
		timecode_FREE_RUN = 2,
		timecode_FREE_RUN_REC_DATE = 4,
		timecode_RECORD_RUN_NO_GAPS = 8,
	};
	inline timecode_enum timecode(void);
	inline void timecode(timecode_enum value);
	inline bool use_proxy_custom_directory(void);
	inline void use_proxy_custom_directory(bool value);
	inline bool use_proxy_custom_file(void);
	inline void use_proxy_custom_file(bool value);

};

/**************** Sequence Color Balance ****************/

class SequenceColorBalance : public SequenceColorBalanceData {
public:
	SequenceColorBalance(const PointerRNA &ptr_arg) :
		SequenceColorBalanceData(ptr_arg)
		{}


};

/**************** Sequence Crop ****************/

class SequenceCrop : public Pointer {
public:
	SequenceCrop(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline int max_y(void);
	inline void max_y(int value);
	inline int min_y(void);
	inline void min_y(int value);
	inline int min_x(void);
	inline void min_x(int value);
	inline int max_x(void);
	inline void max_x(int value);

};

/**************** Sequence Transform ****************/

class SequenceTransform : public Pointer {
public:
	SequenceTransform(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline int offset_x(void);
	inline void offset_x(int value);
	inline int offset_y(void);
	inline void offset_y(int value);

};

/**************** Sequence ****************/

class Sequence : public Pointer {
public:
	Sequence(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		modifiers(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string name(void);
	inline void name(const std::string& value);
	enum type_enum {
		type_IMAGE = 0,
		type_META = 1,
		type_SCENE = 2,
		type_MOVIE = 3,
		type_MOVIECLIP = 6,
		type_MASK = 7,
		type_SOUND = 4,
		type_CROSS = 8,
		type_ADD = 9,
		type_SUBTRACT = 10,
		type_ALPHA_OVER = 11,
		type_ALPHA_UNDER = 12,
		type_GAMMA_CROSS = 13,
		type_MULTIPLY = 14,
		type_OVER_DROP = 15,
		type_WIPE = 25,
		type_GLOW = 26,
		type_TRANSFORM = 27,
		type_COLOR = 28,
		type_SPEED = 29,
		type_MULTICAM = 30,
		type_ADJUSTMENT = 31,
		type_GAUSSIAN_BLUR = 40,
		type_TEXT = 41,
		type_COLORMIX = 42,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	inline bool select(void);
	inline void select(bool value);
	inline bool select_left_handle(void);
	inline void select_left_handle(bool value);
	inline bool select_right_handle(void);
	inline void select_right_handle(bool value);
	inline bool mute(void);
	inline void mute(bool value);
	inline bool lock(void);
	inline void lock(bool value);
	inline int frame_final_duration(void);
	inline void frame_final_duration(int value);
	inline int frame_duration(void);
	inline void frame_duration(int value);
	inline int frame_start(void);
	inline void frame_start(int value);
	inline int frame_final_start(void);
	inline void frame_final_start(int value);
	inline int frame_final_end(void);
	inline void frame_final_end(int value);
	inline int frame_offset_start(void);
	inline void frame_offset_start(int value);
	inline int frame_offset_end(void);
	inline void frame_offset_end(int value);
	inline int frame_still_start(void);
	inline void frame_still_start(int value);
	inline int frame_still_end(void);
	inline void frame_still_end(int value);
	inline int channel(void);
	inline void channel(int value);
	inline bool use_linear_modifiers(void);
	inline void use_linear_modifiers(bool value);
	enum blend_type_enum {
		blend_type_REPLACE = 0,
		blend_type_CROSS = 8,
		blend_type_DARKEN = 46,
		blend_type_MULTIPLY = 14,
		blend_type_BURN = 47,
		blend_type_LINEAR_BURN = 48,
		blend_type_LIGHTEN = 44,
		blend_type_SCREEN = 43,
		blend_type_DODGE = 45,
		blend_type_ADD = 9,
		blend_type_OVERLAY = 49,
		blend_type_SOFT_LIGHT = 51,
		blend_type_HARD_LIGHT = 50,
		blend_type_VIVID_LIGHT = 54,
		blend_type_LINEAR_LIGHT = 53,
		blend_type_PIN_LIGHT = 52,
		blend_type_DIFFERENCE = 59,
		blend_type_EXCLUSION = 60,
		blend_type_SUBTRACT = 10,
		blend_type_HUE = 55,
		blend_type_SATURATION = 56,
		blend_type_COLOR = 58,
		blend_type_VALUE = 57,
		blend_type_ALPHA_OVER = 11,
		blend_type_ALPHA_UNDER = 12,
		blend_type_GAMMA_CROSS = 13,
		blend_type_OVER_DROP = 15,
	};
	inline blend_type_enum blend_type(void);
	inline void blend_type(blend_type_enum value);
	inline float blend_alpha(void);
	inline void blend_alpha(float value);
	inline float effect_fader(void);
	inline void effect_fader(float value);
	inline bool use_default_fade(void);
	inline void use_default_fade(bool value);
	inline float speed_factor(void);
	inline void speed_factor(float value);
	COLLECTION_PROPERTY(SequenceModifiers, SequenceModifier, Sequence, modifiers, false, true, true)

	inline void update(bool data);
	inline SequenceElement strip_elem_from_frame(int frame);
	inline void swap(Sequence& other);
};

/**************** Sequence Editor ****************/

class SequenceEditor : public Pointer {
public:
	SequenceEditor(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		sequences(ptr_arg),
		sequences_all(ptr_arg),
		meta_stack(ptr_arg)
		{}

	inline Struct rna_type(void);
	COLLECTION_PROPERTY(Sequences, Sequence, SequenceEditor, sequences, false, true, true)
	COLLECTION_PROPERTY(DefaultCollectionFunctions, Sequence, SequenceEditor, sequences_all, false, false, true)
	COLLECTION_PROPERTY(DefaultCollectionFunctions, Sequence, SequenceEditor, meta_stack, false, true, true)
	inline Sequence active_strip(void);
	inline bool show_overlay(void);
	inline void show_overlay(bool value);
	inline bool use_overlay_lock(void);
	inline void use_overlay_lock(bool value);
	inline int overlay_frame(void);
	inline void overlay_frame(int value);
	enum proxy_storage_enum {
		proxy_storage_PER_STRIP = 0,
		proxy_storage_PROJECT = 1,
	};
	inline proxy_storage_enum proxy_storage(void);
	inline void proxy_storage(proxy_storage_enum value);
	inline std::string proxy_dir(void);
	inline void proxy_dir(const std::string& value);

};

/**************** Image Sequence ****************/

class ImageSequence : public Sequence {
public:
	ImageSequence(const PointerRNA &ptr_arg) :
		Sequence(ptr_arg),
		elements(ptr_arg)
		{}

	inline std::string directory(void);
	inline void directory(const std::string& value);
	COLLECTION_PROPERTY(SequenceElements, SequenceElement, ImageSequence, elements, true, true, false)
	inline bool use_multiview(void);
	inline void use_multiview(bool value);
	enum views_format_enum {
		views_format_INDIVIDUAL = 0,
		views_format_STEREO_3D = 1,
	};
	inline views_format_enum views_format(void);
	inline void views_format(views_format_enum value);
	inline Stereo3dFormat stereo_3d_format(void);
	inline bool use_deinterlace(void);
	inline void use_deinterlace(bool value);
	enum alpha_mode_enum {
		alpha_mode_STRAIGHT = 0,
		alpha_mode_PREMUL = 1,
	};
	inline alpha_mode_enum alpha_mode(void);
	inline void alpha_mode(alpha_mode_enum value);
	inline bool use_flip_x(void);
	inline void use_flip_x(bool value);
	inline bool use_flip_y(void);
	inline void use_flip_y(bool value);
	inline bool use_float(void);
	inline void use_float(bool value);
	inline bool use_reverse_frames(void);
	inline void use_reverse_frames(bool value);
	inline float color_multiply(void);
	inline void color_multiply(float value);
	inline float color_saturation(void);
	inline void color_saturation(float value);
	inline float strobe(void);
	inline void strobe(float value);
	inline bool use_translation(void);
	inline void use_translation(bool value);
	inline SequenceTransform transform(void);
	inline bool use_crop(void);
	inline void use_crop(bool value);
	inline SequenceCrop crop(void);
	inline bool use_proxy(void);
	inline void use_proxy(bool value);
	inline SequenceProxy proxy(void);
	inline int animation_offset_start(void);
	inline void animation_offset_start(int value);
	inline int animation_offset_end(void);
	inline void animation_offset_end(int value);
	inline ColorManagedInputColorspaceSettings colorspace_settings(void);

};

/**************** Meta Sequence ****************/

class MetaSequence : public Sequence {
public:
	MetaSequence(const PointerRNA &ptr_arg) :
		Sequence(ptr_arg),
		sequences(ptr_arg)
		{}

	COLLECTION_PROPERTY(DefaultCollectionFunctions, Sequence, MetaSequence, sequences, false, true, true)
	inline bool use_deinterlace(void);
	inline void use_deinterlace(bool value);
	enum alpha_mode_enum {
		alpha_mode_STRAIGHT = 0,
		alpha_mode_PREMUL = 1,
	};
	inline alpha_mode_enum alpha_mode(void);
	inline void alpha_mode(alpha_mode_enum value);
	inline bool use_flip_x(void);
	inline void use_flip_x(bool value);
	inline bool use_flip_y(void);
	inline void use_flip_y(bool value);
	inline bool use_float(void);
	inline void use_float(bool value);
	inline bool use_reverse_frames(void);
	inline void use_reverse_frames(bool value);
	inline float color_multiply(void);
	inline void color_multiply(float value);
	inline float color_saturation(void);
	inline void color_saturation(float value);
	inline float strobe(void);
	inline void strobe(float value);
	inline bool use_translation(void);
	inline void use_translation(bool value);
	inline SequenceTransform transform(void);
	inline bool use_crop(void);
	inline void use_crop(bool value);
	inline SequenceCrop crop(void);
	inline bool use_proxy(void);
	inline void use_proxy(bool value);
	inline SequenceProxy proxy(void);
	inline int animation_offset_start(void);
	inline void animation_offset_start(int value);
	inline int animation_offset_end(void);
	inline void animation_offset_end(int value);

};

/**************** Scene Sequence ****************/

class SceneSequence : public Sequence {
public:
	SceneSequence(const PointerRNA &ptr_arg) :
		Sequence(ptr_arg)
		{}

	inline Scene scene(void);
	inline Object scene_camera(void);
	inline bool use_sequence(void);
	inline void use_sequence(bool value);
	inline bool use_grease_pencil(void);
	inline void use_grease_pencil(bool value);
	inline bool use_deinterlace(void);
	inline void use_deinterlace(bool value);
	enum alpha_mode_enum {
		alpha_mode_STRAIGHT = 0,
		alpha_mode_PREMUL = 1,
	};
	inline alpha_mode_enum alpha_mode(void);
	inline void alpha_mode(alpha_mode_enum value);
	inline bool use_flip_x(void);
	inline void use_flip_x(bool value);
	inline bool use_flip_y(void);
	inline void use_flip_y(bool value);
	inline bool use_float(void);
	inline void use_float(bool value);
	inline bool use_reverse_frames(void);
	inline void use_reverse_frames(bool value);
	inline float color_multiply(void);
	inline void color_multiply(float value);
	inline float color_saturation(void);
	inline void color_saturation(float value);
	inline float strobe(void);
	inline void strobe(float value);
	inline bool use_translation(void);
	inline void use_translation(bool value);
	inline SequenceTransform transform(void);
	inline bool use_crop(void);
	inline void use_crop(bool value);
	inline SequenceCrop crop(void);
	inline bool use_proxy(void);
	inline void use_proxy(bool value);
	inline SequenceProxy proxy(void);
	inline int animation_offset_start(void);
	inline void animation_offset_start(int value);
	inline int animation_offset_end(void);
	inline void animation_offset_end(int value);
	inline float fps(void);
	inline void fps(float value);

};

/**************** Movie Sequence ****************/

class MovieSequence : public Sequence {
public:
	MovieSequence(const PointerRNA &ptr_arg) :
		Sequence(ptr_arg),
		elements(ptr_arg)
		{}

	inline int mpeg_preseek(void);
	inline void mpeg_preseek(int value);
	inline int stream_index(void);
	inline void stream_index(int value);
	COLLECTION_PROPERTY(DefaultCollectionFunctions, SequenceElement, MovieSequence, elements, true, true, false)
	inline std::string filepath(void);
	inline void filepath(const std::string& value);
	inline bool use_multiview(void);
	inline void use_multiview(bool value);
	enum views_format_enum {
		views_format_INDIVIDUAL = 0,
		views_format_STEREO_3D = 1,
	};
	inline views_format_enum views_format(void);
	inline void views_format(views_format_enum value);
	inline Stereo3dFormat stereo_3d_format(void);
	inline bool use_deinterlace(void);
	inline void use_deinterlace(bool value);
	enum alpha_mode_enum {
		alpha_mode_STRAIGHT = 0,
		alpha_mode_PREMUL = 1,
	};
	inline alpha_mode_enum alpha_mode(void);
	inline void alpha_mode(alpha_mode_enum value);
	inline bool use_flip_x(void);
	inline void use_flip_x(bool value);
	inline bool use_flip_y(void);
	inline void use_flip_y(bool value);
	inline bool use_float(void);
	inline void use_float(bool value);
	inline bool use_reverse_frames(void);
	inline void use_reverse_frames(bool value);
	inline float color_multiply(void);
	inline void color_multiply(float value);
	inline float color_saturation(void);
	inline void color_saturation(float value);
	inline float strobe(void);
	inline void strobe(float value);
	inline bool use_translation(void);
	inline void use_translation(bool value);
	inline SequenceTransform transform(void);
	inline bool use_crop(void);
	inline void use_crop(bool value);
	inline SequenceCrop crop(void);
	inline bool use_proxy(void);
	inline void use_proxy(bool value);
	inline SequenceProxy proxy(void);
	inline int animation_offset_start(void);
	inline void animation_offset_start(int value);
	inline int animation_offset_end(void);
	inline void animation_offset_end(int value);
	inline ColorManagedInputColorspaceSettings colorspace_settings(void);
	inline float fps(void);
	inline void fps(float value);

	inline IDPropertyWrapPtr metadata();
};

/**************** MovieClip Sequence ****************/

class MovieClipSequence : public Sequence {
public:
	MovieClipSequence(const PointerRNA &ptr_arg) :
		Sequence(ptr_arg)
		{}

	inline bool undistort(void);
	inline void undistort(bool value);
	inline bool stabilize2d(void);
	inline void stabilize2d(bool value);
	inline bool use_deinterlace(void);
	inline void use_deinterlace(bool value);
	enum alpha_mode_enum {
		alpha_mode_STRAIGHT = 0,
		alpha_mode_PREMUL = 1,
	};
	inline alpha_mode_enum alpha_mode(void);
	inline void alpha_mode(alpha_mode_enum value);
	inline bool use_flip_x(void);
	inline void use_flip_x(bool value);
	inline bool use_flip_y(void);
	inline void use_flip_y(bool value);
	inline bool use_float(void);
	inline void use_float(bool value);
	inline bool use_reverse_frames(void);
	inline void use_reverse_frames(bool value);
	inline float color_multiply(void);
	inline void color_multiply(float value);
	inline float color_saturation(void);
	inline void color_saturation(float value);
	inline float strobe(void);
	inline void strobe(float value);
	inline bool use_translation(void);
	inline void use_translation(bool value);
	inline SequenceTransform transform(void);
	inline bool use_crop(void);
	inline void use_crop(bool value);
	inline SequenceCrop crop(void);
	inline int animation_offset_start(void);
	inline void animation_offset_start(int value);
	inline int animation_offset_end(void);
	inline void animation_offset_end(int value);
	inline float fps(void);
	inline void fps(float value);

};

/**************** Mask Sequence ****************/

class MaskSequence : public Sequence {
public:
	MaskSequence(const PointerRNA &ptr_arg) :
		Sequence(ptr_arg)
		{}

	inline Mask mask(void);
	inline bool use_deinterlace(void);
	inline void use_deinterlace(bool value);
	enum alpha_mode_enum {
		alpha_mode_STRAIGHT = 0,
		alpha_mode_PREMUL = 1,
	};
	inline alpha_mode_enum alpha_mode(void);
	inline void alpha_mode(alpha_mode_enum value);
	inline bool use_flip_x(void);
	inline void use_flip_x(bool value);
	inline bool use_flip_y(void);
	inline void use_flip_y(bool value);
	inline bool use_float(void);
	inline void use_float(bool value);
	inline bool use_reverse_frames(void);
	inline void use_reverse_frames(bool value);
	inline float color_multiply(void);
	inline void color_multiply(float value);
	inline float color_saturation(void);
	inline void color_saturation(float value);
	inline float strobe(void);
	inline void strobe(float value);
	inline bool use_translation(void);
	inline void use_translation(bool value);
	inline SequenceTransform transform(void);
	inline bool use_crop(void);
	inline void use_crop(bool value);
	inline SequenceCrop crop(void);
	inline int animation_offset_start(void);
	inline void animation_offset_start(int value);
	inline int animation_offset_end(void);
	inline void animation_offset_end(int value);

};

/**************** Sound Sequence ****************/

class SoundSequence : public Sequence {
public:
	SoundSequence(const PointerRNA &ptr_arg) :
		Sequence(ptr_arg)
		{}

	inline Sound sound(void);
	inline float volume(void);
	inline void volume(float value);
	inline float pitch(void);
	inline void pitch(float value);
	inline float pan(void);
	inline void pan(float value);
	inline bool show_waveform(void);
	inline void show_waveform(bool value);
	inline int animation_offset_start(void);
	inline void animation_offset_start(int value);
	inline int animation_offset_end(void);
	inline void animation_offset_end(int value);

};

/**************** Effect Sequence ****************/

class EffectSequence : public Sequence {
public:
	EffectSequence(const PointerRNA &ptr_arg) :
		Sequence(ptr_arg)
		{}

	inline bool use_deinterlace(void);
	inline void use_deinterlace(bool value);
	enum alpha_mode_enum {
		alpha_mode_STRAIGHT = 0,
		alpha_mode_PREMUL = 1,
	};
	inline alpha_mode_enum alpha_mode(void);
	inline void alpha_mode(alpha_mode_enum value);
	inline bool use_flip_x(void);
	inline void use_flip_x(bool value);
	inline bool use_flip_y(void);
	inline void use_flip_y(bool value);
	inline bool use_float(void);
	inline void use_float(bool value);
	inline bool use_reverse_frames(void);
	inline void use_reverse_frames(bool value);
	inline float color_multiply(void);
	inline void color_multiply(float value);
	inline float color_saturation(void);
	inline void color_saturation(float value);
	inline float strobe(void);
	inline void strobe(float value);
	inline bool use_translation(void);
	inline void use_translation(bool value);
	inline SequenceTransform transform(void);
	inline bool use_crop(void);
	inline void use_crop(bool value);
	inline SequenceCrop crop(void);
	inline bool use_proxy(void);
	inline void use_proxy(bool value);
	inline SequenceProxy proxy(void);

};

/**************** Add Sequence ****************/

class AddSequence : public EffectSequence {
public:
	AddSequence(const PointerRNA &ptr_arg) :
		EffectSequence(ptr_arg)
		{}

	inline int input_count(void);
	inline void input_count(int value);
	inline Sequence input_1(void);
	inline Sequence input_2(void);

};

/**************** Adjustment Layer Sequence ****************/

class AdjustmentSequence : public EffectSequence {
public:
	AdjustmentSequence(const PointerRNA &ptr_arg) :
		EffectSequence(ptr_arg)
		{}

	inline int input_count(void);
	inline void input_count(int value);
	inline int animation_offset_start(void);
	inline void animation_offset_start(int value);
	inline int animation_offset_end(void);
	inline void animation_offset_end(int value);

};

/**************** Alpha Over Sequence ****************/

class AlphaOverSequence : public EffectSequence {
public:
	AlphaOverSequence(const PointerRNA &ptr_arg) :
		EffectSequence(ptr_arg)
		{}

	inline int input_count(void);
	inline void input_count(int value);
	inline Sequence input_1(void);
	inline Sequence input_2(void);

};

/**************** Alpha Under Sequence ****************/

class AlphaUnderSequence : public EffectSequence {
public:
	AlphaUnderSequence(const PointerRNA &ptr_arg) :
		EffectSequence(ptr_arg)
		{}

	inline int input_count(void);
	inline void input_count(int value);
	inline Sequence input_1(void);
	inline Sequence input_2(void);

};

/**************** Color Sequence ****************/

class ColorSequence : public EffectSequence {
public:
	ColorSequence(const PointerRNA &ptr_arg) :
		EffectSequence(ptr_arg)
		{}

	inline int input_count(void);
	inline void input_count(int value);
	inline Array<float, 3> color(void);
	inline void color(float values[3]);

};

/**************** Cross Sequence ****************/

class CrossSequence : public EffectSequence {
public:
	CrossSequence(const PointerRNA &ptr_arg) :
		EffectSequence(ptr_arg)
		{}

	inline int input_count(void);
	inline void input_count(int value);
	inline Sequence input_1(void);
	inline Sequence input_2(void);

};

/**************** Gamma Cross Sequence ****************/

class GammaCrossSequence : public EffectSequence {
public:
	GammaCrossSequence(const PointerRNA &ptr_arg) :
		EffectSequence(ptr_arg)
		{}

	inline int input_count(void);
	inline void input_count(int value);
	inline Sequence input_1(void);
	inline Sequence input_2(void);

};

/**************** Glow Sequence ****************/

class GlowSequence : public EffectSequence {
public:
	GlowSequence(const PointerRNA &ptr_arg) :
		EffectSequence(ptr_arg)
		{}

	inline int input_count(void);
	inline void input_count(int value);
	inline Sequence input_1(void);
	inline float threshold(void);
	inline void threshold(float value);
	inline float clamp(void);
	inline void clamp(float value);
	inline float boost_factor(void);
	inline void boost_factor(float value);
	inline float blur_radius(void);
	inline void blur_radius(float value);
	inline int quality(void);
	inline void quality(int value);
	inline bool use_only_boost(void);
	inline void use_only_boost(bool value);

};

/**************** Multicam Select Sequence ****************/

class MulticamSequence : public EffectSequence {
public:
	MulticamSequence(const PointerRNA &ptr_arg) :
		EffectSequence(ptr_arg)
		{}

	inline int input_count(void);
	inline void input_count(int value);
	inline int multicam_source(void);
	inline void multicam_source(int value);
	inline int animation_offset_start(void);
	inline void animation_offset_start(int value);
	inline int animation_offset_end(void);
	inline void animation_offset_end(int value);

};

/**************** Multiply Sequence ****************/

class MultiplySequence : public EffectSequence {
public:
	MultiplySequence(const PointerRNA &ptr_arg) :
		EffectSequence(ptr_arg)
		{}

	inline int input_count(void);
	inline void input_count(int value);
	inline Sequence input_1(void);
	inline Sequence input_2(void);

};

/**************** Over Drop Sequence ****************/

class OverDropSequence : public EffectSequence {
public:
	OverDropSequence(const PointerRNA &ptr_arg) :
		EffectSequence(ptr_arg)
		{}

	inline int input_count(void);
	inline void input_count(int value);
	inline Sequence input_1(void);
	inline Sequence input_2(void);

};

/**************** SpeedControl Sequence ****************/

class SpeedControlSequence : public EffectSequence {
public:
	SpeedControlSequence(const PointerRNA &ptr_arg) :
		EffectSequence(ptr_arg)
		{}

	inline int input_count(void);
	inline void input_count(int value);
	inline Sequence input_1(void);
	inline float multiply_speed(void);
	inline void multiply_speed(float value);
	inline bool use_as_speed(void);
	inline void use_as_speed(bool value);
	inline bool use_scale_to_length(void);
	inline void use_scale_to_length(bool value);

};

/**************** Subtract Sequence ****************/

class SubtractSequence : public EffectSequence {
public:
	SubtractSequence(const PointerRNA &ptr_arg) :
		EffectSequence(ptr_arg)
		{}

	inline int input_count(void);
	inline void input_count(int value);
	inline Sequence input_1(void);
	inline Sequence input_2(void);

};

/**************** Transform Sequence ****************/

class TransformSequence : public EffectSequence {
public:
	TransformSequence(const PointerRNA &ptr_arg) :
		EffectSequence(ptr_arg)
		{}

	inline int input_count(void);
	inline void input_count(int value);
	inline Sequence input_1(void);
	inline float scale_start_x(void);
	inline void scale_start_x(float value);
	inline float scale_start_y(void);
	inline void scale_start_y(float value);
	inline bool use_uniform_scale(void);
	inline void use_uniform_scale(bool value);
	inline float translate_start_x(void);
	inline void translate_start_x(float value);
	inline float translate_start_y(void);
	inline void translate_start_y(float value);
	inline float rotation_start(void);
	inline void rotation_start(float value);
	enum translation_unit_enum {
		translation_unit_PIXELS = 0,
		translation_unit_PERCENT = 1,
	};
	inline translation_unit_enum translation_unit(void);
	inline void translation_unit(translation_unit_enum value);
	enum interpolation_enum {
		interpolation_NONE = 0,
		interpolation_BILINEAR = 1,
		interpolation_BICUBIC = 2,
	};
	inline interpolation_enum interpolation(void);
	inline void interpolation(interpolation_enum value);

};

/**************** Wipe Sequence ****************/

class WipeSequence : public EffectSequence {
public:
	WipeSequence(const PointerRNA &ptr_arg) :
		EffectSequence(ptr_arg)
		{}

	inline int input_count(void);
	inline void input_count(int value);
	inline Sequence input_1(void);
	inline Sequence input_2(void);
	inline float blur_width(void);
	inline void blur_width(float value);
	inline float angle(void);
	inline void angle(float value);
	enum direction_enum {
		direction_OUT = 0,
		direction_IN = 1,
	};
	inline direction_enum direction(void);
	inline void direction(direction_enum value);
	enum transition_type_enum {
		transition_type_SINGLE = 0,
		transition_type_DOUBLE = 1,
		transition_type_IRIS = 4,
		transition_type_CLOCK = 5,
	};
	inline transition_type_enum transition_type(void);
	inline void transition_type(transition_type_enum value);

};

/**************** Gaussian Blur Sequence ****************/

class GaussianBlurSequence : public EffectSequence {
public:
	GaussianBlurSequence(const PointerRNA &ptr_arg) :
		EffectSequence(ptr_arg)
		{}

	inline int input_count(void);
	inline void input_count(int value);
	inline Sequence input_1(void);
	inline float size_x(void);
	inline void size_x(float value);
	inline float size_y(void);
	inline void size_y(float value);

};

/**************** Text Sequence ****************/

class TextSequence : public EffectSequence {
public:
	TextSequence(const PointerRNA &ptr_arg) :
		EffectSequence(ptr_arg)
		{}

	inline int input_count(void);
	inline void input_count(int value);
	inline VectorFont font(void);
	inline int font_size(void);
	inline void font_size(int value);
	inline Array<float, 4> color(void);
	inline void color(float values[4]);
	inline Array<float, 4> shadow_color(void);
	inline void shadow_color(float values[4]);
	inline Array<float, 2> location(void);
	inline void location(float values[2]);
	inline float wrap_width(void);
	inline void wrap_width(float value);
	enum align_x_enum {
		align_x_LEFT = 0,
		align_x_CENTER = 1,
		align_x_RIGHT = 2,
	};
	inline align_x_enum align_x(void);
	inline void align_x(align_x_enum value);
	enum align_y_enum {
		align_y_TOP = 0,
		align_y_CENTER = 1,
		align_y_BOTTOM = 2,
	};
	inline align_y_enum align_y(void);
	inline void align_y(align_y_enum value);
	inline std::string text(void);
	inline void text(const std::string& value);
	inline bool use_shadow(void);
	inline void use_shadow(bool value);

};

/**************** Color Mix Sequence ****************/

class ColorMixSequence : public EffectSequence {
public:
	ColorMixSequence(const PointerRNA &ptr_arg) :
		EffectSequence(ptr_arg)
		{}

	inline int input_count(void);
	inline void input_count(int value);
	inline Sequence input_1(void);
	inline Sequence input_2(void);
	enum blend_effect_enum {
		blend_effect_ADD = 9,
		blend_effect_SUBTRACT = 10,
		blend_effect_MULTIPLY = 14,
		blend_effect_LIGHTEN = 44,
		blend_effect_DARKEN = 46,
		blend_effect_SCREEN = 43,
		blend_effect_OVERLAY = 49,
		blend_effect_DODGE = 45,
		blend_effect_BURN = 47,
		blend_effect_LINEAR_BURN = 48,
		blend_effect_SOFT_LIGHT = 51,
		blend_effect_HARD_LIGHT = 50,
		blend_effect_PIN_LIGHT = 52,
		blend_effect_LINEAR_LIGHT = 53,
		blend_effect_VIVID_LIGHT = 54,
		blend_effect_COLOR = 58,
		blend_effect_HUE = 55,
		blend_effect_SATURATION = 56,
		blend_effect_VALUE = 57,
		blend_effect_DIFFERENCE = 59,
		blend_effect_EXCLUSION = 60,
	};
	inline blend_effect_enum blend_effect(void);
	inline void blend_effect(blend_effect_enum value);
	inline float factor(void);
	inline void factor(float value);

};

/**************** SequenceModifier ****************/

class SequenceModifier : public Pointer {
public:
	SequenceModifier(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string name(void);
	inline void name(const std::string& value);
	enum type_enum {
		type_COLOR_BALANCE = 1,
		type_CURVES = 2,
		type_HUE_CORRECT = 3,
		type_BRIGHT_CONTRAST = 4,
		type_MASK = 5,
		type_WHITE_BALANCE = 6,
		type_TONEMAP = 7,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	inline bool mute(void);
	inline void mute(bool value);
	inline bool show_expanded(void);
	inline void show_expanded(bool value);
	enum input_mask_type_enum {
		input_mask_type_STRIP = 0,
		input_mask_type_ID = 1,
	};
	inline input_mask_type_enum input_mask_type(void);
	inline void input_mask_type(input_mask_type_enum value);
	enum mask_time_enum {
		mask_time_RELATIVE = 0,
		mask_time_ABSOLUTE = 1,
	};
	inline mask_time_enum mask_time(void);
	inline void mask_time(mask_time_enum value);
	inline Sequence input_mask_strip(void);
	inline Mask input_mask_id(void);

};

/**************** ColorBalanceModifier ****************/

class ColorBalanceModifier : public SequenceModifier {
public:
	ColorBalanceModifier(const PointerRNA &ptr_arg) :
		SequenceModifier(ptr_arg)
		{}

	inline SequenceColorBalanceData color_balance(void);
	inline float color_multiply(void);
	inline void color_multiply(float value);

};

/**************** CurvesModifier ****************/

class CurvesModifier : public SequenceModifier {
public:
	CurvesModifier(const PointerRNA &ptr_arg) :
		SequenceModifier(ptr_arg)
		{}

	inline CurveMapping curve_mapping(void);

};

/**************** HueCorrectModifier ****************/

class HueCorrectModifier : public SequenceModifier {
public:
	HueCorrectModifier(const PointerRNA &ptr_arg) :
		SequenceModifier(ptr_arg)
		{}

	inline CurveMapping curve_mapping(void);

};

/**************** BrightContrastModifier ****************/

class BrightContrastModifier : public SequenceModifier {
public:
	BrightContrastModifier(const PointerRNA &ptr_arg) :
		SequenceModifier(ptr_arg)
		{}

	inline float bright(void);
	inline void bright(float value);
	inline float contrast(void);
	inline void contrast(float value);

};

/**************** WhiteBalanceModifier ****************/

class WhiteBalanceModifier : public SequenceModifier {
public:
	WhiteBalanceModifier(const PointerRNA &ptr_arg) :
		SequenceModifier(ptr_arg)
		{}

	inline Array<float, 3> white_value(void);
	inline void white_value(float values[3]);

};

/**************** SequencerTonemapModifierData ****************/

class SequencerTonemapModifierData : public SequenceModifier {
public:
	SequencerTonemapModifierData(const PointerRNA &ptr_arg) :
		SequenceModifier(ptr_arg)
		{}

	enum tonemap_type_enum {
		tonemap_type_RD_PHOTORECEPTOR = 1,
		tonemap_type_RH_SIMPLE = 0,
	};
	inline tonemap_type_enum tonemap_type(void);
	inline void tonemap_type(tonemap_type_enum value);
	inline float key(void);
	inline void key(float value);
	inline float offset(void);
	inline void offset(float value);
	inline float gamma(void);
	inline void gamma(float value);
	inline float intensity(void);
	inline void intensity(float value);
	inline float contrast(void);
	inline void contrast(float value);
	inline float adaptation(void);
	inline void adaptation(float value);
	inline float correction(void);
	inline void correction(float value);

};

/**************** Domain Settings ****************/

class SmokeDomainSettings : public Pointer {
public:
	SmokeDomainSettings(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline int resolution_max(void);
	inline void resolution_max(int value);
	inline int amplify(void);
	inline void amplify(int value);
	inline bool use_high_resolution(void);
	inline void use_high_resolution(bool value);
	inline bool show_high_resolution(void);
	inline void show_high_resolution(bool value);
	enum noise_type_enum {
		noise_type_NOISEWAVE = 1,
		noise_type_NOISEFFT = 2,
	};
	inline noise_type_enum noise_type(void);
	inline void noise_type(noise_type_enum value);
	inline float alpha(void);
	inline void alpha(float value);
	inline float beta(void);
	inline void beta(float value);
	inline Collection collision_collection(void);
	inline Collection fluid_collection(void);
	inline Collection effector_collection(void);
	inline float strength(void);
	inline void strength(float value);
	inline int dissolve_speed(void);
	inline void dissolve_speed(int value);
	inline bool use_dissolve_smoke(void);
	inline void use_dissolve_smoke(bool value);
	inline bool use_dissolve_smoke_log(void);
	inline void use_dissolve_smoke_log(bool value);
	inline PointCache point_cache(void);
	enum point_cache_compress_type_enum {
		point_cache_compress_type_CACHELIGHT = 0,
		point_cache_compress_type_CACHEHEAVY = 1,
	};
	inline point_cache_compress_type_enum point_cache_compress_type(void);
	inline void point_cache_compress_type(point_cache_compress_type_enum value);
	enum openvdb_cache_compress_type_enum {
		openvdb_cache_compress_type_ZIP = 1,
		openvdb_cache_compress_type_NONE = 2,
	};
	inline openvdb_cache_compress_type_enum openvdb_cache_compress_type(void);
	inline void openvdb_cache_compress_type(openvdb_cache_compress_type_enum value);
	enum data_depth_enum {
		data_depth_16 = 16,
		data_depth_32 = 0,
	};
	inline data_depth_enum data_depth(void);
	inline void data_depth(data_depth_enum value);
	enum collision_extents_enum {
		collision_extents_BORDEROPEN = 0,
		collision_extents_BORDERVERTICAL = 1,
		collision_extents_BORDERCLOSED = 2,
	};
	inline collision_extents_enum collision_extents(void);
	inline void collision_extents(collision_extents_enum value);
	inline EffectorWeights effector_weights(void);
	enum highres_sampling_enum {
		highres_sampling_FULLSAMPLE = 2,
		highres_sampling_LINEAR = 1,
		highres_sampling_NEAREST = 0,
	};
	inline highres_sampling_enum highres_sampling(void);
	inline void highres_sampling(highres_sampling_enum value);
	inline float time_scale(void);
	inline void time_scale(float value);
	inline float vorticity(void);
	inline void vorticity(float value);
	inline Array<float, 32> density_grid(void);
	inline void density_grid(float values[32]);
	inline Array<float, 32> velocity_grid(void);
	inline void velocity_grid(float values[32]);
	inline Array<float, 32> flame_grid(void);
	inline void flame_grid(float values[32]);
	inline Array<float, 32> color_grid(void);
	inline void color_grid(float values[32]);
	inline Array<float, 32> heat_grid(void);
	inline void heat_grid(float values[32]);
	inline Array<float, 32> temperature_grid(void);
	inline void temperature_grid(float values[32]);
	inline Array<float, 3> cell_size(void);
	inline void cell_size(float values[3]);
	inline Array<float, 3> start_point(void);
	inline void start_point(float values[3]);
	inline Array<int, 3> domain_resolution(void);
	inline void domain_resolution(int values[3]);
	inline float burning_rate(void);
	inline void burning_rate(float value);
	inline float flame_smoke(void);
	inline void flame_smoke(float value);
	inline float flame_vorticity(void);
	inline void flame_vorticity(float value);
	inline float flame_ignition(void);
	inline void flame_ignition(float value);
	inline float flame_max_temp(void);
	inline void flame_max_temp(float value);
	inline Array<float, 3> flame_smoke_color(void);
	inline void flame_smoke_color(float values[3]);
	inline bool use_adaptive_domain(void);
	inline void use_adaptive_domain(bool value);
	inline int additional_res(void);
	inline void additional_res(int value);
	inline int adapt_margin(void);
	inline void adapt_margin(int value);
	inline float adapt_threshold(void);
	inline void adapt_threshold(float value);
	enum cache_file_format_enum {
		cache_file_format_POINTCACHE = 0,
	};
	inline cache_file_format_enum cache_file_format(void);
	inline void cache_file_format(cache_file_format_enum value);
	enum slice_method_enum {
		slice_method_VIEW_ALIGNED = 0,
		slice_method_AXIS_ALIGNED = 1,
	};
	inline slice_method_enum slice_method(void);
	inline void slice_method(slice_method_enum value);
	enum axis_slice_method_enum {
		axis_slice_method_FULL = 0,
		axis_slice_method_SINGLE = 1,
	};
	inline axis_slice_method_enum axis_slice_method(void);
	inline void axis_slice_method(axis_slice_method_enum value);
	enum slice_axis_enum {
		slice_axis_AUTO = 0,
		slice_axis_X = 1,
		slice_axis_Y = 2,
		slice_axis_Z = 3,
	};
	inline slice_axis_enum slice_axis(void);
	inline void slice_axis(slice_axis_enum value);
	inline float slice_per_voxel(void);
	inline void slice_per_voxel(float value);
	inline float slice_depth(void);
	inline void slice_depth(float value);
	inline float display_thickness(void);
	inline void display_thickness(float value);
	enum display_interpolation_enum {
		display_interpolation_LINEAR = 0,
		display_interpolation_CUBIC = 1,
	};
	inline display_interpolation_enum display_interpolation(void);
	inline void display_interpolation(display_interpolation_enum value);
	inline bool show_velocity(void);
	inline void show_velocity(bool value);
	enum vector_display_type_enum {
		vector_display_type_NEEDLE = 0,
		vector_display_type_STREAMLINE = 1,
	};
	inline vector_display_type_enum vector_display_type(void);
	inline void vector_display_type(vector_display_type_enum value);
	inline float vector_scale(void);
	inline void vector_scale(float value);
	inline bool use_color_ramp(void);
	inline void use_color_ramp(bool value);
	enum coba_field_enum {
		coba_field_COLOR_R = 8,
		coba_field_COLOR_G = 9,
		coba_field_COLOR_B = 10,
		coba_field_DENSITY = 0,
		coba_field_FLAME = 4,
		coba_field_FUEL = 2,
		coba_field_HEAT = 1,
		coba_field_VELOCITY_X = 5,
		coba_field_VELOCITY_Y = 6,
		coba_field_VELOCITY_Z = 7,
	};
	inline coba_field_enum coba_field(void);
	inline void coba_field(coba_field_enum value);
	inline ColorRamp color_ramp(void);
	inline float clipping(void);
	inline void clipping(float value);

};

/**************** Flow Settings ****************/

class SmokeFlowSettings : public Pointer {
public:
	SmokeFlowSettings(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline float density(void);
	inline void density(float value);
	inline Array<float, 3> smoke_color(void);
	inline void smoke_color(float values[3]);
	inline float fuel_amount(void);
	inline void fuel_amount(float value);
	inline float temperature(void);
	inline void temperature(float value);
	inline ParticleSystem particle_system(void);
	enum smoke_flow_type_enum {
		smoke_flow_type_OUTFLOW = 2,
		smoke_flow_type_SMOKE = 0,
		smoke_flow_type_BOTH = 3,
		smoke_flow_type_FIRE = 1,
	};
	inline smoke_flow_type_enum smoke_flow_type(void);
	inline void smoke_flow_type(smoke_flow_type_enum value);
	enum smoke_flow_source_enum {
		smoke_flow_source_PARTICLES = 0,
		smoke_flow_source_MESH = 1,
	};
	inline smoke_flow_source_enum smoke_flow_source(void);
	inline void smoke_flow_source(smoke_flow_source_enum value);
	inline bool use_absolute(void);
	inline void use_absolute(bool value);
	inline bool use_initial_velocity(void);
	inline void use_initial_velocity(bool value);
	inline float velocity_factor(void);
	inline void velocity_factor(float value);
	inline float velocity_normal(void);
	inline void velocity_normal(float value);
	inline float velocity_random(void);
	inline void velocity_random(float value);
	inline float volume_density(void);
	inline void volume_density(float value);
	inline float surface_distance(void);
	inline void surface_distance(float value);
	inline float particle_size(void);
	inline void particle_size(float value);
	inline bool use_particle_size(void);
	inline void use_particle_size(bool value);
	inline int subframes(void);
	inline void subframes(int value);
	inline std::string density_vertex_group(void);
	inline void density_vertex_group(const std::string& value);
	inline bool use_texture(void);
	inline void use_texture(bool value);
	enum texture_map_type_enum {
		texture_map_type_AUTO = 0,
		texture_map_type_UV = 1,
	};
	inline texture_map_type_enum texture_map_type(void);
	inline void texture_map_type(texture_map_type_enum value);
	inline std::string uv_layer(void);
	inline void uv_layer(const std::string& value);
	inline Texture noise_texture(void);
	inline float texture_size(void);
	inline void texture_size(float value);
	inline float texture_offset(void);
	inline void texture_offset(float value);

};

/**************** Collision Settings ****************/

class SmokeCollSettings : public Pointer {
public:
	SmokeCollSettings(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	enum collision_type_enum {
		collision_type_COLLSTATIC = 0,
		collision_type_COLLRIGID = 1,
		collision_type_COLLANIMATED = 2,
	};
	inline collision_type_enum collision_type(void);
	inline void collision_type(collision_type_enum value);

};

/**************** Space ****************/

class Space : public Pointer {
public:
	Space(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	enum type_enum {
		type_EMPTY = 0,
		type_VIEW_3D = 1,
		type_IMAGE_EDITOR = 6,
		type_NODE_EDITOR = 16,
		type_SEQUENCE_EDITOR = 8,
		type_CLIP_EDITOR = 20,
		type_DOPESHEET_EDITOR = 12,
		type_GRAPH_EDITOR = 2,
		type_NLA_EDITOR = 13,
		type_TEXT_EDITOR = 9,
		type_CONSOLE = 18,
		type_INFO = 7,
		type_TOPBAR = 21,
		type_STATUSBAR = 22,
		type_OUTLINER = 3,
		type_PROPERTIES = 4,
		type_FILE_BROWSER = 5,
		type_PREFERENCES = 19,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	inline bool show_locked_time(void);
	inline void show_locked_time(bool value);

};

/**************** Space Image Editor ****************/

class SpaceImageEditor : public Space {
public:
	SpaceImageEditor(const PointerRNA &ptr_arg) :
		Space(ptr_arg)
		{}

	inline Image image(void);
	inline ImageUser image_user(void);
	inline Scopes scopes(void);
	inline bool use_image_pin(void);
	inline void use_image_pin(bool value);
	inline Histogram sample_histogram(void);
	inline Array<float, 2> zoom(void);
	inline void zoom(float values[2]);
	inline bool show_repeat(void);
	inline void show_repeat(bool value);
	inline bool show_annotation(void);
	inline void show_annotation(bool value);
	enum display_channels_enum {
		display_channels_COLOR_ALPHA = 4096,
		display_channels_COLOR = 0,
		display_channels_ALPHA = 8192,
		display_channels_Z_BUFFER = 16384,
		display_channels_RED = 134217728,
		display_channels_GREEN = 268435456,
		display_channels_BLUE = 536870912,
	};
	inline display_channels_enum display_channels(void);
	inline void display_channels(display_channels_enum value);
	inline bool show_stereo_3d(void);
	inline void show_stereo_3d(bool value);
	inline SpaceUVEditor uv_editor(void);
	enum mode_enum {
		mode_VIEW = 0,
		mode_UV = 3,
		mode_PAINT = 1,
		mode_MASK = 2,
	};
	inline mode_enum mode(void);
	inline void mode(mode_enum value);
	enum ui_mode_enum {
		ui_mode_VIEW = 0,
		ui_mode_PAINT = 1,
		ui_mode_MASK = 2,
	};
	inline ui_mode_enum ui_mode(void);
	inline void ui_mode(ui_mode_enum value);
	inline Array<float, 2> cursor_location(void);
	inline void cursor_location(float values[2]);
	enum pivot_point_enum {
		pivot_point_BOUNDING_BOX_CENTER = 0,
		pivot_point_CURSOR = 1,
		pivot_point_INDIVIDUAL_ORIGINS = 2,
		pivot_point_MEDIAN_POINT = 3,
		pivot_point_ACTIVE_ELEMENT = 4,
	};
	inline pivot_point_enum pivot_point(void);
	inline void pivot_point(pivot_point_enum value);
	inline GreasePencil grease_pencil(void);
	inline bool use_realtime_update(void);
	inline void use_realtime_update(bool value);
	inline bool show_render(void);
	inline void show_render(bool value);
	inline bool show_paint(void);
	inline void show_paint(bool value);
	inline bool show_uvedit(void);
	inline void show_uvedit(bool value);
	inline bool show_maskedit(void);
	inline void show_maskedit(bool value);
	inline Mask mask(void);
	enum mask_display_type_enum {
		mask_display_type_OUTLINE = 0,
		mask_display_type_DASH = 1,
		mask_display_type_BLACK = 2,
		mask_display_type_WHITE = 3,
	};
	inline mask_display_type_enum mask_display_type(void);
	inline void mask_display_type(mask_display_type_enum value);
	inline bool show_mask_smooth(void);
	inline void show_mask_smooth(bool value);
	inline bool show_mask_overlay(void);
	inline void show_mask_overlay(bool value);
	enum mask_overlay_mode_enum {
		mask_overlay_mode_ALPHACHANNEL = 0,
		mask_overlay_mode_COMBINED = 1,
	};
	inline mask_overlay_mode_enum mask_overlay_mode(void);
	inline void mask_overlay_mode(mask_overlay_mode_enum value);

};

/**************** Space UV Editor ****************/

class SpaceUVEditor : public Pointer {
public:
	SpaceUVEditor(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	enum sticky_select_mode_enum {
		sticky_select_mode_DISABLED = 1,
		sticky_select_mode_SHARED_LOCATION = 0,
		sticky_select_mode_SHARED_VERTEX = 2,
	};
	inline sticky_select_mode_enum sticky_select_mode(void);
	inline void sticky_select_mode(sticky_select_mode_enum value);
	enum edge_display_type_enum {
		edge_display_type_OUTLINE = 0,
		edge_display_type_DASH = 1,
		edge_display_type_BLACK = 2,
		edge_display_type_WHITE = 3,
	};
	inline edge_display_type_enum edge_display_type(void);
	inline void edge_display_type(edge_display_type_enum value);
	inline bool show_smooth_edges(void);
	inline void show_smooth_edges(bool value);
	inline bool show_stretch(void);
	inline void show_stretch(bool value);
	enum display_stretch_type_enum {
		display_stretch_type_ANGLE = 0,
		display_stretch_type_AREA = 1,
	};
	inline display_stretch_type_enum display_stretch_type(void);
	inline void display_stretch_type(display_stretch_type_enum value);
	inline bool show_modified_edges(void);
	inline void show_modified_edges(bool value);
	inline bool show_metadata(void);
	inline void show_metadata(bool value);
	inline bool show_texpaint(void);
	inline void show_texpaint(bool value);
	inline bool show_pixel_coords(void);
	inline void show_pixel_coords(bool value);
	inline bool show_faces(void);
	inline void show_faces(bool value);
	inline bool show_edges(void);
	inline void show_edges(bool value);
	enum pixel_snap_mode_enum {
		pixel_snap_mode_DISABLED = 0,
		pixel_snap_mode_CORNER = 2,
		pixel_snap_mode_CENTER = 1,
	};
	inline pixel_snap_mode_enum pixel_snap_mode(void);
	inline void pixel_snap_mode(pixel_snap_mode_enum value);
	inline bool lock_bounds(void);
	inline void lock_bounds(bool value);
	inline bool use_live_unwrap(void);
	inline void use_live_unwrap(bool value);

};

/**************** Space Sequence Editor ****************/

class SpaceSequenceEditor : public Space {
public:
	SpaceSequenceEditor(const PointerRNA &ptr_arg) :
		Space(ptr_arg)
		{}

	enum view_type_enum {
		view_type_SEQUENCER = 1,
		view_type_PREVIEW = 2,
		view_type_SEQUENCER_PREVIEW = 3,
	};
	inline view_type_enum view_type(void);
	inline void view_type(view_type_enum value);
	enum display_mode_enum {
		display_mode_IMAGE = 1,
		display_mode_WAVEFORM = 2,
		display_mode_VECTOR_SCOPE = 3,
		display_mode_HISTOGRAM = 4,
	};
	inline display_mode_enum display_mode(void);
	inline void display_mode(display_mode_enum value);
	inline bool show_frame_indicator(void);
	inline void show_frame_indicator(bool value);
	inline bool show_frames(void);
	inline void show_frames(bool value);
	inline bool use_marker_sync(void);
	inline void use_marker_sync(bool value);
	inline bool show_separate_color(void);
	inline void show_separate_color(bool value);
	inline bool show_safe_areas(void);
	inline void show_safe_areas(bool value);
	inline bool show_safe_center(void);
	inline void show_safe_center(bool value);
	inline bool show_metadata(void);
	inline void show_metadata(bool value);
	inline bool show_seconds(void);
	inline void show_seconds(bool value);
	inline bool show_marker_lines(void);
	inline void show_marker_lines(bool value);
	inline bool show_annotation(void);
	inline void show_annotation(bool value);
	inline int display_channel(void);
	inline void display_channel(int value);
	enum preview_channels_enum {
		preview_channels_COLOR_ALPHA = 64,
		preview_channels_COLOR = 0,
	};
	inline preview_channels_enum preview_channels(void);
	inline void preview_channels(preview_channels_enum value);
	enum waveform_display_type_enum {
		waveform_display_type_NO_WAVEFORMS = 256,
		waveform_display_type_ALL_WAVEFORMS = 128,
		waveform_display_type_DEFAULT_WAVEFORMS = 0,
	};
	inline waveform_display_type_enum waveform_display_type(void);
	inline void waveform_display_type(waveform_display_type_enum value);
	inline int show_overexposed(void);
	inline void show_overexposed(int value);
	enum proxy_render_size_enum {
		proxy_render_size_NONE = -1,
		proxy_render_size_SCENE = 0,
		proxy_render_size_PROXY_25 = 25,
		proxy_render_size_PROXY_50 = 50,
		proxy_render_size_PROXY_75 = 75,
		proxy_render_size_PROXY_100 = 99,
		proxy_render_size_FULL = 100,
	};
	inline proxy_render_size_enum proxy_render_size(void);
	inline void proxy_render_size(proxy_render_size_enum value);
	inline GreasePencil grease_pencil(void);
	enum overlay_type_enum {
		overlay_type_RECTANGLE = 0,
		overlay_type_REFERENCE = 1,
		overlay_type_CURRENT = 2,
	};
	inline overlay_type_enum overlay_type(void);
	inline void overlay_type(overlay_type_enum value);
	inline bool show_backdrop(void);
	inline void show_backdrop(bool value);
	inline bool show_strip_offset(void);
	inline void show_strip_offset(bool value);

};

/**************** Space Text Editor ****************/

class SpaceTextEditor : public Space {
public:
	SpaceTextEditor(const PointerRNA &ptr_arg) :
		Space(ptr_arg)
		{}

	inline Text text(void);
	inline bool show_word_wrap(void);
	inline void show_word_wrap(bool value);
	inline bool show_line_numbers(void);
	inline void show_line_numbers(bool value);
	inline bool show_syntax_highlight(void);
	inline void show_syntax_highlight(bool value);
	inline bool show_line_highlight(void);
	inline void show_line_highlight(bool value);
	inline int tab_width(void);
	inline void tab_width(int value);
	inline int font_size(void);
	inline void font_size(int value);
	inline bool show_margin(void);
	inline void show_margin(bool value);
	inline int margin_column(void);
	inline void margin_column(int value);
	inline int top(void);
	inline void top(int value);
	inline int visible_lines(void);
	inline void visible_lines(int value);
	inline bool use_overwrite(void);
	inline void use_overwrite(bool value);
	inline bool use_live_edit(void);
	inline void use_live_edit(bool value);
	inline bool use_find_all(void);
	inline void use_find_all(bool value);
	inline bool use_find_wrap(void);
	inline void use_find_wrap(bool value);
	inline bool use_match_case(void);
	inline void use_match_case(bool value);
	inline std::string find_text(void);
	inline void find_text(const std::string& value);
	inline std::string replace_text(void);
	inline void replace_text(const std::string& value);

	inline void region_location_from_cursor(int line, int column, int result[2]);
};

/**************** File Select Parameters ****************/

class FileSelectParams : public Pointer {
public:
	FileSelectParams(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string title(void);
	inline void title(const std::string& value);
	inline std::string directory(void);
	inline void directory(const std::string& value);
	inline std::string filename(void);
	inline void filename(const std::string& value);
	inline bool use_library_browsing(void);
	inline void use_library_browsing(bool value);
	enum display_type_enum {
		display_type_LIST_SHORT = 1,
		display_type_LIST_LONG = 2,
		display_type_THUMBNAIL = 3,
	};
	inline display_type_enum display_type(void);
	inline void display_type(display_type_enum value);
	enum recursion_level_enum {
		recursion_level_NONE = 0,
		recursion_level_BLEND = 1,
		recursion_level_ALL_1 = 2,
		recursion_level_ALL_2 = 3,
		recursion_level_ALL_3 = 4,
	};
	inline recursion_level_enum recursion_level(void);
	inline void recursion_level(recursion_level_enum value);
	inline bool use_filter(void);
	inline void use_filter(bool value);
	inline bool show_hidden(void);
	inline void show_hidden(bool value);
	enum sort_method_enum {
		sort_method_FILE_SORT_ALPHA = 1,
		sort_method_FILE_SORT_EXTENSION = 2,
		sort_method_FILE_SORT_TIME = 3,
		sort_method_FILE_SORT_SIZE = 4,
	};
	inline sort_method_enum sort_method(void);
	inline void sort_method(sort_method_enum value);
	inline bool use_filter_image(void);
	inline void use_filter_image(bool value);
	inline bool use_filter_blender(void);
	inline void use_filter_blender(bool value);
	inline bool use_filter_backup(void);
	inline void use_filter_backup(bool value);
	inline bool use_filter_movie(void);
	inline void use_filter_movie(bool value);
	inline bool use_filter_script(void);
	inline void use_filter_script(bool value);
	inline bool use_filter_font(void);
	inline void use_filter_font(bool value);
	inline bool use_filter_sound(void);
	inline void use_filter_sound(bool value);
	inline bool use_filter_text(void);
	inline void use_filter_text(bool value);
	inline bool use_filter_folder(void);
	inline void use_filter_folder(bool value);
	inline bool use_filter_blendid(void);
	inline void use_filter_blendid(bool value);
	enum filter_id_enum {
		filter_id_ACTION = 1,
		filter_id_ARMATURE = 2,
		filter_id_BRUSH = 4,
		filter_id_CAMERA = 8,
		filter_id_CACHEFILE = 268435456,
		filter_id_CURVE = 16,
		filter_id_GREASE_PENCIL = 32,
		filter_id_GROUP = 64,
		filter_id_IMAGE = 128,
		filter_id_LIGHT = 256,
		filter_id_LINESTYLE = 512,
		filter_id_LATTICE = 1024,
		filter_id_MATERIAL = 2048,
		filter_id_METABALL = 4096,
		filter_id_MOVIE_CLIP = 8192,
		filter_id_MESH = 16384,
		filter_id_MASK = 32768,
		filter_id_NODE_TREE = 65536,
		filter_id_OBJECT = 131072,
		filter_id_PARTICLE_SETTINGS = 134217728,
		filter_id_PALETTE = 262144,
		filter_id_PAINT_CURVE = 524288,
		filter_id_LIGHT_PROBE = -2147483648,
		filter_id_SCENE = 1048576,
		filter_id_SPEAKER = 2097152,
		filter_id_SOUND = 4194304,
		filter_id_TEXTURE = 8388608,
		filter_id_TEXT = 16777216,
		filter_id_FONT = 33554432,
		filter_id_WORLD = 67108864,
		filter_id_WORK_SPACE = 536870912,
	};
	inline filter_id_enum filter_id(void);
	inline void filter_id(filter_id_enum value);
	enum filter_id_category_enum {
		filter_id_category_SCENE = 1048576,
		filter_id_category_ANIMATION = 1,
		filter_id_category_OBJECT = 131136,
		filter_id_category_GEOMETRY = 21522,
		filter_id_category_SHADING = 8456704,
		filter_id_category_IMAGE = 4235392,
		filter_id_category_ENVIRONMENT = 606077192,
		filter_id_category_MISC = 453771300,
	};
	inline filter_id_category_enum filter_id_category(void);
	inline void filter_id_category(filter_id_category_enum value);
	inline std::string filter_glob(void);
	inline void filter_glob(const std::string& value);
	inline std::string filter_search(void);
	inline void filter_search(const std::string& value);
	enum display_size_enum {
		display_size_TINY = 32,
		display_size_SMALL = 64,
		display_size_NORMAL = 128,
		display_size_LARGE = 256,
	};
	inline display_size_enum display_size(void);
	inline void display_size(display_size_enum value);

};

/**************** File Select Parameters ****************/

class FileBrowserFSMenuEntry : public Pointer {
public:
	FileBrowserFSMenuEntry(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string path(void);
	inline void path(const std::string& value);
	inline std::string name(void);
	inline void name(const std::string& value);
	inline bool use_save(void);
	inline void use_save(bool value);
	inline bool is_valid(void);
	inline void is_valid(bool value);

};

/**************** Space File Browser ****************/

class SpaceFileBrowser : public Space {
public:
	SpaceFileBrowser(const PointerRNA &ptr_arg) :
		Space(ptr_arg),
		system_folders(ptr_arg),
		system_bookmarks(ptr_arg),
		bookmarks(ptr_arg),
		recent_folders(ptr_arg)
		{}

	inline FileSelectParams params(void);
	inline Operator active_operator(void);
	inline Operator operator_value(void);
	COLLECTION_PROPERTY(DefaultCollectionFunctions, FileBrowserFSMenuEntry, SpaceFileBrowser, system_folders, true, false, false)
	inline int system_folders_active(void);
	inline void system_folders_active(int value);
	COLLECTION_PROPERTY(DefaultCollectionFunctions, FileBrowserFSMenuEntry, SpaceFileBrowser, system_bookmarks, true, false, false)
	inline int system_bookmarks_active(void);
	inline void system_bookmarks_active(int value);
	COLLECTION_PROPERTY(DefaultCollectionFunctions, FileBrowserFSMenuEntry, SpaceFileBrowser, bookmarks, true, false, false)
	inline int bookmarks_active(void);
	inline void bookmarks_active(int value);
	COLLECTION_PROPERTY(DefaultCollectionFunctions, FileBrowserFSMenuEntry, SpaceFileBrowser, recent_folders, true, false, false)
	inline int recent_folders_active(void);
	inline void recent_folders_active(int value);

};

/**************** Space Outliner ****************/

class SpaceOutliner : public Space {
public:
	SpaceOutliner(const PointerRNA &ptr_arg) :
		Space(ptr_arg)
		{}

	enum display_mode_enum {
		display_mode_SCENES = 0,
		display_mode_VIEW_LAYER = 15,
		display_mode_SEQUENCE = 10,
		display_mode_LIBRARIES = 7,
		display_mode_DATA_API = 11,
		display_mode_ORPHAN_DATA = 14,
	};
	inline display_mode_enum display_mode(void);
	inline void display_mode(display_mode_enum value);
	inline std::string filter_text(void);
	inline void filter_text(const std::string& value);
	inline bool use_filter_case_sensitive(void);
	inline void use_filter_case_sensitive(bool value);
	inline bool use_filter_complete(void);
	inline void use_filter_complete(bool value);
	inline bool use_sort_alpha(void);
	inline void use_sort_alpha(bool value);
	inline bool show_restrict_columns(void);
	inline void show_restrict_columns(bool value);
	inline bool use_filter_object(void);
	inline void use_filter_object(bool value);
	inline bool use_filter_object_content(void);
	inline void use_filter_object_content(bool value);
	inline bool use_filter_children(void);
	inline void use_filter_children(bool value);
	inline bool use_filter_collection(void);
	inline void use_filter_collection(bool value);
	enum filter_state_enum {
		filter_state_ALL = 0,
		filter_state_VISIBLE = 1,
		filter_state_SELECTED = 2,
		filter_state_ACTIVE = 3,
	};
	inline filter_state_enum filter_state(void);
	inline void filter_state(filter_state_enum value);
	inline bool use_filter_object_mesh(void);
	inline void use_filter_object_mesh(bool value);
	inline bool use_filter_object_armature(void);
	inline void use_filter_object_armature(bool value);
	inline bool use_filter_object_empty(void);
	inline void use_filter_object_empty(bool value);
	inline bool use_filter_object_light(void);
	inline void use_filter_object_light(bool value);
	inline bool use_filter_object_camera(void);
	inline void use_filter_object_camera(bool value);
	inline bool use_filter_object_others(void);
	inline void use_filter_object_others(bool value);
	inline bool use_filter_id_type(void);
	inline void use_filter_id_type(bool value);
	enum filter_id_type_enum {
		filter_id_type_ACTION = 17217,
		filter_id_type_ARMATURE = 21057,
		filter_id_type_BRUSH = 21058,
		filter_id_type_CAMERA = 16707,
		filter_id_type_CACHEFILE = 17987,
		filter_id_type_CURVE = 21827,
		filter_id_type_FONT = 18006,
		filter_id_type_GREASEPENCIL = 17479,
		filter_id_type_COLLECTION = 21063,
		filter_id_type_IMAGE = 19785,
		filter_id_type_KEY = 17739,
		filter_id_type_LIGHT = 16716,
		filter_id_type_LIBRARY = 18764,
		filter_id_type_LINESTYLE = 21324,
		filter_id_type_LATTICE = 21580,
		filter_id_type_MASK = 21325,
		filter_id_type_MATERIAL = 16717,
		filter_id_type_META = 16973,
		filter_id_type_MESH = 17741,
		filter_id_type_MOVIECLIP = 17229,
		filter_id_type_NODETREE = 21582,
		filter_id_type_OBJECT = 16975,
		filter_id_type_PAINTCURVE = 17232,
		filter_id_type_PALETTE = 19536,
		filter_id_type_PARTICLE = 16720,
		filter_id_type_LIGHT_PROBE = 20556,
		filter_id_type_SCENE = 17235,
		filter_id_type_SOUND = 20307,
		filter_id_type_SPEAKER = 19283,
		filter_id_type_TEXT = 22612,
		filter_id_type_TEXTURE = 17748,
		filter_id_type_WINDOWMANAGER = 19799,
		filter_id_type_WORLD = 20311,
		filter_id_type_WORKSPACE = 21335,
	};
	inline filter_id_type_enum filter_id_type(void);
	inline void filter_id_type(filter_id_type_enum value);

};

/**************** 3D View Space ****************/

class SpaceView3D : public Space {
public:
	SpaceView3D(const PointerRNA &ptr_arg) :
		Space(ptr_arg),
		region_quadviews(ptr_arg)
		{}

	inline Object camera(void);
	inline bool use_render_border(void);
	inline void use_render_border(bool value);
	inline float render_border_min_x(void);
	inline void render_border_min_x(float value);
	inline float render_border_min_y(void);
	inline void render_border_min_y(float value);
	inline float render_border_max_x(void);
	inline void render_border_max_x(float value);
	inline float render_border_max_y(void);
	inline void render_border_max_y(float value);
	inline Object lock_object(void);
	inline std::string lock_bone(void);
	inline void lock_bone(const std::string& value);
	inline bool lock_cursor(void);
	inline void lock_cursor(bool value);
	inline SpaceView3D local_view(void);
	inline float lens(void);
	inline void lens(float value);
	inline float clip_start(void);
	inline void clip_start(float value);
	inline float clip_end(void);
	inline void clip_end(float value);
	inline bool lock_camera(void);
	inline void lock_camera(bool value);
	inline bool show_gizmo(void);
	inline void show_gizmo(bool value);
	inline bool show_gizmo_navigate(void);
	inline void show_gizmo_navigate(bool value);
	inline bool show_gizmo_context(void);
	inline void show_gizmo_context(bool value);
	inline bool show_gizmo_tool(void);
	inline void show_gizmo_tool(bool value);
	inline bool use_local_camera(void);
	inline void use_local_camera(bool value);
	inline RegionView3D region_3d(void);
	COLLECTION_PROPERTY(DefaultCollectionFunctions, RegionView3D, SpaceView3D, region_quadviews, false, false, false)
	inline bool show_reconstruction(void);
	inline void show_reconstruction(bool value);
	inline float tracks_display_size(void);
	inline void tracks_display_size(float value);
	enum tracks_display_type_enum {
		tracks_display_type_PLAIN_AXES = 2,
		tracks_display_type_ARROWS = 1,
		tracks_display_type_SINGLE_ARROW = 4,
		tracks_display_type_CIRCLE = 3,
		tracks_display_type_CUBE = 5,
		tracks_display_type_SPHERE = 6,
		tracks_display_type_CONE = 7,
	};
	inline tracks_display_type_enum tracks_display_type(void);
	inline void tracks_display_type(tracks_display_type_enum value);
	inline bool show_camera_path(void);
	inline void show_camera_path(bool value);
	inline bool show_bundle_names(void);
	inline void show_bundle_names(bool value);
	inline GPUFXSettings fx_settings(void);
	enum stereo_3d_eye_enum {
		stereo_3d_eye_LEFT_EYE = 0,
		stereo_3d_eye_RIGHT_EYE = 1,
	};
	inline stereo_3d_eye_enum stereo_3d_eye(void);
	inline void stereo_3d_eye(stereo_3d_eye_enum value);
	enum stereo_3d_camera_enum {
		stereo_3d_camera_LEFT = 0,
		stereo_3d_camera_RIGHT = 1,
		stereo_3d_camera_S3D = 2,
	};
	inline stereo_3d_camera_enum stereo_3d_camera(void);
	inline void stereo_3d_camera(stereo_3d_camera_enum value);
	inline bool show_stereo_3d_cameras(void);
	inline void show_stereo_3d_cameras(bool value);
	inline bool show_stereo_3d_convergence_plane(void);
	inline void show_stereo_3d_convergence_plane(bool value);
	inline float stereo_3d_convergence_plane_alpha(void);
	inline void stereo_3d_convergence_plane_alpha(float value);
	inline bool show_stereo_3d_volume(void);
	inline void show_stereo_3d_volume(bool value);
	inline float stereo_3d_volume_alpha(void);
	inline void stereo_3d_volume_alpha(float value);
	inline bool show_object_viewport_mesh(void);
	inline void show_object_viewport_mesh(bool value);
	inline bool show_object_viewport_curve(void);
	inline void show_object_viewport_curve(bool value);
	inline bool show_object_viewport_surf(void);
	inline void show_object_viewport_surf(bool value);
	inline bool show_object_viewport_meta(void);
	inline void show_object_viewport_meta(bool value);
	inline bool show_object_viewport_font(void);
	inline void show_object_viewport_font(bool value);
	inline bool show_object_viewport_armature(void);
	inline void show_object_viewport_armature(bool value);
	inline bool show_object_viewport_lattice(void);
	inline void show_object_viewport_lattice(bool value);
	inline bool show_object_viewport_empty(void);
	inline void show_object_viewport_empty(bool value);
	inline bool show_object_viewport_grease_pencil(void);
	inline void show_object_viewport_grease_pencil(bool value);
	inline bool show_object_viewport_camera(void);
	inline void show_object_viewport_camera(bool value);
	inline bool show_object_viewport_light(void);
	inline void show_object_viewport_light(bool value);
	inline bool show_object_viewport_speaker(void);
	inline void show_object_viewport_speaker(bool value);
	inline bool show_object_viewport_light_probe(void);
	inline void show_object_viewport_light_probe(bool value);
	inline bool show_object_select_mesh(void);
	inline void show_object_select_mesh(bool value);
	inline bool show_object_select_curve(void);
	inline void show_object_select_curve(bool value);
	inline bool show_object_select_surf(void);
	inline void show_object_select_surf(bool value);
	inline bool show_object_select_meta(void);
	inline void show_object_select_meta(bool value);
	inline bool show_object_select_font(void);
	inline void show_object_select_font(bool value);
	inline bool show_object_select_armature(void);
	inline void show_object_select_armature(bool value);
	inline bool show_object_select_lattice(void);
	inline void show_object_select_lattice(bool value);
	inline bool show_object_select_empty(void);
	inline void show_object_select_empty(bool value);
	inline bool show_object_select_grease_pencil(void);
	inline void show_object_select_grease_pencil(bool value);
	inline bool show_object_select_camera(void);
	inline void show_object_select_camera(bool value);
	inline bool show_object_select_light(void);
	inline void show_object_select_light(bool value);
	inline bool show_object_select_speaker(void);
	inline void show_object_select_speaker(bool value);
	inline bool show_object_select_light_probe(void);
	inline void show_object_select_light_probe(bool value);
	inline int icon_from_show_object_viewport(void);
	inline void icon_from_show_object_viewport(int value);
	inline View3DShading shading(void);
	inline View3DOverlay overlay(void);

};

/**************** 3D View Shading Settings ****************/

class View3DShading : public Pointer {
public:
	View3DShading(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	enum type_enum {
		type_WIREFRAME = 2,
		type_SOLID = 3,
		type_MATERIAL = 4,
		type_RENDERED = 6,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	enum light_enum {
		light_FLAT = 0,
		light_STUDIO = 1,
		light_MATCAP = 2,
	};
	inline light_enum light(void);
	inline void light(light_enum value);
	inline bool show_object_outline(void);
	inline void show_object_outline(bool value);
	enum studio_light_enum {
		studio_light_DEFAULT = 0,
	};
	inline studio_light_enum studio_light(void);
	inline void studio_light(studio_light_enum value);
	inline bool use_world_space_lighting(void);
	inline void use_world_space_lighting(bool value);
	inline bool show_backface_culling(void);
	inline void show_backface_culling(bool value);
	inline bool show_cavity(void);
	inline void show_cavity(bool value);
	enum cavity_type_enum {
		cavity_type_WORLD = 0,
		cavity_type_SCREEN = 1,
		cavity_type_BOTH = 2,
	};
	inline cavity_type_enum cavity_type(void);
	inline void cavity_type(cavity_type_enum value);
	inline float curvature_ridge_factor(void);
	inline void curvature_ridge_factor(float value);
	inline float curvature_valley_factor(void);
	inline void curvature_valley_factor(float value);
	inline float cavity_ridge_factor(void);
	inline void cavity_ridge_factor(float value);
	inline float cavity_valley_factor(void);
	inline void cavity_valley_factor(float value);
	inline StudioLight selected_studio_light(void);
	inline float studiolight_rotate_z(void);
	inline void studiolight_rotate_z(float value);
	enum color_type_enum {
		color_type_SINGLE = 2,
		color_type_MATERIAL = 0,
		color_type_OBJECT = 4,
		color_type_RANDOM = 1,
		color_type_TEXTURE = 3,
	};
	inline color_type_enum color_type(void);
	inline void color_type(color_type_enum value);
	enum wireframe_color_type_enum {
		wireframe_color_type_SINGLE = 2,
		wireframe_color_type_MATERIAL = 0,
		wireframe_color_type_OBJECT = 4,
		wireframe_color_type_RANDOM = 1,
		wireframe_color_type_TEXTURE = 3,
	};
	inline wireframe_color_type_enum wireframe_color_type(void);
	inline void wireframe_color_type(wireframe_color_type_enum value);
	inline Array<float, 3> single_color(void);
	inline void single_color(float values[3]);
	enum background_type_enum {
		background_type_THEME = 0,
		background_type_WORLD = 1,
		background_type_VIEWPORT = 2,
	};
	inline background_type_enum background_type(void);
	inline void background_type(background_type_enum value);
	inline Array<float, 3> background_color(void);
	inline void background_color(float values[3]);
	inline bool show_shadows(void);
	inline void show_shadows(bool value);
	inline bool show_xray(void);
	inline void show_xray(bool value);
	inline bool show_xray_wireframe(void);
	inline void show_xray_wireframe(bool value);
	inline float xray_alpha(void);
	inline void xray_alpha(float value);
	inline float xray_alpha_wireframe(void);
	inline void xray_alpha_wireframe(float value);
	inline bool use_dof(void);
	inline void use_dof(bool value);
	inline bool use_scene_lights(void);
	inline void use_scene_lights(bool value);
	inline bool use_scene_world(void);
	inline void use_scene_world(bool value);
	inline bool show_specular_highlight(void);
	inline void show_specular_highlight(bool value);
	inline Array<float, 3> object_outline_color(void);
	inline void object_outline_color(float values[3]);
	inline float shadow_intensity(void);
	inline void shadow_intensity(float value);
	inline float studiolight_background_alpha(void);
	inline void studiolight_background_alpha(float value);

};

/**************** 3D View Overlay Settings ****************/

class View3DOverlay : public Pointer {
public:
	View3DOverlay(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline bool show_overlays(void);
	inline void show_overlays(bool value);
	inline bool show_floor(void);
	inline void show_floor(bool value);
	inline bool show_axis_x(void);
	inline void show_axis_x(bool value);
	inline bool show_axis_y(void);
	inline void show_axis_y(bool value);
	inline bool show_axis_z(void);
	inline void show_axis_z(bool value);
	inline float grid_scale(void);
	inline void grid_scale(float value);
	inline int grid_lines(void);
	inline void grid_lines(int value);
	inline int grid_subdivisions(void);
	inline void grid_subdivisions(int value);
	inline float grid_scale_unit(void);
	inline void grid_scale_unit(float value);
	inline bool show_outline_selected(void);
	inline void show_outline_selected(bool value);
	inline bool show_object_origins(void);
	inline void show_object_origins(bool value);
	inline bool show_object_origins_all(void);
	inline void show_object_origins_all(bool value);
	inline bool show_relationship_lines(void);
	inline void show_relationship_lines(bool value);
	inline bool show_cursor(void);
	inline void show_cursor(bool value);
	inline bool show_text(void);
	inline void show_text(bool value);
	inline bool show_extras(void);
	inline void show_extras(bool value);
	inline bool show_bones(void);
	inline void show_bones(bool value);
	inline bool show_face_orientation(void);
	inline void show_face_orientation(bool value);
	inline bool show_xray_bone(void);
	inline void show_xray_bone(bool value);
	inline float xray_alpha_bone(void);
	inline void xray_alpha_bone(float value);
	inline bool show_motion_paths(void);
	inline void show_motion_paths(bool value);
	inline bool show_onion_skins(void);
	inline void show_onion_skins(bool value);
	inline bool show_look_dev(void);
	inline void show_look_dev(bool value);
	inline bool show_wireframes(void);
	inline void show_wireframes(bool value);
	inline float wireframe_threshold(void);
	inline void wireframe_threshold(float value);
	inline bool show_paint_wire(void);
	inline void show_paint_wire(bool value);
	inline bool show_wpaint_contours(void);
	inline void show_wpaint_contours(bool value);
	inline bool show_weight(void);
	inline void show_weight(bool value);
	inline bool show_occlude_wire(void);
	inline void show_occlude_wire(bool value);
	inline bool show_face_normals(void);
	inline void show_face_normals(bool value);
	inline bool show_vertex_normals(void);
	inline void show_vertex_normals(bool value);
	inline bool show_split_normals(void);
	inline void show_split_normals(bool value);
	inline bool show_edges(void);
	inline void show_edges(bool value);
	inline bool show_faces(void);
	inline void show_faces(bool value);
	inline bool show_face_center(void);
	inline void show_face_center(bool value);
	inline bool show_edge_crease(void);
	inline void show_edge_crease(bool value);
	inline bool show_edge_bevel_weight(void);
	inline void show_edge_bevel_weight(bool value);
	inline bool show_edge_seams(void);
	inline void show_edge_seams(bool value);
	inline bool show_edge_sharp(void);
	inline void show_edge_sharp(bool value);
	inline bool show_freestyle_edge_marks(void);
	inline void show_freestyle_edge_marks(bool value);
	inline bool show_freestyle_face_marks(void);
	inline void show_freestyle_face_marks(bool value);
	inline bool show_statvis(void);
	inline void show_statvis(bool value);
	inline bool show_extra_edge_length(void);
	inline void show_extra_edge_length(bool value);
	inline bool show_extra_edge_angle(void);
	inline void show_extra_edge_angle(bool value);
	inline bool show_extra_face_angle(void);
	inline void show_extra_face_angle(bool value);
	inline bool show_extra_face_area(void);
	inline void show_extra_face_area(bool value);
	inline bool show_extra_indices(void);
	inline void show_extra_indices(bool value);
	inline bool show_curve_handles(void);
	inline void show_curve_handles(bool value);
	inline bool show_curve_normals(void);
	inline void show_curve_normals(bool value);
	inline float normals_length(void);
	inline void normals_length(float value);
	inline float backwire_opacity(void);
	inline void backwire_opacity(float value);
	inline float texture_paint_mode_opacity(void);
	inline void texture_paint_mode_opacity(float value);
	inline float vertex_paint_mode_opacity(void);
	inline void vertex_paint_mode_opacity(float value);
	inline float weight_paint_mode_opacity(void);
	inline void weight_paint_mode_opacity(float value);
	inline bool show_annotation(void);
	inline void show_annotation(bool value);
	inline bool use_gpencil_paper(void);
	inline void use_gpencil_paper(bool value);
	inline bool use_gpencil_grid(void);
	inline void use_gpencil_grid(bool value);
	inline bool use_gpencil_fade_layers(void);
	inline void use_gpencil_fade_layers(bool value);
	inline float gpencil_grid_opacity(void);
	inline void gpencil_grid_opacity(float value);
	inline float gpencil_paper_opacity(void);
	inline void gpencil_paper_opacity(float value);
	inline float gpencil_fade_layer(void);
	inline void gpencil_fade_layer(float value);
	inline bool use_gpencil_edit_lines(void);
	inline void use_gpencil_edit_lines(bool value);
	inline bool use_gpencil_multiedit_line_only(void);
	inline void use_gpencil_multiedit_line_only(bool value);
	inline bool use_gpencil_onion_skin(void);
	inline void use_gpencil_onion_skin(bool value);
	inline float vertex_opacity(void);
	inline void vertex_opacity(float value);

};

/**************** 3D View Region ****************/

class RegionView3D : public Pointer {
public:
	RegionView3D(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline bool lock_rotation(void);
	inline void lock_rotation(bool value);
	inline bool show_sync_view(void);
	inline void show_sync_view(bool value);
	inline bool use_box_clip(void);
	inline void use_box_clip(bool value);
	inline Array<float, 16> perspective_matrix(void);
	inline void perspective_matrix(float values[16]);
	inline Array<float, 16> window_matrix(void);
	inline void window_matrix(float values[16]);
	inline Array<float, 16> view_matrix(void);
	inline void view_matrix(float values[16]);
	enum view_perspective_enum {
		view_perspective_PERSP = 1,
		view_perspective_ORTHO = 0,
		view_perspective_CAMERA = 2,
	};
	inline view_perspective_enum view_perspective(void);
	inline void view_perspective(view_perspective_enum value);
	inline bool is_perspective(void);
	inline void is_perspective(bool value);
	inline bool use_clip_planes(void);
	inline void use_clip_planes(bool value);
	inline Array<float, 24> clip_planes(void);
	inline void clip_planes(float values[24]);
	inline Array<float, 3> view_location(void);
	inline void view_location(float values[3]);
	inline Array<float, 4> view_rotation(void);
	inline void view_rotation(float values[4]);
	inline float view_distance(void);
	inline void view_distance(float value);
	inline float view_camera_zoom(void);
	inline void view_camera_zoom(float value);
	inline Array<float, 2> view_camera_offset(void);
	inline void view_camera_offset(float values[2]);

	inline void update(Context C);
};

/**************** Properties Space ****************/

class SpaceProperties : public Space {
public:
	SpaceProperties(const PointerRNA &ptr_arg) :
		Space(ptr_arg)
		{}

	enum context_enum {
		context_TOOL = 14,
		context_SCENE = 1,
		context_RENDER = 0,
		context_OUTPUT = 16,
		context_VIEW_LAYER = 13,
		context_WORLD = 2,
		context_OBJECT = 3,
		context_CONSTRAINT = 11,
		context_MODIFIER = 10,
		context_DATA = 4,
		context_BONE = 9,
		context_BONE_CONSTRAINT = 12,
		context_MATERIAL = 5,
		context_TEXTURE = 6,
		context_PARTICLES = 7,
		context_PHYSICS = 8,
		context_SHADERFX = 15,
	};
	inline context_enum context(void);
	inline void context(context_enum value);
	inline ID pin_id(void);
	inline bool use_pin_id(void);
	inline void use_pin_id(bool value);

};

/**************** Space Dope Sheet Editor ****************/

class SpaceDopeSheetEditor : public Space {
public:
	SpaceDopeSheetEditor(const PointerRNA &ptr_arg) :
		Space(ptr_arg)
		{}

	inline Action action(void);
	enum mode_enum {
		mode_DOPESHEET = 3,
		mode_TIMELINE = 6,
		mode_ACTION = 0,
		mode_SHAPEKEY = 1,
		mode_GPENCIL = 2,
		mode_MASK = 4,
		mode_CACHEFILE = 5,
	};
	inline mode_enum mode(void);
	inline void mode(mode_enum value);
	enum ui_mode_enum {
		ui_mode_DOPESHEET = 3,
		ui_mode_ACTION = 0,
		ui_mode_SHAPEKEY = 1,
		ui_mode_GPENCIL = 2,
		ui_mode_MASK = 4,
		ui_mode_CACHEFILE = 5,
	};
	inline ui_mode_enum ui_mode(void);
	inline void ui_mode(ui_mode_enum value);
	inline bool show_seconds(void);
	inline void show_seconds(bool value);
	inline bool show_frame_indicator(void);
	inline void show_frame_indicator(bool value);
	inline bool show_sliders(void);
	inline void show_sliders(bool value);
	inline bool show_pose_markers(void);
	inline void show_pose_markers(bool value);
	inline bool show_group_colors(void);
	inline void show_group_colors(bool value);
	inline bool show_interpolation(void);
	inline void show_interpolation(bool value);
	inline bool show_extremes(void);
	inline void show_extremes(bool value);
	inline bool show_marker_lines(void);
	inline void show_marker_lines(bool value);
	inline bool use_auto_merge_keyframes(void);
	inline void use_auto_merge_keyframes(bool value);
	inline bool use_realtime_update(void);
	inline void use_realtime_update(bool value);
	inline bool use_marker_sync(void);
	inline void use_marker_sync(bool value);
	inline DopeSheet dopesheet(void);
	enum auto_snap_enum {
		auto_snap_NONE = 0,
		auto_snap_STEP = 1,
		auto_snap_TIME_STEP = 5,
		auto_snap_FRAME = 2,
		auto_snap_SECOND = 4,
		auto_snap_MARKER = 3,
	};
	inline auto_snap_enum auto_snap(void);
	inline void auto_snap(auto_snap_enum value);
	inline bool show_cache(void);
	inline void show_cache(bool value);
	inline bool cache_softbody(void);
	inline void cache_softbody(bool value);
	inline bool cache_particles(void);
	inline void cache_particles(bool value);
	inline bool cache_cloth(void);
	inline void cache_cloth(bool value);
	inline bool cache_smoke(void);
	inline void cache_smoke(bool value);
	inline bool cache_dynamicpaint(void);
	inline void cache_dynamicpaint(bool value);
	inline bool cache_rigidbody(void);
	inline void cache_rigidbody(bool value);

};

/**************** Space Graph Editor ****************/

class SpaceGraphEditor : public Space {
public:
	SpaceGraphEditor(const PointerRNA &ptr_arg) :
		Space(ptr_arg)
		{}

	enum mode_enum {
		mode_FCURVES = 0,
		mode_DRIVERS = 1,
	};
	inline mode_enum mode(void);
	inline void mode(mode_enum value);
	inline bool show_seconds(void);
	inline void show_seconds(bool value);
	inline bool show_frame_indicator(void);
	inline void show_frame_indicator(bool value);
	inline bool show_sliders(void);
	inline void show_sliders(bool value);
	inline bool show_handles(void);
	inline void show_handles(bool value);
	inline bool use_only_selected_curves_handles(void);
	inline void use_only_selected_curves_handles(bool value);
	inline bool use_only_selected_keyframe_handles(void);
	inline void use_only_selected_keyframe_handles(bool value);
	inline bool use_beauty_drawing(void);
	inline void use_beauty_drawing(bool value);
	inline bool show_group_colors(void);
	inline void show_group_colors(bool value);
	inline bool show_marker_lines(void);
	inline void show_marker_lines(bool value);
	inline bool use_auto_merge_keyframes(void);
	inline void use_auto_merge_keyframes(bool value);
	inline bool use_realtime_update(void);
	inline void use_realtime_update(bool value);
	inline bool show_cursor(void);
	inline void show_cursor(bool value);
	inline float cursor_position_x(void);
	inline void cursor_position_x(float value);
	inline float cursor_position_y(void);
	inline void cursor_position_y(float value);
	enum pivot_point_enum {
		pivot_point_BOUNDING_BOX_CENTER = 0,
		pivot_point_CURSOR = 1,
		pivot_point_INDIVIDUAL_ORIGINS = 2,
	};
	inline pivot_point_enum pivot_point(void);
	inline void pivot_point(pivot_point_enum value);
	inline DopeSheet dopesheet(void);
	enum auto_snap_enum {
		auto_snap_NONE = 0,
		auto_snap_STEP = 1,
		auto_snap_TIME_STEP = 5,
		auto_snap_FRAME = 2,
		auto_snap_SECOND = 4,
		auto_snap_MARKER = 3,
	};
	inline auto_snap_enum auto_snap(void);
	inline void auto_snap(auto_snap_enum value);
	inline bool has_ghost_curves(void);
	inline void has_ghost_curves(bool value);
	inline bool use_normalization(void);
	inline void use_normalization(bool value);
	inline bool use_auto_normalization(void);
	inline void use_auto_normalization(bool value);

};

/**************** Space Nla Editor ****************/

class SpaceNLA : public Space {
public:
	SpaceNLA(const PointerRNA &ptr_arg) :
		Space(ptr_arg)
		{}

	inline bool show_seconds(void);
	inline void show_seconds(bool value);
	inline bool show_frame_indicator(void);
	inline void show_frame_indicator(bool value);
	inline bool show_strip_curves(void);
	inline void show_strip_curves(bool value);
	inline bool show_local_markers(void);
	inline void show_local_markers(bool value);
	inline bool show_marker_lines(void);
	inline void show_marker_lines(bool value);
	inline bool use_realtime_update(void);
	inline void use_realtime_update(bool value);
	inline DopeSheet dopesheet(void);
	enum auto_snap_enum {
		auto_snap_NONE = 0,
		auto_snap_STEP = 1,
		auto_snap_TIME_STEP = 5,
		auto_snap_FRAME = 2,
		auto_snap_SECOND = 4,
		auto_snap_MARKER = 3,
	};
	inline auto_snap_enum auto_snap(void);
	inline void auto_snap(auto_snap_enum value);

};

/**************** Space Console ****************/

class SpaceConsole : public Space {
public:
	SpaceConsole(const PointerRNA &ptr_arg) :
		Space(ptr_arg),
		history(ptr_arg),
		scrollback(ptr_arg)
		{}

	inline int font_size(void);
	inline void font_size(int value);
	inline int select_start(void);
	inline void select_start(int value);
	inline int select_end(void);
	inline void select_end(int value);
	inline std::string prompt(void);
	inline void prompt(const std::string& value);
	inline std::string language(void);
	inline void language(const std::string& value);
	COLLECTION_PROPERTY(DefaultCollectionFunctions, ConsoleLine, SpaceConsole, history, false, true, false)
	COLLECTION_PROPERTY(DefaultCollectionFunctions, ConsoleLine, SpaceConsole, scrollback, false, true, false)

};

/**************** Console Input ****************/

class ConsoleLine : public Pointer {
public:
	ConsoleLine(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string body(void);
	inline void body(const std::string& value);
	inline int current_character(void);
	inline void current_character(int value);
	enum type_enum {
		type_OUTPUT = 0,
		type_INPUT = 1,
		type_INFO = 2,
		type_ERROR = 3,
	};
	inline type_enum type(void);
	inline void type(type_enum value);

};

/**************** Space Info ****************/

class SpaceInfo : public Space {
public:
	SpaceInfo(const PointerRNA &ptr_arg) :
		Space(ptr_arg)
		{}

	inline bool show_report_debug(void);
	inline void show_report_debug(bool value);
	inline bool show_report_info(void);
	inline void show_report_info(bool value);
	inline bool show_report_operator(void);
	inline void show_report_operator(bool value);
	inline bool show_report_warning(void);
	inline void show_report_warning(bool value);
	inline bool show_report_error(void);
	inline void show_report_error(bool value);

};

/**************** Space Preferences ****************/

class SpacePreferences : public Space {
public:
	SpacePreferences(const PointerRNA &ptr_arg) :
		Space(ptr_arg)
		{}

	enum filter_type_enum {
		filter_type_NAME = 0,
		filter_type_KEY = 1,
	};
	inline filter_type_enum filter_type(void);
	inline void filter_type(filter_type_enum value);
	inline std::string filter_text(void);
	inline void filter_text(const std::string& value);

};

/**************** Node Tree Path ****************/

class NodeTreePath : public Pointer {
public:
	NodeTreePath(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline NodeTree node_tree(void);

};

/**************** Space Node Editor ****************/

class SpaceNodeEditor : public Space {
public:
	SpaceNodeEditor(const PointerRNA &ptr_arg) :
		Space(ptr_arg),
		path(ptr_arg)
		{}

	enum tree_type_enum {
		tree_type_DUMMY = 0,
	};
	inline tree_type_enum tree_type(void);
	inline void tree_type(tree_type_enum value);
	enum texture_type_enum {
		texture_type_WORLD = 1,
		texture_type_BRUSH = 2,
		texture_type_LINESTYLE = 3,
	};
	inline texture_type_enum texture_type(void);
	inline void texture_type(texture_type_enum value);
	enum shader_type_enum {
		shader_type_OBJECT = 0,
		shader_type_WORLD = 1,
		shader_type_LINESTYLE = 2,
	};
	inline shader_type_enum shader_type(void);
	inline void shader_type(shader_type_enum value);
	inline ID id(void);
	inline ID id_from(void);
	COLLECTION_PROPERTY(SpaceNodeEditorPath, NodeTreePath, SpaceNodeEditor, path, false, true, false)
	inline NodeTree node_tree(void);
	inline NodeTree edit_tree(void);
	inline bool pin(void);
	inline void pin(bool value);
	inline bool show_backdrop(void);
	inline void show_backdrop(bool value);
	inline bool show_annotation(void);
	inline void show_annotation(bool value);
	inline bool use_auto_render(void);
	inline void use_auto_render(bool value);
	inline float backdrop_zoom(void);
	inline void backdrop_zoom(float value);
	inline Array<float, 2> backdrop_offset(void);
	inline void backdrop_offset(float values[2]);
	enum backdrop_channels_enum {
		backdrop_channels_COLOR_ALPHA = 8,
		backdrop_channels_COLOR = 0,
		backdrop_channels_ALPHA = 16,
		backdrop_channels_RED = 128,
		backdrop_channels_GREEN = 256,
		backdrop_channels_BLUE = 512,
	};
	inline backdrop_channels_enum backdrop_channels(void);
	inline void backdrop_channels(backdrop_channels_enum value);
	inline Array<float, 2> cursor_location(void);
	inline void cursor_location(float values[2]);
	inline bool use_insert_offset(void);
	inline void use_insert_offset(bool value);
	enum insert_offset_direction_enum {
		insert_offset_direction_RIGHT = 0,
		insert_offset_direction_LEFT = 1,
	};
	inline insert_offset_direction_enum insert_offset_direction(void);
	inline void insert_offset_direction(insert_offset_direction_enum value);

	inline void cursor_location_from_region(Context C, int x, int y);
};

/**************** Space Clip Editor ****************/

class SpaceClipEditor : public Space {
public:
	SpaceClipEditor(const PointerRNA &ptr_arg) :
		Space(ptr_arg)
		{}

	inline MovieClip clip(void);
	inline MovieClipUser clip_user(void);
	inline Mask mask(void);
	enum mask_display_type_enum {
		mask_display_type_OUTLINE = 0,
		mask_display_type_DASH = 1,
		mask_display_type_BLACK = 2,
		mask_display_type_WHITE = 3,
	};
	inline mask_display_type_enum mask_display_type(void);
	inline void mask_display_type(mask_display_type_enum value);
	inline bool show_mask_smooth(void);
	inline void show_mask_smooth(bool value);
	inline bool show_mask_overlay(void);
	inline void show_mask_overlay(bool value);
	enum mask_overlay_mode_enum {
		mask_overlay_mode_ALPHACHANNEL = 0,
		mask_overlay_mode_COMBINED = 1,
	};
	inline mask_overlay_mode_enum mask_overlay_mode(void);
	inline void mask_overlay_mode(mask_overlay_mode_enum value);
	enum mode_enum {
		mode_TRACKING = 0,
		mode_MASK = 3,
	};
	inline mode_enum mode(void);
	inline void mode(mode_enum value);
	enum view_enum {
		view_CLIP = 0,
		view_GRAPH = 1,
		view_DOPESHEET = 2,
	};
	inline view_enum view(void);
	inline void view(view_enum value);
	inline bool show_marker_pattern(void);
	inline void show_marker_pattern(bool value);
	inline bool show_marker_search(void);
	inline void show_marker_search(bool value);
	inline bool lock_selection(void);
	inline void lock_selection(bool value);
	inline bool lock_time_cursor(void);
	inline void lock_time_cursor(bool value);
	inline bool show_track_path(void);
	inline void show_track_path(bool value);
	inline int path_length(void);
	inline void path_length(int value);
	inline bool show_tiny_markers(void);
	inline void show_tiny_markers(bool value);
	inline bool show_bundles(void);
	inline void show_bundles(bool value);
	inline bool use_mute_footage(void);
	inline void use_mute_footage(bool value);
	inline bool show_disabled(void);
	inline void show_disabled(bool value);
	inline bool show_metadata(void);
	inline void show_metadata(bool value);
	inline MovieClipScopes scopes(void);
	inline bool show_names(void);
	inline void show_names(bool value);
	inline bool show_grid(void);
	inline void show_grid(bool value);
	inline bool show_stable(void);
	inline void show_stable(bool value);
	inline bool use_manual_calibration(void);
	inline void use_manual_calibration(bool value);
	inline bool show_annotation(void);
	inline void show_annotation(bool value);
	inline bool show_filters(void);
	inline void show_filters(bool value);
	inline bool show_graph_frames(void);
	inline void show_graph_frames(bool value);
	inline bool show_graph_tracks_motion(void);
	inline void show_graph_tracks_motion(bool value);
	inline bool show_graph_tracks_error(void);
	inline void show_graph_tracks_error(bool value);
	inline bool show_graph_only_selected(void);
	inline void show_graph_only_selected(bool value);
	inline bool show_graph_hidden(void);
	inline void show_graph_hidden(bool value);
	inline bool show_red_channel(void);
	inline void show_red_channel(bool value);
	inline bool show_green_channel(void);
	inline void show_green_channel(bool value);
	inline bool show_blue_channel(void);
	inline void show_blue_channel(bool value);
	inline bool use_grayscale_preview(void);
	inline void use_grayscale_preview(bool value);
	inline bool show_seconds(void);
	inline void show_seconds(bool value);
	enum grease_pencil_source_enum {
		grease_pencil_source_CLIP = 0,
		grease_pencil_source_TRACK = 1,
	};
	inline grease_pencil_source_enum grease_pencil_source(void);
	inline void grease_pencil_source(grease_pencil_source_enum value);
	enum pivot_point_enum {
		pivot_point_BOUNDING_BOX_CENTER = 0,
		pivot_point_CURSOR = 1,
		pivot_point_INDIVIDUAL_ORIGINS = 2,
		pivot_point_MEDIAN_POINT = 3,
	};
	inline pivot_point_enum pivot_point(void);
	inline void pivot_point(pivot_point_enum value);

};

/**************** Speaker ****************/

class Speaker : public ID {
public:
	Speaker(const PointerRNA &ptr_arg) :
		ID(ptr_arg)
		{}

	inline bool muted(void);
	inline void muted(bool value);
	inline Sound sound(void);
	inline float volume_max(void);
	inline void volume_max(float value);
	inline float volume_min(void);
	inline void volume_min(float value);
	inline float distance_max(void);
	inline void distance_max(float value);
	inline float distance_reference(void);
	inline void distance_reference(float value);
	inline float attenuation(void);
	inline void attenuation(float value);
	inline float cone_angle_outer(void);
	inline void cone_angle_outer(float value);
	inline float cone_angle_inner(void);
	inline void cone_angle_inner(float value);
	inline float cone_volume_outer(void);
	inline void cone_volume_outer(float value);
	inline float volume(void);
	inline void volume(float value);
	inline float pitch(void);
	inline void pitch(float value);
	inline AnimData animation_data(void);

};

/**************** Text Line ****************/

class TextLine : public Pointer {
public:
	TextLine(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string body(void);
	inline void body(const std::string& value);

};

/**************** Text ****************/

class Text : public ID {
public:
	Text(const PointerRNA &ptr_arg) :
		ID(ptr_arg),
		lines(ptr_arg)
		{}

	inline std::string filepath(void);
	inline void filepath(const std::string& value);
	inline bool is_dirty(void);
	inline void is_dirty(bool value);
	inline bool is_modified(void);
	inline void is_modified(bool value);
	inline bool is_in_memory(void);
	inline void is_in_memory(bool value);
	inline bool use_module(void);
	inline void use_module(bool value);
	inline bool use_tabs_as_spaces(void);
	inline void use_tabs_as_spaces(bool value);
	COLLECTION_PROPERTY(DefaultCollectionFunctions, TextLine, Text, lines, false, true, false)
	inline TextLine current_line(void);
	inline int current_character(void);
	inline void current_character(int value);
	inline int current_line_index(void);
	inline void current_line_index(int value);
	inline TextLine select_end_line(void);
	inline int select_end_character(void);
	inline void select_end_character(int value);

	inline void clear();
	inline void write(const char * text);
};

/**************** Marker ****************/

class TimelineMarker : public Pointer {
public:
	TimelineMarker(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string name(void);
	inline void name(const std::string& value);
	inline int frame(void);
	inline void frame(int value);
	inline bool select(void);
	inline void select(bool value);
	inline Object camera(void);

};

/**************** Sound ****************/

class Sound : public ID {
public:
	Sound(const PointerRNA &ptr_arg) :
		ID(ptr_arg)
		{}

	inline std::string filepath(void);
	inline void filepath(const std::string& value);
	inline PackedFile packed_file(void);
	inline bool use_memory_cache(void);
	inline void use_memory_cache(bool value);
	inline bool use_mono(void);
	inline void use_mono(bool value);

	inline void pack(void *main);
	inline void unpack(void *main, int method);
};

/**************** UI Layout ****************/

class UILayout : public Pointer {
public:
	UILayout(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline bool active(void);
	inline void active(bool value);
	inline bool active_default(void);
	inline void active_default(bool value);
	inline bool activate_init(void);
	inline void activate_init(bool value);
	enum operator_context_enum {
		operator_context_INVOKE_DEFAULT = 0,
		operator_context_INVOKE_REGION_WIN = 1,
		operator_context_INVOKE_REGION_CHANNELS = 2,
		operator_context_INVOKE_REGION_PREVIEW = 3,
		operator_context_INVOKE_AREA = 4,
		operator_context_INVOKE_SCREEN = 5,
		operator_context_EXEC_DEFAULT = 6,
		operator_context_EXEC_REGION_WIN = 7,
		operator_context_EXEC_REGION_CHANNELS = 8,
		operator_context_EXEC_REGION_PREVIEW = 9,
		operator_context_EXEC_AREA = 10,
		operator_context_EXEC_SCREEN = 11,
	};
	inline operator_context_enum operator_context(void);
	inline void operator_context(operator_context_enum value);
	inline bool enabled(void);
	inline void enabled(bool value);
	inline bool alert(void);
	inline void alert(bool value);
	enum alignment_enum {
		alignment_EXPAND = 0,
		alignment_LEFT = 1,
		alignment_CENTER = 2,
		alignment_RIGHT = 3,
	};
	inline alignment_enum alignment(void);
	inline void alignment(alignment_enum value);
	enum direction_enum {
		direction_HORIZONTAL = 0,
		direction_VERTICAL = 1,
	};
	inline direction_enum direction(void);
	inline void direction(direction_enum value);
	inline float scale_x(void);
	inline void scale_x(float value);
	inline float scale_y(void);
	inline void scale_y(float value);
	inline float ui_units_x(void);
	inline void ui_units_x(float value);
	inline float ui_units_y(void);
	inline void ui_units_y(float value);
	enum emboss_enum {
		emboss_NORMAL = 0,
		emboss_NONE = 1,
		emboss_PULLDOWN_MENU = 2,
		emboss_RADIAL_MENU = 3,
	};
	inline emboss_enum emboss(void);
	inline void emboss(emboss_enum value);
	inline bool use_property_split(void);
	inline void use_property_split(bool value);
	inline bool use_property_decorate(void);
	inline void use_property_decorate(bool value);

	inline UILayout row(bool align);
	inline UILayout column(bool align);
	inline UILayout column_flow(int columns, bool align);
	inline UILayout grid_flow(bool row_major, int columns, bool even_columns, bool even_rows, bool align);
	inline UILayout box();
	inline UILayout split(float factor, bool align);
	inline UILayout menu_pie();
	inline int icon(Context C, AnyType& data);
	inline const char * enum_item_name(Context C, AnyType& data, const char * property, const char * identifier);
	inline const char * enum_item_description(Context C, AnyType& data, const char * property, const char * identifier);
	inline int enum_item_icon(Context C, AnyType& data, const char * property, const char * identifier);
	inline void prop(AnyType& data, const char * property, const char * text, const char * text_ctxt, bool translate, int icon, bool expand, bool slider, bool toggle, bool icon_only, bool event, bool full_event, bool emboss, int index, int icon_value);
	inline void props_enum(AnyType& data, const char * property);
	inline void prop_menu_enum(AnyType& data, const char * property, const char * text, const char * text_ctxt, bool translate, int icon);
	inline void prop_with_popover(AnyType& data, const char * property, const char * text, const char * text_ctxt, bool translate, int icon, bool icon_only, const char * panel);
	inline void prop_with_menu(AnyType& data, const char * property, const char * text, const char * text_ctxt, bool translate, int icon, bool icon_only, const char * menu);
	inline void prop_tabs_enum(Context C, AnyType& data, const char * property, bool icon_only);
	inline void prop_enum(AnyType& data, const char * property, const char * value, const char * text, const char * text_ctxt, bool translate, int icon);
	inline void prop_search(AnyType& data, const char * property, AnyType& search_data, const char * search_property, const char * text, const char * text_ctxt, bool translate, int icon);
	inline OperatorProperties operator_value(const char * operator_value, const char * text, const char * text_ctxt, bool translate, int icon, bool emboss, bool depress, int icon_value);
	inline OperatorProperties operator_menu_hold(const char * operator_value, const char * text, const char * text_ctxt, bool translate, int icon, bool emboss, bool depress, int icon_value, const char * menu);
	inline void operator_enum(const char * operator_value, const char * property);
	inline void operator_menu_enum(Context C, const char * operator_value, const char * property, const char * text, const char * text_ctxt, bool translate, int icon);
	inline void label(const char * text, const char * text_ctxt, bool translate, int icon, int icon_value);
	inline void menu(const char * menu, const char * text, const char * text_ctxt, bool translate, int icon, int icon_value);
	inline void menu_contents(const char * menu);
	inline void popover(Context C, const char * panel, const char * text, const char * text_ctxt, bool translate, int icon, int icon_value);
	inline void popover_group(Context C, int space_type, int region_type, const char * context, const char * category);
	inline void separator(float factor);
	inline void separator_spacer();
	inline void context_pointer_set(const char * name, AnyType& data);
	inline void template_header(Context C);
	inline void template_ID(Context C, AnyType& data, const char * property, const char * create, const char * open, const char * unlink, int filter, bool live_icon);
	inline void template_ID_preview(Context C, AnyType& data, const char * property, const char * create, const char * open, const char * unlink, int rows, int cols, int filter, bool hide_buttons);
	inline void template_any_ID(AnyType& data, const char * property, const char * type_property, const char * text, const char * text_ctxt, bool translate);
	inline void template_ID_tabs(Context C, AnyType& data, const char * property, const char * create, const char * menu, int filter);
	inline void template_search(Context C, AnyType& data, const char * property, AnyType& search_data, const char * search_property, const char * create, const char * unlink);
	inline void template_search_preview(Context C, AnyType& data, const char * property, AnyType& search_data, const char * search_property, const char * create, const char * unlink, int rows, int cols);
	inline void template_path_builder(AnyType& data, const char * property, ID& root, const char * text, const char * text_ctxt, bool translate);
	inline UILayout template_modifier(Context C, Modifier& data);
	inline UILayout template_greasepencil_modifier(Context C, GpencilModifier& data);
	inline UILayout template_shaderfx(Context C, ShaderFx& data);
	inline void template_greasepencil_color(Context C, AnyType& data, const char * property, int rows, int cols, float scale, int filter);
	inline UILayout template_constraint(Constraint& data);
	inline void template_preview(Context C, ID& id, bool show_buttons, ID& parent, TextureSlot& slot, const char * preview_id);
	inline void template_curve_mapping(AnyType& data, const char * property, int type, bool levels, bool brush, bool use_negative_slope, bool show_tone);
	inline void template_color_ramp(AnyType& data, const char * property, bool expand);
	inline void template_icon(int icon_value, float scale);
	inline void template_icon_view(AnyType& data, const char * property, bool show_labels, float scale, float scale_popup);
	inline void template_histogram(AnyType& data, const char * property);
	inline void template_waveform(AnyType& data, const char * property);
	inline void template_vectorscope(AnyType& data, const char * property);
	inline void template_layers(AnyType& data, const char * property, AnyType& used_layers_data, const char * used_layers_property, int active_layer);
	inline void template_color_picker(AnyType& data, const char * property, bool value_slider, bool lock, bool lock_luminosity, bool cubic);
	inline void template_palette(AnyType& data, const char * property, bool color);
	inline void template_image_layers(Context C, Image& image, ImageUser& image_user);
	inline void template_image(Context C, AnyType& data, const char * property, ImageUser& image_user, bool compact, bool multiview);
	inline void template_image_settings(ImageFormatSettings& image_settings, bool color_management);
	inline void template_image_stereo_3d(Stereo3dFormat& stereo_3d_format);
	inline void template_image_views(ImageFormatSettings& image_settings);
	inline void template_movieclip(Context C, AnyType& data, const char * property, bool compact);
	inline void template_track(AnyType& data, const char * property);
	inline void template_marker(AnyType& data, const char * property, MovieClipUser& clip_user, MovieTrackingTrack& track, bool compact);
	inline void template_movieclip_information(AnyType& data, const char * property, MovieClipUser& clip_user);
	inline void template_list(Context C, const char * listtype_name, const char * list_id, AnyType& dataptr, const char * propname, AnyType& active_dataptr, const char * active_propname, const char * item_dyntip_propname, int rows, int maxrows, int type, int columns, bool sort_reverse, bool sort_lock);
	inline void template_running_jobs(Context C);
	inline void template_operator_search();
	inline void template_header_3D_mode(Context C);
	inline void template_edit_mode_selection(Context C);
	inline void template_reports_banner(Context C);
	inline void template_input_status(Context C);
	inline void template_node_link(NodeTree& ntree, Node& node, NodeSocket& socket);
	inline void template_node_view(Context C, NodeTree& ntree, Node& node, NodeSocket& socket);
	inline void template_texture_user(Context C);
	inline void template_keymap_item_properties(KeyMapItem& item);
	inline void template_component_menu(AnyType& data, const char * property, const char * name);
	inline void template_colorspace_settings(AnyType& data, const char * property);
	inline void template_colormanaged_view_settings(Context C, AnyType& data, const char * property);
	inline void template_node_socket(Context C, float color[4]);
	inline void template_cache_file(Context C, AnyType& data, const char * property);
	inline int template_recent_files(int rows);
};

/**************** Panel ****************/

class Panel : public Pointer {
public:
	Panel(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline UILayout layout(void);
	inline std::string text(void);
	inline void text(const std::string& value);
	inline std::string bl_idname(void);
	inline void bl_idname(const std::string& value);
	inline std::string bl_label(void);
	inline void bl_label(const std::string& value);
	inline std::string bl_translation_context(void);
	inline void bl_translation_context(const std::string& value);
	inline std::string bl_category(void);
	inline void bl_category(const std::string& value);
	inline std::string bl_owner_id(void);
	inline void bl_owner_id(const std::string& value);
	enum bl_space_type_enum {
		bl_space_type_EMPTY = 0,
		bl_space_type_VIEW_3D = 1,
		bl_space_type_IMAGE_EDITOR = 6,
		bl_space_type_NODE_EDITOR = 16,
		bl_space_type_SEQUENCE_EDITOR = 8,
		bl_space_type_CLIP_EDITOR = 20,
		bl_space_type_DOPESHEET_EDITOR = 12,
		bl_space_type_GRAPH_EDITOR = 2,
		bl_space_type_NLA_EDITOR = 13,
		bl_space_type_TEXT_EDITOR = 9,
		bl_space_type_CONSOLE = 18,
		bl_space_type_INFO = 7,
		bl_space_type_TOPBAR = 21,
		bl_space_type_STATUSBAR = 22,
		bl_space_type_OUTLINER = 3,
		bl_space_type_PROPERTIES = 4,
		bl_space_type_FILE_BROWSER = 5,
		bl_space_type_PREFERENCES = 19,
	};
	inline bl_space_type_enum bl_space_type(void);
	inline void bl_space_type(bl_space_type_enum value);
	enum bl_region_type_enum {
		bl_region_type_WINDOW = 0,
		bl_region_type_HEADER = 1,
		bl_region_type_CHANNELS = 2,
		bl_region_type_TEMPORARY = 3,
		bl_region_type_UI = 4,
		bl_region_type_TOOLS = 5,
		bl_region_type_TOOL_PROPS = 6,
		bl_region_type_PREVIEW = 7,
		bl_region_type_HUD = 8,
		bl_region_type_NAVIGATION_BAR = 9,
		bl_region_type_EXECUTE = 10,
		bl_region_type_FOOTER = 11,
	};
	inline bl_region_type_enum bl_region_type(void);
	inline void bl_region_type(bl_region_type_enum value);
	inline std::string bl_context(void);
	inline void bl_context(const std::string& value);
	enum bl_options_enum {
		bl_options_DEFAULT_CLOSED = 1,
		bl_options_HIDE_HEADER = 2,
	};
	inline bl_options_enum bl_options(void);
	inline void bl_options(bl_options_enum value);
	inline std::string bl_parent_id(void);
	inline void bl_parent_id(const std::string& value);
	inline int bl_ui_units_x(void);
	inline void bl_ui_units_x(int value);
	inline bool use_pin(void);
	inline void use_pin(bool value);
	inline bool is_popover(void);
	inline void is_popover(bool value);

};

/**************** UIList ****************/

class UIList : public Pointer {
public:
	UIList(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string bl_idname(void);
	inline void bl_idname(const std::string& value);
	enum layout_type_enum {
		layout_type_DEFAULT = 0,
		layout_type_COMPACT = 1,
		layout_type_GRID = 2,
	};
	inline layout_type_enum layout_type(void);
	inline void layout_type(layout_type_enum value);
	inline bool use_filter_show(void);
	inline void use_filter_show(bool value);
	inline std::string filter_name(void);
	inline void filter_name(const std::string& value);
	inline bool use_filter_invert(void);
	inline void use_filter_invert(bool value);
	inline bool use_filter_sort_alpha(void);
	inline void use_filter_sort_alpha(bool value);
	inline bool use_filter_sort_reverse(void);
	inline void use_filter_sort_reverse(bool value);
	inline bool use_filter_sort_lock(void);
	inline void use_filter_sort_lock(bool value);
	inline int bitflag_filter_item(void);
	inline void bitflag_filter_item(int value);

};

/**************** Header ****************/

class Header : public Pointer {
public:
	Header(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline UILayout layout(void);
	inline std::string bl_idname(void);
	inline void bl_idname(const std::string& value);
	enum bl_space_type_enum {
		bl_space_type_EMPTY = 0,
		bl_space_type_VIEW_3D = 1,
		bl_space_type_IMAGE_EDITOR = 6,
		bl_space_type_NODE_EDITOR = 16,
		bl_space_type_SEQUENCE_EDITOR = 8,
		bl_space_type_CLIP_EDITOR = 20,
		bl_space_type_DOPESHEET_EDITOR = 12,
		bl_space_type_GRAPH_EDITOR = 2,
		bl_space_type_NLA_EDITOR = 13,
		bl_space_type_TEXT_EDITOR = 9,
		bl_space_type_CONSOLE = 18,
		bl_space_type_INFO = 7,
		bl_space_type_TOPBAR = 21,
		bl_space_type_STATUSBAR = 22,
		bl_space_type_OUTLINER = 3,
		bl_space_type_PROPERTIES = 4,
		bl_space_type_FILE_BROWSER = 5,
		bl_space_type_PREFERENCES = 19,
	};
	inline bl_space_type_enum bl_space_type(void);
	inline void bl_space_type(bl_space_type_enum value);
	enum bl_region_type_enum {
		bl_region_type_WINDOW = 0,
		bl_region_type_HEADER = 1,
		bl_region_type_CHANNELS = 2,
		bl_region_type_TEMPORARY = 3,
		bl_region_type_UI = 4,
		bl_region_type_TOOLS = 5,
		bl_region_type_TOOL_PROPS = 6,
		bl_region_type_PREVIEW = 7,
		bl_region_type_HUD = 8,
		bl_region_type_NAVIGATION_BAR = 9,
		bl_region_type_EXECUTE = 10,
		bl_region_type_FOOTER = 11,
	};
	inline bl_region_type_enum bl_region_type(void);
	inline void bl_region_type(bl_region_type_enum value);

};

/**************** Menu ****************/

class Menu : public Pointer {
public:
	Menu(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline UILayout layout(void);
	inline std::string bl_idname(void);
	inline void bl_idname(const std::string& value);
	inline std::string bl_label(void);
	inline void bl_label(const std::string& value);
	inline std::string bl_translation_context(void);
	inline void bl_translation_context(const std::string& value);
	inline std::string bl_description(void);
	inline void bl_description(const std::string& value);
	inline std::string bl_owner_id(void);
	inline void bl_owner_id(const std::string& value);

};

/**************** Font Style ****************/

class ThemeFontStyle : public Pointer {
public:
	ThemeFontStyle(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline int points(void);
	inline void points(int value);
	enum font_kerning_style_enum {
		font_kerning_style_UNFITTED = 0,
		font_kerning_style_FITTED = 1,
	};
	inline font_kerning_style_enum font_kerning_style(void);
	inline void font_kerning_style(font_kerning_style_enum value);
	inline int shadow(void);
	inline void shadow(int value);
	inline int shadow_offset_x(void);
	inline void shadow_offset_x(int value);
	inline int shadow_offset_y(void);
	inline void shadow_offset_y(int value);
	inline float shadow_alpha(void);
	inline void shadow_alpha(float value);
	inline float shadow_value(void);
	inline void shadow_value(float value);

};

/**************** Style ****************/

class ThemeStyle : public Pointer {
public:
	ThemeStyle(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline ThemeFontStyle panel_title(void);
	inline ThemeFontStyle widget_label(void);
	inline ThemeFontStyle widget(void);

};

/**************** Theme Widget Color Set ****************/

class ThemeWidgetColors : public Pointer {
public:
	ThemeWidgetColors(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline Array<float, 3> outline(void);
	inline void outline(float values[3]);
	inline Array<float, 4> inner(void);
	inline void inner(float values[4]);
	inline Array<float, 4> inner_sel(void);
	inline void inner_sel(float values[4]);
	inline Array<float, 4> item(void);
	inline void item(float values[4]);
	inline Array<float, 3> text(void);
	inline void text(float values[3]);
	inline Array<float, 3> text_sel(void);
	inline void text_sel(float values[3]);
	inline bool show_shaded(void);
	inline void show_shaded(bool value);
	inline int shadetop(void);
	inline void shadetop(int value);
	inline int shadedown(void);
	inline void shadedown(int value);
	inline float roundness(void);
	inline void roundness(float value);

};

/**************** Theme Widget State Color ****************/

class ThemeWidgetStateColors : public Pointer {
public:
	ThemeWidgetStateColors(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline Array<float, 3> inner_anim(void);
	inline void inner_anim(float values[3]);
	inline Array<float, 3> inner_anim_sel(void);
	inline void inner_anim_sel(float values[3]);
	inline Array<float, 3> inner_key(void);
	inline void inner_key(float values[3]);
	inline Array<float, 3> inner_key_sel(void);
	inline void inner_key_sel(float values[3]);
	inline Array<float, 3> inner_driven(void);
	inline void inner_driven(float values[3]);
	inline Array<float, 3> inner_driven_sel(void);
	inline void inner_driven_sel(float values[3]);
	inline Array<float, 3> inner_overridden(void);
	inline void inner_overridden(float values[3]);
	inline Array<float, 3> inner_overridden_sel(void);
	inline void inner_overridden_sel(float values[3]);
	inline Array<float, 3> inner_changed(void);
	inline void inner_changed(float values[3]);
	inline Array<float, 3> inner_changed_sel(void);
	inline void inner_changed_sel(float values[3]);
	inline float blend(void);
	inline void blend(float value);

};

/**************** Theme Panel Color ****************/

class ThemePanelColors : public Pointer {
public:
	ThemePanelColors(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline Array<float, 4> header(void);
	inline void header(float values[4]);
	inline Array<float, 4> back(void);
	inline void back(float values[4]);
	inline Array<float, 4> sub_back(void);
	inline void sub_back(float values[4]);

};

/**************** Theme Background Color ****************/

class ThemeGradientColors : public Pointer {
public:
	ThemeGradientColors(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline bool show_grad(void);
	inline void show_grad(bool value);
	inline Array<float, 3> high_gradient(void);
	inline void high_gradient(float values[3]);
	inline Array<float, 3> gradient(void);
	inline void gradient(float values[3]);

};

/**************** Theme User Interface ****************/

class ThemeUserInterface : public Pointer {
public:
	ThemeUserInterface(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline ThemeWidgetColors wcol_regular(void);
	inline ThemeWidgetColors wcol_tool(void);
	inline ThemeWidgetColors wcol_toolbar_item(void);
	inline ThemeWidgetColors wcol_radio(void);
	inline ThemeWidgetColors wcol_text(void);
	inline ThemeWidgetColors wcol_option(void);
	inline ThemeWidgetColors wcol_toggle(void);
	inline ThemeWidgetColors wcol_num(void);
	inline ThemeWidgetColors wcol_numslider(void);
	inline ThemeWidgetColors wcol_box(void);
	inline ThemeWidgetColors wcol_menu(void);
	inline ThemeWidgetColors wcol_pulldown(void);
	inline ThemeWidgetColors wcol_menu_back(void);
	inline ThemeWidgetColors wcol_pie_menu(void);
	inline ThemeWidgetColors wcol_tooltip(void);
	inline ThemeWidgetColors wcol_menu_item(void);
	inline ThemeWidgetColors wcol_scroll(void);
	inline ThemeWidgetColors wcol_progress(void);
	inline ThemeWidgetColors wcol_list_item(void);
	inline ThemeWidgetStateColors wcol_state(void);
	inline ThemeWidgetColors wcol_tab(void);
	inline float menu_shadow_fac(void);
	inline void menu_shadow_fac(float value);
	inline int menu_shadow_width(void);
	inline void menu_shadow_width(int value);
	inline float icon_alpha(void);
	inline void icon_alpha(float value);
	inline float icon_saturation(void);
	inline void icon_saturation(float value);
	inline Array<float, 4> widget_emboss(void);
	inline void widget_emboss(float values[4]);
	inline Array<float, 3> editor_outline(void);
	inline void editor_outline(float values[3]);
	inline Array<float, 3> axis_x(void);
	inline void axis_x(float values[3]);
	inline Array<float, 3> axis_y(void);
	inline void axis_y(float values[3]);
	inline Array<float, 3> axis_z(void);
	inline void axis_z(float values[3]);
	inline Array<float, 3> gizmo_hi(void);
	inline void gizmo_hi(float values[3]);
	inline Array<float, 3> gizmo_primary(void);
	inline void gizmo_primary(float values[3]);
	inline Array<float, 3> gizmo_secondary(void);
	inline void gizmo_secondary(float values[3]);
	inline Array<float, 3> gizmo_a(void);
	inline void gizmo_a(float values[3]);
	inline Array<float, 3> gizmo_b(void);
	inline void gizmo_b(float values[3]);
	inline Array<float, 4> icon_collection(void);
	inline void icon_collection(float values[4]);
	inline Array<float, 4> icon_object(void);
	inline void icon_object(float values[4]);
	inline Array<float, 4> icon_object_data(void);
	inline void icon_object_data(float values[4]);
	inline Array<float, 4> icon_modifier(void);
	inline void icon_modifier(float values[4]);
	inline Array<float, 4> icon_shading(void);
	inline void icon_shading(float values[4]);

};

/**************** Theme Space Settings ****************/

class ThemeSpaceGeneric : public Pointer {
public:
	ThemeSpaceGeneric(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline Array<float, 3> back(void);
	inline void back(float values[3]);
	inline Array<float, 3> title(void);
	inline void title(float values[3]);
	inline Array<float, 3> text(void);
	inline void text(float values[3]);
	inline Array<float, 3> text_hi(void);
	inline void text_hi(float values[3]);
	inline Array<float, 4> header(void);
	inline void header(float values[4]);
	inline Array<float, 3> header_text(void);
	inline void header_text(float values[3]);
	inline Array<float, 3> header_text_hi(void);
	inline void header_text_hi(float values[3]);
	inline ThemePanelColors panelcolors(void);
	inline Array<float, 4> button(void);
	inline void button(float values[4]);
	inline Array<float, 3> button_title(void);
	inline void button_title(float values[3]);
	inline Array<float, 3> button_text(void);
	inline void button_text(float values[3]);
	inline Array<float, 3> button_text_hi(void);
	inline void button_text_hi(float values[3]);
	inline Array<float, 4> navigation_bar(void);
	inline void navigation_bar(float values[4]);
	inline Array<float, 4> execution_buts(void);
	inline void execution_buts(float values[4]);
	inline Array<float, 3> tab_active(void);
	inline void tab_active(float values[3]);
	inline Array<float, 3> tab_inactive(void);
	inline void tab_inactive(float values[3]);
	inline Array<float, 4> tab_back(void);
	inline void tab_back(float values[4]);
	inline Array<float, 3> tab_outline(void);
	inline void tab_outline(float values[3]);

};

/**************** Theme Space Settings ****************/

class ThemeSpaceGradient : public Pointer {
public:
	ThemeSpaceGradient(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline ThemeGradientColors gradients(void);
	inline Array<float, 3> title(void);
	inline void title(float values[3]);
	inline Array<float, 3> text(void);
	inline void text(float values[3]);
	inline Array<float, 3> text_hi(void);
	inline void text_hi(float values[3]);
	inline Array<float, 4> header(void);
	inline void header(float values[4]);
	inline Array<float, 3> header_text(void);
	inline void header_text(float values[3]);
	inline Array<float, 3> header_text_hi(void);
	inline void header_text_hi(float values[3]);
	inline ThemePanelColors panelcolors(void);
	inline Array<float, 4> button(void);
	inline void button(float values[4]);
	inline Array<float, 3> button_title(void);
	inline void button_title(float values[3]);
	inline Array<float, 3> button_text(void);
	inline void button_text(float values[3]);
	inline Array<float, 3> button_text_hi(void);
	inline void button_text_hi(float values[3]);
	inline Array<float, 4> navigation_bar(void);
	inline void navigation_bar(float values[4]);
	inline Array<float, 4> execution_buts(void);
	inline void execution_buts(float values[4]);
	inline Array<float, 3> tab_active(void);
	inline void tab_active(float values[3]);
	inline Array<float, 3> tab_inactive(void);
	inline void tab_inactive(float values[3]);
	inline Array<float, 4> tab_back(void);
	inline void tab_back(float values[4]);
	inline Array<float, 3> tab_outline(void);
	inline void tab_outline(float values[3]);

};

/**************** Theme Space List Settings ****************/

class ThemeSpaceListGeneric : public Pointer {
public:
	ThemeSpaceListGeneric(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline Array<float, 3> list(void);
	inline void list(float values[3]);
	inline Array<float, 3> list_title(void);
	inline void list_title(float values[3]);
	inline Array<float, 3> list_text(void);
	inline void list_text(float values[3]);
	inline Array<float, 3> list_text_hi(void);
	inline void list_text_hi(float values[3]);

};

/**************** Theme 3D View ****************/

class ThemeView3D : public Pointer {
public:
	ThemeView3D(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline ThemeSpaceGradient space(void);
	inline Array<float, 4> grid(void);
	inline void grid(float values[4]);
	inline Array<float, 4> clipping_border_3d(void);
	inline void clipping_border_3d(float values[4]);
	inline Array<float, 3> wire(void);
	inline void wire(float values[3]);
	inline Array<float, 3> wire_edit(void);
	inline void wire_edit(float values[3]);
	inline Array<float, 3> gp_vertex(void);
	inline void gp_vertex(float values[3]);
	inline Array<float, 3> gp_vertex_select(void);
	inline void gp_vertex_select(float values[3]);
	inline int gp_vertex_size(void);
	inline void gp_vertex_size(int value);
	inline Array<float, 3> text_grease_pencil(void);
	inline void text_grease_pencil(float values[3]);
	inline Array<float, 3> object_selected(void);
	inline void object_selected(float values[3]);
	inline Array<float, 3> object_active(void);
	inline void object_active(float values[3]);
	inline Array<float, 3> text_keyframe(void);
	inline void text_keyframe(float values[3]);
	inline Array<float, 3> camera(void);
	inline void camera(float values[3]);
	inline Array<float, 3> empty(void);
	inline void empty(float values[3]);
	inline Array<float, 4> light(void);
	inline void light(float values[4]);
	inline Array<float, 3> speaker(void);
	inline void speaker(float values[3]);
	inline Array<float, 3> vertex(void);
	inline void vertex(float values[3]);
	inline Array<float, 3> vertex_select(void);
	inline void vertex_select(float values[3]);
	inline int vertex_size(void);
	inline void vertex_size(int value);
	inline Array<float, 3> vertex_bevel(void);
	inline void vertex_bevel(float values[3]);
	inline Array<float, 3> vertex_unreferenced(void);
	inline void vertex_unreferenced(float values[3]);
	inline Array<float, 3> edge_select(void);
	inline void edge_select(float values[3]);
	inline Array<float, 3> edge_seam(void);
	inline void edge_seam(float values[3]);
	inline Array<float, 3> edge_sharp(void);
	inline void edge_sharp(float values[3]);
	inline Array<float, 3> edge_crease(void);
	inline void edge_crease(float values[3]);
	inline Array<float, 3> edge_bevel(void);
	inline void edge_bevel(float values[3]);
	inline Array<float, 3> edge_facesel(void);
	inline void edge_facesel(float values[3]);
	inline Array<float, 3> freestyle_edge_mark(void);
	inline void freestyle_edge_mark(float values[3]);
	inline Array<float, 4> face(void);
	inline void face(float values[4]);
	inline Array<float, 4> face_select(void);
	inline void face_select(float values[4]);
	inline Array<float, 3> face_dot(void);
	inline void face_dot(float values[3]);
	inline int facedot_size(void);
	inline void facedot_size(int value);
	inline Array<float, 4> freestyle_face_mark(void);
	inline void freestyle_face_mark(float values[4]);
	inline Array<float, 3> nurb_uline(void);
	inline void nurb_uline(float values[3]);
	inline Array<float, 3> nurb_vline(void);
	inline void nurb_vline(float values[3]);
	inline Array<float, 3> nurb_sel_uline(void);
	inline void nurb_sel_uline(float values[3]);
	inline Array<float, 3> nurb_sel_vline(void);
	inline void nurb_sel_vline(float values[3]);
	inline Array<float, 3> act_spline(void);
	inline void act_spline(float values[3]);
	inline Array<float, 3> handle_free(void);
	inline void handle_free(float values[3]);
	inline Array<float, 3> handle_auto(void);
	inline void handle_auto(float values[3]);
	inline Array<float, 3> handle_vect(void);
	inline void handle_vect(float values[3]);
	inline Array<float, 3> handle_sel_vect(void);
	inline void handle_sel_vect(float values[3]);
	inline Array<float, 3> handle_align(void);
	inline void handle_align(float values[3]);
	inline Array<float, 3> handle_sel_free(void);
	inline void handle_sel_free(float values[3]);
	inline Array<float, 3> handle_sel_auto(void);
	inline void handle_sel_auto(float values[3]);
	inline Array<float, 3> handle_sel_align(void);
	inline void handle_sel_align(float values[3]);
	inline Array<float, 3> lastsel_point(void);
	inline void lastsel_point(float values[3]);
	inline Array<float, 3> extra_edge_len(void);
	inline void extra_edge_len(float values[3]);
	inline Array<float, 3> extra_edge_angle(void);
	inline void extra_edge_angle(float values[3]);
	inline Array<float, 3> extra_face_angle(void);
	inline void extra_face_angle(float values[3]);
	inline Array<float, 3> extra_face_area(void);
	inline void extra_face_area(float values[3]);
	inline Array<float, 4> editmesh_active(void);
	inline void editmesh_active(float values[4]);
	inline Array<float, 3> normal(void);
	inline void normal(float values[3]);
	inline Array<float, 3> vertex_normal(void);
	inline void vertex_normal(float values[3]);
	inline Array<float, 3> split_normal(void);
	inline void split_normal(float values[3]);
	inline Array<float, 3> bone_pose(void);
	inline void bone_pose(float values[3]);
	inline Array<float, 3> bone_pose_active(void);
	inline void bone_pose_active(float values[3]);
	inline Array<float, 3> bone_solid(void);
	inline void bone_solid(float values[3]);
	inline Array<float, 3> bundle_solid(void);
	inline void bundle_solid(float values[3]);
	inline Array<float, 3> camera_path(void);
	inline void camera_path(float values[3]);
	inline Array<float, 3> skin_root(void);
	inline void skin_root(float values[3]);
	inline Array<float, 3> view_overlay(void);
	inline void view_overlay(float values[3]);
	inline Array<float, 3> transform(void);
	inline void transform(float values[3]);
	inline Array<float, 3> frame_current(void);
	inline void frame_current(float values[3]);
	inline Array<float, 4> paint_curve_handle(void);
	inline void paint_curve_handle(float values[4]);
	inline Array<float, 4> paint_curve_pivot(void);
	inline void paint_curve_pivot(float values[4]);
	inline int outline_width(void);
	inline void outline_width(int value);

};

/**************** Theme Graph Editor ****************/

class ThemeGraphEditor : public Pointer {
public:
	ThemeGraphEditor(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline ThemeSpaceGeneric space(void);
	inline ThemeSpaceListGeneric space_list(void);
	inline Array<float, 3> grid(void);
	inline void grid(float values[3]);
	inline Array<float, 3> frame_current(void);
	inline void frame_current(float values[3]);
	inline Array<float, 3> window_sliders(void);
	inline void window_sliders(float values[3]);
	inline Array<float, 3> channels_region(void);
	inline void channels_region(float values[3]);
	inline Array<float, 3> dopesheet_channel(void);
	inline void dopesheet_channel(float values[3]);
	inline Array<float, 3> dopesheet_subchannel(void);
	inline void dopesheet_subchannel(float values[3]);
	inline Array<float, 3> channel_group(void);
	inline void channel_group(float values[3]);
	inline Array<float, 3> active_channels_group(void);
	inline void active_channels_group(float values[3]);
	inline Array<float, 4> preview_range(void);
	inline void preview_range(float values[4]);
	inline Array<float, 3> vertex(void);
	inline void vertex(float values[3]);
	inline Array<float, 3> vertex_select(void);
	inline void vertex_select(float values[3]);
	inline int vertex_size(void);
	inline void vertex_size(int value);
	inline Array<float, 3> vertex_bevel(void);
	inline void vertex_bevel(float values[3]);
	inline Array<float, 3> vertex_unreferenced(void);
	inline void vertex_unreferenced(float values[3]);
	inline Array<float, 3> handle_free(void);
	inline void handle_free(float values[3]);
	inline Array<float, 3> handle_auto(void);
	inline void handle_auto(float values[3]);
	inline Array<float, 3> handle_vect(void);
	inline void handle_vect(float values[3]);
	inline Array<float, 3> handle_sel_vect(void);
	inline void handle_sel_vect(float values[3]);
	inline Array<float, 3> handle_align(void);
	inline void handle_align(float values[3]);
	inline Array<float, 3> handle_sel_free(void);
	inline void handle_sel_free(float values[3]);
	inline Array<float, 3> handle_sel_auto(void);
	inline void handle_sel_auto(float values[3]);
	inline Array<float, 3> handle_sel_align(void);
	inline void handle_sel_align(float values[3]);
	inline Array<float, 3> handle_auto_clamped(void);
	inline void handle_auto_clamped(float values[3]);
	inline Array<float, 3> handle_sel_auto_clamped(void);
	inline void handle_sel_auto_clamped(float values[3]);
	inline Array<float, 3> lastsel_point(void);
	inline void lastsel_point(float values[3]);
	inline Array<float, 3> handle_vertex(void);
	inline void handle_vertex(float values[3]);
	inline Array<float, 3> handle_vertex_select(void);
	inline void handle_vertex_select(float values[3]);
	inline int handle_vertex_size(void);
	inline void handle_vertex_size(int value);

};

/**************** Theme File Browser ****************/

class ThemeFileBrowser : public Pointer {
public:
	ThemeFileBrowser(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline ThemeSpaceGeneric space(void);
	inline Array<float, 3> selected_file(void);
	inline void selected_file(float values[3]);

};

/**************** Theme Nonlinear Animation ****************/

class ThemeNLAEditor : public Pointer {
public:
	ThemeNLAEditor(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline ThemeSpaceGeneric space(void);
	inline ThemeSpaceListGeneric space_list(void);
	inline Array<float, 3> grid(void);
	inline void grid(float values[3]);
	inline Array<float, 3> view_sliders(void);
	inline void view_sliders(float values[3]);
	inline Array<float, 4> active_action(void);
	inline void active_action(float values[4]);
	inline Array<float, 4> active_action_unset(void);
	inline void active_action_unset(float values[4]);
	inline Array<float, 4> preview_range(void);
	inline void preview_range(float values[4]);
	inline Array<float, 3> strips(void);
	inline void strips(float values[3]);
	inline Array<float, 3> strips_selected(void);
	inline void strips_selected(float values[3]);
	inline Array<float, 3> transition_strips(void);
	inline void transition_strips(float values[3]);
	inline Array<float, 3> transition_strips_selected(void);
	inline void transition_strips_selected(float values[3]);
	inline Array<float, 3> meta_strips(void);
	inline void meta_strips(float values[3]);
	inline Array<float, 3> meta_strips_selected(void);
	inline void meta_strips_selected(float values[3]);
	inline Array<float, 3> sound_strips(void);
	inline void sound_strips(float values[3]);
	inline Array<float, 3> sound_strips_selected(void);
	inline void sound_strips_selected(float values[3]);
	inline Array<float, 3> tweak(void);
	inline void tweak(float values[3]);
	inline Array<float, 3> tweak_duplicate(void);
	inline void tweak_duplicate(float values[3]);
	inline Array<float, 4> keyframe_border(void);
	inline void keyframe_border(float values[4]);
	inline Array<float, 4> keyframe_border_selected(void);
	inline void keyframe_border_selected(float values[4]);
	inline Array<float, 3> frame_current(void);
	inline void frame_current(float values[3]);

};

/**************** Theme Dope Sheet ****************/

class ThemeDopeSheet : public Pointer {
public:
	ThemeDopeSheet(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline ThemeSpaceGeneric space(void);
	inline ThemeSpaceListGeneric space_list(void);
	inline Array<float, 3> grid(void);
	inline void grid(float values[3]);
	inline Array<float, 3> frame_current(void);
	inline void frame_current(float values[3]);
	inline Array<float, 3> value_sliders(void);
	inline void value_sliders(float values[3]);
	inline Array<float, 3> view_sliders(void);
	inline void view_sliders(float values[3]);
	inline Array<float, 4> dopesheet_channel(void);
	inline void dopesheet_channel(float values[4]);
	inline Array<float, 4> dopesheet_subchannel(void);
	inline void dopesheet_subchannel(float values[4]);
	inline Array<float, 4> channels(void);
	inline void channels(float values[4]);
	inline Array<float, 4> channels_selected(void);
	inline void channels_selected(float values[4]);
	inline Array<float, 4> channel_group(void);
	inline void channel_group(float values[4]);
	inline Array<float, 4> active_channels_group(void);
	inline void active_channels_group(float values[4]);
	inline Array<float, 4> long_key(void);
	inline void long_key(float values[4]);
	inline Array<float, 4> long_key_selected(void);
	inline void long_key_selected(float values[4]);
	inline Array<float, 3> keyframe(void);
	inline void keyframe(float values[3]);
	inline Array<float, 3> keyframe_selected(void);
	inline void keyframe_selected(float values[3]);
	inline Array<float, 3> keyframe_extreme(void);
	inline void keyframe_extreme(float values[3]);
	inline Array<float, 3> keyframe_extreme_selected(void);
	inline void keyframe_extreme_selected(float values[3]);
	inline Array<float, 3> keyframe_breakdown(void);
	inline void keyframe_breakdown(float values[3]);
	inline Array<float, 3> keyframe_breakdown_selected(void);
	inline void keyframe_breakdown_selected(float values[3]);
	inline Array<float, 3> keyframe_jitter(void);
	inline void keyframe_jitter(float values[3]);
	inline Array<float, 3> keyframe_jitter_selected(void);
	inline void keyframe_jitter_selected(float values[3]);
	inline Array<float, 3> keyframe_movehold(void);
	inline void keyframe_movehold(float values[3]);
	inline Array<float, 3> keyframe_movehold_selected(void);
	inline void keyframe_movehold_selected(float values[3]);
	inline Array<float, 4> keyframe_border(void);
	inline void keyframe_border(float values[4]);
	inline Array<float, 4> keyframe_border_selected(void);
	inline void keyframe_border_selected(float values[4]);
	inline float keyframe_scale_factor(void);
	inline void keyframe_scale_factor(float value);
	inline Array<float, 4> summary(void);
	inline void summary(float values[4]);
	inline Array<float, 4> preview_range(void);
	inline void preview_range(float values[4]);
	inline Array<float, 4> interpolation_line(void);
	inline void interpolation_line(float values[4]);

};

/**************** Theme Image Editor ****************/

class ThemeImageEditor : public Pointer {
public:
	ThemeImageEditor(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline ThemeSpaceGeneric space(void);
	inline Array<float, 3> gp_vertex(void);
	inline void gp_vertex(float values[3]);
	inline Array<float, 3> gp_vertex_select(void);
	inline void gp_vertex_select(float values[3]);
	inline int gp_vertex_size(void);
	inline void gp_vertex_size(int value);
	inline Array<float, 3> vertex(void);
	inline void vertex(float values[3]);
	inline Array<float, 3> vertex_select(void);
	inline void vertex_select(float values[3]);
	inline int vertex_size(void);
	inline void vertex_size(int value);
	inline Array<float, 3> vertex_bevel(void);
	inline void vertex_bevel(float values[3]);
	inline Array<float, 3> vertex_unreferenced(void);
	inline void vertex_unreferenced(float values[3]);
	inline Array<float, 4> face(void);
	inline void face(float values[4]);
	inline Array<float, 4> face_select(void);
	inline void face_select(float values[4]);
	inline Array<float, 3> face_dot(void);
	inline void face_dot(float values[3]);
	inline int facedot_size(void);
	inline void facedot_size(int value);
	inline Array<float, 4> freestyle_face_mark(void);
	inline void freestyle_face_mark(float values[4]);
	inline Array<float, 4> editmesh_active(void);
	inline void editmesh_active(float values[4]);
	inline Array<float, 3> wire_edit(void);
	inline void wire_edit(float values[3]);
	inline Array<float, 3> edge_select(void);
	inline void edge_select(float values[3]);
	inline Array<float, 4> scope_back(void);
	inline void scope_back(float values[4]);
	inline Array<float, 4> preview_stitch_face(void);
	inline void preview_stitch_face(float values[4]);
	inline Array<float, 4> preview_stitch_edge(void);
	inline void preview_stitch_edge(float values[4]);
	inline Array<float, 4> preview_stitch_vert(void);
	inline void preview_stitch_vert(float values[4]);
	inline Array<float, 4> preview_stitch_stitchable(void);
	inline void preview_stitch_stitchable(float values[4]);
	inline Array<float, 4> preview_stitch_unstitchable(void);
	inline void preview_stitch_unstitchable(float values[4]);
	inline Array<float, 4> preview_stitch_active(void);
	inline void preview_stitch_active(float values[4]);
	inline Array<float, 4> uv_shadow(void);
	inline void uv_shadow(float values[4]);
	inline Array<float, 4> uv_others(void);
	inline void uv_others(float values[4]);
	inline Array<float, 3> frame_current(void);
	inline void frame_current(float values[3]);
	inline Array<float, 3> metadatabg(void);
	inline void metadatabg(float values[3]);
	inline Array<float, 3> metadatatext(void);
	inline void metadatatext(float values[3]);
	inline Array<float, 3> handle_free(void);
	inline void handle_free(float values[3]);
	inline Array<float, 3> handle_auto(void);
	inline void handle_auto(float values[3]);
	inline Array<float, 3> handle_align(void);
	inline void handle_align(float values[3]);
	inline Array<float, 3> handle_sel_free(void);
	inline void handle_sel_free(float values[3]);
	inline Array<float, 3> handle_sel_auto(void);
	inline void handle_sel_auto(float values[3]);
	inline Array<float, 3> handle_sel_align(void);
	inline void handle_sel_align(float values[3]);
	inline Array<float, 3> handle_auto_clamped(void);
	inline void handle_auto_clamped(float values[3]);
	inline Array<float, 3> handle_sel_auto_clamped(void);
	inline void handle_sel_auto_clamped(float values[3]);
	inline Array<float, 3> handle_vertex(void);
	inline void handle_vertex(float values[3]);
	inline Array<float, 3> handle_vertex_select(void);
	inline void handle_vertex_select(float values[3]);
	inline int handle_vertex_size(void);
	inline void handle_vertex_size(int value);
	inline Array<float, 4> paint_curve_handle(void);
	inline void paint_curve_handle(float values[4]);
	inline Array<float, 4> paint_curve_pivot(void);
	inline void paint_curve_pivot(float values[4]);

};

/**************** Theme Sequence Editor ****************/

class ThemeSequenceEditor : public Pointer {
public:
	ThemeSequenceEditor(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline ThemeSpaceGeneric space(void);
	inline Array<float, 3> gp_vertex(void);
	inline void gp_vertex(float values[3]);
	inline Array<float, 3> gp_vertex_select(void);
	inline void gp_vertex_select(float values[3]);
	inline int gp_vertex_size(void);
	inline void gp_vertex_size(int value);
	inline Array<float, 3> grid(void);
	inline void grid(float values[3]);
	inline Array<float, 3> window_sliders(void);
	inline void window_sliders(float values[3]);
	inline Array<float, 3> movie_strip(void);
	inline void movie_strip(float values[3]);
	inline Array<float, 3> movieclip_strip(void);
	inline void movieclip_strip(float values[3]);
	inline Array<float, 3> image_strip(void);
	inline void image_strip(float values[3]);
	inline Array<float, 3> scene_strip(void);
	inline void scene_strip(float values[3]);
	inline Array<float, 3> audio_strip(void);
	inline void audio_strip(float values[3]);
	inline Array<float, 3> effect_strip(void);
	inline void effect_strip(float values[3]);
	inline Array<float, 3> transition_strip(void);
	inline void transition_strip(float values[3]);
	inline Array<float, 3> meta_strip(void);
	inline void meta_strip(float values[3]);
	inline Array<float, 3> text_strip(void);
	inline void text_strip(float values[3]);
	inline Array<float, 3> frame_current(void);
	inline void frame_current(float values[3]);
	inline Array<float, 3> keyframe(void);
	inline void keyframe(float values[3]);
	inline Array<float, 3> draw_action(void);
	inline void draw_action(float values[3]);
	inline Array<float, 3> preview_back(void);
	inline void preview_back(float values[3]);
	inline Array<float, 3> metadatabg(void);
	inline void metadatabg(float values[3]);
	inline Array<float, 3> metadatatext(void);
	inline void metadatatext(float values[3]);

};

/**************** Theme Properties ****************/

class ThemeProperties : public Pointer {
public:
	ThemeProperties(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline ThemeSpaceGeneric space(void);

};

/**************** Theme Text Editor ****************/

class ThemeTextEditor : public Pointer {
public:
	ThemeTextEditor(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline ThemeSpaceGeneric space(void);
	inline Array<float, 3> line_numbers_background(void);
	inline void line_numbers_background(float values[3]);
	inline Array<float, 3> selected_text(void);
	inline void selected_text(float values[3]);
	inline Array<float, 3> cursor(void);
	inline void cursor(float values[3]);
	inline Array<float, 3> syntax_builtin(void);
	inline void syntax_builtin(float values[3]);
	inline Array<float, 3> syntax_symbols(void);
	inline void syntax_symbols(float values[3]);
	inline Array<float, 3> syntax_special(void);
	inline void syntax_special(float values[3]);
	inline Array<float, 3> syntax_preprocessor(void);
	inline void syntax_preprocessor(float values[3]);
	inline Array<float, 3> syntax_reserved(void);
	inline void syntax_reserved(float values[3]);
	inline Array<float, 3> syntax_comment(void);
	inline void syntax_comment(float values[3]);
	inline Array<float, 3> syntax_string(void);
	inline void syntax_string(float values[3]);
	inline Array<float, 3> syntax_numbers(void);
	inline void syntax_numbers(float values[3]);

};

/**************** Theme Node Editor ****************/

class ThemeNodeEditor : public Pointer {
public:
	ThemeNodeEditor(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline ThemeSpaceGeneric space(void);
	inline ThemeSpaceListGeneric space_list(void);
	inline Array<float, 3> gp_vertex(void);
	inline void gp_vertex(float values[3]);
	inline Array<float, 3> gp_vertex_select(void);
	inline void gp_vertex_select(float values[3]);
	inline int gp_vertex_size(void);
	inline void gp_vertex_size(int value);
	inline Array<float, 3> node_selected(void);
	inline void node_selected(float values[3]);
	inline Array<float, 3> node_active(void);
	inline void node_active(float values[3]);
	inline Array<float, 3> wire(void);
	inline void wire(float values[3]);
	inline Array<float, 3> wire_inner(void);
	inline void wire_inner(float values[3]);
	inline Array<float, 3> wire_select(void);
	inline void wire_select(float values[3]);
	inline Array<float, 3> selected_text(void);
	inline void selected_text(float values[3]);
	inline Array<float, 4> node_backdrop(void);
	inline void node_backdrop(float values[4]);
	inline Array<float, 3> converter_node(void);
	inline void converter_node(float values[3]);
	inline Array<float, 3> color_node(void);
	inline void color_node(float values[3]);
	inline Array<float, 4> group_node(void);
	inline void group_node(float values[4]);
	inline Array<float, 3> group_socket_node(void);
	inline void group_socket_node(float values[3]);
	inline Array<float, 4> frame_node(void);
	inline void frame_node(float values[4]);
	inline Array<float, 3> matte_node(void);
	inline void matte_node(float values[3]);
	inline Array<float, 3> distor_node(void);
	inline void distor_node(float values[3]);
	inline int noodle_curving(void);
	inline void noodle_curving(int value);
	inline Array<float, 3> input_node(void);
	inline void input_node(float values[3]);
	inline Array<float, 3> output_node(void);
	inline void output_node(float values[3]);
	inline Array<float, 3> filter_node(void);
	inline void filter_node(float values[3]);
	inline Array<float, 3> vector_node(void);
	inline void vector_node(float values[3]);
	inline Array<float, 3> texture_node(void);
	inline void texture_node(float values[3]);
	inline Array<float, 3> shader_node(void);
	inline void shader_node(float values[3]);
	inline Array<float, 3> script_node(void);
	inline void script_node(float values[3]);
	inline Array<float, 3> pattern_node(void);
	inline void pattern_node(float values[3]);
	inline Array<float, 3> layout_node(void);
	inline void layout_node(float values[3]);

};

/**************** Theme Outliner ****************/

class ThemeOutliner : public Pointer {
public:
	ThemeOutliner(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline ThemeSpaceGeneric space(void);
	inline Array<float, 3> match(void);
	inline void match(float values[3]);
	inline Array<float, 3> selected_highlight(void);
	inline void selected_highlight(float values[3]);

};

/**************** Theme Info ****************/

class ThemeInfo : public Pointer {
public:
	ThemeInfo(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline ThemeSpaceGeneric space(void);
	inline Array<float, 3> info_selected(void);
	inline void info_selected(float values[3]);
	inline Array<float, 3> info_selected_text(void);
	inline void info_selected_text(float values[3]);
	inline Array<float, 3> info_error(void);
	inline void info_error(float values[3]);
	inline Array<float, 3> info_error_text(void);
	inline void info_error_text(float values[3]);
	inline Array<float, 3> info_warning(void);
	inline void info_warning(float values[3]);
	inline Array<float, 3> info_warning_text(void);
	inline void info_warning_text(float values[3]);
	inline Array<float, 3> info_info(void);
	inline void info_info(float values[3]);
	inline Array<float, 3> info_info_text(void);
	inline void info_info_text(float values[3]);
	inline Array<float, 3> info_debug(void);
	inline void info_debug(float values[3]);
	inline Array<float, 3> info_debug_text(void);
	inline void info_debug_text(float values[3]);

};

/**************** Theme Preferences ****************/

class ThemePreferences : public Pointer {
public:
	ThemePreferences(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline ThemeSpaceGeneric space(void);

};

/**************** Theme Console ****************/

class ThemeConsole : public Pointer {
public:
	ThemeConsole(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline ThemeSpaceGeneric space(void);
	inline Array<float, 3> line_output(void);
	inline void line_output(float values[3]);
	inline Array<float, 3> line_input(void);
	inline void line_input(float values[3]);
	inline Array<float, 3> line_info(void);
	inline void line_info(float values[3]);
	inline Array<float, 3> line_error(void);
	inline void line_error(float values[3]);
	inline Array<float, 3> cursor(void);
	inline void cursor(float values[3]);
	inline Array<float, 4> select(void);
	inline void select(float values[4]);

};

/**************** Theme Clip Editor ****************/

class ThemeClipEditor : public Pointer {
public:
	ThemeClipEditor(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline ThemeSpaceGeneric space(void);
	inline ThemeSpaceListGeneric space_list(void);
	inline Array<float, 3> gp_vertex(void);
	inline void gp_vertex(float values[3]);
	inline Array<float, 3> gp_vertex_select(void);
	inline void gp_vertex_select(float values[3]);
	inline int gp_vertex_size(void);
	inline void gp_vertex_size(int value);
	inline Array<float, 3> marker_outline(void);
	inline void marker_outline(float values[3]);
	inline Array<float, 3> marker(void);
	inline void marker(float values[3]);
	inline Array<float, 3> active_marker(void);
	inline void active_marker(float values[3]);
	inline Array<float, 3> selected_marker(void);
	inline void selected_marker(float values[3]);
	inline Array<float, 3> disabled_marker(void);
	inline void disabled_marker(float values[3]);
	inline Array<float, 3> locked_marker(void);
	inline void locked_marker(float values[3]);
	inline Array<float, 3> path_before(void);
	inline void path_before(float values[3]);
	inline Array<float, 3> path_after(void);
	inline void path_after(float values[3]);
	inline Array<float, 3> frame_current(void);
	inline void frame_current(float values[3]);
	inline Array<float, 3> strips(void);
	inline void strips(float values[3]);
	inline Array<float, 3> strips_selected(void);
	inline void strips_selected(float values[3]);
	inline Array<float, 3> metadatabg(void);
	inline void metadatabg(float values[3]);
	inline Array<float, 3> metadatatext(void);
	inline void metadatatext(float values[3]);
	inline Array<float, 3> handle_free(void);
	inline void handle_free(float values[3]);
	inline Array<float, 3> handle_auto(void);
	inline void handle_auto(float values[3]);
	inline Array<float, 3> handle_align(void);
	inline void handle_align(float values[3]);
	inline Array<float, 3> handle_sel_free(void);
	inline void handle_sel_free(float values[3]);
	inline Array<float, 3> handle_sel_auto(void);
	inline void handle_sel_auto(float values[3]);
	inline Array<float, 3> handle_sel_align(void);
	inline void handle_sel_align(float values[3]);
	inline Array<float, 3> handle_auto_clamped(void);
	inline void handle_auto_clamped(float values[3]);
	inline Array<float, 3> handle_sel_auto_clamped(void);
	inline void handle_sel_auto_clamped(float values[3]);
	inline Array<float, 3> handle_vertex(void);
	inline void handle_vertex(float values[3]);
	inline Array<float, 3> handle_vertex_select(void);
	inline void handle_vertex_select(float values[3]);
	inline int handle_vertex_size(void);
	inline void handle_vertex_size(int value);

};

/**************** Theme Top Bar ****************/

class ThemeTopBar : public Pointer {
public:
	ThemeTopBar(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline ThemeSpaceGeneric space(void);

};

/**************** Theme Status Bar ****************/

class ThemeStatusBar : public Pointer {
public:
	ThemeStatusBar(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline ThemeSpaceGeneric space(void);

};

/**************** Theme Bone Color Set ****************/

class ThemeBoneColorSet : public Pointer {
public:
	ThemeBoneColorSet(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline Array<float, 3> normal(void);
	inline void normal(float values[3]);
	inline Array<float, 3> select(void);
	inline void select(float values[3]);
	inline Array<float, 3> active(void);
	inline void active(float values[3]);
	inline bool show_colored_constraints(void);
	inline void show_colored_constraints(bool value);

};

/**************** Theme ****************/

class Theme : public Pointer {
public:
	Theme(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		bone_color_sets(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string name(void);
	inline void name(const std::string& value);
	enum theme_area_enum {
		theme_area_USER_INTERFACE = 0,
		theme_area_STYLE = 19,
		theme_area_BONE_COLOR_SETS = 18,
		theme_area_VIEW_3D = 1,
		theme_area_GRAPH_EDITOR = 3,
		theme_area_DOPESHEET_EDITOR = 4,
		theme_area_NLA_EDITOR = 5,
		theme_area_IMAGE_EDITOR = 6,
		theme_area_SEQUENCE_EDITOR = 7,
		theme_area_TEXT_EDITOR = 8,
		theme_area_NODE_EDITOR = 9,
		theme_area_PROPERTIES = 11,
		theme_area_OUTLINER = 12,
		theme_area_PREFERENCES = 14,
		theme_area_INFO = 15,
		theme_area_FILE_BROWSER = 16,
		theme_area_CONSOLE = 17,
		theme_area_CLIP_EDITOR = 20,
		theme_area_TOPBAR = 21,
		theme_area_STATUSBAR = 22,
	};
	inline theme_area_enum theme_area(void);
	inline void theme_area(theme_area_enum value);
	inline ThemeUserInterface user_interface(void);
	inline ThemeView3D view_3d(void);
	inline ThemeGraphEditor graph_editor(void);
	inline ThemeFileBrowser file_browser(void);
	inline ThemeNLAEditor nla_editor(void);
	inline ThemeDopeSheet dopesheet_editor(void);
	inline ThemeImageEditor image_editor(void);
	inline ThemeSequenceEditor sequence_editor(void);
	inline ThemeProperties properties(void);
	inline ThemeTextEditor text_editor(void);
	inline ThemeNodeEditor node_editor(void);
	inline ThemeOutliner outliner(void);
	inline ThemeInfo info(void);
	inline ThemePreferences preferences(void);
	inline ThemeConsole console(void);
	inline ThemeClipEditor clip_editor(void);
	inline ThemeTopBar topbar(void);
	inline ThemeStatusBar statusbar(void);
	COLLECTION_PROPERTY(DefaultCollectionFunctions, ThemeBoneColorSet, Theme, bone_color_sets, true, true, false)

};

/**************** Solid Light ****************/

class UserSolidLight : public Pointer {
public:
	UserSolidLight(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline bool use(void);
	inline void use(bool value);
	inline float smooth(void);
	inline void smooth(float value);
	inline Array<float, 3> direction(void);
	inline void direction(float values[3]);
	inline Array<float, 3> specular_color(void);
	inline void specular_color(float values[3]);
	inline Array<float, 3> diffuse_color(void);
	inline void diffuse_color(float values[3]);

};

/**************** Walk Navigation ****************/

class WalkNavigation : public Pointer {
public:
	WalkNavigation(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline float mouse_speed(void);
	inline void mouse_speed(float value);
	inline float walk_speed(void);
	inline void walk_speed(float value);
	inline float walk_speed_factor(void);
	inline void walk_speed_factor(float value);
	inline float view_height(void);
	inline void view_height(float value);
	inline float jump_height(void);
	inline void jump_height(float value);
	inline float teleport_time(void);
	inline void teleport_time(float value);
	inline bool use_gravity(void);
	inline void use_gravity(bool value);
	inline bool use_mouse_reverse(void);
	inline void use_mouse_reverse(bool value);

};

/**************** Preferences ****************/

class Preferences : public Pointer {
public:
	Preferences(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		themes(ptr_arg),
		ui_styles(ptr_arg),
		addons(ptr_arg),
		autoexec_paths(ptr_arg),
		studio_lights(ptr_arg)
		{}

	inline Struct rna_type(void);
	enum active_section_enum {
		active_section_INTERFACE = 0,
		active_section_THEMES = 4,
		active_section_VIEWPORT = 12,
		active_section_LIGHTS = 7,
		active_section_EDITING = 1,
		active_section_ANIMATION = 13,
		active_section_ADDONS = 6,
		active_section_INPUT = 5,
		active_section_NAVIGATION = 14,
		active_section_KEYMAP = 8,
		active_section_SYSTEM = 3,
		active_section_SAVE_LOAD = 2,
		active_section_FILE_PATHS = 15,
	};
	inline active_section_enum active_section(void);
	inline void active_section(active_section_enum value);
	inline std::string app_template(void);
	inline void app_template(const std::string& value);
	COLLECTION_PROPERTY(DefaultCollectionFunctions, Theme, Preferences, themes, false, true, true)
	COLLECTION_PROPERTY(DefaultCollectionFunctions, ThemeStyle, Preferences, ui_styles, false, true, false)
	COLLECTION_PROPERTY(Addons, Addon, Preferences, addons, false, true, true)
	COLLECTION_PROPERTY(PathCompareCollection, PathCompare, Preferences, autoexec_paths, false, true, true)
	inline PreferencesView view(void);
	inline PreferencesEdit edit(void);
	inline PreferencesInput inputs(void);
	inline PreferencesKeymap keymap(void);
	inline PreferencesFilePaths filepaths(void);
	inline PreferencesSystem system(void);
	inline Array<int, 3> version(void);
	inline void version(int values[3]);
	COLLECTION_PROPERTY(StudioLights, StudioLight, Preferences, studio_lights, false, false, false)

};

/**************** View & Controls ****************/

class PreferencesView : public Pointer {
public:
	PreferencesView(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline float ui_scale(void);
	inline void ui_scale(float value);
	enum ui_line_width_enum {
		ui_line_width_THIN = -1,
		ui_line_width_AUTO = 0,
		ui_line_width_THICK = 1,
	};
	inline ui_line_width_enum ui_line_width(void);
	inline void ui_line_width(ui_line_width_enum value);
	inline bool show_tooltips(void);
	inline void show_tooltips(bool value);
	inline bool show_tooltips_python(void);
	inline void show_tooltips_python(bool value);
	inline bool show_developer_ui(void);
	inline void show_developer_ui(bool value);
	inline bool show_object_info(void);
	inline void show_object_info(bool value);
	inline bool show_large_cursors(void);
	inline void show_large_cursors(bool value);
	inline bool show_view_name(void);
	inline void show_view_name(bool value);
	inline bool show_splash(void);
	inline void show_splash(bool value);
	inline bool show_playback_fps(void);
	inline void show_playback_fps(bool value);
	enum factor_display_type_enum {
		factor_display_type_FACTOR = 0,
		factor_display_type_PERCENTAGE = 1,
	};
	inline factor_display_type_enum factor_display_type(void);
	inline void factor_display_type(factor_display_type_enum value);
	inline bool use_weight_color_range(void);
	inline void use_weight_color_range(bool value);
	inline ColorRamp weight_color_range(void);
	inline bool show_layout_ui(void);
	inline void show_layout_ui(bool value);
	inline bool use_mouse_over_open(void);
	inline void use_mouse_over_open(bool value);
	inline int open_toplevel_delay(void);
	inline void open_toplevel_delay(int value);
	inline int open_sublevel_delay(void);
	inline void open_sublevel_delay(int value);
	enum color_picker_type_enum {
		color_picker_type_CIRCLE_HSV = 0,
		color_picker_type_CIRCLE_HSL = 4,
		color_picker_type_SQUARE_SV = 1,
		color_picker_type_SQUARE_HS = 2,
		color_picker_type_SQUARE_HV = 3,
	};
	inline color_picker_type_enum color_picker_type(void);
	inline void color_picker_type(color_picker_type_enum value);
	inline int pie_initial_timeout(void);
	inline void pie_initial_timeout(int value);
	inline int pie_tap_timeout(void);
	inline void pie_tap_timeout(int value);
	inline int pie_animation_timeout(void);
	inline void pie_animation_timeout(int value);
	inline int pie_menu_radius(void);
	inline void pie_menu_radius(int value);
	inline int pie_menu_threshold(void);
	inline void pie_menu_threshold(int value);
	inline int pie_menu_confirm(void);
	inline void pie_menu_confirm(int value);
	inline bool use_save_prompt(void);
	inline void use_save_prompt(bool value);
	inline bool show_column_layout(void);
	inline void show_column_layout(bool value);
	inline bool use_directional_menus(void);
	inline void use_directional_menus(bool value);
	enum header_align_enum {
		header_align_NONE = 0,
		header_align_TOP = 256,
		header_align_BOTTOM = 384,
	};
	inline header_align_enum header_align(void);
	inline void header_align(header_align_enum value);
	enum mini_axis_type_enum {
		mini_axis_type_MINIMAL = 0,
		mini_axis_type_GIZMO = 131072,
	};
	inline mini_axis_type_enum mini_axis_type(void);
	inline void mini_axis_type(mini_axis_type_enum value);
	inline int mini_axis_size(void);
	inline void mini_axis_size(int value);
	inline int mini_axis_brightness(void);
	inline void mini_axis_brightness(int value);
	inline int smooth_view(void);
	inline void smooth_view(int value);
	inline float rotation_angle(void);
	inline void rotation_angle(float value);
	inline bool show_gizmo(void);
	inline void show_gizmo(bool value);
	inline int gizmo_size(void);
	inline void gizmo_size(int value);
	inline int object_origin_size(void);
	inline void object_origin_size(int value);
	inline int view2d_grid_spacing_min(void);
	inline void view2d_grid_spacing_min(int value);
	enum timecode_style_enum {
		timecode_style_MINIMAL = 0,
		timecode_style_SMPTE = 2,
		timecode_style_SMPTE_COMPACT = 1,
		timecode_style_MILLISECONDS = 3,
		timecode_style_SECONDS_ONLY = 4,
	};
	inline timecode_style_enum timecode_style(void);
	inline void timecode_style(timecode_style_enum value);
	enum view_frame_type_enum {
		view_frame_type_KEEP_RANGE = 0,
		view_frame_type_SECONDS = 1,
		view_frame_type_KEYFRAMES = 2,
	};
	inline view_frame_type_enum view_frame_type(void);
	inline void view_frame_type(view_frame_type_enum value);
	inline int view_frame_keyframes(void);
	inline void view_frame_keyframes(int value);
	inline float view_frame_seconds(void);
	inline void view_frame_seconds(float value);
	inline bool use_text_antialiasing(void);
	inline void use_text_antialiasing(bool value);
	enum text_hinting_enum {
		text_hinting_AUTO = 0,
		text_hinting_NONE = 2,
		text_hinting_SLIGHT = 4,
		text_hinting_FULL = 8,
	};
	inline text_hinting_enum text_hinting(void);
	inline void text_hinting(text_hinting_enum value);
	inline std::string font_path_ui(void);
	inline void font_path_ui(const std::string& value);
	inline std::string font_path_ui_mono(void);
	inline void font_path_ui_mono(const std::string& value);
	inline bool use_international_fonts(void);
	inline void use_international_fonts(bool value);
	enum language_enum {
		language_DEFAULT = 0,
	};
	inline language_enum language(void);
	inline void language(language_enum value);
	inline bool use_translate_tooltips(void);
	inline void use_translate_tooltips(bool value);
	inline bool use_translate_interface(void);
	inline void use_translate_interface(bool value);
	inline bool use_translate_new_dataname(void);
	inline void use_translate_new_dataname(bool value);

};

/**************** Edit Methods ****************/

class PreferencesEdit : public Pointer {
public:
	PreferencesEdit(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	enum material_link_enum {
		material_link_OBDATA = 0,
		material_link_OBJECT = 256,
	};
	inline material_link_enum material_link(void);
	inline void material_link(material_link_enum value);
	enum object_align_enum {
		object_align_WORLD = 0,
		object_align_VIEW = 524288,
	};
	inline object_align_enum object_align(void);
	inline void object_align(object_align_enum value);
	inline bool use_enter_edit_mode(void);
	inline void use_enter_edit_mode(bool value);
	inline int undo_steps(void);
	inline void undo_steps(int value);
	inline int undo_memory_limit(void);
	inline void undo_memory_limit(int value);
	inline bool use_global_undo(void);
	inline void use_global_undo(bool value);
	inline bool use_auto_keying(void);
	inline void use_auto_keying(bool value);
	enum auto_keying_mode_enum {
		auto_keying_mode_ADD_REPLACE_KEYS = 3,
		auto_keying_mode_REPLACE_KEYS = 5,
	};
	inline auto_keying_mode_enum auto_keying_mode(void);
	inline void auto_keying_mode(auto_keying_mode_enum value);
	inline bool use_keyframe_insert_available(void);
	inline void use_keyframe_insert_available(bool value);
	inline bool use_auto_keying_warning(void);
	inline void use_auto_keying_warning(bool value);
	inline bool use_keyframe_insert_needed(void);
	inline void use_keyframe_insert_needed(bool value);
	inline bool use_visual_keying(void);
	inline void use_visual_keying(bool value);
	inline bool use_insertkey_xyz_to_rgb(void);
	inline void use_insertkey_xyz_to_rgb(bool value);
	enum keyframe_new_interpolation_type_enum {
		keyframe_new_interpolation_type_CONSTANT = 0,
		keyframe_new_interpolation_type_LINEAR = 1,
		keyframe_new_interpolation_type_BEZIER = 2,
		keyframe_new_interpolation_type_SINE = 12,
		keyframe_new_interpolation_type_QUAD = 9,
		keyframe_new_interpolation_type_CUBIC = 6,
		keyframe_new_interpolation_type_QUART = 10,
		keyframe_new_interpolation_type_QUINT = 11,
		keyframe_new_interpolation_type_EXPO = 8,
		keyframe_new_interpolation_type_CIRC = 5,
		keyframe_new_interpolation_type_BACK = 3,
		keyframe_new_interpolation_type_BOUNCE = 4,
		keyframe_new_interpolation_type_ELASTIC = 7,
	};
	inline keyframe_new_interpolation_type_enum keyframe_new_interpolation_type(void);
	inline void keyframe_new_interpolation_type(keyframe_new_interpolation_type_enum value);
	enum keyframe_new_handle_type_enum {
		keyframe_new_handle_type_FREE = 0,
		keyframe_new_handle_type_ALIGNED = 3,
		keyframe_new_handle_type_VECTOR = 2,
		keyframe_new_handle_type_AUTO = 1,
		keyframe_new_handle_type_AUTO_CLAMPED = 4,
	};
	inline keyframe_new_handle_type_enum keyframe_new_handle_type(void);
	inline void keyframe_new_handle_type(keyframe_new_handle_type_enum value);
	inline bool use_negative_frames(void);
	inline void use_negative_frames(bool value);
	inline float fcurve_unselected_alpha(void);
	inline void fcurve_unselected_alpha(float value);
	inline int grease_pencil_manhattan_distance(void);
	inline void grease_pencil_manhattan_distance(int value);
	inline int grease_pencil_euclidean_distance(void);
	inline void grease_pencil_euclidean_distance(int value);
	inline bool use_grease_pencil_simplify_stroke(void);
	inline void use_grease_pencil_simplify_stroke(bool value);
	inline int grease_pencil_eraser_radius(void);
	inline void grease_pencil_eraser_radius(int value);
	inline Array<float, 4> grease_pencil_default_color(void);
	inline void grease_pencil_default_color(float values[4]);
	inline Array<float, 3> sculpt_paint_overlay_color(void);
	inline void sculpt_paint_overlay_color(float values[3]);
	inline bool use_duplicate_mesh(void);
	inline void use_duplicate_mesh(bool value);
	inline bool use_duplicate_surface(void);
	inline void use_duplicate_surface(bool value);
	inline bool use_duplicate_curve(void);
	inline void use_duplicate_curve(bool value);
	inline bool use_duplicate_text(void);
	inline void use_duplicate_text(bool value);
	inline bool use_duplicate_metaball(void);
	inline void use_duplicate_metaball(bool value);
	inline bool use_duplicate_armature(void);
	inline void use_duplicate_armature(bool value);
	inline bool use_duplicate_light(void);
	inline void use_duplicate_light(bool value);
	inline bool use_duplicate_material(void);
	inline void use_duplicate_material(bool value);
	inline bool use_duplicate_texture(void);
	inline void use_duplicate_texture(bool value);
	inline bool use_duplicate_fcurve(void);
	inline void use_duplicate_fcurve(bool value);
	inline bool use_duplicate_action(void);
	inline void use_duplicate_action(bool value);
	inline bool use_duplicate_particle(void);
	inline void use_duplicate_particle(bool value);
	inline int node_margin(void);
	inline void node_margin(int value);
	inline bool use_cursor_lock_adjust(void);
	inline void use_cursor_lock_adjust(bool value);
	inline bool use_mouse_depth_cursor(void);
	inline void use_mouse_depth_cursor(bool value);

};

/**************** Input ****************/

class PreferencesInput : public Pointer {
public:
	PreferencesInput(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	enum view_zoom_method_enum {
		view_zoom_method_CONTINUE = 0,
		view_zoom_method_DOLLY = 2,
		view_zoom_method_SCALE = 1,
	};
	inline view_zoom_method_enum view_zoom_method(void);
	inline void view_zoom_method(view_zoom_method_enum value);
	enum view_zoom_axis_enum {
		view_zoom_axis_VERTICAL = 0,
		view_zoom_axis_HORIZONTAL = 67108864,
	};
	inline view_zoom_axis_enum view_zoom_axis(void);
	inline void view_zoom_axis(view_zoom_axis_enum value);
	inline bool invert_mouse_zoom(void);
	inline void invert_mouse_zoom(bool value);
	inline bool use_mouse_depth_navigate(void);
	inline void use_mouse_depth_navigate(bool value);
	inline bool use_camera_lock_parent(void);
	inline void use_camera_lock_parent(bool value);
	inline bool use_zoom_to_mouse(void);
	inline void use_zoom_to_mouse(bool value);
	inline bool use_auto_perspective(void);
	inline void use_auto_perspective(bool value);
	inline bool use_rotate_around_active(void);
	inline void use_rotate_around_active(bool value);
	enum view_rotate_method_enum {
		view_rotate_method_TURNTABLE = 0,
		view_rotate_method_TRACKBALL = 32,
	};
	inline view_rotate_method_enum view_rotate_method(void);
	inline void view_rotate_method(view_rotate_method_enum value);
	inline bool use_mouse_continuous(void);
	inline void use_mouse_continuous(bool value);
	inline bool use_drag_immediately(void);
	inline void use_drag_immediately(bool value);
	inline bool use_numeric_input_advanced(void);
	inline void use_numeric_input_advanced(bool value);
	enum navigation_mode_enum {
		navigation_mode_WALK = 0,
		navigation_mode_FLY = 1,
	};
	inline navigation_mode_enum navigation_mode(void);
	inline void navigation_mode(navigation_mode_enum value);
	inline WalkNavigation walk_navigation(void);
	inline int drag_threshold(void);
	inline void drag_threshold(int value);
	inline int move_threshold(void);
	inline void move_threshold(int value);
	inline float pressure_threshold_max(void);
	inline void pressure_threshold_max(float value);
	inline float pressure_softness(void);
	inline void pressure_softness(float value);
	enum tablet_api_enum {
		tablet_api_AUTOMATIC = 0,
		tablet_api_WINDOWS_INK = 1,
		tablet_api_WINTAB = 2,
	};
	inline tablet_api_enum tablet_api(void);
	inline void tablet_api(tablet_api_enum value);
	inline float ndof_sensitivity(void);
	inline void ndof_sensitivity(float value);
	inline float ndof_orbit_sensitivity(void);
	inline void ndof_orbit_sensitivity(float value);
	inline float ndof_deadzone(void);
	inline void ndof_deadzone(float value);
	inline bool ndof_pan_yz_swap_axis(void);
	inline void ndof_pan_yz_swap_axis(bool value);
	inline bool ndof_zoom_invert(void);
	inline void ndof_zoom_invert(bool value);
	inline bool ndof_show_guide(void);
	inline void ndof_show_guide(bool value);
	enum ndof_view_navigate_method_enum {
		ndof_view_navigate_method_FREE = 0,
		ndof_view_navigate_method_ORBIT = 64,
	};
	inline ndof_view_navigate_method_enum ndof_view_navigate_method(void);
	inline void ndof_view_navigate_method(ndof_view_navigate_method_enum value);
	enum ndof_view_rotate_method_enum {
		ndof_view_rotate_method_TURNTABLE = 32768,
		ndof_view_rotate_method_TRACKBALL = 0,
	};
	inline ndof_view_rotate_method_enum ndof_view_rotate_method(void);
	inline void ndof_view_rotate_method(ndof_view_rotate_method_enum value);
	inline bool ndof_rotx_invert_axis(void);
	inline void ndof_rotx_invert_axis(bool value);
	inline bool ndof_roty_invert_axis(void);
	inline void ndof_roty_invert_axis(bool value);
	inline bool ndof_rotz_invert_axis(void);
	inline void ndof_rotz_invert_axis(bool value);
	inline bool ndof_panx_invert_axis(void);
	inline void ndof_panx_invert_axis(bool value);
	inline bool ndof_pany_invert_axis(void);
	inline void ndof_pany_invert_axis(bool value);
	inline bool ndof_panz_invert_axis(void);
	inline void ndof_panz_invert_axis(bool value);
	inline bool ndof_lock_horizon(void);
	inline void ndof_lock_horizon(bool value);
	inline bool ndof_fly_helicopter(void);
	inline void ndof_fly_helicopter(bool value);
	inline int mouse_double_click_time(void);
	inline void mouse_double_click_time(int value);
	inline bool use_mouse_emulate_3_button(void);
	inline void use_mouse_emulate_3_button(bool value);
	inline bool use_emulate_numpad(void);
	inline void use_emulate_numpad(bool value);
	inline bool invert_zoom_wheel(void);
	inline void invert_zoom_wheel(bool value);
	inline int wheel_scroll_lines(void);
	inline void wheel_scroll_lines(int value);
	inline bool use_trackpad_natural(void);
	inline void use_trackpad_natural(bool value);

};

/**************** Keymap ****************/

class PreferencesKeymap : public Pointer {
public:
	PreferencesKeymap(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline bool show_ui_keyconfig(void);
	inline void show_ui_keyconfig(bool value);
	inline std::string active_keyconfig(void);
	inline void active_keyconfig(const std::string& value);

};

/**************** File Paths ****************/

class PreferencesFilePaths : public Pointer {
public:
	PreferencesFilePaths(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline bool show_hidden_files_datablocks(void);
	inline void show_hidden_files_datablocks(bool value);
	inline bool use_filter_files(void);
	inline void use_filter_files(bool value);
	inline bool hide_recent_locations(void);
	inline void hide_recent_locations(bool value);
	inline bool hide_system_bookmarks(void);
	inline void hide_system_bookmarks(bool value);
	inline bool show_thumbnails(void);
	inline void show_thumbnails(bool value);
	inline bool use_relative_paths(void);
	inline void use_relative_paths(bool value);
	inline bool use_file_compression(void);
	inline void use_file_compression(bool value);
	inline bool use_load_ui(void);
	inline void use_load_ui(bool value);
	inline bool use_scripts_auto_execute(void);
	inline void use_scripts_auto_execute(bool value);
	inline bool use_tabs_as_spaces(void);
	inline void use_tabs_as_spaces(bool value);
	inline std::string font_directory(void);
	inline void font_directory(const std::string& value);
	inline std::string texture_directory(void);
	inline void texture_directory(const std::string& value);
	inline std::string render_output_directory(void);
	inline void render_output_directory(const std::string& value);
	inline std::string script_directory(void);
	inline void script_directory(const std::string& value);
	inline std::string i18n_branches_directory(void);
	inline void i18n_branches_directory(const std::string& value);
	inline std::string sound_directory(void);
	inline void sound_directory(const std::string& value);
	inline std::string temporary_directory(void);
	inline void temporary_directory(const std::string& value);
	inline std::string render_cache_directory(void);
	inline void render_cache_directory(const std::string& value);
	inline std::string image_editor(void);
	inline void image_editor(const std::string& value);
	inline std::string animation_player(void);
	inline void animation_player(const std::string& value);
	enum animation_player_preset_enum {
		animation_player_preset_INTERNAL = 0,
		animation_player_preset_DJV = 2,
		animation_player_preset_FRAMECYCLER = 3,
		animation_player_preset_RV = 4,
		animation_player_preset_MPLAYER = 5,
		animation_player_preset_CUSTOM = 50,
	};
	inline animation_player_preset_enum animation_player_preset(void);
	inline void animation_player_preset(animation_player_preset_enum value);
	inline int save_version(void);
	inline void save_version(int value);
	inline bool use_auto_save_temporary_files(void);
	inline void use_auto_save_temporary_files(bool value);
	inline int auto_save_time(void);
	inline void auto_save_time(int value);
	inline int recent_files(void);
	inline void recent_files(int value);
	inline bool use_save_preview_images(void);
	inline void use_save_preview_images(bool value);

};

/**************** System & OpenGL ****************/

class PreferencesSystem : public Pointer {
public:
	PreferencesSystem(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		solid_lights(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline float ui_scale(void);
	inline void ui_scale(float value);
	inline float ui_line_width(void);
	inline void ui_line_width(float value);
	inline int dpi(void);
	inline void dpi(int value);
	inline float pixel_size(void);
	inline void pixel_size(float value);
	inline int prefetch_frames(void);
	inline void prefetch_frames(int value);
	inline int memory_cache_limit(void);
	inline void memory_cache_limit(int value);
	inline int scrollback(void);
	inline void scrollback(int value);
	enum multi_sample_enum {
		multi_sample_NONE = 0,
		multi_sample_2 = 2,
		multi_sample_4 = 4,
		multi_sample_8 = 8,
		multi_sample_16 = 16,
	};
	inline multi_sample_enum multi_sample(void);
	inline void multi_sample(multi_sample_enum value);
	inline bool use_edit_mode_smooth_wire(void);
	inline void use_edit_mode_smooth_wire(bool value);
	enum gpencil_multi_sample_enum {
		gpencil_multi_sample_NONE = 0,
		gpencil_multi_sample_2 = 2,
		gpencil_multi_sample_4 = 4,
		gpencil_multi_sample_8 = 8,
		gpencil_multi_sample_16 = 16,
	};
	inline gpencil_multi_sample_enum gpencil_multi_sample(void);
	inline void gpencil_multi_sample(gpencil_multi_sample_enum value);
	inline bool use_region_overlap(void);
	inline void use_region_overlap(bool value);
	inline float gpu_viewport_quality(void);
	inline void gpu_viewport_quality(float value);
	COLLECTION_PROPERTY(DefaultCollectionFunctions, UserSolidLight, PreferencesSystem, solid_lights, true, true, false)
	inline Array<float, 3> light_ambient(void);
	inline void light_ambient(float values[3]);
	inline bool use_studio_light_edit(void);
	inline void use_studio_light_edit(bool value);
	inline float gl_clip_alpha(void);
	inline void gl_clip_alpha(float value);
	enum image_draw_method_enum {
		image_draw_method_2DTEXTURE = 2,
		image_draw_method_GLSL = 1,
		image_draw_method_DRAWPIXELS = 3,
	};
	inline image_draw_method_enum image_draw_method(void);
	inline void image_draw_method(image_draw_method_enum value);
	enum anisotropic_filter_enum {
		anisotropic_filter_FILTER_0 = 1,
		anisotropic_filter_FILTER_2 = 2,
		anisotropic_filter_FILTER_4 = 4,
		anisotropic_filter_FILTER_8 = 8,
		anisotropic_filter_FILTER_16 = 16,
	};
	inline anisotropic_filter_enum anisotropic_filter(void);
	inline void anisotropic_filter(anisotropic_filter_enum value);
	enum gl_texture_limit_enum {
		gl_texture_limit_CLAMP_OFF = 0,
		gl_texture_limit_CLAMP_8192 = 8192,
		gl_texture_limit_CLAMP_4096 = 4096,
		gl_texture_limit_CLAMP_2048 = 2048,
		gl_texture_limit_CLAMP_1024 = 1024,
		gl_texture_limit_CLAMP_512 = 512,
		gl_texture_limit_CLAMP_256 = 256,
		gl_texture_limit_CLAMP_128 = 128,
	};
	inline gl_texture_limit_enum gl_texture_limit(void);
	inline void gl_texture_limit(gl_texture_limit_enum value);
	inline int texture_time_out(void);
	inline void texture_time_out(int value);
	inline int texture_collection_rate(void);
	inline void texture_collection_rate(int value);
	inline bool use_select_pick_depth(void);
	inline void use_select_pick_depth(bool value);
	enum audio_mixing_buffer_enum {
		audio_mixing_buffer_SAMPLES_256 = 256,
		audio_mixing_buffer_SAMPLES_512 = 512,
		audio_mixing_buffer_SAMPLES_1024 = 1024,
		audio_mixing_buffer_SAMPLES_2048 = 2048,
		audio_mixing_buffer_SAMPLES_4096 = 4096,
		audio_mixing_buffer_SAMPLES_8192 = 8192,
		audio_mixing_buffer_SAMPLES_16384 = 16384,
		audio_mixing_buffer_SAMPLES_32768 = 32768,
	};
	inline audio_mixing_buffer_enum audio_mixing_buffer(void);
	inline void audio_mixing_buffer(audio_mixing_buffer_enum value);
	enum audio_device_enum {
		audio_device_Null = 0,
	};
	inline audio_device_enum audio_device(void);
	inline void audio_device(audio_device_enum value);
	enum audio_sample_rate_enum {
		audio_sample_rate_RATE_44100 = 44100,
		audio_sample_rate_RATE_48000 = 48000,
		audio_sample_rate_RATE_96000 = 96000,
		audio_sample_rate_RATE_192000 = 192000,
	};
	inline audio_sample_rate_enum audio_sample_rate(void);
	inline void audio_sample_rate(audio_sample_rate_enum value);
	enum audio_sample_format_enum {
		audio_sample_format_U8 = 1,
		audio_sample_format_S16 = 18,
		audio_sample_format_S24 = 19,
		audio_sample_format_S32 = 20,
		audio_sample_format_FLOAT = 36,
		audio_sample_format_DOUBLE = 40,
	};
	inline audio_sample_format_enum audio_sample_format(void);
	inline void audio_sample_format(audio_sample_format_enum value);
	enum audio_channels_enum {
		audio_channels_MONO = 1,
		audio_channels_STEREO = 2,
		audio_channels_SURROUND4 = 4,
		audio_channels_SURROUND51 = 6,
		audio_channels_SURROUND71 = 8,
	};
	inline audio_channels_enum audio_channels(void);
	inline void audio_channels(audio_channels_enum value);
	enum opensubdiv_compute_type_enum {
		opensubdiv_compute_type_NONE = 0,
		opensubdiv_compute_type_CPU = 1,
		opensubdiv_compute_type_OPENMP = 2,
		opensubdiv_compute_type_OPENCL = 3,
		opensubdiv_compute_type_CUDA = 4,
		opensubdiv_compute_type_GLSL_TRANSFORM_FEEDBACK = 5,
		opensubdiv_compute_type_GLSL_COMPUTE = 6,
	};
	inline opensubdiv_compute_type_enum opensubdiv_compute_type(void);
	inline void opensubdiv_compute_type(opensubdiv_compute_type_enum value);
	inline int legacy_compute_device_type(void);
	inline void legacy_compute_device_type(int value);

};

/**************** Add-on ****************/

class Addon : public Pointer {
public:
	Addon(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string module(void);
	inline void module(const std::string& value);
	inline AddonPreferences preferences(void);

};

/**************** Add-on Preferences ****************/

class AddonPreferences : public Pointer {
public:
	AddonPreferences(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string bl_idname(void);
	inline void bl_idname(const std::string& value);

};

/**************** Studio Light ****************/

class StudioLight : public Pointer {
public:
	StudioLight(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		solid_lights(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline int index(void);
	inline void index(int value);
	inline bool is_user_defined(void);
	inline void is_user_defined(bool value);
	enum type_enum {
		type_STUDIO = 16,
		type_WORLD = 32,
		type_MATCAP = 64,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	inline std::string name(void);
	inline void name(const std::string& value);
	inline std::string path(void);
	inline void path(const std::string& value);
	COLLECTION_PROPERTY(DefaultCollectionFunctions, UserSolidLight, StudioLight, solid_lights, true, true, false)
	inline Array<float, 3> light_ambient(void);
	inline void light_ambient(float values[3]);
	inline std::string path_irr_cache(void);
	inline void path_irr_cache(const std::string& value);
	inline std::string path_sh_cache(void);
	inline void path_sh_cache(const std::string& value);
	inline Array<float, 12> spherical_harmonics_coefficients(void);
	inline void spherical_harmonics_coefficients(float values[12]);

};

/**************** Path Compare ****************/

class PathCompare : public Pointer {
public:
	PathCompare(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string path(void);
	inline void path(const std::string& value);
	inline bool use_glob(void);
	inline void use_glob(bool value);

};

/**************** Vector Font ****************/

class VectorFont : public ID {
public:
	VectorFont(const PointerRNA &ptr_arg) :
		ID(ptr_arg)
		{}

	inline std::string filepath(void);
	inline void filepath(const std::string& value);
	inline PackedFile packed_file(void);

	inline void pack(void *main);
	inline void unpack(void *main, int method);
};

/**************** Operator ****************/

class Operator : public Pointer {
public:
	Operator(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		macros(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string name(void);
	inline void name(const std::string& value);
	inline OperatorProperties properties(void);
	inline bool has_reports(void);
	inline void has_reports(bool value);
	inline UILayout layout(void);
	inline OperatorOptions options(void);
	inline std::string bl_idname(void);
	inline void bl_idname(const std::string& value);
	inline std::string bl_label(void);
	inline void bl_label(const std::string& value);
	inline std::string bl_translation_context(void);
	inline void bl_translation_context(const std::string& value);
	inline std::string bl_description(void);
	inline void bl_description(const std::string& value);
	inline std::string bl_undo_group(void);
	inline void bl_undo_group(const std::string& value);
	enum bl_options_enum {
		bl_options_REGISTER = 1,
		bl_options_UNDO = 2,
		bl_options_UNDO_GROUPED = 256,
		bl_options_BLOCKING = 4,
		bl_options_MACRO = 8,
		bl_options_GRAB_CURSOR = 16,
		bl_options_PRESET = 32,
		bl_options_INTERNAL = 64,
		bl_options_USE_EVAL_DATA = 512,
	};
	inline bl_options_enum bl_options(void);
	inline void bl_options(bl_options_enum value);
	COLLECTION_PROPERTY(DefaultCollectionFunctions, Macro, Operator, macros, false, true, true)

	inline void report(int type, const char * message);
	inline bool is_repeat(Context C);
};

/**************** Operator Properties ****************/

class OperatorProperties : public Pointer {
public:
	OperatorProperties(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

};

/**************** Operator Options ****************/

class OperatorOptions : public Pointer {
public:
	OperatorOptions(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline bool is_grab_cursor(void);
	inline void is_grab_cursor(bool value);
	inline bool is_invoke(void);
	inline void is_invoke(bool value);
	inline bool is_repeat(void);
	inline void is_repeat(bool value);
	inline bool use_cursor_region(void);
	inline void use_cursor_region(bool value);

};

/**************** Operator Mouse Path ****************/

class OperatorMousePath : public PropertyGroup {
public:
	OperatorMousePath(const PointerRNA &ptr_arg) :
		PropertyGroup(ptr_arg)
		{}


};

/**************** Operator File List Element ****************/

class OperatorFileListElement : public PropertyGroup {
public:
	OperatorFileListElement(const PointerRNA &ptr_arg) :
		PropertyGroup(ptr_arg)
		{}


};

/**************** Macro Operator ****************/

class Macro : public Pointer {
public:
	Macro(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string name(void);
	inline void name(const std::string& value);
	inline OperatorProperties properties(void);
	inline std::string bl_idname(void);
	inline void bl_idname(const std::string& value);
	inline std::string bl_label(void);
	inline void bl_label(const std::string& value);
	inline std::string bl_translation_context(void);
	inline void bl_translation_context(const std::string& value);
	inline std::string bl_description(void);
	inline void bl_description(const std::string& value);
	inline std::string bl_undo_group(void);
	inline void bl_undo_group(const std::string& value);
	enum bl_options_enum {
		bl_options_REGISTER = 1,
		bl_options_UNDO = 2,
		bl_options_UNDO_GROUPED = 256,
		bl_options_BLOCKING = 4,
		bl_options_MACRO = 8,
		bl_options_GRAB_CURSOR = 16,
		bl_options_PRESET = 32,
		bl_options_INTERNAL = 64,
		bl_options_USE_EVAL_DATA = 512,
	};
	inline bl_options_enum bl_options(void);
	inline void bl_options(bl_options_enum value);

	inline void report(int type, const char * message);
};

/**************** Operator Macro ****************/

class OperatorMacro : public Pointer {
public:
	OperatorMacro(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline OperatorProperties properties(void);

};

/**************** Event ****************/

class Event : public Pointer {
public:
	Event(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string ascii(void);
	inline void ascii(const std::string& value);
	inline std::string unicode(void);
	inline void unicode(const std::string& value);
	enum value_enum {
		value_ANY = -1,
		value_NOTHING = 0,
		value_PRESS = 1,
		value_RELEASE = 2,
		value_CLICK = 3,
		value_DOUBLE_CLICK = 4,
		value_CLICK_DRAG = 5,
		value_NORTH = 1,
		value_NORTH_EAST = 2,
		value_EAST = 3,
		value_SOUTH_EAST = 4,
		value_SOUTH = 5,
		value_SOUTH_WEST = 6,
		value_WEST = 7,
		value_NORTH_WEST = 8,
	};
	inline value_enum value(void);
	inline void value(value_enum value);
	enum type_enum {
		type_NONE = 0,
		type_LEFTMOUSE = 1,
		type_MIDDLEMOUSE = 2,
		type_RIGHTMOUSE = 3,
		type_BUTTON4MOUSE = 7,
		type_BUTTON5MOUSE = 8,
		type_BUTTON6MOUSE = 18,
		type_BUTTON7MOUSE = 19,
		type_PEN = 26,
		type_ERASER = 27,
		type_MOUSEMOVE = 4,
		type_INBETWEEN_MOUSEMOVE = 17,
		type_TRACKPADPAN = 14,
		type_TRACKPADZOOM = 15,
		type_MOUSEROTATE = 16,
		type_WHEELUPMOUSE = 10,
		type_WHEELDOWNMOUSE = 11,
		type_WHEELINMOUSE = 12,
		type_WHEELOUTMOUSE = 13,
		type_EVT_TWEAK_L = 20482,
		type_EVT_TWEAK_M = 20483,
		type_EVT_TWEAK_R = 20484,
		type_A = 97,
		type_B = 98,
		type_C = 99,
		type_D = 100,
		type_E = 101,
		type_F = 102,
		type_G = 103,
		type_H = 104,
		type_I = 105,
		type_J = 106,
		type_K = 107,
		type_L = 108,
		type_M = 109,
		type_N = 110,
		type_O = 111,
		type_P = 112,
		type_Q = 113,
		type_R = 114,
		type_S = 115,
		type_T = 116,
		type_U = 117,
		type_V = 118,
		type_W = 119,
		type_X = 120,
		type_Y = 121,
		type_Z = 122,
		type_ZERO = 48,
		type_ONE = 49,
		type_TWO = 50,
		type_THREE = 51,
		type_FOUR = 52,
		type_FIVE = 53,
		type_SIX = 54,
		type_SEVEN = 55,
		type_EIGHT = 56,
		type_NINE = 57,
		type_LEFT_CTRL = 212,
		type_LEFT_ALT = 213,
		type_LEFT_SHIFT = 217,
		type_RIGHT_ALT = 214,
		type_RIGHT_CTRL = 215,
		type_RIGHT_SHIFT = 216,
		type_OSKEY = 172,
		type_GRLESS = 173,
		type_ESC = 218,
		type_TAB = 219,
		type_RET = 220,
		type_SPACE = 221,
		type_LINE_FEED = 222,
		type_BACK_SPACE = 223,
		type_DEL = 224,
		type_SEMI_COLON = 225,
		type_PERIOD = 226,
		type_COMMA = 227,
		type_QUOTE = 228,
		type_ACCENT_GRAVE = 229,
		type_MINUS = 230,
		type_PLUS = 231,
		type_SLASH = 232,
		type_BACK_SLASH = 233,
		type_EQUAL = 234,
		type_LEFT_BRACKET = 235,
		type_RIGHT_BRACKET = 236,
		type_LEFT_ARROW = 137,
		type_DOWN_ARROW = 138,
		type_RIGHT_ARROW = 139,
		type_UP_ARROW = 140,
		type_NUMPAD_2 = 152,
		type_NUMPAD_4 = 154,
		type_NUMPAD_6 = 156,
		type_NUMPAD_8 = 158,
		type_NUMPAD_1 = 151,
		type_NUMPAD_3 = 153,
		type_NUMPAD_5 = 155,
		type_NUMPAD_7 = 157,
		type_NUMPAD_9 = 159,
		type_NUMPAD_PERIOD = 199,
		type_NUMPAD_SLASH = 161,
		type_NUMPAD_ASTERIX = 160,
		type_NUMPAD_0 = 150,
		type_NUMPAD_MINUS = 162,
		type_NUMPAD_ENTER = 163,
		type_NUMPAD_PLUS = 164,
		type_F1 = 300,
		type_F2 = 301,
		type_F3 = 302,
		type_F4 = 303,
		type_F5 = 304,
		type_F6 = 305,
		type_F7 = 306,
		type_F8 = 307,
		type_F9 = 308,
		type_F10 = 309,
		type_F11 = 310,
		type_F12 = 311,
		type_F13 = 312,
		type_F14 = 313,
		type_F15 = 314,
		type_F16 = 315,
		type_F17 = 316,
		type_F18 = 317,
		type_F19 = 318,
		type_PAUSE = 165,
		type_INSERT = 166,
		type_HOME = 167,
		type_PAGE_UP = 168,
		type_PAGE_DOWN = 169,
		type_END = 170,
		type_MEDIA_PLAY = 174,
		type_MEDIA_STOP = 175,
		type_MEDIA_FIRST = 176,
		type_MEDIA_LAST = 177,
		type_TEXTINPUT = -2,
		type_WINDOW_DEACTIVATE = 260,
		type_TIMER = 272,
		type_TIMER0 = 273,
		type_TIMER1 = 274,
		type_TIMER2 = 275,
		type_TIMER_JOBS = 276,
		type_TIMER_AUTOSAVE = 277,
		type_TIMER_REPORT = 278,
		type_TIMERREGION = 279,
		type_NDOF_MOTION = 400,
		type_NDOF_BUTTON_MENU = 401,
		type_NDOF_BUTTON_FIT = 402,
		type_NDOF_BUTTON_TOP = 403,
		type_NDOF_BUTTON_BOTTOM = 404,
		type_NDOF_BUTTON_LEFT = 405,
		type_NDOF_BUTTON_RIGHT = 406,
		type_NDOF_BUTTON_FRONT = 407,
		type_NDOF_BUTTON_BACK = 408,
		type_NDOF_BUTTON_ISO1 = 409,
		type_NDOF_BUTTON_ISO2 = 410,
		type_NDOF_BUTTON_ROLL_CW = 411,
		type_NDOF_BUTTON_ROLL_CCW = 412,
		type_NDOF_BUTTON_SPIN_CW = 413,
		type_NDOF_BUTTON_SPIN_CCW = 414,
		type_NDOF_BUTTON_TILT_CW = 415,
		type_NDOF_BUTTON_TILT_CCW = 416,
		type_NDOF_BUTTON_ROTATE = 417,
		type_NDOF_BUTTON_PANZOOM = 418,
		type_NDOF_BUTTON_DOMINANT = 419,
		type_NDOF_BUTTON_PLUS = 420,
		type_NDOF_BUTTON_MINUS = 421,
		type_NDOF_BUTTON_ESC = 422,
		type_NDOF_BUTTON_ALT = 423,
		type_NDOF_BUTTON_SHIFT = 424,
		type_NDOF_BUTTON_CTRL = 425,
		type_NDOF_BUTTON_1 = 426,
		type_NDOF_BUTTON_2 = 427,
		type_NDOF_BUTTON_3 = 428,
		type_NDOF_BUTTON_4 = 429,
		type_NDOF_BUTTON_5 = 430,
		type_NDOF_BUTTON_6 = 431,
		type_NDOF_BUTTON_7 = 432,
		type_NDOF_BUTTON_8 = 433,
		type_NDOF_BUTTON_9 = 434,
		type_NDOF_BUTTON_10 = 435,
		type_NDOF_BUTTON_A = 436,
		type_NDOF_BUTTON_B = 437,
		type_NDOF_BUTTON_C = 438,
		type_ACTIONZONE_AREA = 20480,
		type_ACTIONZONE_REGION = 20481,
		type_ACTIONZONE_FULLSCREEN = 20497,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	inline int mouse_x(void);
	inline void mouse_x(int value);
	inline int mouse_y(void);
	inline void mouse_y(int value);
	inline int mouse_region_x(void);
	inline void mouse_region_x(int value);
	inline int mouse_region_y(void);
	inline void mouse_region_y(int value);
	inline int mouse_prev_x(void);
	inline void mouse_prev_x(int value);
	inline int mouse_prev_y(void);
	inline void mouse_prev_y(int value);
	inline float pressure(void);
	inline void pressure(float value);
	inline Array<float, 2> tilt(void);
	inline void tilt(float values[2]);
	inline bool is_tablet(void);
	inline void is_tablet(bool value);
	inline bool is_mouse_absolute(void);
	inline void is_mouse_absolute(bool value);
	inline bool shift(void);
	inline void shift(bool value);
	inline bool ctrl(void);
	inline void ctrl(bool value);
	inline bool alt(void);
	inline void alt(bool value);
	inline bool oskey(void);
	inline void oskey(bool value);

};

/**************** Timer ****************/

class Timer : public Pointer {
public:
	Timer(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline float time_step(void);
	inline void time_step(float value);
	inline float time_delta(void);
	inline void time_delta(float value);
	inline float time_duration(void);
	inline void time_duration(float value);

};

/**************** UIPopupMenu ****************/

class UIPopupMenu : public Pointer {
public:
	UIPopupMenu(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline UILayout layout(void);

};

/**************** UIPopover ****************/

class UIPopover : public Pointer {
public:
	UIPopover(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline UILayout layout(void);

};

/**************** UIPieMenu ****************/

class UIPieMenu : public Pointer {
public:
	UIPieMenu(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline UILayout layout(void);

};

/**************** Window ****************/

class Window : public Pointer {
public:
	Window(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline Window parent(void);
	inline Scene scene(void);
	inline WorkSpace workspace(void);
	inline Screen screen(void);
	inline ViewLayer view_layer(void);
	inline int x(void);
	inline void x(int value);
	inline int y(void);
	inline void y(int value);
	inline int width(void);
	inline void width(int value);
	inline int height(void);
	inline void height(int value);
	inline Stereo3dDisplay stereo_3d_display(void);

	inline void cursor_warp(int x, int y);
	inline void cursor_set(int cursor);
	inline void cursor_modal_set(int cursor);
	inline void cursor_modal_restore();
	inline Event event_simulate(int type, int value, const char * unicode, int x, int y, bool shift, bool ctrl, bool alt, bool oskey);
};

/**************** Stereo 3D Display ****************/

class Stereo3dDisplay : public Pointer {
public:
	Stereo3dDisplay(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	enum display_mode_enum {
		display_mode_ANAGLYPH = 0,
		display_mode_INTERLACE = 1,
		display_mode_TIMESEQUENTIAL = 2,
		display_mode_SIDEBYSIDE = 3,
		display_mode_TOPBOTTOM = 4,
	};
	inline display_mode_enum display_mode(void);
	inline void display_mode(display_mode_enum value);
	enum anaglyph_type_enum {
		anaglyph_type_RED_CYAN = 0,
		anaglyph_type_GREEN_MAGENTA = 1,
		anaglyph_type_YELLOW_BLUE = 2,
	};
	inline anaglyph_type_enum anaglyph_type(void);
	inline void anaglyph_type(anaglyph_type_enum value);
	enum interlace_type_enum {
		interlace_type_ROW_INTERLEAVED = 0,
		interlace_type_COLUMN_INTERLEAVED = 1,
		interlace_type_CHECKERBOARD_INTERLEAVED = 2,
	};
	inline interlace_type_enum interlace_type(void);
	inline void interlace_type(interlace_type_enum value);
	inline bool use_interlace_swap(void);
	inline void use_interlace_swap(bool value);
	inline bool use_sidebyside_crosseyed(void);
	inline void use_sidebyside_crosseyed(bool value);

};

/**************** Window Manager ****************/

class WindowManager : public ID {
public:
	WindowManager(const PointerRNA &ptr_arg) :
		ID(ptr_arg),
		operators(ptr_arg),
		windows(ptr_arg),
		keyconfigs(ptr_arg)
		{}

	COLLECTION_PROPERTY(DefaultCollectionFunctions, Operator, WindowManager, operators, false, true, true)
	COLLECTION_PROPERTY(DefaultCollectionFunctions, Window, WindowManager, windows, false, true, false)
	COLLECTION_PROPERTY(KeyConfigurations, KeyConfig, WindowManager, keyconfigs, false, true, true)
	inline std::string clipboard(void);
	inline void clipboard(const std::string& value);

	inline void fileselect_add(Context C, Operator& operator_value);
	inline bool modal_handler_add(Context C, Operator& operator_value);
	inline Timer event_timer_add(float time_step, Window& window);
	inline void event_timer_remove(Timer& timer);
	inline void gizmo_group_type_ensure(const char * identifier);
	inline void gizmo_group_type_unlink_delayed(const char * identifier);
	inline void progress_begin(float min, float max);
	inline void progress_update(float value);
	inline void progress_end();
	inline int invoke_props_popup(Context C, Operator& operator_value, Event& event);
	inline int invoke_props_dialog(Context C, Operator& operator_value, int width, int height);
	inline void invoke_search_popup(Context C, Operator& operator_value);
	inline int invoke_popup(Context C, Operator& operator_value, int width, int height);
	inline int invoke_confirm(Context C, Operator& operator_value, Event& event);
	inline UIPopupMenu popmenu_begin__internal(Context C, const char * title, int icon);
	inline void popmenu_end__internal(Context C, UIPopupMenu& menu);
	inline UIPopover popover_begin__internal(Context C, int ui_units_x);
	inline void popover_end__internal(Context C, UIPopover& menu, KeyMap& keymap);
	inline UIPieMenu piemenu_begin__internal(Context C, const char * title, int icon, Event& event);
	inline void piemenu_end__internal(Context C, UIPieMenu& menu);
	inline OperatorProperties operator_properties_last(const char * operator_value);
	inline void print_undo_steps();
};

/**************** Key-Config Preferences ****************/

class KeyConfigPreferences : public Pointer {
public:
	KeyConfigPreferences(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string bl_idname(void);
	inline void bl_idname(const std::string& value);

};

/**************** Key Configuration ****************/

class KeyConfig : public Pointer {
public:
	KeyConfig(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		keymaps(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string name(void);
	inline void name(const std::string& value);
	COLLECTION_PROPERTY(KeyMaps, KeyMap, KeyConfig, keymaps, false, true, true)
	inline bool is_user_defined(void);
	inline void is_user_defined(bool value);
	inline KeyConfigPreferences preferences(void);

};

/**************** Key Map ****************/

class KeyMap : public Pointer {
public:
	KeyMap(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		keymap_items(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string name(void);
	inline void name(const std::string& value);
	inline std::string bl_owner_id(void);
	inline void bl_owner_id(const std::string& value);
	enum space_type_enum {
		space_type_EMPTY = 0,
		space_type_VIEW_3D = 1,
		space_type_IMAGE_EDITOR = 6,
		space_type_NODE_EDITOR = 16,
		space_type_SEQUENCE_EDITOR = 8,
		space_type_CLIP_EDITOR = 20,
		space_type_DOPESHEET_EDITOR = 12,
		space_type_GRAPH_EDITOR = 2,
		space_type_NLA_EDITOR = 13,
		space_type_TEXT_EDITOR = 9,
		space_type_CONSOLE = 18,
		space_type_INFO = 7,
		space_type_TOPBAR = 21,
		space_type_STATUSBAR = 22,
		space_type_OUTLINER = 3,
		space_type_PROPERTIES = 4,
		space_type_FILE_BROWSER = 5,
		space_type_PREFERENCES = 19,
	};
	inline space_type_enum space_type(void);
	inline void space_type(space_type_enum value);
	enum region_type_enum {
		region_type_WINDOW = 0,
		region_type_HEADER = 1,
		region_type_CHANNELS = 2,
		region_type_TEMPORARY = 3,
		region_type_UI = 4,
		region_type_TOOLS = 5,
		region_type_TOOL_PROPS = 6,
		region_type_PREVIEW = 7,
		region_type_HUD = 8,
		region_type_NAVIGATION_BAR = 9,
		region_type_EXECUTE = 10,
		region_type_FOOTER = 11,
	};
	inline region_type_enum region_type(void);
	inline void region_type(region_type_enum value);
	COLLECTION_PROPERTY(KeyMapItems, KeyMapItem, KeyMap, keymap_items, false, true, true)
	inline bool is_user_modified(void);
	inline void is_user_modified(bool value);
	inline bool is_modal(void);
	inline void is_modal(bool value);
	inline bool show_expanded_items(void);
	inline void show_expanded_items(bool value);
	inline bool show_expanded_children(void);
	inline void show_expanded_children(bool value);

	inline KeyMap active(Context C);
	inline void restore_to_default(Context C);
	inline void restore_item_to_default(Context C, KeyMapItem& item);
};

/**************** Key Map Item ****************/

class KeyMapItem : public Pointer {
public:
	KeyMapItem(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string idname(void);
	inline void idname(const std::string& value);
	inline std::string name(void);
	inline void name(const std::string& value);
	inline OperatorProperties properties(void);
	enum map_type_enum {
		map_type_KEYBOARD = 0,
		map_type_TWEAK = 2,
		map_type_MOUSE = 1,
		map_type_NDOF = 5,
		map_type_TEXTINPUT = 3,
		map_type_TIMER = 4,
	};
	inline map_type_enum map_type(void);
	inline void map_type(map_type_enum value);
	enum type_enum {
		type_NONE = 0,
		type_LEFTMOUSE = 1,
		type_MIDDLEMOUSE = 2,
		type_RIGHTMOUSE = 3,
		type_BUTTON4MOUSE = 7,
		type_BUTTON5MOUSE = 8,
		type_BUTTON6MOUSE = 18,
		type_BUTTON7MOUSE = 19,
		type_PEN = 26,
		type_ERASER = 27,
		type_MOUSEMOVE = 4,
		type_INBETWEEN_MOUSEMOVE = 17,
		type_TRACKPADPAN = 14,
		type_TRACKPADZOOM = 15,
		type_MOUSEROTATE = 16,
		type_WHEELUPMOUSE = 10,
		type_WHEELDOWNMOUSE = 11,
		type_WHEELINMOUSE = 12,
		type_WHEELOUTMOUSE = 13,
		type_EVT_TWEAK_L = 20482,
		type_EVT_TWEAK_M = 20483,
		type_EVT_TWEAK_R = 20484,
		type_A = 97,
		type_B = 98,
		type_C = 99,
		type_D = 100,
		type_E = 101,
		type_F = 102,
		type_G = 103,
		type_H = 104,
		type_I = 105,
		type_J = 106,
		type_K = 107,
		type_L = 108,
		type_M = 109,
		type_N = 110,
		type_O = 111,
		type_P = 112,
		type_Q = 113,
		type_R = 114,
		type_S = 115,
		type_T = 116,
		type_U = 117,
		type_V = 118,
		type_W = 119,
		type_X = 120,
		type_Y = 121,
		type_Z = 122,
		type_ZERO = 48,
		type_ONE = 49,
		type_TWO = 50,
		type_THREE = 51,
		type_FOUR = 52,
		type_FIVE = 53,
		type_SIX = 54,
		type_SEVEN = 55,
		type_EIGHT = 56,
		type_NINE = 57,
		type_LEFT_CTRL = 212,
		type_LEFT_ALT = 213,
		type_LEFT_SHIFT = 217,
		type_RIGHT_ALT = 214,
		type_RIGHT_CTRL = 215,
		type_RIGHT_SHIFT = 216,
		type_OSKEY = 172,
		type_GRLESS = 173,
		type_ESC = 218,
		type_TAB = 219,
		type_RET = 220,
		type_SPACE = 221,
		type_LINE_FEED = 222,
		type_BACK_SPACE = 223,
		type_DEL = 224,
		type_SEMI_COLON = 225,
		type_PERIOD = 226,
		type_COMMA = 227,
		type_QUOTE = 228,
		type_ACCENT_GRAVE = 229,
		type_MINUS = 230,
		type_PLUS = 231,
		type_SLASH = 232,
		type_BACK_SLASH = 233,
		type_EQUAL = 234,
		type_LEFT_BRACKET = 235,
		type_RIGHT_BRACKET = 236,
		type_LEFT_ARROW = 137,
		type_DOWN_ARROW = 138,
		type_RIGHT_ARROW = 139,
		type_UP_ARROW = 140,
		type_NUMPAD_2 = 152,
		type_NUMPAD_4 = 154,
		type_NUMPAD_6 = 156,
		type_NUMPAD_8 = 158,
		type_NUMPAD_1 = 151,
		type_NUMPAD_3 = 153,
		type_NUMPAD_5 = 155,
		type_NUMPAD_7 = 157,
		type_NUMPAD_9 = 159,
		type_NUMPAD_PERIOD = 199,
		type_NUMPAD_SLASH = 161,
		type_NUMPAD_ASTERIX = 160,
		type_NUMPAD_0 = 150,
		type_NUMPAD_MINUS = 162,
		type_NUMPAD_ENTER = 163,
		type_NUMPAD_PLUS = 164,
		type_F1 = 300,
		type_F2 = 301,
		type_F3 = 302,
		type_F4 = 303,
		type_F5 = 304,
		type_F6 = 305,
		type_F7 = 306,
		type_F8 = 307,
		type_F9 = 308,
		type_F10 = 309,
		type_F11 = 310,
		type_F12 = 311,
		type_F13 = 312,
		type_F14 = 313,
		type_F15 = 314,
		type_F16 = 315,
		type_F17 = 316,
		type_F18 = 317,
		type_F19 = 318,
		type_PAUSE = 165,
		type_INSERT = 166,
		type_HOME = 167,
		type_PAGE_UP = 168,
		type_PAGE_DOWN = 169,
		type_END = 170,
		type_MEDIA_PLAY = 174,
		type_MEDIA_STOP = 175,
		type_MEDIA_FIRST = 176,
		type_MEDIA_LAST = 177,
		type_TEXTINPUT = -2,
		type_WINDOW_DEACTIVATE = 260,
		type_TIMER = 272,
		type_TIMER0 = 273,
		type_TIMER1 = 274,
		type_TIMER2 = 275,
		type_TIMER_JOBS = 276,
		type_TIMER_AUTOSAVE = 277,
		type_TIMER_REPORT = 278,
		type_TIMERREGION = 279,
		type_NDOF_MOTION = 400,
		type_NDOF_BUTTON_MENU = 401,
		type_NDOF_BUTTON_FIT = 402,
		type_NDOF_BUTTON_TOP = 403,
		type_NDOF_BUTTON_BOTTOM = 404,
		type_NDOF_BUTTON_LEFT = 405,
		type_NDOF_BUTTON_RIGHT = 406,
		type_NDOF_BUTTON_FRONT = 407,
		type_NDOF_BUTTON_BACK = 408,
		type_NDOF_BUTTON_ISO1 = 409,
		type_NDOF_BUTTON_ISO2 = 410,
		type_NDOF_BUTTON_ROLL_CW = 411,
		type_NDOF_BUTTON_ROLL_CCW = 412,
		type_NDOF_BUTTON_SPIN_CW = 413,
		type_NDOF_BUTTON_SPIN_CCW = 414,
		type_NDOF_BUTTON_TILT_CW = 415,
		type_NDOF_BUTTON_TILT_CCW = 416,
		type_NDOF_BUTTON_ROTATE = 417,
		type_NDOF_BUTTON_PANZOOM = 418,
		type_NDOF_BUTTON_DOMINANT = 419,
		type_NDOF_BUTTON_PLUS = 420,
		type_NDOF_BUTTON_MINUS = 421,
		type_NDOF_BUTTON_ESC = 422,
		type_NDOF_BUTTON_ALT = 423,
		type_NDOF_BUTTON_SHIFT = 424,
		type_NDOF_BUTTON_CTRL = 425,
		type_NDOF_BUTTON_1 = 426,
		type_NDOF_BUTTON_2 = 427,
		type_NDOF_BUTTON_3 = 428,
		type_NDOF_BUTTON_4 = 429,
		type_NDOF_BUTTON_5 = 430,
		type_NDOF_BUTTON_6 = 431,
		type_NDOF_BUTTON_7 = 432,
		type_NDOF_BUTTON_8 = 433,
		type_NDOF_BUTTON_9 = 434,
		type_NDOF_BUTTON_10 = 435,
		type_NDOF_BUTTON_A = 436,
		type_NDOF_BUTTON_B = 437,
		type_NDOF_BUTTON_C = 438,
		type_ACTIONZONE_AREA = 20480,
		type_ACTIONZONE_REGION = 20481,
		type_ACTIONZONE_FULLSCREEN = 20497,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	enum value_enum {
		value_ANY = -1,
		value_NOTHING = 0,
		value_PRESS = 1,
		value_RELEASE = 2,
		value_CLICK = 3,
		value_DOUBLE_CLICK = 4,
		value_CLICK_DRAG = 5,
		value_NORTH = 1,
		value_NORTH_EAST = 2,
		value_EAST = 3,
		value_SOUTH_EAST = 4,
		value_SOUTH = 5,
		value_SOUTH_WEST = 6,
		value_WEST = 7,
		value_NORTH_WEST = 8,
	};
	inline value_enum value(void);
	inline void value(value_enum value);
	inline int id(void);
	inline void id(int value);
	inline bool any(void);
	inline void any(bool value);
	inline bool shift(void);
	inline void shift(bool value);
	inline bool ctrl(void);
	inline void ctrl(bool value);
	inline bool alt(void);
	inline void alt(bool value);
	inline bool oskey(void);
	inline void oskey(bool value);
	enum key_modifier_enum {
		key_modifier_NONE = 0,
		key_modifier_LEFTMOUSE = 1,
		key_modifier_MIDDLEMOUSE = 2,
		key_modifier_RIGHTMOUSE = 3,
		key_modifier_BUTTON4MOUSE = 7,
		key_modifier_BUTTON5MOUSE = 8,
		key_modifier_BUTTON6MOUSE = 18,
		key_modifier_BUTTON7MOUSE = 19,
		key_modifier_PEN = 26,
		key_modifier_ERASER = 27,
		key_modifier_MOUSEMOVE = 4,
		key_modifier_INBETWEEN_MOUSEMOVE = 17,
		key_modifier_TRACKPADPAN = 14,
		key_modifier_TRACKPADZOOM = 15,
		key_modifier_MOUSEROTATE = 16,
		key_modifier_WHEELUPMOUSE = 10,
		key_modifier_WHEELDOWNMOUSE = 11,
		key_modifier_WHEELINMOUSE = 12,
		key_modifier_WHEELOUTMOUSE = 13,
		key_modifier_EVT_TWEAK_L = 20482,
		key_modifier_EVT_TWEAK_M = 20483,
		key_modifier_EVT_TWEAK_R = 20484,
		key_modifier_A = 97,
		key_modifier_B = 98,
		key_modifier_C = 99,
		key_modifier_D = 100,
		key_modifier_E = 101,
		key_modifier_F = 102,
		key_modifier_G = 103,
		key_modifier_H = 104,
		key_modifier_I = 105,
		key_modifier_J = 106,
		key_modifier_K = 107,
		key_modifier_L = 108,
		key_modifier_M = 109,
		key_modifier_N = 110,
		key_modifier_O = 111,
		key_modifier_P = 112,
		key_modifier_Q = 113,
		key_modifier_R = 114,
		key_modifier_S = 115,
		key_modifier_T = 116,
		key_modifier_U = 117,
		key_modifier_V = 118,
		key_modifier_W = 119,
		key_modifier_X = 120,
		key_modifier_Y = 121,
		key_modifier_Z = 122,
		key_modifier_ZERO = 48,
		key_modifier_ONE = 49,
		key_modifier_TWO = 50,
		key_modifier_THREE = 51,
		key_modifier_FOUR = 52,
		key_modifier_FIVE = 53,
		key_modifier_SIX = 54,
		key_modifier_SEVEN = 55,
		key_modifier_EIGHT = 56,
		key_modifier_NINE = 57,
		key_modifier_LEFT_CTRL = 212,
		key_modifier_LEFT_ALT = 213,
		key_modifier_LEFT_SHIFT = 217,
		key_modifier_RIGHT_ALT = 214,
		key_modifier_RIGHT_CTRL = 215,
		key_modifier_RIGHT_SHIFT = 216,
		key_modifier_OSKEY = 172,
		key_modifier_GRLESS = 173,
		key_modifier_ESC = 218,
		key_modifier_TAB = 219,
		key_modifier_RET = 220,
		key_modifier_SPACE = 221,
		key_modifier_LINE_FEED = 222,
		key_modifier_BACK_SPACE = 223,
		key_modifier_DEL = 224,
		key_modifier_SEMI_COLON = 225,
		key_modifier_PERIOD = 226,
		key_modifier_COMMA = 227,
		key_modifier_QUOTE = 228,
		key_modifier_ACCENT_GRAVE = 229,
		key_modifier_MINUS = 230,
		key_modifier_PLUS = 231,
		key_modifier_SLASH = 232,
		key_modifier_BACK_SLASH = 233,
		key_modifier_EQUAL = 234,
		key_modifier_LEFT_BRACKET = 235,
		key_modifier_RIGHT_BRACKET = 236,
		key_modifier_LEFT_ARROW = 137,
		key_modifier_DOWN_ARROW = 138,
		key_modifier_RIGHT_ARROW = 139,
		key_modifier_UP_ARROW = 140,
		key_modifier_NUMPAD_2 = 152,
		key_modifier_NUMPAD_4 = 154,
		key_modifier_NUMPAD_6 = 156,
		key_modifier_NUMPAD_8 = 158,
		key_modifier_NUMPAD_1 = 151,
		key_modifier_NUMPAD_3 = 153,
		key_modifier_NUMPAD_5 = 155,
		key_modifier_NUMPAD_7 = 157,
		key_modifier_NUMPAD_9 = 159,
		key_modifier_NUMPAD_PERIOD = 199,
		key_modifier_NUMPAD_SLASH = 161,
		key_modifier_NUMPAD_ASTERIX = 160,
		key_modifier_NUMPAD_0 = 150,
		key_modifier_NUMPAD_MINUS = 162,
		key_modifier_NUMPAD_ENTER = 163,
		key_modifier_NUMPAD_PLUS = 164,
		key_modifier_F1 = 300,
		key_modifier_F2 = 301,
		key_modifier_F3 = 302,
		key_modifier_F4 = 303,
		key_modifier_F5 = 304,
		key_modifier_F6 = 305,
		key_modifier_F7 = 306,
		key_modifier_F8 = 307,
		key_modifier_F9 = 308,
		key_modifier_F10 = 309,
		key_modifier_F11 = 310,
		key_modifier_F12 = 311,
		key_modifier_F13 = 312,
		key_modifier_F14 = 313,
		key_modifier_F15 = 314,
		key_modifier_F16 = 315,
		key_modifier_F17 = 316,
		key_modifier_F18 = 317,
		key_modifier_F19 = 318,
		key_modifier_PAUSE = 165,
		key_modifier_INSERT = 166,
		key_modifier_HOME = 167,
		key_modifier_PAGE_UP = 168,
		key_modifier_PAGE_DOWN = 169,
		key_modifier_END = 170,
		key_modifier_MEDIA_PLAY = 174,
		key_modifier_MEDIA_STOP = 175,
		key_modifier_MEDIA_FIRST = 176,
		key_modifier_MEDIA_LAST = 177,
		key_modifier_TEXTINPUT = -2,
		key_modifier_WINDOW_DEACTIVATE = 260,
		key_modifier_TIMER = 272,
		key_modifier_TIMER0 = 273,
		key_modifier_TIMER1 = 274,
		key_modifier_TIMER2 = 275,
		key_modifier_TIMER_JOBS = 276,
		key_modifier_TIMER_AUTOSAVE = 277,
		key_modifier_TIMER_REPORT = 278,
		key_modifier_TIMERREGION = 279,
		key_modifier_NDOF_MOTION = 400,
		key_modifier_NDOF_BUTTON_MENU = 401,
		key_modifier_NDOF_BUTTON_FIT = 402,
		key_modifier_NDOF_BUTTON_TOP = 403,
		key_modifier_NDOF_BUTTON_BOTTOM = 404,
		key_modifier_NDOF_BUTTON_LEFT = 405,
		key_modifier_NDOF_BUTTON_RIGHT = 406,
		key_modifier_NDOF_BUTTON_FRONT = 407,
		key_modifier_NDOF_BUTTON_BACK = 408,
		key_modifier_NDOF_BUTTON_ISO1 = 409,
		key_modifier_NDOF_BUTTON_ISO2 = 410,
		key_modifier_NDOF_BUTTON_ROLL_CW = 411,
		key_modifier_NDOF_BUTTON_ROLL_CCW = 412,
		key_modifier_NDOF_BUTTON_SPIN_CW = 413,
		key_modifier_NDOF_BUTTON_SPIN_CCW = 414,
		key_modifier_NDOF_BUTTON_TILT_CW = 415,
		key_modifier_NDOF_BUTTON_TILT_CCW = 416,
		key_modifier_NDOF_BUTTON_ROTATE = 417,
		key_modifier_NDOF_BUTTON_PANZOOM = 418,
		key_modifier_NDOF_BUTTON_DOMINANT = 419,
		key_modifier_NDOF_BUTTON_PLUS = 420,
		key_modifier_NDOF_BUTTON_MINUS = 421,
		key_modifier_NDOF_BUTTON_ESC = 422,
		key_modifier_NDOF_BUTTON_ALT = 423,
		key_modifier_NDOF_BUTTON_SHIFT = 424,
		key_modifier_NDOF_BUTTON_CTRL = 425,
		key_modifier_NDOF_BUTTON_1 = 426,
		key_modifier_NDOF_BUTTON_2 = 427,
		key_modifier_NDOF_BUTTON_3 = 428,
		key_modifier_NDOF_BUTTON_4 = 429,
		key_modifier_NDOF_BUTTON_5 = 430,
		key_modifier_NDOF_BUTTON_6 = 431,
		key_modifier_NDOF_BUTTON_7 = 432,
		key_modifier_NDOF_BUTTON_8 = 433,
		key_modifier_NDOF_BUTTON_9 = 434,
		key_modifier_NDOF_BUTTON_10 = 435,
		key_modifier_NDOF_BUTTON_A = 436,
		key_modifier_NDOF_BUTTON_B = 437,
		key_modifier_NDOF_BUTTON_C = 438,
		key_modifier_ACTIONZONE_AREA = 20480,
		key_modifier_ACTIONZONE_REGION = 20481,
		key_modifier_ACTIONZONE_FULLSCREEN = 20497,
	};
	inline key_modifier_enum key_modifier(void);
	inline void key_modifier(key_modifier_enum value);
	inline bool show_expanded(void);
	inline void show_expanded(bool value);
	enum propvalue_enum {
		propvalue_NONE = 0,
	};
	inline propvalue_enum propvalue(void);
	inline void propvalue(propvalue_enum value);
	inline bool active(void);
	inline void active(bool value);
	inline bool is_user_modified(void);
	inline void is_user_modified(bool value);
	inline bool is_user_defined(void);
	inline void is_user_defined(bool value);

	inline bool compare(KeyMapItem& item);
	inline void to_string(bool compact, char * result);
};

/**************** GizmoGroup ****************/

class GizmoGroup : public Pointer {
public:
	GizmoGroup(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		gizmos(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string bl_idname(void);
	inline void bl_idname(const std::string& value);
	inline std::string bl_label(void);
	inline void bl_label(const std::string& value);
	enum bl_space_type_enum {
		bl_space_type_EMPTY = 0,
		bl_space_type_VIEW_3D = 1,
		bl_space_type_IMAGE_EDITOR = 6,
		bl_space_type_NODE_EDITOR = 16,
		bl_space_type_SEQUENCE_EDITOR = 8,
		bl_space_type_CLIP_EDITOR = 20,
		bl_space_type_DOPESHEET_EDITOR = 12,
		bl_space_type_GRAPH_EDITOR = 2,
		bl_space_type_NLA_EDITOR = 13,
		bl_space_type_TEXT_EDITOR = 9,
		bl_space_type_CONSOLE = 18,
		bl_space_type_INFO = 7,
		bl_space_type_TOPBAR = 21,
		bl_space_type_STATUSBAR = 22,
		bl_space_type_OUTLINER = 3,
		bl_space_type_PROPERTIES = 4,
		bl_space_type_FILE_BROWSER = 5,
		bl_space_type_PREFERENCES = 19,
	};
	inline bl_space_type_enum bl_space_type(void);
	inline void bl_space_type(bl_space_type_enum value);
	enum bl_region_type_enum {
		bl_region_type_WINDOW = 0,
		bl_region_type_HEADER = 1,
		bl_region_type_CHANNELS = 2,
		bl_region_type_TEMPORARY = 3,
		bl_region_type_UI = 4,
		bl_region_type_TOOLS = 5,
		bl_region_type_TOOL_PROPS = 6,
		bl_region_type_PREVIEW = 7,
		bl_region_type_HUD = 8,
		bl_region_type_NAVIGATION_BAR = 9,
		bl_region_type_EXECUTE = 10,
		bl_region_type_FOOTER = 11,
	};
	inline bl_region_type_enum bl_region_type(void);
	inline void bl_region_type(bl_region_type_enum value);
	inline std::string bl_owner_id(void);
	inline void bl_owner_id(const std::string& value);
	enum bl_options_enum {
		bl_options_3D = 1,
		bl_options_SCALE = 2,
		bl_options_DEPTH_3D = 4,
		bl_options_SELECT = 8,
		bl_options_PERSISTENT = 16,
		bl_options_SHOW_MODAL_ALL = 32,
		bl_options_TOOL_INIT = 64,
	};
	inline bl_options_enum bl_options(void);
	inline void bl_options(bl_options_enum value);
	inline std::string name(void);
	inline void name(const std::string& value);
	inline bool has_reports(void);
	inline void has_reports(bool value);
	COLLECTION_PROPERTY(Gizmos, Gizmo, GizmoGroup, gizmos, false, true, false)

};

/**************** Gizmo ****************/

class Gizmo : public Pointer {
public:
	Gizmo(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline GizmoProperties properties(void);
	inline std::string bl_idname(void);
	inline void bl_idname(const std::string& value);
	inline GizmoGroup group(void);
	inline Array<float, 3> color(void);
	inline void color(float values[3]);
	inline float alpha(void);
	inline void alpha(float value);
	inline Array<float, 3> color_highlight(void);
	inline void color_highlight(float values[3]);
	inline float alpha_highlight(void);
	inline void alpha_highlight(float value);
	inline Array<float, 16> matrix_space(void);
	inline void matrix_space(float values[16]);
	inline Array<float, 16> matrix_basis(void);
	inline void matrix_basis(float values[16]);
	inline Array<float, 16> matrix_offset(void);
	inline void matrix_offset(float values[16]);
	inline Array<float, 16> matrix_world(void);
	inline void matrix_world(float values[16]);
	inline float scale_basis(void);
	inline void scale_basis(float value);
	inline float line_width(void);
	inline void line_width(float value);
	inline bool hide(void);
	inline void hide(bool value);
	inline bool hide_select(void);
	inline void hide_select(bool value);
	inline bool use_grab_cursor(void);
	inline void use_grab_cursor(bool value);
	inline bool use_draw_hover(void);
	inline void use_draw_hover(bool value);
	inline bool use_draw_modal(void);
	inline void use_draw_modal(bool value);
	inline bool use_draw_value(void);
	inline void use_draw_value(bool value);
	inline bool use_draw_offset_scale(void);
	inline void use_draw_offset_scale(bool value);
	inline bool use_draw_scale(void);
	inline void use_draw_scale(bool value);
	inline bool use_select_background(void);
	inline void use_select_background(bool value);
	inline bool use_operator_tool_properties(void);
	inline void use_operator_tool_properties(bool value);
	inline bool is_highlight(void);
	inline void is_highlight(bool value);
	inline bool is_modal(void);
	inline void is_modal(bool value);
	inline bool select(void);
	inline void select(bool value);

	inline void draw_preset_box(float matrix[16], int select_id);
	inline void draw_preset_arrow(float matrix[16], int axis, int select_id);
	inline void draw_preset_circle(float matrix[16], int axis, int select_id);
	inline void draw_preset_facemap(Context C, Object& object, int face_map, int select_id);
	inline void target_set_prop(const char * target, AnyType& data, const char * property, int index);
	inline OperatorProperties target_set_operator(const char * operator_value, int index);
	inline bool target_is_valid(const char * property);
};

/**************** Gizmo Properties ****************/

class GizmoProperties : public Pointer {
public:
	GizmoProperties(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

};

/**************** Gizmo Group Properties ****************/

class GizmoGroupProperties : public Pointer {
public:
	GizmoGroupProperties(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

};

/**************** Work Space UI Tag ****************/

class wmOwnerID : public Pointer {
public:
	wmOwnerID(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string name(void);
	inline void name(const std::string& value);

};

/**************** Work Space Tool ****************/

class WorkSpaceTool : public Pointer {
public:
	WorkSpaceTool(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string idname(void);
	inline void idname(const std::string& value);
	inline int index(void);
	inline void index(int value);
	enum space_type_enum {
		space_type_EMPTY = 0,
		space_type_VIEW_3D = 1,
		space_type_IMAGE_EDITOR = 6,
		space_type_NODE_EDITOR = 16,
		space_type_SEQUENCE_EDITOR = 8,
		space_type_CLIP_EDITOR = 20,
		space_type_DOPESHEET_EDITOR = 12,
		space_type_GRAPH_EDITOR = 2,
		space_type_NLA_EDITOR = 13,
		space_type_TEXT_EDITOR = 9,
		space_type_CONSOLE = 18,
		space_type_INFO = 7,
		space_type_TOPBAR = 21,
		space_type_STATUSBAR = 22,
		space_type_OUTLINER = 3,
		space_type_PROPERTIES = 4,
		space_type_FILE_BROWSER = 5,
		space_type_PREFERENCES = 19,
	};
	inline space_type_enum space_type(void);
	inline void space_type(space_type_enum value);
	enum mode_enum {
		mode_DEFAULT = 0,
	};
	inline mode_enum mode(void);
	inline void mode(mode_enum value);
	inline bool has_datablock(void);
	inline void has_datablock(bool value);
	inline std::string widget(void);
	inline void widget(const std::string& value);

	inline void setup(Context C, const char * idname, int cursor, const char * keymap, const char * gizmo_group, const char * data_block, const char * operator_value, int index);
	inline OperatorProperties operator_properties(const char * operator_value);
	inline GizmoGroupProperties gizmo_group_properties(const char * group);
	inline void refresh_from_context(void *main);
};

/**************** Workspace ****************/

class WorkSpace : public ID {
public:
	WorkSpace(const PointerRNA &ptr_arg) :
		ID(ptr_arg),
		screens(ptr_arg),
		owner_ids(ptr_arg),
		tools(ptr_arg)
		{}

	COLLECTION_PROPERTY(DefaultCollectionFunctions, Screen, WorkSpace, screens, false, true, true)
	COLLECTION_PROPERTY(wmOwnerIDs, wmOwnerID, WorkSpace, owner_ids, false, true, true)
	COLLECTION_PROPERTY(wmTools, WorkSpaceTool, WorkSpace, tools, false, true, true)
	enum tools_space_type_enum {
		tools_space_type_EMPTY = 0,
		tools_space_type_VIEW_3D = 1,
		tools_space_type_IMAGE_EDITOR = 6,
		tools_space_type_NODE_EDITOR = 16,
		tools_space_type_SEQUENCE_EDITOR = 8,
		tools_space_type_CLIP_EDITOR = 20,
		tools_space_type_DOPESHEET_EDITOR = 12,
		tools_space_type_GRAPH_EDITOR = 2,
		tools_space_type_NLA_EDITOR = 13,
		tools_space_type_TEXT_EDITOR = 9,
		tools_space_type_CONSOLE = 18,
		tools_space_type_INFO = 7,
		tools_space_type_TOPBAR = 21,
		tools_space_type_STATUSBAR = 22,
		tools_space_type_OUTLINER = 3,
		tools_space_type_PROPERTIES = 4,
		tools_space_type_FILE_BROWSER = 5,
		tools_space_type_PREFERENCES = 19,
	};
	inline tools_space_type_enum tools_space_type(void);
	inline void tools_space_type(tools_space_type_enum value);
	enum tools_mode_enum {
		tools_mode_DEFAULT = 0,
	};
	inline tools_mode_enum tools_mode(void);
	inline void tools_mode(tools_mode_enum value);
	enum object_mode_enum {
		object_mode_OBJECT = 0,
		object_mode_EDIT = 1,
		object_mode_POSE = 64,
		object_mode_SCULPT = 2,
		object_mode_VERTEX_PAINT = 4,
		object_mode_WEIGHT_PAINT = 8,
		object_mode_TEXTURE_PAINT = 16,
		object_mode_PARTICLE_EDIT = 32,
		object_mode_EDIT_GPENCIL = 128,
		object_mode_SCULPT_GPENCIL = 512,
		object_mode_PAINT_GPENCIL = 256,
		object_mode_WEIGHT_GPENCIL = 1024,
	};
	inline object_mode_enum object_mode(void);
	inline void object_mode(object_mode_enum value);
	inline bool use_filter_by_owner(void);
	inline void use_filter_by_owner(bool value);

	inline void status_text_set(Context C, const char * text);
};

/**************** World ****************/

class World : public ID {
public:
	World(const PointerRNA &ptr_arg) :
		ID(ptr_arg)
		{}

	inline AnimData animation_data(void);
	inline Array<float, 3> color(void);
	inline void color(float values[3]);
	inline WorldLighting light_settings(void);
	inline WorldMistSettings mist_settings(void);
	inline NodeTree node_tree(void);
	inline bool use_nodes(void);
	inline void use_nodes(bool value);

};

/**************** Lighting ****************/

class WorldLighting : public Pointer {
public:
	WorldLighting(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline bool use_ambient_occlusion(void);
	inline void use_ambient_occlusion(bool value);
	inline float ao_factor(void);
	inline void ao_factor(float value);
	inline float distance(void);
	inline void distance(float value);

};

/**************** World Mist ****************/

class WorldMistSettings : public Pointer {
public:
	WorldMistSettings(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline bool use_mist(void);
	inline void use_mist(bool value);
	inline float intensity(void);
	inline void intensity(float value);
	inline float start(void);
	inline void start(float value);
	inline float depth(void);
	inline void depth(float value);
	inline float height(void);
	inline void height(float value);
	enum falloff_enum {
		falloff_QUADRATIC = 0,
		falloff_LINEAR = 1,
		falloff_INVERSE_QUADRATIC = 2,
	};
	inline falloff_enum falloff(void);
	inline void falloff(falloff_enum value);

};

/**************** MovieClip ****************/

class MovieClip : public ID {
public:
	MovieClip(const PointerRNA &ptr_arg) :
		ID(ptr_arg)
		{}

	inline std::string filepath(void);
	inline void filepath(const std::string& value);
	inline MovieTracking tracking(void);
	inline MovieClipProxy proxy(void);
	inline bool use_proxy(void);
	inline void use_proxy(bool value);
	inline Array<int, 2> size(void);
	inline void size(int values[2]);
	inline Array<float, 2> display_aspect(void);
	inline void display_aspect(float values[2]);
	enum source_enum {
		source_SEQUENCE = 1,
		source_MOVIE = 2,
	};
	inline source_enum source(void);
	inline void source(source_enum value);
	inline bool use_proxy_custom_directory(void);
	inline void use_proxy_custom_directory(bool value);
	inline GreasePencil grease_pencil(void);
	inline int frame_start(void);
	inline void frame_start(int value);
	inline int frame_offset(void);
	inline void frame_offset(int value);
	inline int frame_duration(void);
	inline void frame_duration(int value);
	inline float fps(void);
	inline void fps(float value);
	inline ColorManagedInputColorspaceSettings colorspace_settings(void);
	inline AnimData animation_data(void);

	inline IDPropertyWrapPtr metadata();
};

/**************** Movie Clip Proxy ****************/

class MovieClipProxy : public Pointer {
public:
	MovieClipProxy(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline bool build_25(void);
	inline void build_25(bool value);
	inline bool build_50(void);
	inline void build_50(bool value);
	inline bool build_75(void);
	inline void build_75(bool value);
	inline bool build_100(void);
	inline void build_100(bool value);
	inline bool build_undistorted_25(void);
	inline void build_undistorted_25(bool value);
	inline bool build_undistorted_50(void);
	inline void build_undistorted_50(bool value);
	inline bool build_undistorted_75(void);
	inline void build_undistorted_75(bool value);
	inline bool build_undistorted_100(void);
	inline void build_undistorted_100(bool value);
	inline bool build_record_run(void);
	inline void build_record_run(bool value);
	inline bool build_free_run(void);
	inline void build_free_run(bool value);
	inline bool build_free_run_rec_date(void);
	inline void build_free_run_rec_date(bool value);
	inline int quality(void);
	inline void quality(int value);
	enum timecode_enum {
		timecode_NONE = 0,
		timecode_RECORD_RUN = 1,
		timecode_FREE_RUN = 2,
		timecode_FREE_RUN_REC_DATE = 4,
		timecode_FREE_RUN_NO_GAPS = 8,
	};
	inline timecode_enum timecode(void);
	inline void timecode(timecode_enum value);
	inline std::string directory(void);
	inline void directory(const std::string& value);

};

/**************** Movie Clip User ****************/

class MovieClipUser : public Pointer {
public:
	MovieClipUser(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline int frame_current(void);
	inline void frame_current(int value);
	enum proxy_render_size_enum {
		proxy_render_size_PROXY_25 = 1,
		proxy_render_size_PROXY_50 = 2,
		proxy_render_size_PROXY_75 = 3,
		proxy_render_size_PROXY_100 = 4,
		proxy_render_size_FULL = 0,
	};
	inline proxy_render_size_enum proxy_render_size(void);
	inline void proxy_render_size(proxy_render_size_enum value);
	inline bool use_render_undistorted(void);
	inline void use_render_undistorted(bool value);

};

/**************** MovieClipScopes ****************/

class MovieClipScopes : public Pointer {
public:
	MovieClipScopes(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

};

/**************** Movie tracking settings ****************/

class MovieTrackingSettings : public Pointer {
public:
	MovieTrackingSettings(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	enum speed_enum {
		speed_FASTEST = 0,
		speed_DOUBLE = 5,
		speed_REALTIME = 1,
		speed_HALF = 2,
		speed_QUARTER = 4,
	};
	inline speed_enum speed(void);
	inline void speed(speed_enum value);
	inline bool use_keyframe_selection(void);
	inline void use_keyframe_selection(bool value);
	enum refine_intrinsics_enum {
		refine_intrinsics_NONE = 0,
		refine_intrinsics_FOCAL_LENGTH = 1,
		refine_intrinsics_FOCAL_LENGTH_RADIAL_K1 = 5,
		refine_intrinsics_FOCAL_LENGTH_RADIAL_K1_K2 = 21,
		refine_intrinsics_FOCAL_LENGTH_PRINCIPAL_POINT_RADIAL_K1_K2 = 23,
		refine_intrinsics_FOCAL_LENGTH_PRINCIPAL_POINT = 3,
		refine_intrinsics_RADIAL_K1_K2 = 20,
	};
	inline refine_intrinsics_enum refine_intrinsics(void);
	inline void refine_intrinsics(refine_intrinsics_enum value);
	inline float distance(void);
	inline void distance(float value);
	inline int clean_frames(void);
	inline void clean_frames(int value);
	inline float clean_error(void);
	inline void clean_error(float value);
	enum clean_action_enum {
		clean_action_SELECT = 0,
		clean_action_DELETE_TRACK = 1,
		clean_action_DELETE_SEGMENTS = 2,
	};
	inline clean_action_enum clean_action(void);
	inline void clean_action(clean_action_enum value);
	inline bool show_default_expanded(void);
	inline void show_default_expanded(bool value);
	inline bool show_extra_expanded(void);
	inline void show_extra_expanded(bool value);
	inline bool use_tripod_solver(void);
	inline void use_tripod_solver(bool value);
	inline int default_frames_limit(void);
	inline void default_frames_limit(int value);
	enum default_pattern_match_enum {
		default_pattern_match_KEYFRAME = 0,
		default_pattern_match_PREV_FRAME = 1,
	};
	inline default_pattern_match_enum default_pattern_match(void);
	inline void default_pattern_match(default_pattern_match_enum value);
	inline int default_margin(void);
	inline void default_margin(int value);
	enum default_motion_model_enum {
		default_motion_model_Perspective = 5,
		default_motion_model_Affine = 4,
		default_motion_model_LocRotScale = 3,
		default_motion_model_LocScale = 2,
		default_motion_model_LocRot = 1,
		default_motion_model_Loc = 0,
	};
	inline default_motion_model_enum default_motion_model(void);
	inline void default_motion_model(default_motion_model_enum value);
	inline bool use_default_brute(void);
	inline void use_default_brute(bool value);
	inline bool use_default_mask(void);
	inline void use_default_mask(bool value);
	inline bool use_default_normalization(void);
	inline void use_default_normalization(bool value);
	inline float default_correlation_min(void);
	inline void default_correlation_min(float value);
	inline int default_pattern_size(void);
	inline void default_pattern_size(int value);
	inline int default_search_size(void);
	inline void default_search_size(int value);
	inline bool use_default_red_channel(void);
	inline void use_default_red_channel(bool value);
	inline bool use_default_green_channel(void);
	inline void use_default_green_channel(bool value);
	inline bool use_default_blue_channel(void);
	inline void use_default_blue_channel(bool value);
	inline float default_weight(void);
	inline void default_weight(float value);
	inline float object_distance(void);
	inline void object_distance(float value);

};

/**************** Movie tracking camera data ****************/

class MovieTrackingCamera : public Pointer {
public:
	MovieTrackingCamera(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	enum distortion_model_enum {
		distortion_model_POLYNOMIAL = 0,
		distortion_model_DIVISION = 1,
	};
	inline distortion_model_enum distortion_model(void);
	inline void distortion_model(distortion_model_enum value);
	inline float sensor_width(void);
	inline void sensor_width(float value);
	inline float focal_length(void);
	inline void focal_length(float value);
	inline float focal_length_pixels(void);
	inline void focal_length_pixels(float value);
	enum units_enum {
		units_PIXELS = 0,
		units_MILLIMETERS = 1,
	};
	inline units_enum units(void);
	inline void units(units_enum value);
	inline Array<float, 2> principal(void);
	inline void principal(float values[2]);
	inline float k1(void);
	inline void k1(float value);
	inline float k2(void);
	inline void k2(float value);
	inline float k3(void);
	inline void k3(float value);
	inline float division_k1(void);
	inline void division_k1(float value);
	inline float division_k2(void);
	inline void division_k2(float value);
	inline float pixel_aspect(void);
	inline void pixel_aspect(float value);

};

/**************** Movie tracking marker data ****************/

class MovieTrackingMarker : public Pointer {
public:
	MovieTrackingMarker(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline Array<float, 2> co(void);
	inline void co(float values[2]);
	inline int frame(void);
	inline void frame(int value);
	inline bool mute(void);
	inline void mute(bool value);
	inline Array<float, 8> pattern_corners(void);
	inline void pattern_corners(float values[8]);
	inline Array<float, 4> pattern_bound_box(void);
	inline void pattern_bound_box(float values[4]);
	inline Array<float, 2> search_min(void);
	inline void search_min(float values[2]);
	inline Array<float, 2> search_max(void);
	inline void search_max(float values[2]);
	inline bool is_keyed(void);
	inline void is_keyed(bool value);

};

/**************** Movie tracking track data ****************/

class MovieTrackingTrack : public Pointer {
public:
	MovieTrackingTrack(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		markers(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string name(void);
	inline void name(const std::string& value);
	inline int frames_limit(void);
	inline void frames_limit(int value);
	enum pattern_match_enum {
		pattern_match_KEYFRAME = 0,
		pattern_match_PREV_FRAME = 1,
	};
	inline pattern_match_enum pattern_match(void);
	inline void pattern_match(pattern_match_enum value);
	inline int margin(void);
	inline void margin(int value);
	enum motion_model_enum {
		motion_model_Perspective = 5,
		motion_model_Affine = 4,
		motion_model_LocRotScale = 3,
		motion_model_LocScale = 2,
		motion_model_LocRot = 1,
		motion_model_Loc = 0,
	};
	inline motion_model_enum motion_model(void);
	inline void motion_model(motion_model_enum value);
	inline float correlation_min(void);
	inline void correlation_min(float value);
	inline bool use_brute(void);
	inline void use_brute(bool value);
	inline bool use_mask(void);
	inline void use_mask(bool value);
	inline bool use_normalization(void);
	inline void use_normalization(bool value);
	COLLECTION_PROPERTY(MovieTrackingMarkers, MovieTrackingMarker, MovieTrackingTrack, markers, true, true, false)
	inline bool use_red_channel(void);
	inline void use_red_channel(bool value);
	inline bool use_green_channel(void);
	inline void use_green_channel(bool value);
	inline bool use_blue_channel(void);
	inline void use_blue_channel(bool value);
	inline bool use_grayscale_preview(void);
	inline void use_grayscale_preview(bool value);
	inline bool use_alpha_preview(void);
	inline void use_alpha_preview(bool value);
	inline bool has_bundle(void);
	inline void has_bundle(bool value);
	inline Array<float, 3> bundle(void);
	inline void bundle(float values[3]);
	inline bool hide(void);
	inline void hide(bool value);
	inline bool select(void);
	inline void select(bool value);
	inline bool select_anchor(void);
	inline void select_anchor(bool value);
	inline bool select_pattern(void);
	inline void select_pattern(bool value);
	inline bool select_search(void);
	inline void select_search(bool value);
	inline bool lock(void);
	inline void lock(bool value);
	inline bool use_custom_color(void);
	inline void use_custom_color(bool value);
	inline Array<float, 3> color(void);
	inline void color(float values[3]);
	inline float average_error(void);
	inline void average_error(float value);
	inline GreasePencil grease_pencil(void);
	inline float weight(void);
	inline void weight(float value);
	inline float weight_stab(void);
	inline void weight_stab(float value);
	inline Array<float, 2> offset(void);
	inline void offset(float values[2]);

};

/**************** Movie Tracking Plane Marker Data ****************/

class MovieTrackingPlaneMarker : public Pointer {
public:
	MovieTrackingPlaneMarker(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline int frame(void);
	inline void frame(int value);
	inline Array<float, 8> corners(void);
	inline void corners(float values[8]);
	inline bool mute(void);
	inline void mute(bool value);

};

/**************** Movie tracking plane track data ****************/

class MovieTrackingPlaneTrack : public Pointer {
public:
	MovieTrackingPlaneTrack(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		markers(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string name(void);
	inline void name(const std::string& value);
	COLLECTION_PROPERTY(MovieTrackingPlaneMarkers, MovieTrackingPlaneMarker, MovieTrackingPlaneTrack, markers, true, true, false)
	inline bool select(void);
	inline void select(bool value);
	inline bool use_auto_keying(void);
	inline void use_auto_keying(bool value);
	inline Image image(void);
	inline float image_opacity(void);
	inline void image_opacity(float value);

};

/**************** Movie tracking stabilization data ****************/

class MovieTrackingStabilization : public Pointer {
public:
	MovieTrackingStabilization(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		tracks(ptr_arg),
		rotation_tracks(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline bool use_2d_stabilization(void);
	inline void use_2d_stabilization(bool value);
	inline bool use_stabilize_rotation(void);
	inline void use_stabilize_rotation(bool value);
	inline bool use_stabilize_scale(void);
	inline void use_stabilize_scale(bool value);
	COLLECTION_PROPERTY(DefaultCollectionFunctions, MovieTrackingTrack, MovieTrackingStabilization, tracks, false, false, false)
	inline int active_track_index(void);
	inline void active_track_index(int value);
	COLLECTION_PROPERTY(DefaultCollectionFunctions, MovieTrackingTrack, MovieTrackingStabilization, rotation_tracks, false, false, false)
	inline int active_rotation_track_index(void);
	inline void active_rotation_track_index(int value);
	inline int anchor_frame(void);
	inline void anchor_frame(int value);
	inline Array<float, 2> target_position(void);
	inline void target_position(float values[2]);
	inline float target_rotation(void);
	inline void target_rotation(float value);
	inline float target_scale(void);
	inline void target_scale(float value);
	inline bool use_autoscale(void);
	inline void use_autoscale(bool value);
	inline float scale_max(void);
	inline void scale_max(float value);
	inline float influence_location(void);
	inline void influence_location(float value);
	inline float influence_scale(void);
	inline void influence_scale(float value);
	inline float influence_rotation(void);
	inline void influence_rotation(float value);
	enum filter_type_enum {
		filter_type_NEAREST = 0,
		filter_type_BILINEAR = 1,
		filter_type_BICUBIC = 2,
	};
	inline filter_type_enum filter_type(void);
	inline void filter_type(filter_type_enum value);
	inline bool show_tracks_expanded(void);
	inline void show_tracks_expanded(bool value);

};

/**************** Movie tracking reconstructed camera data ****************/

class MovieReconstructedCamera : public Pointer {
public:
	MovieReconstructedCamera(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline int frame(void);
	inline void frame(int value);
	inline Array<float, 16> matrix(void);
	inline void matrix(float values[16]);
	inline float average_error(void);
	inline void average_error(float value);

};

/**************** Movie tracking reconstruction data ****************/

class MovieTrackingReconstruction : public Pointer {
public:
	MovieTrackingReconstruction(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		cameras(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline bool is_valid(void);
	inline void is_valid(bool value);
	inline float average_error(void);
	inline void average_error(float value);
	COLLECTION_PROPERTY(MovieTrackingReconstructedCameras, MovieReconstructedCamera, MovieTrackingReconstruction, cameras, true, true, false)

};

/**************** Movie tracking object data ****************/

class MovieTrackingObject : public Pointer {
public:
	MovieTrackingObject(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		tracks(ptr_arg),
		plane_tracks(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string name(void);
	inline void name(const std::string& value);
	inline bool is_camera(void);
	inline void is_camera(bool value);
	COLLECTION_PROPERTY(MovieTrackingObjectTracks, MovieTrackingTrack, MovieTrackingObject, tracks, false, true, true)
	COLLECTION_PROPERTY(MovieTrackingObjectPlaneTracks, MovieTrackingPlaneTrack, MovieTrackingObject, plane_tracks, false, true, true)
	inline MovieTrackingReconstruction reconstruction(void);
	inline float scale(void);
	inline void scale(float value);
	inline int keyframe_a(void);
	inline void keyframe_a(int value);
	inline int keyframe_b(void);
	inline void keyframe_b(int value);

};

/**************** Movie Tracking Dopesheet ****************/

class MovieTrackingDopesheet : public Pointer {
public:
	MovieTrackingDopesheet(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	enum sort_method_enum {
		sort_method_NAME = 0,
		sort_method_LONGEST = 1,
		sort_method_TOTAL = 2,
		sort_method_AVERAGE_ERROR = 3,
	};
	inline sort_method_enum sort_method(void);
	inline void sort_method(sort_method_enum value);
	inline bool use_invert_sort(void);
	inline void use_invert_sort(bool value);
	inline bool show_only_selected(void);
	inline void show_only_selected(bool value);
	inline bool show_hidden(void);
	inline void show_hidden(bool value);

};

/**************** Movie tracking data ****************/

class MovieTracking : public Pointer {
public:
	MovieTracking(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		tracks(ptr_arg),
		plane_tracks(ptr_arg),
		objects(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline MovieTrackingSettings settings(void);
	inline MovieTrackingCamera camera(void);
	COLLECTION_PROPERTY(MovieTrackingTracks, MovieTrackingTrack, MovieTracking, tracks, false, true, true)
	COLLECTION_PROPERTY(MovieTrackingPlaneTracks, MovieTrackingPlaneTrack, MovieTracking, plane_tracks, false, true, true)
	inline MovieTrackingStabilization stabilization(void);
	inline MovieTrackingReconstruction reconstruction(void);
	COLLECTION_PROPERTY(MovieTrackingObjects, MovieTrackingObject, MovieTracking, objects, false, true, true)
	inline int active_object_index(void);
	inline void active_object_index(int value);
	inline MovieTrackingDopesheet dopesheet(void);

};

/**************** Mask Parent ****************/

class MaskParent : public Pointer {
public:
	MaskParent(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline ID id(void);
	enum id_type_enum {
		id_type_MOVIECLIP = 17229,
	};
	inline id_type_enum id_type(void);
	inline void id_type(id_type_enum value);
	enum type_enum {
		type_POINT_TRACK = 0,
		type_PLANE_TRACK = 1,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	inline std::string parent(void);
	inline void parent(const std::string& value);
	inline std::string sub_parent(void);
	inline void sub_parent(const std::string& value);

};

/**************** Mask Spline UW Point ****************/

class MaskSplinePointUW : public Pointer {
public:
	MaskSplinePointUW(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline float u(void);
	inline void u(float value);
	inline float weight(void);
	inline void weight(float value);
	inline bool select(void);
	inline void select(bool value);

};

/**************** Mask Spline Point ****************/

class MaskSplinePoint : public Pointer {
public:
	MaskSplinePoint(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		feather_points(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline Array<float, 2> handle_left(void);
	inline void handle_left(float values[2]);
	inline Array<float, 2> co(void);
	inline void co(float values[2]);
	inline Array<float, 2> handle_right(void);
	inline void handle_right(float values[2]);
	enum handle_type_enum {
		handle_type_AUTO = 1,
		handle_type_VECTOR = 2,
		handle_type_ALIGNED = 3,
		handle_type_ALIGNED_DOUBLESIDE = 5,
		handle_type_FREE = 0,
	};
	inline handle_type_enum handle_type(void);
	inline void handle_type(handle_type_enum value);
	enum handle_left_type_enum {
		handle_left_type_AUTO = 1,
		handle_left_type_VECTOR = 2,
		handle_left_type_ALIGNED = 3,
		handle_left_type_ALIGNED_DOUBLESIDE = 5,
		handle_left_type_FREE = 0,
	};
	inline handle_left_type_enum handle_left_type(void);
	inline void handle_left_type(handle_left_type_enum value);
	enum handle_right_type_enum {
		handle_right_type_AUTO = 1,
		handle_right_type_VECTOR = 2,
		handle_right_type_ALIGNED = 3,
		handle_right_type_ALIGNED_DOUBLESIDE = 5,
		handle_right_type_FREE = 0,
	};
	inline handle_right_type_enum handle_right_type(void);
	inline void handle_right_type(handle_right_type_enum value);
	inline float weight(void);
	inline void weight(float value);
	inline bool select(void);
	inline void select(bool value);
	inline MaskParent parent(void);
	COLLECTION_PROPERTY(DefaultCollectionFunctions, MaskSplinePointUW, MaskSplinePoint, feather_points, true, true, false)

};

/**************** Mask spline ****************/

class MaskSpline : public Pointer {
public:
	MaskSpline(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		points(ptr_arg)
		{}

	inline Struct rna_type(void);
	enum offset_mode_enum {
		offset_mode_EVEN = 0,
		offset_mode_SMOOTH = 1,
	};
	inline offset_mode_enum offset_mode(void);
	inline void offset_mode(offset_mode_enum value);
	enum weight_interpolation_enum {
		weight_interpolation_LINEAR = 1,
		weight_interpolation_EASE = 2,
	};
	inline weight_interpolation_enum weight_interpolation(void);
	inline void weight_interpolation(weight_interpolation_enum value);
	inline bool use_cyclic(void);
	inline void use_cyclic(bool value);
	inline bool use_fill(void);
	inline void use_fill(bool value);
	inline bool use_self_intersection_check(void);
	inline void use_self_intersection_check(bool value);
	COLLECTION_PROPERTY(MaskSplinePoints, MaskSplinePoint, MaskSpline, points, true, true, false)

};

/**************** Mask Layer ****************/

class MaskLayer : public Pointer {
public:
	MaskLayer(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		splines(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string name(void);
	inline void name(const std::string& value);
	COLLECTION_PROPERTY(MaskSplines, MaskSpline, MaskLayer, splines, false, true, false)
	inline bool hide(void);
	inline void hide(bool value);
	inline bool hide_select(void);
	inline void hide_select(bool value);
	inline bool hide_render(void);
	inline void hide_render(bool value);
	inline bool select(void);
	inline void select(bool value);
	inline float alpha(void);
	inline void alpha(float value);
	enum blend_enum {
		blend_MERGE_ADD = 7,
		blend_MERGE_SUBTRACT = 8,
		blend_ADD = 0,
		blend_SUBTRACT = 1,
		blend_LIGHTEN = 2,
		blend_DARKEN = 3,
		blend_MUL = 4,
		blend_REPLACE = 5,
		blend_DIFFERENCE = 6,
	};
	inline blend_enum blend(void);
	inline void blend(blend_enum value);
	inline bool invert(void);
	inline void invert(bool value);
	enum falloff_enum {
		falloff_SMOOTH = 0,
		falloff_SPHERE = 1,
		falloff_ROOT = 2,
		falloff_INVERSE_SQUARE = 7,
		falloff_SHARP = 3,
		falloff_LINEAR = 4,
	};
	inline falloff_enum falloff(void);
	inline void falloff(falloff_enum value);
	inline bool use_fill_holes(void);
	inline void use_fill_holes(bool value);
	inline bool use_fill_overlap(void);
	inline void use_fill_overlap(bool value);

};

/**************** Mask ****************/

class Mask : public ID {
public:
	Mask(const PointerRNA &ptr_arg) :
		ID(ptr_arg),
		layers(ptr_arg)
		{}

	COLLECTION_PROPERTY(MaskLayers, MaskLayer, Mask, layers, false, false, false)
	inline int active_layer_index(void);
	inline void active_layer_index(int value);
	inline int frame_start(void);
	inline void frame_start(int value);
	inline int frame_end(void);
	inline void frame_end(int value);
	inline AnimData animation_data(void);

};

} /* namespace BL */

/**************** Implementation ****************/

/* Structure prototypes */

extern "C" {
struct ID;
struct AnimData;
struct Material;
struct FCurve;
struct PointerRNA;
struct bActionGroup;
struct TimeMarker;
struct NlaTrack;
struct KS_Path;
struct EditBone;
struct Scene;
struct CameraBGImage;
struct Object;
struct Collection;
struct CurveMapPoint;
struct CBData;
struct bConstraintTarget;
struct Nurb;
struct BezTriple;
struct FModifier;
struct DriverVar;
struct FCM_EnvelopeData;
struct bGPDlayer;
struct bGPDframe;
struct bGPDstroke;
struct ImageUser;
struct RenderSlot;
struct FreestyleModuleConfig;
struct FreestyleLineSet;
struct ViewLayer;
struct MTex;
struct LineStyleModifier;
struct Camera;
struct bNodeTree;
struct Mesh;
struct Depsgraph;
struct Light;
struct Image;
struct Lattice;
struct Curve;
struct MetaBall;
struct VFont;
struct Tex;
struct Brush;
struct World;
struct Text;
struct Speaker;
struct bSound;
struct bArmature;
struct bAction;
struct ParticleSettings;
struct Palette;
struct bGPdata;
struct MovieClip;
struct Mask;
struct FreestyleLineStyle;
struct LightProbe;
struct CustomDataLayer;
struct MetaElem;
struct NlaStrip;
struct bContext;
struct bNodeSocket;
struct uiLayout;
struct bNode;
struct bNodeLink;
struct View3D;
struct bPoseChannel;
struct ModifierData;
struct GpencilModifierData;
struct ShaderFxData;
struct bConstraint;
struct bDeformGroup;
struct bFaceMap;
struct PaletteColor;
struct ParticleSystemModifierData;
struct ParticleData;
struct RenderResult;
struct RenderPass;
struct Editing;
struct KeyingSet;
struct SceneRenderView;
struct StripElem;
struct Sequence;
struct SequenceModifierData;
struct bAddon;
struct bPathCompare;
struct StudioLight;
struct wmEvent;
struct wmOperator;
struct wmWindow;
struct wmTimer;
struct wmKeyMap;
struct wmKeyConfig;
struct wmKeyMapItem;
struct wmGizmo;
struct wmOwnerID;
struct bToolRef;
struct MovieTrackingMarker;
struct MovieTrackingPlaneMarker;
struct MovieTrackingTrack;
struct MovieReconstructedCamera;
struct MovieTrackingObject;
struct MaskSpline;
struct MaskLayer;

}

namespace BL {
	POINTER_PROPERTY(Struct, Struct, rna_type)
	STRING_PROPERTY(Struct, name)
	STRING_PROPERTY(Struct, identifier)
	STRING_PROPERTY(Struct, description)
	STRING_PROPERTY(Struct, translation_context)
	POINTER_PROPERTY(Struct, Struct, base)
	POINTER_PROPERTY(Struct, Struct, nested)
	POINTER_PROPERTY(StringProperty, Struct, name_property)





	POINTER_PROPERTY(Struct, Property, rna_type)
	STRING_PROPERTY(Property, name)
	STRING_PROPERTY(Property, identifier)
	STRING_PROPERTY(Property, description)
	STRING_PROPERTY(Property, translation_context)
	ENUM_PROPERTY(type_enum, Property, type)
	ENUM_PROPERTY(subtype_enum, Property, subtype)
	POINTER_PROPERTY(Struct, Property, srna)
	ENUM_PROPERTY(unit_enum, Property, unit)
	ENUM_PROPERTY(icon_enum, Property, icon)
	BOOLEAN_PROPERTY(Property, is_readonly)
	BOOLEAN_PROPERTY(Property, is_animatable)
	BOOLEAN_PROPERTY(Property, is_overridable)
	BOOLEAN_PROPERTY(Property, is_required)
	BOOLEAN_PROPERTY(Property, is_argument_optional)
	BOOLEAN_PROPERTY(Property, is_never_none)
	BOOLEAN_PROPERTY(Property, is_hidden)
	BOOLEAN_PROPERTY(Property, is_skip_save)
	BOOLEAN_PROPERTY(Property, is_output)
	BOOLEAN_PROPERTY(Property, is_registered)
	BOOLEAN_PROPERTY(Property, is_registered_optional)
	BOOLEAN_PROPERTY(Property, is_runtime)
	BOOLEAN_PROPERTY(Property, is_enum_flag)
	BOOLEAN_PROPERTY(Property, is_library_editable)
	ENUM_PROPERTY(tags_enum, Property, tags)


	BOOLEAN_PROPERTY(BoolProperty, default_value)
	BOOLEAN_ARRAY_PROPERTY(BoolProperty, 3, default_array)
	INT_PROPERTY(BoolProperty, array_length)
	INT_ARRAY_PROPERTY(BoolProperty, 3, array_dimensions)
	BOOLEAN_PROPERTY(BoolProperty, is_array)


	INT_PROPERTY(IntProperty, default_value)
	INT_ARRAY_PROPERTY(IntProperty, 3, default_array)
	INT_PROPERTY(IntProperty, array_length)
	INT_ARRAY_PROPERTY(IntProperty, 3, array_dimensions)
	BOOLEAN_PROPERTY(IntProperty, is_array)
	INT_PROPERTY(IntProperty, hard_min)
	INT_PROPERTY(IntProperty, hard_max)
	INT_PROPERTY(IntProperty, soft_min)
	INT_PROPERTY(IntProperty, soft_max)
	INT_PROPERTY(IntProperty, step)


	FLOAT_PROPERTY(FloatProperty, default_value)
	FLOAT_ARRAY_PROPERTY(FloatProperty, 3, default_array)
	INT_PROPERTY(FloatProperty, array_length)
	INT_ARRAY_PROPERTY(FloatProperty, 3, array_dimensions)
	BOOLEAN_PROPERTY(FloatProperty, is_array)
	FLOAT_PROPERTY(FloatProperty, hard_min)
	FLOAT_PROPERTY(FloatProperty, hard_max)
	FLOAT_PROPERTY(FloatProperty, soft_min)
	FLOAT_PROPERTY(FloatProperty, soft_max)
	FLOAT_PROPERTY(FloatProperty, step)
	INT_PROPERTY(FloatProperty, precision)


	STRING_PROPERTY(StringProperty, default_value)
	INT_PROPERTY(StringProperty, length_max)


	ENUM_PROPERTY(default_value_enum, EnumProperty, default_value)
	ENUM_PROPERTY(default_flag_enum, EnumProperty, default_flag)




	POINTER_PROPERTY(Struct, EnumPropertyItem, rna_type)
	STRING_PROPERTY(EnumPropertyItem, name)
	STRING_PROPERTY(EnumPropertyItem, description)
	STRING_PROPERTY(EnumPropertyItem, identifier)
	INT_PROPERTY(EnumPropertyItem, value)
	ENUM_PROPERTY(icon_enum, EnumPropertyItem, icon)


	POINTER_PROPERTY(Struct, PointerProperty, fixed_type)


	POINTER_PROPERTY(Struct, CollectionProperty, fixed_type)


	POINTER_PROPERTY(Struct, Function, rna_type)
	STRING_PROPERTY(Function, identifier)
	STRING_PROPERTY(Function, description)

	BOOLEAN_PROPERTY(Function, is_registered)
	BOOLEAN_PROPERTY(Function, is_registered_optional)
	BOOLEAN_PROPERTY(Function, use_self)
	BOOLEAN_PROPERTY(Function, use_self_type)


	POINTER_PROPERTY(Struct, BlenderRNA, rna_type)



	POINTER_PROPERTY(Struct, UnknownType, rna_type)


	POINTER_PROPERTY(Struct, AnyType, rna_type)


	POINTER_PROPERTY(Struct, ID, rna_type)
	STRING_PROPERTY(ID, name)
	STRING_PROPERTY(ID, name_full)
	BOOLEAN_PROPERTY(ID, is_evaluated)
	POINTER_PROPERTY(ID, ID, original)
	INT_PROPERTY(ID, users)
	BOOLEAN_PROPERTY(ID, use_fake_user)
	BOOLEAN_PROPERTY(ID, tag)
	BOOLEAN_PROPERTY(ID, is_library_indirect)
	POINTER_PROPERTY(Library, ID, library)
	POINTER_PROPERTY(IDOverrideStatic, ID, override_static)
	POINTER_PROPERTY(ImagePreview, ID, preview)

	inline ID ID::copy(void *main) {
		PointerRNA result;
		::ID *retdata = ID_copy((::ID *) this->ptr.data, (::Main *) main);
		RNA_id_pointer_create((::ID *) retdata, &result);
		return ID(result);
	}

	inline ID ID::override_create(void *main) {
		PointerRNA result;
		::ID *retdata = ID_override_create((::ID *) this->ptr.data, (::Main *) main);
		RNA_id_pointer_create((::ID *) retdata, &result);
		return ID(result);
	}

	inline void ID::user_clear() {
		ID_user_clear((::ID *) this->ptr.data);
	}

	inline void ID::user_remap(void *main, ID& new_id) {
		ID_user_remap((::ID *) this->ptr.data, (::Main *) main, (::ID *) new_id.ptr.data);
	}

	inline ID ID::make_local(void *main, bool clear_proxy) {
		PointerRNA result;
		::ID *retdata = ID_make_local((::ID *) this->ptr.data, (::Main *) main, clear_proxy);
		RNA_id_pointer_create((::ID *) retdata, &result);
		return ID(result);
	}

	inline int ID::user_of_id(ID& id) {
		return ID_user_of_id((::ID *) this->ptr.data, (::ID *) id.ptr.data);
	}

	inline AnimData ID::animation_data_create(void *main) {
		PointerRNA result;
		::AnimData *retdata = ID_animation_data_create((::ID *) this->ptr.data, (::Main *) main);
		RNA_pointer_create((::ID *) ptr.id.data, &RNA_AnimData, retdata, &result);
		return AnimData(result);
	}

	inline void ID::animation_data_clear(void *main) {
		ID_animation_data_clear((::ID *) this->ptr.data, (::Main *) main);
	}

	inline void ID::update_tag(int refresh) {
		ID_update_tag((::ID *) this->ptr.data, NULL, refresh);
	}


	POINTER_PROPERTY(Struct, IDOverrideStatic, rna_type)
	POINTER_PROPERTY(ID, IDOverrideStatic, reference)
	BOOLEAN_PROPERTY(IDOverrideStatic, auto_generate)



	POINTER_PROPERTY(Struct, IDOverrideStaticProperty, rna_type)
	STRING_PROPERTY(IDOverrideStaticProperty, rna_path)



	POINTER_PROPERTY(Struct, IDOverrideStaticPropertyOperation, rna_type)
	ENUM_PROPERTY(operation_enum, IDOverrideStaticPropertyOperation, operation)
	ENUM_PROPERTY(flag_enum, IDOverrideStaticPropertyOperation, flag)
	STRING_PROPERTY(IDOverrideStaticPropertyOperation, subitem_reference_name)
	STRING_PROPERTY(IDOverrideStaticPropertyOperation, subitem_local_name)
	INT_PROPERTY(IDOverrideStaticPropertyOperation, subitem_reference_index)
	INT_PROPERTY(IDOverrideStaticPropertyOperation, subitem_local_index)


	POINTER_PROPERTY(Struct, ImagePreview, rna_type)
	BOOLEAN_PROPERTY(ImagePreview, is_image_custom)
	INT_ARRAY_PROPERTY(ImagePreview, 2, image_size)
	INT_DYNAMIC_ARRAY_PROPERTY(ImagePreview, image_pixels)
	FLOAT_DYNAMIC_ARRAY_PROPERTY(ImagePreview, image_pixels_float)
	BOOLEAN_PROPERTY(ImagePreview, is_icon_custom)
	INT_ARRAY_PROPERTY(ImagePreview, 2, icon_size)
	INT_DYNAMIC_ARRAY_PROPERTY(ImagePreview, icon_pixels)
	FLOAT_DYNAMIC_ARRAY_PROPERTY(ImagePreview, icon_pixels_float)
	INT_PROPERTY(ImagePreview, icon_id)

	inline void ImagePreview::reload() {
		ImagePreview_reload((::PreviewImage *) this->ptr.data);
	}


	POINTER_PROPERTY(Struct, PropertyGroupItem, rna_type)


	POINTER_PROPERTY(Struct, PropertyGroup, rna_type)


	POINTER_PROPERTY(Struct, IDMaterials, rna_type)

	inline void IDMaterials::append(void *main, Material& material) {
		IDMaterials_append((::ID *) this->ptr.data, (::Main *) main, (::Material *) material.ptr.data);
	}

	inline Material IDMaterials::pop(void *main, int index, bool update_data) {
		PointerRNA result;
		::Material *retdata = IDMaterials_pop((::ID *) this->ptr.data, (::Main *) main, NULL, index, update_data);
		RNA_id_pointer_create((::ID *) retdata, &result);
		return Material(result);
	}

	inline void IDMaterials::clear(void *main, bool update_data) {
		IDMaterials_clear((::ID *) this->ptr.data, (::Main *) main, update_data);
	}


	STRING_PROPERTY(Library, filepath)
	POINTER_PROPERTY(Library, Library, parent)
	POINTER_PROPERTY(PackedFile, Library, packed_file)
	INT_ARRAY_PROPERTY(Library, 3, version)

	inline void Library::reload(Context C) {
		Library_reload((::Library *) this->ptr.data, (::bContext *) C.ptr.data, NULL);
	}


	POINTER_PROPERTY(Struct, IDPropertyWrapPtr, rna_type)


	ENUM_PROPERTY(type_enum, Texture, type)
	BOOLEAN_PROPERTY(Texture, use_clamp)
	BOOLEAN_PROPERTY(Texture, use_color_ramp)
	POINTER_PROPERTY(ColorRamp, Texture, color_ramp)
	FLOAT_PROPERTY(Texture, intensity)
	FLOAT_PROPERTY(Texture, contrast)
	FLOAT_PROPERTY(Texture, saturation)
	FLOAT_PROPERTY(Texture, factor_red)
	FLOAT_PROPERTY(Texture, factor_green)
	FLOAT_PROPERTY(Texture, factor_blue)
	BOOLEAN_PROPERTY(Texture, use_preview_alpha)
	BOOLEAN_PROPERTY(Texture, use_nodes)
	POINTER_PROPERTY(NodeTree, Texture, node_tree)
	POINTER_PROPERTY(AnimData, Texture, animation_data)

	inline void Texture::evaluate(float value[3], float result[4]) {
		Texture_evaluate((::Tex *) this->ptr.data, value, result);
	}


	FLOAT_PROPERTY(CloudsTexture, noise_scale)
	INT_PROPERTY(CloudsTexture, noise_depth)
	ENUM_PROPERTY(noise_basis_enum, CloudsTexture, noise_basis)
	ENUM_PROPERTY(noise_type_enum, CloudsTexture, noise_type)
	ENUM_PROPERTY(cloud_type_enum, CloudsTexture, cloud_type)
	FLOAT_PROPERTY(CloudsTexture, nabla)


	FLOAT_PROPERTY(WoodTexture, noise_scale)
	FLOAT_PROPERTY(WoodTexture, turbulence)
	ENUM_PROPERTY(noise_basis_enum, WoodTexture, noise_basis)
	ENUM_PROPERTY(noise_type_enum, WoodTexture, noise_type)
	ENUM_PROPERTY(wood_type_enum, WoodTexture, wood_type)
	ENUM_PROPERTY(noise_basis_2_enum, WoodTexture, noise_basis_2)
	FLOAT_PROPERTY(WoodTexture, nabla)


	FLOAT_PROPERTY(MarbleTexture, noise_scale)
	FLOAT_PROPERTY(MarbleTexture, turbulence)
	INT_PROPERTY(MarbleTexture, noise_depth)
	ENUM_PROPERTY(noise_type_enum, MarbleTexture, noise_type)
	ENUM_PROPERTY(marble_type_enum, MarbleTexture, marble_type)
	ENUM_PROPERTY(noise_basis_enum, MarbleTexture, noise_basis)
	ENUM_PROPERTY(noise_basis_2_enum, MarbleTexture, noise_basis_2)
	FLOAT_PROPERTY(MarbleTexture, nabla)


	FLOAT_PROPERTY(MagicTexture, turbulence)
	INT_PROPERTY(MagicTexture, noise_depth)


	ENUM_PROPERTY(progression_enum, BlendTexture, progression)
	ENUM_PROPERTY(use_flip_axis_enum, BlendTexture, use_flip_axis)


	FLOAT_PROPERTY(StucciTexture, turbulence)
	ENUM_PROPERTY(noise_basis_enum, StucciTexture, noise_basis)
	FLOAT_PROPERTY(StucciTexture, noise_scale)
	ENUM_PROPERTY(noise_type_enum, StucciTexture, noise_type)
	ENUM_PROPERTY(stucci_type_enum, StucciTexture, stucci_type)




	BOOLEAN_PROPERTY(ImageTexture, use_interpolation)
	BOOLEAN_PROPERTY(ImageTexture, use_flip_axis)
	BOOLEAN_PROPERTY(ImageTexture, use_alpha)
	BOOLEAN_PROPERTY(ImageTexture, use_calculate_alpha)
	BOOLEAN_PROPERTY(ImageTexture, invert_alpha)
	BOOLEAN_PROPERTY(ImageTexture, use_mipmap)
	BOOLEAN_PROPERTY(ImageTexture, use_mipmap_gauss)
	ENUM_PROPERTY(filter_type_enum, ImageTexture, filter_type)
	INT_PROPERTY(ImageTexture, filter_lightprobes)
	INT_PROPERTY(ImageTexture, filter_eccentricity)
	BOOLEAN_PROPERTY(ImageTexture, use_filter_size_min)
	FLOAT_PROPERTY(ImageTexture, filter_size)
	ENUM_PROPERTY(extension_enum, ImageTexture, extension)
	INT_PROPERTY(ImageTexture, repeat_x)
	INT_PROPERTY(ImageTexture, repeat_y)
	BOOLEAN_PROPERTY(ImageTexture, use_mirror_x)
	BOOLEAN_PROPERTY(ImageTexture, use_mirror_y)
	BOOLEAN_PROPERTY(ImageTexture, use_checker_odd)
	BOOLEAN_PROPERTY(ImageTexture, use_checker_even)
	FLOAT_PROPERTY(ImageTexture, checker_distance)
	FLOAT_PROPERTY(ImageTexture, crop_min_x)
	FLOAT_PROPERTY(ImageTexture, crop_min_y)
	FLOAT_PROPERTY(ImageTexture, crop_max_x)
	FLOAT_PROPERTY(ImageTexture, crop_max_y)
	POINTER_PROPERTY(Image, ImageTexture, image)
	POINTER_PROPERTY(ImageUser, ImageTexture, image_user)
	BOOLEAN_PROPERTY(ImageTexture, use_normal_map)


	ENUM_PROPERTY(musgrave_type_enum, MusgraveTexture, musgrave_type)
	FLOAT_PROPERTY(MusgraveTexture, dimension_max)
	FLOAT_PROPERTY(MusgraveTexture, lacunarity)
	FLOAT_PROPERTY(MusgraveTexture, octaves)
	FLOAT_PROPERTY(MusgraveTexture, offset)
	FLOAT_PROPERTY(MusgraveTexture, gain)
	FLOAT_PROPERTY(MusgraveTexture, noise_intensity)
	FLOAT_PROPERTY(MusgraveTexture, noise_scale)
	ENUM_PROPERTY(noise_basis_enum, MusgraveTexture, noise_basis)
	FLOAT_PROPERTY(MusgraveTexture, nabla)


	FLOAT_PROPERTY(VoronoiTexture, weight_1)
	FLOAT_PROPERTY(VoronoiTexture, weight_2)
	FLOAT_PROPERTY(VoronoiTexture, weight_3)
	FLOAT_PROPERTY(VoronoiTexture, weight_4)
	FLOAT_PROPERTY(VoronoiTexture, minkovsky_exponent)
	ENUM_PROPERTY(distance_metric_enum, VoronoiTexture, distance_metric)
	ENUM_PROPERTY(color_mode_enum, VoronoiTexture, color_mode)
	FLOAT_PROPERTY(VoronoiTexture, noise_intensity)
	FLOAT_PROPERTY(VoronoiTexture, noise_scale)
	FLOAT_PROPERTY(VoronoiTexture, nabla)


	FLOAT_PROPERTY(DistortedNoiseTexture, distortion)
	FLOAT_PROPERTY(DistortedNoiseTexture, noise_scale)
	ENUM_PROPERTY(noise_basis_enum, DistortedNoiseTexture, noise_basis)
	ENUM_PROPERTY(noise_distortion_enum, DistortedNoiseTexture, noise_distortion)
	FLOAT_PROPERTY(DistortedNoiseTexture, nabla)


	POINTER_PROPERTY(Struct, TextureSlot, rna_type)
	POINTER_PROPERTY(Texture, TextureSlot, texture)
	STRING_PROPERTY(TextureSlot, name)
	FLOAT_ARRAY_PROPERTY(TextureSlot, 3, offset)
	FLOAT_ARRAY_PROPERTY(TextureSlot, 3, scale)
	FLOAT_ARRAY_PROPERTY(TextureSlot, 3, color)
	ENUM_PROPERTY(blend_type_enum, TextureSlot, blend_type)
	FLOAT_PROPERTY(TextureSlot, default_value)
	ENUM_PROPERTY(output_node_enum, TextureSlot, output_node)


	POINTER_PROPERTY(Struct, TexMapping, rna_type)
	ENUM_PROPERTY(vector_type_enum, TexMapping, vector_type)
	FLOAT_ARRAY_PROPERTY(TexMapping, 3, translation)
	FLOAT_ARRAY_PROPERTY(TexMapping, 3, rotation)
	FLOAT_ARRAY_PROPERTY(TexMapping, 3, scale)
	FLOAT_ARRAY_PROPERTY(TexMapping, 3, min)
	FLOAT_ARRAY_PROPERTY(TexMapping, 3, max)
	BOOLEAN_PROPERTY(TexMapping, use_min)
	BOOLEAN_PROPERTY(TexMapping, use_max)
	ENUM_PROPERTY(mapping_x_enum, TexMapping, mapping_x)
	ENUM_PROPERTY(mapping_y_enum, TexMapping, mapping_y)
	ENUM_PROPERTY(mapping_z_enum, TexMapping, mapping_z)
	ENUM_PROPERTY(mapping_enum, TexMapping, mapping)


	POINTER_PROPERTY(Struct, ColorMapping, rna_type)
	BOOLEAN_PROPERTY(ColorMapping, use_color_ramp)
	POINTER_PROPERTY(ColorRamp, ColorMapping, color_ramp)
	FLOAT_PROPERTY(ColorMapping, brightness)
	FLOAT_PROPERTY(ColorMapping, contrast)
	FLOAT_PROPERTY(ColorMapping, saturation)
	ENUM_PROPERTY(blend_type_enum, ColorMapping, blend_type)
	FLOAT_ARRAY_PROPERTY(ColorMapping, 3, blend_color)
	FLOAT_PROPERTY(ColorMapping, blend_factor)





	FLOAT_ARRAY_PROPERTY(Action, 2, frame_range)
	ENUM_PROPERTY(id_root_enum, Action, id_root)


	POINTER_PROPERTY(Struct, ActionFCurves, rna_type)

	inline FCurve ActionFCurves::create(void *main, const char * data_path, int index, const char * action_group) {
		PointerRNA result;
		::FCurve *retdata = ActionFCurves_new((::bAction *) this->ptr.data, (::Main *) main, NULL, data_path, index, action_group);
		RNA_pointer_create((::ID *) ptr.id.data, &RNA_FCurve, retdata, &result);
		return FCurve(result);
	}

	inline FCurve ActionFCurves::find(const char * data_path, int index) {
		PointerRNA result;
		::FCurve *retdata = ActionFCurves_find((::bAction *) this->ptr.data, NULL, data_path, index);
		RNA_pointer_create((::ID *) ptr.id.data, &RNA_FCurve, retdata, &result);
		return FCurve(result);
	}

	inline void ActionFCurves::remove(FCurve& fcurve) {
		ActionFCurves_remove((::bAction *) this->ptr.data, NULL, (::PointerRNA *) &fcurve.ptr);
	}


	POINTER_PROPERTY(Struct, ActionGroups, rna_type)

	inline ActionGroup ActionGroups::create(const char * name) {
		PointerRNA result;
		::bActionGroup *retdata = ActionGroups_new((::bAction *) this->ptr.data, name);
		RNA_pointer_create((::ID *) ptr.id.data, &RNA_ActionGroup, retdata, &result);
		return ActionGroup(result);
	}

	inline void ActionGroups::remove(ActionGroup& action_group) {
		ActionGroups_remove((::bAction *) this->ptr.data, NULL, (::PointerRNA *) &action_group.ptr);
	}


	POINTER_PROPERTY(Struct, ActionPoseMarkers, rna_type)
	POINTER_PROPERTY(TimelineMarker, ActionPoseMarkers, active)
	INT_PROPERTY(ActionPoseMarkers, active_index)

	inline TimelineMarker ActionPoseMarkers::create(const char * name) {
		PointerRNA result;
		::TimeMarker *retdata = ActionPoseMarkers_new((::bAction *) this->ptr.data, name);
		RNA_pointer_create((::ID *) ptr.id.data, &RNA_TimelineMarker, retdata, &result);
		return TimelineMarker(result);
	}

	inline void ActionPoseMarkers::remove(TimelineMarker& marker) {
		ActionPoseMarkers_remove((::bAction *) this->ptr.data, NULL, (::PointerRNA *) &marker.ptr);
	}


	POINTER_PROPERTY(Struct, ActionGroup, rna_type)
	STRING_PROPERTY(ActionGroup, name)

	BOOLEAN_PROPERTY(ActionGroup, select)
	BOOLEAN_PROPERTY(ActionGroup, lock)
	BOOLEAN_PROPERTY(ActionGroup, show_expanded)
	ENUM_PROPERTY(color_set_enum, ActionGroup, color_set)
	BOOLEAN_PROPERTY(ActionGroup, is_custom_color_set)
	POINTER_PROPERTY(ThemeBoneColorSet, ActionGroup, colors)


	POINTER_PROPERTY(Struct, DopeSheet, rna_type)
	POINTER_PROPERTY(ID, DopeSheet, source)
	BOOLEAN_PROPERTY(DopeSheet, show_datablock_filters)
	BOOLEAN_PROPERTY(DopeSheet, show_only_selected)
	BOOLEAN_PROPERTY(DopeSheet, show_hidden)
	BOOLEAN_PROPERTY(DopeSheet, use_datablock_sort)
	BOOLEAN_PROPERTY(DopeSheet, show_only_errors)
	POINTER_PROPERTY(Collection, DopeSheet, filter_collection)
	STRING_PROPERTY(DopeSheet, filter_fcurve_name)
	STRING_PROPERTY(DopeSheet, filter_text)
	BOOLEAN_PROPERTY(DopeSheet, use_multi_word_filter)
	BOOLEAN_PROPERTY(DopeSheet, show_missing_nla)
	BOOLEAN_PROPERTY(DopeSheet, show_summary)
	BOOLEAN_PROPERTY(DopeSheet, show_expanded_summary)
	BOOLEAN_PROPERTY(DopeSheet, show_transforms)
	BOOLEAN_PROPERTY(DopeSheet, show_shapekeys)
	BOOLEAN_PROPERTY(DopeSheet, show_modifiers)
	BOOLEAN_PROPERTY(DopeSheet, show_meshes)
	BOOLEAN_PROPERTY(DopeSheet, show_lattices)
	BOOLEAN_PROPERTY(DopeSheet, show_cameras)
	BOOLEAN_PROPERTY(DopeSheet, show_materials)
	BOOLEAN_PROPERTY(DopeSheet, show_lights)
	BOOLEAN_PROPERTY(DopeSheet, show_linestyles)
	BOOLEAN_PROPERTY(DopeSheet, show_textures)
	BOOLEAN_PROPERTY(DopeSheet, show_curves)
	BOOLEAN_PROPERTY(DopeSheet, show_worlds)
	BOOLEAN_PROPERTY(DopeSheet, show_scenes)
	BOOLEAN_PROPERTY(DopeSheet, show_particles)
	BOOLEAN_PROPERTY(DopeSheet, show_metaballs)
	BOOLEAN_PROPERTY(DopeSheet, show_armatures)
	BOOLEAN_PROPERTY(DopeSheet, show_nodes)
	BOOLEAN_PROPERTY(DopeSheet, show_speakers)
	BOOLEAN_PROPERTY(DopeSheet, show_cache_files)
	BOOLEAN_PROPERTY(DopeSheet, show_gpencil)
	BOOLEAN_PROPERTY(DopeSheet, show_gpencil_3d_only)


	POINTER_PROPERTY(Struct, AnimData, rna_type)

	POINTER_PROPERTY(Action, AnimData, action)
	ENUM_PROPERTY(action_extrapolation_enum, AnimData, action_extrapolation)
	ENUM_PROPERTY(action_blend_type_enum, AnimData, action_blend_type)
	FLOAT_PROPERTY(AnimData, action_influence)

	BOOLEAN_PROPERTY(AnimData, use_nla)
	BOOLEAN_PROPERTY(AnimData, use_tweak_mode)


	POINTER_PROPERTY(Struct, NlaTracks, rna_type)
	POINTER_PROPERTY(NlaTrack, NlaTracks, active)

	inline NlaTrack NlaTracks::create(void *main, Context C, NlaTrack& prev) {
		PointerRNA result;
		::NlaTrack *retdata = NlaTracks_new((::ID *) ptr.id.data, (::AnimData *) this->ptr.data, (::Main *) main, (::bContext *) C.ptr.data, (::NlaTrack *) prev.ptr.data);
		RNA_pointer_create((::ID *) ptr.id.data, &RNA_NlaTrack, retdata, &result);
		return NlaTrack(result);
	}

	inline void NlaTracks::remove(void *main, Context C, NlaTrack& track) {
		NlaTracks_remove((::ID *) ptr.id.data, (::AnimData *) this->ptr.data, (::Main *) main, (::bContext *) C.ptr.data, NULL, (::PointerRNA *) &track.ptr);
	}


	POINTER_PROPERTY(Struct, AnimDataDrivers, rna_type)

	inline FCurve AnimDataDrivers::create(const char * data_path, int index) {
		PointerRNA result;
		::FCurve *retdata = AnimDataDrivers_new((::ID *) ptr.id.data, (::AnimData *) this->ptr.data, NULL, data_path, index);
		RNA_pointer_create((::ID *) ptr.id.data, &RNA_FCurve, retdata, &result);
		return FCurve(result);
	}

	inline void AnimDataDrivers::remove(FCurve& driver) {
		AnimDataDrivers_remove((::AnimData *) this->ptr.data, NULL, (::FCurve *) driver.ptr.data);
	}

	inline FCurve AnimDataDrivers::from_existing(Context C, FCurve& src_driver) {
		PointerRNA result;
		::FCurve *retdata = AnimDataDrivers_from_existing((::AnimData *) this->ptr.data, (::bContext *) C.ptr.data, (::FCurve *) src_driver.ptr.data);
		RNA_pointer_create((::ID *) ptr.id.data, &RNA_FCurve, retdata, &result);
		return FCurve(result);
	}

	inline FCurve AnimDataDrivers::find(const char * data_path, int index) {
		PointerRNA result;
		::FCurve *retdata = AnimDataDrivers_find((::AnimData *) this->ptr.data, NULL, data_path, index);
		RNA_pointer_create((::ID *) ptr.id.data, &RNA_FCurve, retdata, &result);
		return FCurve(result);
	}


	POINTER_PROPERTY(Struct, KeyingSet, rna_type)
	STRING_PROPERTY(KeyingSet, bl_idname)
	STRING_PROPERTY(KeyingSet, bl_label)
	STRING_PROPERTY(KeyingSet, bl_description)
	POINTER_PROPERTY(KeyingSetInfo, KeyingSet, type_info)

	BOOLEAN_PROPERTY(KeyingSet, is_path_absolute)
	BOOLEAN_PROPERTY(KeyingSet, use_insertkey_override_needed)
	BOOLEAN_PROPERTY(KeyingSet, use_insertkey_override_visual)
	BOOLEAN_PROPERTY(KeyingSet, use_insertkey_override_xyz_to_rgb)
	BOOLEAN_PROPERTY(KeyingSet, use_insertkey_needed)
	BOOLEAN_PROPERTY(KeyingSet, use_insertkey_visual)
	BOOLEAN_PROPERTY(KeyingSet, use_insertkey_xyz_to_rgb)

	inline void KeyingSet::refresh(Context C) {
		KeyingSet_refresh((::KeyingSet *) this->ptr.data, (::bContext *) C.ptr.data, NULL);
	}


	POINTER_PROPERTY(Struct, KeyingSetPaths, rna_type)
	POINTER_PROPERTY(KeyingSetPath, KeyingSetPaths, active)
	INT_PROPERTY(KeyingSetPaths, active_index)

	inline KeyingSetPath KeyingSetPaths::add(ID& target_id, const char * data_path, int index, int group_method, const char * group_name) {
		PointerRNA result;
		::KS_Path *retdata = KeyingSetPaths_add((::KeyingSet *) this->ptr.data, NULL, (::ID *) target_id.ptr.data, data_path, index, group_method, group_name);
		RNA_pointer_create((::ID *) ptr.id.data, &RNA_KeyingSetPath, retdata, &result);
		return KeyingSetPath(result);
	}

	inline void KeyingSetPaths::remove(KeyingSetPath& path) {
		KeyingSetPaths_remove((::KeyingSet *) this->ptr.data, NULL, (::PointerRNA *) &path.ptr);
	}

	inline void KeyingSetPaths::clear() {
		KeyingSetPaths_clear((::KeyingSet *) this->ptr.data, NULL);
	}


	POINTER_PROPERTY(Struct, KeyingSetPath, rna_type)
	POINTER_PROPERTY(ID, KeyingSetPath, id)
	ENUM_PROPERTY(id_type_enum, KeyingSetPath, id_type)
	STRING_PROPERTY(KeyingSetPath, group)
	ENUM_PROPERTY(group_method_enum, KeyingSetPath, group_method)
	STRING_PROPERTY(KeyingSetPath, data_path)
	INT_PROPERTY(KeyingSetPath, array_index)
	BOOLEAN_PROPERTY(KeyingSetPath, use_entire_array)
	BOOLEAN_PROPERTY(KeyingSetPath, use_insertkey_override_needed)
	BOOLEAN_PROPERTY(KeyingSetPath, use_insertkey_override_visual)
	BOOLEAN_PROPERTY(KeyingSetPath, use_insertkey_override_xyz_to_rgb)
	BOOLEAN_PROPERTY(KeyingSetPath, use_insertkey_needed)
	BOOLEAN_PROPERTY(KeyingSetPath, use_insertkey_visual)
	BOOLEAN_PROPERTY(KeyingSetPath, use_insertkey_xyz_to_rgb)


	POINTER_PROPERTY(Struct, KeyingSetInfo, rna_type)
	STRING_PROPERTY(KeyingSetInfo, bl_idname)
	STRING_PROPERTY(KeyingSetInfo, bl_label)
	STRING_PROPERTY(KeyingSetInfo, bl_description)
	ENUM_PROPERTY(bl_options_enum, KeyingSetInfo, bl_options)


	POINTER_PROPERTY(Struct, AnimViz, rna_type)
	POINTER_PROPERTY(AnimVizMotionPaths, AnimViz, motion_path)


	POINTER_PROPERTY(Struct, AnimVizMotionPaths, rna_type)
	ENUM_PROPERTY(type_enum, AnimVizMotionPaths, type)
	ENUM_PROPERTY(bake_location_enum, AnimVizMotionPaths, bake_location)
	BOOLEAN_PROPERTY(AnimVizMotionPaths, show_frame_numbers)
	BOOLEAN_PROPERTY(AnimVizMotionPaths, show_keyframe_highlight)
	BOOLEAN_PROPERTY(AnimVizMotionPaths, show_keyframe_numbers)
	BOOLEAN_PROPERTY(AnimVizMotionPaths, show_keyframe_action_all)
	INT_PROPERTY(AnimVizMotionPaths, frame_step)
	INT_PROPERTY(AnimVizMotionPaths, frame_start)
	INT_PROPERTY(AnimVizMotionPaths, frame_end)
	INT_PROPERTY(AnimVizMotionPaths, frame_before)
	INT_PROPERTY(AnimVizMotionPaths, frame_after)
	BOOLEAN_PROPERTY(AnimVizMotionPaths, has_motion_paths)


	POINTER_PROPERTY(Struct, MotionPath, rna_type)

	INT_PROPERTY(MotionPath, frame_start)
	INT_PROPERTY(MotionPath, frame_end)
	INT_PROPERTY(MotionPath, length)
	FLOAT_ARRAY_PROPERTY(MotionPath, 3, color)
	INT_PROPERTY(MotionPath, line_thickness)
	BOOLEAN_PROPERTY(MotionPath, use_bone_head)
	BOOLEAN_PROPERTY(MotionPath, is_modified)
	BOOLEAN_PROPERTY(MotionPath, use_custom_color)
	BOOLEAN_PROPERTY(MotionPath, lines)


	POINTER_PROPERTY(Struct, MotionPathVert, rna_type)
	FLOAT_ARRAY_PROPERTY(MotionPathVert, 3, co)
	BOOLEAN_PROPERTY(MotionPathVert, select)


	POINTER_PROPERTY(AnimData, Armature, animation_data)


	ENUM_PROPERTY(pose_position_enum, Armature, pose_position)
	ENUM_PROPERTY(display_type_enum, Armature, display_type)
	BOOLEAN_ARRAY_PROPERTY(Armature, 32, layers)
	BOOLEAN_ARRAY_PROPERTY(Armature, 32, layers_protected)
	BOOLEAN_PROPERTY(Armature, show_axes)
	BOOLEAN_PROPERTY(Armature, show_names)
	BOOLEAN_PROPERTY(Armature, use_deform_delay)
	BOOLEAN_PROPERTY(Armature, use_mirror_x)
	BOOLEAN_PROPERTY(Armature, use_auto_ik)
	BOOLEAN_PROPERTY(Armature, show_bone_custom_shapes)
	BOOLEAN_PROPERTY(Armature, show_group_colors)
	BOOLEAN_PROPERTY(Armature, is_editmode)

	inline void Armature::transform(void *main, float matrix[16]) {
		Armature_transform((::bArmature *) this->ptr.data, (::Main *) main, matrix);
	}


	POINTER_PROPERTY(Struct, ArmatureBones, rna_type)
	POINTER_PROPERTY(Bone, ArmatureBones, active)


	POINTER_PROPERTY(Struct, ArmatureEditBones, rna_type)
	POINTER_PROPERTY(EditBone, ArmatureEditBones, active)

	inline EditBone ArmatureEditBones::create(const char * name) {
		PointerRNA result;
		::EditBone *retdata = ArmatureEditBones_new((::bArmature *) this->ptr.data, NULL, name);
		RNA_pointer_create((::ID *) ptr.id.data, &RNA_EditBone, retdata, &result);
		return EditBone(result);
	}

	inline void ArmatureEditBones::remove(EditBone& bone) {
		ArmatureEditBones_remove((::bArmature *) this->ptr.data, NULL, (::PointerRNA *) &bone.ptr);
	}


	POINTER_PROPERTY(Struct, Bone, rna_type)
	POINTER_PROPERTY(Bone, Bone, parent)

	STRING_PROPERTY(Bone, name)
	BOOLEAN_ARRAY_PROPERTY(Bone, 32, layers)
	BOOLEAN_PROPERTY(Bone, use_connect)
	BOOLEAN_PROPERTY(Bone, use_inherit_rotation)
	BOOLEAN_PROPERTY(Bone, use_envelope_multiply)
	BOOLEAN_PROPERTY(Bone, use_deform)
	BOOLEAN_PROPERTY(Bone, use_inherit_scale)
	BOOLEAN_PROPERTY(Bone, use_local_location)
	BOOLEAN_PROPERTY(Bone, use_relative_parent)
	BOOLEAN_PROPERTY(Bone, show_wire)
	BOOLEAN_PROPERTY(Bone, use_cyclic_offset)
	BOOLEAN_PROPERTY(Bone, hide_select)
	FLOAT_PROPERTY(Bone, envelope_distance)
	FLOAT_PROPERTY(Bone, envelope_weight)
	FLOAT_PROPERTY(Bone, head_radius)
	FLOAT_PROPERTY(Bone, tail_radius)
	INT_PROPERTY(Bone, bbone_segments)
	FLOAT_PROPERTY(Bone, bbone_x)
	FLOAT_PROPERTY(Bone, bbone_z)
	ENUM_PROPERTY(bbone_handle_type_start_enum, Bone, bbone_handle_type_start)
	POINTER_PROPERTY(Bone, Bone, bbone_custom_handle_start)
	ENUM_PROPERTY(bbone_handle_type_end_enum, Bone, bbone_handle_type_end)
	POINTER_PROPERTY(Bone, Bone, bbone_custom_handle_end)
	FLOAT_PROPERTY(Bone, bbone_rollin)
	FLOAT_PROPERTY(Bone, bbone_rollout)
	BOOLEAN_PROPERTY(Bone, use_endroll_as_inroll)
	FLOAT_PROPERTY(Bone, bbone_curveinx)
	FLOAT_PROPERTY(Bone, bbone_curveiny)
	FLOAT_PROPERTY(Bone, bbone_curveoutx)
	FLOAT_PROPERTY(Bone, bbone_curveouty)
	FLOAT_PROPERTY(Bone, bbone_easein)
	FLOAT_PROPERTY(Bone, bbone_easeout)
	FLOAT_PROPERTY(Bone, bbone_scalein)
	FLOAT_PROPERTY(Bone, bbone_scaleout)
	BOOLEAN_PROPERTY(Bone, hide)
	BOOLEAN_PROPERTY(Bone, select)
	BOOLEAN_PROPERTY(Bone, select_head)
	BOOLEAN_PROPERTY(Bone, select_tail)
	FLOAT_ARRAY_PROPERTY(Bone, 9, matrix)
	FLOAT_ARRAY_PROPERTY(Bone, 16, matrix_local)
	FLOAT_ARRAY_PROPERTY(Bone, 3, tail)
	FLOAT_ARRAY_PROPERTY(Bone, 3, tail_local)
	FLOAT_ARRAY_PROPERTY(Bone, 3, head)
	FLOAT_ARRAY_PROPERTY(Bone, 3, head_local)

	inline float Bone::evaluate_envelope(float point[3]) {
		return Bone_evaluate_envelope((::Bone *) this->ptr.data, point);
	}

	inline void Bone::convert_local_to_pose(float matrix_return[16], float matrix[16], float matrix_local[16], float parent_matrix[16], float parent_matrix_local[16], bool invert) {
		Bone_convert_local_to_pose((::Bone *) this->ptr.data, matrix_return, matrix, matrix_local, parent_matrix, parent_matrix_local, invert);
	}

	inline void Bone::MatrixFromAxisRoll(float axis[3], float roll, float result_matrix[9]) {
		Bone_MatrixFromAxisRoll(axis, roll, result_matrix);
	}

	inline void Bone::AxisRollFromMatrix(float matrix[9], float axis[3], float result_axis[3], float *result_roll) {
		Bone_AxisRollFromMatrix(matrix, axis, result_axis, result_roll);
	}


	POINTER_PROPERTY(Struct, EditBone, rna_type)
	POINTER_PROPERTY(EditBone, EditBone, parent)
	FLOAT_PROPERTY(EditBone, roll)
	FLOAT_ARRAY_PROPERTY(EditBone, 3, head)
	FLOAT_ARRAY_PROPERTY(EditBone, 3, tail)
	STRING_PROPERTY(EditBone, name)
	BOOLEAN_ARRAY_PROPERTY(EditBone, 32, layers)
	BOOLEAN_PROPERTY(EditBone, use_connect)
	BOOLEAN_PROPERTY(EditBone, use_inherit_rotation)
	BOOLEAN_PROPERTY(EditBone, use_envelope_multiply)
	BOOLEAN_PROPERTY(EditBone, use_deform)
	BOOLEAN_PROPERTY(EditBone, use_inherit_scale)
	BOOLEAN_PROPERTY(EditBone, use_local_location)
	BOOLEAN_PROPERTY(EditBone, use_relative_parent)
	BOOLEAN_PROPERTY(EditBone, show_wire)
	BOOLEAN_PROPERTY(EditBone, use_cyclic_offset)
	BOOLEAN_PROPERTY(EditBone, hide_select)
	FLOAT_PROPERTY(EditBone, envelope_distance)
	FLOAT_PROPERTY(EditBone, envelope_weight)
	FLOAT_PROPERTY(EditBone, head_radius)
	FLOAT_PROPERTY(EditBone, tail_radius)
	INT_PROPERTY(EditBone, bbone_segments)
	FLOAT_PROPERTY(EditBone, bbone_x)
	FLOAT_PROPERTY(EditBone, bbone_z)
	ENUM_PROPERTY(bbone_handle_type_start_enum, EditBone, bbone_handle_type_start)
	POINTER_PROPERTY(EditBone, EditBone, bbone_custom_handle_start)
	ENUM_PROPERTY(bbone_handle_type_end_enum, EditBone, bbone_handle_type_end)
	POINTER_PROPERTY(EditBone, EditBone, bbone_custom_handle_end)
	FLOAT_PROPERTY(EditBone, bbone_rollin)
	FLOAT_PROPERTY(EditBone, bbone_rollout)
	BOOLEAN_PROPERTY(EditBone, use_endroll_as_inroll)
	FLOAT_PROPERTY(EditBone, bbone_curveinx)
	FLOAT_PROPERTY(EditBone, bbone_curveiny)
	FLOAT_PROPERTY(EditBone, bbone_curveoutx)
	FLOAT_PROPERTY(EditBone, bbone_curveouty)
	FLOAT_PROPERTY(EditBone, bbone_easein)
	FLOAT_PROPERTY(EditBone, bbone_easeout)
	FLOAT_PROPERTY(EditBone, bbone_scalein)
	FLOAT_PROPERTY(EditBone, bbone_scaleout)
	BOOLEAN_PROPERTY(EditBone, hide)
	BOOLEAN_PROPERTY(EditBone, lock)
	BOOLEAN_PROPERTY(EditBone, select)
	BOOLEAN_PROPERTY(EditBone, select_head)
	BOOLEAN_PROPERTY(EditBone, select_tail)
	FLOAT_ARRAY_PROPERTY(EditBone, 16, matrix)

	inline void EditBone::align_roll(float vector[3]) {
		EditBone_align_roll((::EditBone *) this->ptr.data, vector);
	}


	POINTER_PROPERTY(Struct, BoidRule, rna_type)
	STRING_PROPERTY(BoidRule, name)
	ENUM_PROPERTY(type_enum, BoidRule, type)
	BOOLEAN_PROPERTY(BoidRule, use_in_air)
	BOOLEAN_PROPERTY(BoidRule, use_on_land)


	POINTER_PROPERTY(Object, BoidRuleGoal, object)
	BOOLEAN_PROPERTY(BoidRuleGoal, use_predict)


	POINTER_PROPERTY(Object, BoidRuleAvoid, object)
	BOOLEAN_PROPERTY(BoidRuleAvoid, use_predict)
	FLOAT_PROPERTY(BoidRuleAvoid, fear_factor)


	BOOLEAN_PROPERTY(BoidRuleAvoidCollision, use_avoid)
	BOOLEAN_PROPERTY(BoidRuleAvoidCollision, use_avoid_collision)
	FLOAT_PROPERTY(BoidRuleAvoidCollision, look_ahead)


	POINTER_PROPERTY(Object, BoidRuleFollowLeader, object)
	FLOAT_PROPERTY(BoidRuleFollowLeader, distance)
	INT_PROPERTY(BoidRuleFollowLeader, queue_count)
	BOOLEAN_PROPERTY(BoidRuleFollowLeader, use_line)


	FLOAT_PROPERTY(BoidRuleAverageSpeed, wander)
	FLOAT_PROPERTY(BoidRuleAverageSpeed, level)
	FLOAT_PROPERTY(BoidRuleAverageSpeed, speed)


	FLOAT_PROPERTY(BoidRuleFight, distance)
	FLOAT_PROPERTY(BoidRuleFight, flee_distance)


	POINTER_PROPERTY(Struct, BoidState, rna_type)
	STRING_PROPERTY(BoidState, name)
	ENUM_PROPERTY(ruleset_type_enum, BoidState, ruleset_type)

	POINTER_PROPERTY(BoidRule, BoidState, active_boid_rule)
	INT_PROPERTY(BoidState, active_boid_rule_index)
	FLOAT_PROPERTY(BoidState, rule_fuzzy)
	FLOAT_PROPERTY(BoidState, volume)
	FLOAT_PROPERTY(BoidState, falloff)


	POINTER_PROPERTY(Struct, BoidSettings, rna_type)
	FLOAT_PROPERTY(BoidSettings, land_smooth)
	FLOAT_PROPERTY(BoidSettings, bank)
	FLOAT_PROPERTY(BoidSettings, pitch)
	FLOAT_PROPERTY(BoidSettings, height)

	POINTER_PROPERTY(BoidRule, BoidSettings, active_boid_state)
	INT_PROPERTY(BoidSettings, active_boid_state_index)
	FLOAT_PROPERTY(BoidSettings, health)
	FLOAT_PROPERTY(BoidSettings, strength)
	FLOAT_PROPERTY(BoidSettings, aggression)
	FLOAT_PROPERTY(BoidSettings, accuracy)
	FLOAT_PROPERTY(BoidSettings, range)
	FLOAT_PROPERTY(BoidSettings, air_speed_min)
	FLOAT_PROPERTY(BoidSettings, air_speed_max)
	FLOAT_PROPERTY(BoidSettings, air_acc_max)
	FLOAT_PROPERTY(BoidSettings, air_ave_max)
	FLOAT_PROPERTY(BoidSettings, air_personal_space)
	FLOAT_PROPERTY(BoidSettings, land_jump_speed)
	FLOAT_PROPERTY(BoidSettings, land_speed_max)
	FLOAT_PROPERTY(BoidSettings, land_acc_max)
	FLOAT_PROPERTY(BoidSettings, land_ave_max)
	FLOAT_PROPERTY(BoidSettings, land_personal_space)
	FLOAT_PROPERTY(BoidSettings, land_stick_force)
	BOOLEAN_PROPERTY(BoidSettings, use_flight)
	BOOLEAN_PROPERTY(BoidSettings, use_land)
	BOOLEAN_PROPERTY(BoidSettings, use_climb)


	ENUM_PROPERTY(blend_enum, Brush, blend)
	ENUM_PROPERTY(sculpt_tool_enum, Brush, sculpt_tool)
	ENUM_PROPERTY(vertex_tool_enum, Brush, vertex_tool)
	ENUM_PROPERTY(weight_tool_enum, Brush, weight_tool)
	ENUM_PROPERTY(image_tool_enum, Brush, image_tool)
	ENUM_PROPERTY(gpencil_tool_enum, Brush, gpencil_tool)
	ENUM_PROPERTY(direction_enum, Brush, direction)
	ENUM_PROPERTY(stroke_method_enum, Brush, stroke_method)
	ENUM_PROPERTY(sculpt_plane_enum, Brush, sculpt_plane)
	ENUM_PROPERTY(mask_tool_enum, Brush, mask_tool)
	INT_PROPERTY(Brush, size)
	FLOAT_PROPERTY(Brush, unprojected_radius)
	FLOAT_PROPERTY(Brush, jitter)
	INT_PROPERTY(Brush, jitter_absolute)
	INT_PROPERTY(Brush, spacing)
	INT_PROPERTY(Brush, grad_spacing)
	INT_PROPERTY(Brush, smooth_stroke_radius)
	FLOAT_PROPERTY(Brush, smooth_stroke_factor)
	FLOAT_PROPERTY(Brush, rate)
	FLOAT_ARRAY_PROPERTY(Brush, 3, color)
	FLOAT_ARRAY_PROPERTY(Brush, 3, secondary_color)
	FLOAT_PROPERTY(Brush, weight)
	FLOAT_PROPERTY(Brush, strength)
	FLOAT_PROPERTY(Brush, plane_offset)
	FLOAT_PROPERTY(Brush, plane_trim)
	FLOAT_PROPERTY(Brush, height)
	FLOAT_PROPERTY(Brush, texture_sample_bias)
	FLOAT_PROPERTY(Brush, normal_weight)
	FLOAT_PROPERTY(Brush, rake_factor)
	FLOAT_PROPERTY(Brush, crease_pinch_factor)
	FLOAT_PROPERTY(Brush, auto_smooth_factor)
	FLOAT_PROPERTY(Brush, topology_rake_factor)
	FLOAT_ARRAY_PROPERTY(Brush, 2, stencil_pos)
	FLOAT_ARRAY_PROPERTY(Brush, 2, stencil_dimension)
	FLOAT_ARRAY_PROPERTY(Brush, 2, mask_stencil_pos)
	FLOAT_ARRAY_PROPERTY(Brush, 2, mask_stencil_dimension)
	FLOAT_PROPERTY(Brush, sharp_threshold)
	FLOAT_PROPERTY(Brush, fill_threshold)
	INT_PROPERTY(Brush, blur_kernel_radius)
	ENUM_PROPERTY(blur_mode_enum, Brush, blur_mode)
	FLOAT_PROPERTY(Brush, falloff_angle)
	BOOLEAN_PROPERTY(Brush, use_projected)
	BOOLEAN_PROPERTY(Brush, use_airbrush)
	BOOLEAN_PROPERTY(Brush, use_original_normal)
	BOOLEAN_PROPERTY(Brush, use_pressure_strength)
	BOOLEAN_PROPERTY(Brush, use_offset_pressure)
	BOOLEAN_PROPERTY(Brush, use_pressure_size)
	BOOLEAN_PROPERTY(Brush, use_gradient)
	BOOLEAN_PROPERTY(Brush, use_pressure_jitter)
	BOOLEAN_PROPERTY(Brush, use_pressure_spacing)
	ENUM_PROPERTY(use_pressure_masking_enum, Brush, use_pressure_masking)
	BOOLEAN_PROPERTY(Brush, use_inverse_smooth_pressure)
	BOOLEAN_PROPERTY(Brush, use_relative_jitter)
	BOOLEAN_PROPERTY(Brush, use_plane_trim)
	BOOLEAN_PROPERTY(Brush, use_frontface)
	BOOLEAN_PROPERTY(Brush, use_frontface_falloff)
	BOOLEAN_PROPERTY(Brush, use_anchor)
	BOOLEAN_PROPERTY(Brush, use_space)
	BOOLEAN_PROPERTY(Brush, use_line)
	BOOLEAN_PROPERTY(Brush, use_curve)
	BOOLEAN_PROPERTY(Brush, use_smooth_stroke)
	BOOLEAN_PROPERTY(Brush, use_persistent)
	BOOLEAN_PROPERTY(Brush, use_accumulate)
	BOOLEAN_PROPERTY(Brush, use_space_attenuation)
	BOOLEAN_PROPERTY(Brush, use_adaptive_space)
	ENUM_PROPERTY(use_locked_size_enum, Brush, use_locked_size)
	BOOLEAN_PROPERTY(Brush, use_edge_to_edge)
	BOOLEAN_PROPERTY(Brush, use_restore_mesh)
	BOOLEAN_PROPERTY(Brush, use_alpha)
	POINTER_PROPERTY(CurveMapping, Brush, curve)
	POINTER_PROPERTY(PaintCurve, Brush, paint_curve)
	POINTER_PROPERTY(ColorRamp, Brush, gradient)
	ENUM_PROPERTY(gradient_stroke_mode_enum, Brush, gradient_stroke_mode)
	ENUM_PROPERTY(gradient_fill_mode_enum, Brush, gradient_fill_mode)
	BOOLEAN_PROPERTY(Brush, use_primary_overlay)
	BOOLEAN_PROPERTY(Brush, use_secondary_overlay)
	BOOLEAN_PROPERTY(Brush, use_cursor_overlay)
	BOOLEAN_PROPERTY(Brush, use_cursor_overlay_override)
	BOOLEAN_PROPERTY(Brush, use_primary_overlay_override)
	BOOLEAN_PROPERTY(Brush, use_secondary_overlay_override)
	BOOLEAN_PROPERTY(Brush, use_paint_sculpt)
	BOOLEAN_PROPERTY(Brush, use_paint_vertex)
	BOOLEAN_PROPERTY(Brush, use_paint_weight)
	BOOLEAN_PROPERTY(Brush, use_paint_image)
	BOOLEAN_PROPERTY(Brush, use_paint_grease_pencil)
	POINTER_PROPERTY(BrushTextureSlot, Brush, texture_slot)
	POINTER_PROPERTY(Texture, Brush, texture)
	POINTER_PROPERTY(BrushTextureSlot, Brush, mask_texture_slot)
	POINTER_PROPERTY(Texture, Brush, mask_texture)
	INT_PROPERTY(Brush, texture_overlay_alpha)
	INT_PROPERTY(Brush, mask_overlay_alpha)
	INT_PROPERTY(Brush, cursor_overlay_alpha)
	FLOAT_ARRAY_PROPERTY(Brush, 3, cursor_color_add)
	FLOAT_ARRAY_PROPERTY(Brush, 3, cursor_color_subtract)
	BOOLEAN_PROPERTY(Brush, use_custom_icon)
	STRING_PROPERTY(Brush, icon_filepath)
	POINTER_PROPERTY(Image, Brush, clone_image)
	FLOAT_PROPERTY(Brush, clone_alpha)
	FLOAT_ARRAY_PROPERTY(Brush, 2, clone_offset)
	POINTER_PROPERTY(BrushCapabilities, Brush, brush_capabilities)
	POINTER_PROPERTY(BrushCapabilitiesSculpt, Brush, sculpt_capabilities)
	POINTER_PROPERTY(BrushCapabilitiesImagePaint, Brush, image_paint_capabilities)
	POINTER_PROPERTY(BrushCapabilitiesVertexPaint, Brush, vertex_paint_capabilities)
	POINTER_PROPERTY(BrushCapabilitiesWeightPaint, Brush, weight_paint_capabilities)
	POINTER_PROPERTY(BrushGpencilSettings, Brush, gpencil_settings)


	POINTER_PROPERTY(Struct, BrushCapabilities, rna_type)
	BOOLEAN_PROPERTY(BrushCapabilities, has_overlay)
	BOOLEAN_PROPERTY(BrushCapabilities, has_random_texture_angle)
	BOOLEAN_PROPERTY(BrushCapabilities, has_spacing)
	BOOLEAN_PROPERTY(BrushCapabilities, has_smooth_stroke)


	POINTER_PROPERTY(Struct, BrushCapabilitiesSculpt, rna_type)
	BOOLEAN_PROPERTY(BrushCapabilitiesSculpt, has_accumulate)
	BOOLEAN_PROPERTY(BrushCapabilitiesSculpt, has_auto_smooth)
	BOOLEAN_PROPERTY(BrushCapabilitiesSculpt, has_topology_rake)
	BOOLEAN_PROPERTY(BrushCapabilitiesSculpt, has_height)
	BOOLEAN_PROPERTY(BrushCapabilitiesSculpt, has_jitter)
	BOOLEAN_PROPERTY(BrushCapabilitiesSculpt, has_normal_weight)
	BOOLEAN_PROPERTY(BrushCapabilitiesSculpt, has_rake_factor)
	BOOLEAN_PROPERTY(BrushCapabilitiesSculpt, has_persistence)
	BOOLEAN_PROPERTY(BrushCapabilitiesSculpt, has_pinch_factor)
	BOOLEAN_PROPERTY(BrushCapabilitiesSculpt, has_plane_offset)
	BOOLEAN_PROPERTY(BrushCapabilitiesSculpt, has_random_texture_angle)
	BOOLEAN_PROPERTY(BrushCapabilitiesSculpt, has_sculpt_plane)
	BOOLEAN_PROPERTY(BrushCapabilitiesSculpt, has_secondary_color)
	BOOLEAN_PROPERTY(BrushCapabilitiesSculpt, has_smooth_stroke)
	BOOLEAN_PROPERTY(BrushCapabilitiesSculpt, has_space_attenuation)
	BOOLEAN_PROPERTY(BrushCapabilitiesSculpt, has_strength_pressure)
	BOOLEAN_PROPERTY(BrushCapabilitiesSculpt, has_direction)
	BOOLEAN_PROPERTY(BrushCapabilitiesSculpt, has_gravity)


	POINTER_PROPERTY(Struct, BrushCapabilitiesImagePaint, rna_type)
	BOOLEAN_PROPERTY(BrushCapabilitiesImagePaint, has_accumulate)
	BOOLEAN_PROPERTY(BrushCapabilitiesImagePaint, has_space_attenuation)
	BOOLEAN_PROPERTY(BrushCapabilitiesImagePaint, has_radius)
	BOOLEAN_PROPERTY(BrushCapabilitiesImagePaint, has_color)


	POINTER_PROPERTY(Struct, BrushCapabilitiesVertexPaint, rna_type)
	BOOLEAN_PROPERTY(BrushCapabilitiesVertexPaint, has_color)


	POINTER_PROPERTY(Struct, BrushCapabilitiesWeightPaint, rna_type)
	BOOLEAN_PROPERTY(BrushCapabilitiesWeightPaint, has_weight)


	POINTER_PROPERTY(Struct, BrushGpencilSettings, rna_type)
	FLOAT_PROPERTY(BrushGpencilSettings, pen_sensitivity_factor)
	FLOAT_PROPERTY(BrushGpencilSettings, pen_strength)
	FLOAT_PROPERTY(BrushGpencilSettings, pen_jitter)
	FLOAT_PROPERTY(BrushGpencilSettings, random_pressure)
	FLOAT_PROPERTY(BrushGpencilSettings, random_strength)
	FLOAT_PROPERTY(BrushGpencilSettings, random_subdiv)
	FLOAT_PROPERTY(BrushGpencilSettings, angle)
	FLOAT_PROPERTY(BrushGpencilSettings, angle_factor)
	FLOAT_PROPERTY(BrushGpencilSettings, pen_smooth_factor)
	INT_PROPERTY(BrushGpencilSettings, pen_smooth_steps)
	FLOAT_PROPERTY(BrushGpencilSettings, pen_thick_smooth_factor)
	INT_PROPERTY(BrushGpencilSettings, pen_thick_smooth_steps)
	INT_PROPERTY(BrushGpencilSettings, pen_subdivision_steps)
	POINTER_PROPERTY(CurveMapping, BrushGpencilSettings, curve_sensitivity)
	POINTER_PROPERTY(CurveMapping, BrushGpencilSettings, curve_strength)
	POINTER_PROPERTY(CurveMapping, BrushGpencilSettings, curve_jitter)
	FLOAT_PROPERTY(BrushGpencilSettings, fill_threshold)
	INT_PROPERTY(BrushGpencilSettings, fill_leak)
	INT_PROPERTY(BrushGpencilSettings, fill_factor)
	INT_PROPERTY(BrushGpencilSettings, fill_simplify_level)
	FLOAT_PROPERTY(BrushGpencilSettings, uv_random)
	INT_PROPERTY(BrushGpencilSettings, input_samples)
	FLOAT_PROPERTY(BrushGpencilSettings, active_smooth_factor)
	FLOAT_PROPERTY(BrushGpencilSettings, eraser_strength_factor)
	FLOAT_PROPERTY(BrushGpencilSettings, eraser_thickness_factor)
	ENUM_PROPERTY(gp_icon_enum, BrushGpencilSettings, gp_icon)
	BOOLEAN_PROPERTY(BrushGpencilSettings, use_pressure)
	BOOLEAN_PROPERTY(BrushGpencilSettings, use_strength_pressure)
	BOOLEAN_PROPERTY(BrushGpencilSettings, use_jitter_pressure)
	BOOLEAN_PROPERTY(BrushGpencilSettings, use_settings_stabilizer)
	BOOLEAN_PROPERTY(BrushGpencilSettings, use_cursor)
	ENUM_PROPERTY(eraser_mode_enum, BrushGpencilSettings, eraser_mode)
	ENUM_PROPERTY(fill_draw_mode_enum, BrushGpencilSettings, fill_draw_mode)
	BOOLEAN_PROPERTY(BrushGpencilSettings, trim)
	POINTER_PROPERTY(Material, BrushGpencilSettings, material)
	BOOLEAN_PROPERTY(BrushGpencilSettings, show_fill_boundary)
	BOOLEAN_PROPERTY(BrushGpencilSettings, show_fill)
	BOOLEAN_PROPERTY(BrushGpencilSettings, use_default_eraser)
	BOOLEAN_PROPERTY(BrushGpencilSettings, use_settings_postprocess)
	BOOLEAN_PROPERTY(BrushGpencilSettings, use_settings_random)
	BOOLEAN_PROPERTY(BrushGpencilSettings, use_material_pin)
	BOOLEAN_PROPERTY(BrushGpencilSettings, show_lasso)
	BOOLEAN_PROPERTY(BrushGpencilSettings, use_occlude_eraser)


	FLOAT_PROPERTY(BrushTextureSlot, angle)
	ENUM_PROPERTY(map_mode_enum, BrushTextureSlot, map_mode)
	ENUM_PROPERTY(tex_paint_map_mode_enum, BrushTextureSlot, tex_paint_map_mode)
	ENUM_PROPERTY(mask_map_mode_enum, BrushTextureSlot, mask_map_mode)
	BOOLEAN_PROPERTY(BrushTextureSlot, use_rake)
	BOOLEAN_PROPERTY(BrushTextureSlot, use_random)
	FLOAT_PROPERTY(BrushTextureSlot, random_angle)
	BOOLEAN_PROPERTY(BrushTextureSlot, has_texture_angle_source)
	BOOLEAN_PROPERTY(BrushTextureSlot, has_random_texture_angle)
	BOOLEAN_PROPERTY(BrushTextureSlot, has_texture_angle)




	STRING_PROPERTY(CacheFile, filepath)
	BOOLEAN_PROPERTY(CacheFile, is_sequence)
	BOOLEAN_PROPERTY(CacheFile, override_frame)
	FLOAT_PROPERTY(CacheFile, frame)
	FLOAT_PROPERTY(CacheFile, frame_offset)
	ENUM_PROPERTY(forward_axis_enum, CacheFile, forward_axis)
	ENUM_PROPERTY(up_axis_enum, CacheFile, up_axis)
	FLOAT_PROPERTY(CacheFile, scale)

	POINTER_PROPERTY(AnimData, CacheFile, animation_data)


	POINTER_PROPERTY(Struct, AlembicObjectPaths, rna_type)


	POINTER_PROPERTY(Struct, AlembicObjectPath, rna_type)
	STRING_PROPERTY(AlembicObjectPath, path)


	ENUM_PROPERTY(type_enum, Camera, type)
	ENUM_PROPERTY(sensor_fit_enum, Camera, sensor_fit)
	FLOAT_PROPERTY(Camera, passepartout_alpha)
	FLOAT_PROPERTY(Camera, angle_x)
	FLOAT_PROPERTY(Camera, angle_y)
	FLOAT_PROPERTY(Camera, angle)
	FLOAT_PROPERTY(Camera, clip_start)
	FLOAT_PROPERTY(Camera, clip_end)
	FLOAT_PROPERTY(Camera, lens)
	FLOAT_PROPERTY(Camera, sensor_width)
	FLOAT_PROPERTY(Camera, sensor_height)
	FLOAT_PROPERTY(Camera, ortho_scale)
	FLOAT_PROPERTY(Camera, display_size)
	FLOAT_PROPERTY(Camera, shift_x)
	FLOAT_PROPERTY(Camera, shift_y)
	FLOAT_PROPERTY(Camera, dof_distance)
	POINTER_PROPERTY(CameraStereoData, Camera, stereo)
	BOOLEAN_PROPERTY(Camera, show_limits)
	BOOLEAN_PROPERTY(Camera, show_mist)
	BOOLEAN_PROPERTY(Camera, show_passepartout)
	BOOLEAN_PROPERTY(Camera, show_safe_areas)
	BOOLEAN_PROPERTY(Camera, show_safe_center)
	BOOLEAN_PROPERTY(Camera, show_name)
	BOOLEAN_PROPERTY(Camera, show_sensor)
	BOOLEAN_PROPERTY(Camera, show_background_images)
	ENUM_PROPERTY(lens_unit_enum, Camera, lens_unit)
	BOOLEAN_PROPERTY(Camera, show_composition_center)
	BOOLEAN_PROPERTY(Camera, show_composition_center_diagonal)
	BOOLEAN_PROPERTY(Camera, show_composition_thirds)
	BOOLEAN_PROPERTY(Camera, show_composition_golden)
	BOOLEAN_PROPERTY(Camera, show_composition_golden_tria_a)
	BOOLEAN_PROPERTY(Camera, show_composition_golden_tria_b)
	BOOLEAN_PROPERTY(Camera, show_composition_harmony_tri_a)
	BOOLEAN_PROPERTY(Camera, show_composition_harmony_tri_b)
	POINTER_PROPERTY(Object, Camera, dof_object)
	POINTER_PROPERTY(GPUDOFSettings, Camera, gpu_dof)

	POINTER_PROPERTY(AnimData, Camera, animation_data)

	inline void Camera::view_frame(Scene& scene, float result_1[3], float result_2[3], float result_3[3], float result_4[3]) {
		Camera_view_frame((::Camera *) this->ptr.data, (::Scene *) scene.ptr.data, result_1, result_2, result_3, result_4);
	}


	POINTER_PROPERTY(Struct, CameraBackgroundImage, rna_type)
	ENUM_PROPERTY(source_enum, CameraBackgroundImage, source)
	POINTER_PROPERTY(Image, CameraBackgroundImage, image)
	POINTER_PROPERTY(MovieClip, CameraBackgroundImage, clip)
	POINTER_PROPERTY(ImageUser, CameraBackgroundImage, image_user)
	POINTER_PROPERTY(MovieClipUser, CameraBackgroundImage, clip_user)
	FLOAT_ARRAY_PROPERTY(CameraBackgroundImage, 2, offset)
	FLOAT_PROPERTY(CameraBackgroundImage, scale)
	FLOAT_PROPERTY(CameraBackgroundImage, rotation)
	BOOLEAN_PROPERTY(CameraBackgroundImage, use_flip_x)
	BOOLEAN_PROPERTY(CameraBackgroundImage, use_flip_y)
	FLOAT_PROPERTY(CameraBackgroundImage, alpha)
	BOOLEAN_PROPERTY(CameraBackgroundImage, show_expanded)
	BOOLEAN_PROPERTY(CameraBackgroundImage, use_camera_clip)
	BOOLEAN_PROPERTY(CameraBackgroundImage, show_background_image)
	BOOLEAN_PROPERTY(CameraBackgroundImage, show_on_foreground)
	ENUM_PROPERTY(display_depth_enum, CameraBackgroundImage, display_depth)
	ENUM_PROPERTY(frame_method_enum, CameraBackgroundImage, frame_method)


	POINTER_PROPERTY(Struct, CameraBackgroundImages, rna_type)

	inline CameraBackgroundImage CameraBackgroundImages::create() {
		PointerRNA result;
		::CameraBGImage *retdata = CameraBackgroundImages_new((::Camera *) this->ptr.data);
		RNA_pointer_create((::ID *) ptr.id.data, &RNA_CameraBackgroundImage, retdata, &result);
		return CameraBackgroundImage(result);
	}

	inline void CameraBackgroundImages::remove(CameraBackgroundImage& image) {
		CameraBackgroundImages_remove((::Camera *) this->ptr.data, NULL, (::PointerRNA *) &image.ptr);
	}

	inline void CameraBackgroundImages::clear() {
		CameraBackgroundImages_clear((::Camera *) this->ptr.data);
	}


	POINTER_PROPERTY(Struct, CameraStereoData, rna_type)
	ENUM_PROPERTY(convergence_mode_enum, CameraStereoData, convergence_mode)
	ENUM_PROPERTY(pivot_enum, CameraStereoData, pivot)
	FLOAT_PROPERTY(CameraStereoData, interocular_distance)
	FLOAT_PROPERTY(CameraStereoData, convergence_distance)
	BOOLEAN_PROPERTY(CameraStereoData, use_spherical_stereo)
	BOOLEAN_PROPERTY(CameraStereoData, use_pole_merge)
	FLOAT_PROPERTY(CameraStereoData, pole_merge_angle_from)
	FLOAT_PROPERTY(CameraStereoData, pole_merge_angle_to)


	POINTER_PROPERTY(Struct, ClothSolverResult, rna_type)
	ENUM_PROPERTY(status_enum, ClothSolverResult, status)
	FLOAT_PROPERTY(ClothSolverResult, max_error)
	FLOAT_PROPERTY(ClothSolverResult, min_error)
	FLOAT_PROPERTY(ClothSolverResult, avg_error)
	INT_PROPERTY(ClothSolverResult, max_iterations)
	INT_PROPERTY(ClothSolverResult, min_iterations)
	FLOAT_PROPERTY(ClothSolverResult, avg_iterations)


	POINTER_PROPERTY(Struct, ClothSettings, rna_type)
	FLOAT_PROPERTY(ClothSettings, goal_min)
	FLOAT_PROPERTY(ClothSettings, goal_max)
	FLOAT_PROPERTY(ClothSettings, goal_default)
	FLOAT_PROPERTY(ClothSettings, goal_spring)
	FLOAT_PROPERTY(ClothSettings, goal_friction)
	FLOAT_PROPERTY(ClothSettings, internal_friction)
	FLOAT_PROPERTY(ClothSettings, collider_friction)
	FLOAT_PROPERTY(ClothSettings, density_target)
	FLOAT_PROPERTY(ClothSettings, density_strength)
	FLOAT_PROPERTY(ClothSettings, mass)
	STRING_PROPERTY(ClothSettings, vertex_group_mass)
	FLOAT_ARRAY_PROPERTY(ClothSettings, 3, gravity)
	FLOAT_PROPERTY(ClothSettings, air_damping)
	FLOAT_PROPERTY(ClothSettings, pin_stiffness)
	INT_PROPERTY(ClothSettings, quality)
	FLOAT_PROPERTY(ClothSettings, time_scale)
	STRING_PROPERTY(ClothSettings, vertex_group_shrink)
	FLOAT_PROPERTY(ClothSettings, shrink_min)
	FLOAT_PROPERTY(ClothSettings, shrink_max)
	FLOAT_PROPERTY(ClothSettings, voxel_cell_size)
	FLOAT_PROPERTY(ClothSettings, tension_damping)
	FLOAT_PROPERTY(ClothSettings, compression_damping)
	FLOAT_PROPERTY(ClothSettings, shear_damping)
	FLOAT_PROPERTY(ClothSettings, tension_stiffness)
	FLOAT_PROPERTY(ClothSettings, tension_stiffness_max)
	FLOAT_PROPERTY(ClothSettings, compression_stiffness)
	FLOAT_PROPERTY(ClothSettings, compression_stiffness_max)
	FLOAT_PROPERTY(ClothSettings, shear_stiffness)
	FLOAT_PROPERTY(ClothSettings, shear_stiffness_max)
	FLOAT_PROPERTY(ClothSettings, sewing_force_max)
	STRING_PROPERTY(ClothSettings, vertex_group_structural_stiffness)
	STRING_PROPERTY(ClothSettings, vertex_group_shear_stiffness)
	FLOAT_PROPERTY(ClothSettings, bending_stiffness)
	FLOAT_PROPERTY(ClothSettings, bending_stiffness_max)
	FLOAT_PROPERTY(ClothSettings, bending_damping)
	BOOLEAN_PROPERTY(ClothSettings, use_sewing_springs)
	STRING_PROPERTY(ClothSettings, vertex_group_bending)
	POINTER_PROPERTY(EffectorWeights, ClothSettings, effector_weights)
	POINTER_PROPERTY(ShapeKey, ClothSettings, rest_shape_key)
	BOOLEAN_PROPERTY(ClothSettings, use_dynamic_mesh)
	ENUM_PROPERTY(bending_model_enum, ClothSettings, bending_model)


	POINTER_PROPERTY(Struct, ClothCollisionSettings, rna_type)
	BOOLEAN_PROPERTY(ClothCollisionSettings, use_collision)
	FLOAT_PROPERTY(ClothCollisionSettings, distance_min)
	FLOAT_PROPERTY(ClothCollisionSettings, friction)
	FLOAT_PROPERTY(ClothCollisionSettings, damping)
	INT_PROPERTY(ClothCollisionSettings, collision_quality)
	FLOAT_PROPERTY(ClothCollisionSettings, impulse_clamp)
	BOOLEAN_PROPERTY(ClothCollisionSettings, use_self_collision)
	FLOAT_PROPERTY(ClothCollisionSettings, self_distance_min)
	FLOAT_PROPERTY(ClothCollisionSettings, self_friction)
	POINTER_PROPERTY(Collection, ClothCollisionSettings, collection)
	STRING_PROPERTY(ClothCollisionSettings, vertex_group_self_collisions)
	FLOAT_PROPERTY(ClothCollisionSettings, self_impulse_clamp)


	FLOAT_ARRAY_PROPERTY(Collection, 3, instance_offset)



	BOOLEAN_PROPERTY(Collection, hide_select)
	BOOLEAN_PROPERTY(Collection, hide_viewport)
	BOOLEAN_PROPERTY(Collection, hide_render)


	POINTER_PROPERTY(Struct, CollectionObjects, rna_type)

	inline void CollectionObjects::link(void *main, Object& object) {
		CollectionObjects_link((::Collection *) this->ptr.data, (::Main *) main, NULL, (::Object *) object.ptr.data);
	}

	inline void CollectionObjects::unlink(void *main, Object& object) {
		CollectionObjects_unlink((::Collection *) this->ptr.data, (::Main *) main, NULL, (::Object *) object.ptr.data);
	}


	POINTER_PROPERTY(Struct, CollectionChildren, rna_type)

	inline void CollectionChildren::link(void *main, Collection& child) {
		CollectionChildren_link((::Collection *) this->ptr.data, (::Main *) main, NULL, (::Collection *) child.ptr.data);
	}

	inline void CollectionChildren::unlink(void *main, Collection& child) {
		CollectionChildren_unlink((::Collection *) this->ptr.data, (::Main *) main, NULL, (::Collection *) child.ptr.data);
	}


	POINTER_PROPERTY(Struct, CurveMapPoint, rna_type)
	FLOAT_ARRAY_PROPERTY(CurveMapPoint, 2, location)
	ENUM_PROPERTY(handle_type_enum, CurveMapPoint, handle_type)
	BOOLEAN_PROPERTY(CurveMapPoint, select)


	POINTER_PROPERTY(Struct, CurveMap, rna_type)
	ENUM_PROPERTY(extend_enum, CurveMap, extend)


	inline float CurveMap::evaluate(float position) {
		return CurveMap_evaluate((::CurveMap *) this->ptr.data, NULL, position);
	}


	POINTER_PROPERTY(Struct, CurveMapPoints, rna_type)

	inline CurveMapPoint CurveMapPoints::create(float position, float value) {
		PointerRNA result;
		::CurveMapPoint *retdata = CurveMapPoints_new((::CurveMap *) this->ptr.data, position, value);
		RNA_pointer_create((::ID *) ptr.id.data, &RNA_CurveMapPoint, retdata, &result);
		return CurveMapPoint(result);
	}

	inline void CurveMapPoints::remove(CurveMapPoint& point) {
		CurveMapPoints_remove((::CurveMap *) this->ptr.data, NULL, (::PointerRNA *) &point.ptr);
	}


	POINTER_PROPERTY(Struct, CurveMapping, rna_type)
	ENUM_PROPERTY(tone_enum, CurveMapping, tone)
	BOOLEAN_PROPERTY(CurveMapping, use_clip)
	FLOAT_PROPERTY(CurveMapping, clip_min_x)
	FLOAT_PROPERTY(CurveMapping, clip_min_y)
	FLOAT_PROPERTY(CurveMapping, clip_max_x)
	FLOAT_PROPERTY(CurveMapping, clip_max_y)

	FLOAT_ARRAY_PROPERTY(CurveMapping, 3, black_level)
	FLOAT_ARRAY_PROPERTY(CurveMapping, 3, white_level)

	inline void CurveMapping::update() {
		CurveMapping_update((::CurveMapping *) this->ptr.data);
	}

	inline void CurveMapping::initialize() {
		CurveMapping_initialize((::CurveMapping *) this->ptr.data);
	}


	POINTER_PROPERTY(Struct, ColorRampElement, rna_type)
	FLOAT_ARRAY_PROPERTY(ColorRampElement, 4, color)
	FLOAT_PROPERTY(ColorRampElement, alpha)
	FLOAT_PROPERTY(ColorRampElement, position)


	POINTER_PROPERTY(Struct, ColorRamp, rna_type)

	ENUM_PROPERTY(interpolation_enum, ColorRamp, interpolation)
	ENUM_PROPERTY(hue_interpolation_enum, ColorRamp, hue_interpolation)
	ENUM_PROPERTY(color_mode_enum, ColorRamp, color_mode)

	inline void ColorRamp::evaluate(float position, float color[4]) {
		ColorRamp_evaluate((::ColorBand *) this->ptr.data, position, color);
	}


	POINTER_PROPERTY(Struct, ColorRampElements, rna_type)

	inline ColorRampElement ColorRampElements::create(float position) {
		PointerRNA result;
		::CBData *retdata = ColorRampElements_new((::ColorBand *) this->ptr.data, NULL, position);
		RNA_pointer_create((::ID *) ptr.id.data, &RNA_ColorRampElement, retdata, &result);
		return ColorRampElement(result);
	}

	inline void ColorRampElements::remove(ColorRampElement& element) {
		ColorRampElements_remove((::ColorBand *) this->ptr.data, NULL, (::PointerRNA *) &element.ptr);
	}


	POINTER_PROPERTY(Struct, Histogram, rna_type)
	ENUM_PROPERTY(mode_enum, Histogram, mode)
	BOOLEAN_PROPERTY(Histogram, show_line)


	POINTER_PROPERTY(Struct, Scopes, rna_type)
	BOOLEAN_PROPERTY(Scopes, use_full_resolution)
	FLOAT_PROPERTY(Scopes, accuracy)
	POINTER_PROPERTY(Histogram, Scopes, histogram)
	ENUM_PROPERTY(waveform_mode_enum, Scopes, waveform_mode)
	FLOAT_PROPERTY(Scopes, waveform_alpha)
	FLOAT_PROPERTY(Scopes, vectorscope_alpha)


	POINTER_PROPERTY(Struct, ColorManagedDisplaySettings, rna_type)
	ENUM_PROPERTY(display_device_enum, ColorManagedDisplaySettings, display_device)


	POINTER_PROPERTY(Struct, ColorManagedViewSettings, rna_type)
	ENUM_PROPERTY(look_enum, ColorManagedViewSettings, look)
	ENUM_PROPERTY(view_transform_enum, ColorManagedViewSettings, view_transform)
	FLOAT_PROPERTY(ColorManagedViewSettings, exposure)
	FLOAT_PROPERTY(ColorManagedViewSettings, gamma)
	POINTER_PROPERTY(CurveMapping, ColorManagedViewSettings, curve_mapping)
	BOOLEAN_PROPERTY(ColorManagedViewSettings, use_curve_mapping)


	POINTER_PROPERTY(Struct, ColorManagedInputColorspaceSettings, rna_type)
	ENUM_PROPERTY(name_enum, ColorManagedInputColorspaceSettings, name)


	POINTER_PROPERTY(Struct, ColorManagedSequencerColorspaceSettings, rna_type)
	ENUM_PROPERTY(name_enum, ColorManagedSequencerColorspaceSettings, name)


	POINTER_PROPERTY(Struct, Constraint, rna_type)
	STRING_PROPERTY(Constraint, name)
	ENUM_PROPERTY(type_enum, Constraint, type)
	ENUM_PROPERTY(owner_space_enum, Constraint, owner_space)
	ENUM_PROPERTY(target_space_enum, Constraint, target_space)
	BOOLEAN_PROPERTY(Constraint, mute)
	BOOLEAN_PROPERTY(Constraint, show_expanded)
	BOOLEAN_PROPERTY(Constraint, is_valid)
	BOOLEAN_PROPERTY(Constraint, active)
	BOOLEAN_PROPERTY(Constraint, is_proxy_local)
	FLOAT_PROPERTY(Constraint, influence)
	FLOAT_PROPERTY(Constraint, error_location)
	FLOAT_PROPERTY(Constraint, error_rotation)


	POINTER_PROPERTY(Struct, ConstraintTarget, rna_type)
	POINTER_PROPERTY(Object, ConstraintTarget, target)
	STRING_PROPERTY(ConstraintTarget, subtarget)


	POINTER_PROPERTY(Struct, ConstraintTargetBone, rna_type)
	POINTER_PROPERTY(Object, ConstraintTargetBone, target)
	STRING_PROPERTY(ConstraintTargetBone, subtarget)
	FLOAT_PROPERTY(ConstraintTargetBone, weight)


	POINTER_PROPERTY(Object, ChildOfConstraint, target)
	STRING_PROPERTY(ChildOfConstraint, subtarget)
	BOOLEAN_PROPERTY(ChildOfConstraint, use_location_x)
	BOOLEAN_PROPERTY(ChildOfConstraint, use_location_y)
	BOOLEAN_PROPERTY(ChildOfConstraint, use_location_z)
	BOOLEAN_PROPERTY(ChildOfConstraint, use_rotation_x)
	BOOLEAN_PROPERTY(ChildOfConstraint, use_rotation_y)
	BOOLEAN_PROPERTY(ChildOfConstraint, use_rotation_z)
	BOOLEAN_PROPERTY(ChildOfConstraint, use_scale_x)
	BOOLEAN_PROPERTY(ChildOfConstraint, use_scale_y)
	BOOLEAN_PROPERTY(ChildOfConstraint, use_scale_z)
	FLOAT_ARRAY_PROPERTY(ChildOfConstraint, 16, inverse_matrix)



	INT_PROPERTY(PythonConstraint, target_count)
	POINTER_PROPERTY(Text, PythonConstraint, text)
	BOOLEAN_PROPERTY(PythonConstraint, use_targets)
	BOOLEAN_PROPERTY(PythonConstraint, has_script_error)



	BOOLEAN_PROPERTY(ArmatureConstraint, use_deform_preserve_volume)
	BOOLEAN_PROPERTY(ArmatureConstraint, use_bone_envelopes)
	BOOLEAN_PROPERTY(ArmatureConstraint, use_current_location)


	POINTER_PROPERTY(Struct, ArmatureConstraintTargets, rna_type)

	inline ConstraintTargetBone ArmatureConstraintTargets::create(void *main) {
		PointerRNA result;
		::bConstraintTarget *retdata = ArmatureConstraintTargets_new((::ID *) ptr.id.data, (::bConstraint *) this->ptr.data, (::Main *) main);
		RNA_pointer_create((::ID *) ptr.id.data, &RNA_ConstraintTargetBone, retdata, &result);
		return ConstraintTargetBone(result);
	}

	inline void ArmatureConstraintTargets::remove(void *main, ConstraintTargetBone& target) {
		ArmatureConstraintTargets_remove((::ID *) ptr.id.data, (::bConstraint *) this->ptr.data, (::Main *) main, NULL, (::PointerRNA *) &target.ptr);
	}

	inline void ArmatureConstraintTargets::clear(void *main) {
		ArmatureConstraintTargets_clear((::ID *) ptr.id.data, (::bConstraint *) this->ptr.data, (::Main *) main);
	}


	FLOAT_PROPERTY(StretchToConstraint, head_tail)
	BOOLEAN_PROPERTY(StretchToConstraint, use_bbone_shape)
	POINTER_PROPERTY(Object, StretchToConstraint, target)
	STRING_PROPERTY(StretchToConstraint, subtarget)
	ENUM_PROPERTY(volume_enum, StretchToConstraint, volume)
	ENUM_PROPERTY(keep_axis_enum, StretchToConstraint, keep_axis)
	FLOAT_PROPERTY(StretchToConstraint, rest_length)
	FLOAT_PROPERTY(StretchToConstraint, bulge)
	BOOLEAN_PROPERTY(StretchToConstraint, use_bulge_min)
	BOOLEAN_PROPERTY(StretchToConstraint, use_bulge_max)
	FLOAT_PROPERTY(StretchToConstraint, bulge_min)
	FLOAT_PROPERTY(StretchToConstraint, bulge_max)
	FLOAT_PROPERTY(StretchToConstraint, bulge_smooth)


	POINTER_PROPERTY(Object, FollowPathConstraint, target)
	FLOAT_PROPERTY(FollowPathConstraint, offset)
	FLOAT_PROPERTY(FollowPathConstraint, offset_factor)
	ENUM_PROPERTY(forward_axis_enum, FollowPathConstraint, forward_axis)
	ENUM_PROPERTY(up_axis_enum, FollowPathConstraint, up_axis)
	BOOLEAN_PROPERTY(FollowPathConstraint, use_curve_follow)
	BOOLEAN_PROPERTY(FollowPathConstraint, use_fixed_location)
	BOOLEAN_PROPERTY(FollowPathConstraint, use_curve_radius)


	FLOAT_PROPERTY(LockedTrackConstraint, head_tail)
	BOOLEAN_PROPERTY(LockedTrackConstraint, use_bbone_shape)
	POINTER_PROPERTY(Object, LockedTrackConstraint, target)
	STRING_PROPERTY(LockedTrackConstraint, subtarget)
	ENUM_PROPERTY(track_axis_enum, LockedTrackConstraint, track_axis)
	ENUM_PROPERTY(lock_axis_enum, LockedTrackConstraint, lock_axis)


	POINTER_PROPERTY(Object, ActionConstraint, target)
	STRING_PROPERTY(ActionConstraint, subtarget)
	ENUM_PROPERTY(transform_channel_enum, ActionConstraint, transform_channel)
	POINTER_PROPERTY(Action, ActionConstraint, action)
	BOOLEAN_PROPERTY(ActionConstraint, use_bone_object_action)
	INT_PROPERTY(ActionConstraint, frame_start)
	INT_PROPERTY(ActionConstraint, frame_end)
	FLOAT_PROPERTY(ActionConstraint, max)
	FLOAT_PROPERTY(ActionConstraint, min)


	POINTER_PROPERTY(Object, CopyScaleConstraint, target)
	STRING_PROPERTY(CopyScaleConstraint, subtarget)
	BOOLEAN_PROPERTY(CopyScaleConstraint, use_x)
	BOOLEAN_PROPERTY(CopyScaleConstraint, use_y)
	BOOLEAN_PROPERTY(CopyScaleConstraint, use_z)
	BOOLEAN_PROPERTY(CopyScaleConstraint, use_offset)
	BOOLEAN_PROPERTY(CopyScaleConstraint, use_add)


	ENUM_PROPERTY(free_axis_enum, MaintainVolumeConstraint, free_axis)
	FLOAT_PROPERTY(MaintainVolumeConstraint, volume)


	FLOAT_PROPERTY(CopyLocationConstraint, head_tail)
	BOOLEAN_PROPERTY(CopyLocationConstraint, use_bbone_shape)
	POINTER_PROPERTY(Object, CopyLocationConstraint, target)
	STRING_PROPERTY(CopyLocationConstraint, subtarget)
	BOOLEAN_PROPERTY(CopyLocationConstraint, use_x)
	BOOLEAN_PROPERTY(CopyLocationConstraint, use_y)
	BOOLEAN_PROPERTY(CopyLocationConstraint, use_z)
	BOOLEAN_PROPERTY(CopyLocationConstraint, invert_x)
	BOOLEAN_PROPERTY(CopyLocationConstraint, invert_y)
	BOOLEAN_PROPERTY(CopyLocationConstraint, invert_z)
	BOOLEAN_PROPERTY(CopyLocationConstraint, use_offset)


	POINTER_PROPERTY(Object, CopyRotationConstraint, target)
	STRING_PROPERTY(CopyRotationConstraint, subtarget)
	BOOLEAN_PROPERTY(CopyRotationConstraint, use_x)
	BOOLEAN_PROPERTY(CopyRotationConstraint, use_y)
	BOOLEAN_PROPERTY(CopyRotationConstraint, use_z)
	BOOLEAN_PROPERTY(CopyRotationConstraint, invert_x)
	BOOLEAN_PROPERTY(CopyRotationConstraint, invert_y)
	BOOLEAN_PROPERTY(CopyRotationConstraint, invert_z)
	BOOLEAN_PROPERTY(CopyRotationConstraint, use_offset)


	FLOAT_PROPERTY(CopyTransformsConstraint, head_tail)
	BOOLEAN_PROPERTY(CopyTransformsConstraint, use_bbone_shape)
	POINTER_PROPERTY(Object, CopyTransformsConstraint, target)
	STRING_PROPERTY(CopyTransformsConstraint, subtarget)


	POINTER_PROPERTY(Object, FloorConstraint, target)
	STRING_PROPERTY(FloorConstraint, subtarget)
	ENUM_PROPERTY(floor_location_enum, FloorConstraint, floor_location)
	BOOLEAN_PROPERTY(FloorConstraint, use_sticky)
	BOOLEAN_PROPERTY(FloorConstraint, use_rotation)
	FLOAT_PROPERTY(FloorConstraint, offset)


	FLOAT_PROPERTY(TrackToConstraint, head_tail)
	BOOLEAN_PROPERTY(TrackToConstraint, use_bbone_shape)
	POINTER_PROPERTY(Object, TrackToConstraint, target)
	STRING_PROPERTY(TrackToConstraint, subtarget)
	ENUM_PROPERTY(track_axis_enum, TrackToConstraint, track_axis)
	ENUM_PROPERTY(up_axis_enum, TrackToConstraint, up_axis)
	BOOLEAN_PROPERTY(TrackToConstraint, use_target_z)


	POINTER_PROPERTY(Object, KinematicConstraint, target)
	STRING_PROPERTY(KinematicConstraint, subtarget)
	INT_PROPERTY(KinematicConstraint, iterations)
	POINTER_PROPERTY(Object, KinematicConstraint, pole_target)
	STRING_PROPERTY(KinematicConstraint, pole_subtarget)
	FLOAT_PROPERTY(KinematicConstraint, pole_angle)
	FLOAT_PROPERTY(KinematicConstraint, weight)
	FLOAT_PROPERTY(KinematicConstraint, orient_weight)
	INT_PROPERTY(KinematicConstraint, chain_count)
	BOOLEAN_PROPERTY(KinematicConstraint, use_tail)
	ENUM_PROPERTY(reference_axis_enum, KinematicConstraint, reference_axis)
	BOOLEAN_PROPERTY(KinematicConstraint, use_location)
	BOOLEAN_PROPERTY(KinematicConstraint, lock_location_x)
	BOOLEAN_PROPERTY(KinematicConstraint, lock_location_y)
	BOOLEAN_PROPERTY(KinematicConstraint, lock_location_z)
	BOOLEAN_PROPERTY(KinematicConstraint, use_rotation)
	BOOLEAN_PROPERTY(KinematicConstraint, lock_rotation_x)
	BOOLEAN_PROPERTY(KinematicConstraint, lock_rotation_y)
	BOOLEAN_PROPERTY(KinematicConstraint, lock_rotation_z)
	BOOLEAN_PROPERTY(KinematicConstraint, use_stretch)
	ENUM_PROPERTY(ik_type_enum, KinematicConstraint, ik_type)
	ENUM_PROPERTY(limit_mode_enum, KinematicConstraint, limit_mode)
	FLOAT_PROPERTY(KinematicConstraint, distance)


	POINTER_PROPERTY(Object, ClampToConstraint, target)
	ENUM_PROPERTY(main_axis_enum, ClampToConstraint, main_axis)
	BOOLEAN_PROPERTY(ClampToConstraint, use_cyclic)


	FLOAT_PROPERTY(LimitDistanceConstraint, head_tail)
	BOOLEAN_PROPERTY(LimitDistanceConstraint, use_bbone_shape)
	POINTER_PROPERTY(Object, LimitDistanceConstraint, target)
	STRING_PROPERTY(LimitDistanceConstraint, subtarget)
	FLOAT_PROPERTY(LimitDistanceConstraint, distance)
	ENUM_PROPERTY(limit_mode_enum, LimitDistanceConstraint, limit_mode)
	BOOLEAN_PROPERTY(LimitDistanceConstraint, use_transform_limit)


	BOOLEAN_PROPERTY(LimitScaleConstraint, use_min_x)
	BOOLEAN_PROPERTY(LimitScaleConstraint, use_min_y)
	BOOLEAN_PROPERTY(LimitScaleConstraint, use_min_z)
	BOOLEAN_PROPERTY(LimitScaleConstraint, use_max_x)
	BOOLEAN_PROPERTY(LimitScaleConstraint, use_max_y)
	BOOLEAN_PROPERTY(LimitScaleConstraint, use_max_z)
	FLOAT_PROPERTY(LimitScaleConstraint, min_x)
	FLOAT_PROPERTY(LimitScaleConstraint, min_y)
	FLOAT_PROPERTY(LimitScaleConstraint, min_z)
	FLOAT_PROPERTY(LimitScaleConstraint, max_x)
	FLOAT_PROPERTY(LimitScaleConstraint, max_y)
	FLOAT_PROPERTY(LimitScaleConstraint, max_z)
	BOOLEAN_PROPERTY(LimitScaleConstraint, use_transform_limit)


	BOOLEAN_PROPERTY(LimitRotationConstraint, use_limit_x)
	BOOLEAN_PROPERTY(LimitRotationConstraint, use_limit_y)
	BOOLEAN_PROPERTY(LimitRotationConstraint, use_limit_z)
	FLOAT_PROPERTY(LimitRotationConstraint, min_x)
	FLOAT_PROPERTY(LimitRotationConstraint, min_y)
	FLOAT_PROPERTY(LimitRotationConstraint, min_z)
	FLOAT_PROPERTY(LimitRotationConstraint, max_x)
	FLOAT_PROPERTY(LimitRotationConstraint, max_y)
	FLOAT_PROPERTY(LimitRotationConstraint, max_z)
	BOOLEAN_PROPERTY(LimitRotationConstraint, use_transform_limit)


	BOOLEAN_PROPERTY(LimitLocationConstraint, use_min_x)
	BOOLEAN_PROPERTY(LimitLocationConstraint, use_min_y)
	BOOLEAN_PROPERTY(LimitLocationConstraint, use_min_z)
	BOOLEAN_PROPERTY(LimitLocationConstraint, use_max_x)
	BOOLEAN_PROPERTY(LimitLocationConstraint, use_max_y)
	BOOLEAN_PROPERTY(LimitLocationConstraint, use_max_z)
	FLOAT_PROPERTY(LimitLocationConstraint, min_x)
	FLOAT_PROPERTY(LimitLocationConstraint, min_y)
	FLOAT_PROPERTY(LimitLocationConstraint, min_z)
	FLOAT_PROPERTY(LimitLocationConstraint, max_x)
	FLOAT_PROPERTY(LimitLocationConstraint, max_y)
	FLOAT_PROPERTY(LimitLocationConstraint, max_z)
	BOOLEAN_PROPERTY(LimitLocationConstraint, use_transform_limit)


	POINTER_PROPERTY(Object, TransformConstraint, target)
	STRING_PROPERTY(TransformConstraint, subtarget)
	ENUM_PROPERTY(map_from_enum, TransformConstraint, map_from)
	ENUM_PROPERTY(map_to_enum, TransformConstraint, map_to)
	ENUM_PROPERTY(map_to_x_from_enum, TransformConstraint, map_to_x_from)
	ENUM_PROPERTY(map_to_y_from_enum, TransformConstraint, map_to_y_from)
	ENUM_PROPERTY(map_to_z_from_enum, TransformConstraint, map_to_z_from)
	BOOLEAN_PROPERTY(TransformConstraint, use_motion_extrapolate)
	FLOAT_PROPERTY(TransformConstraint, from_min_x)
	FLOAT_PROPERTY(TransformConstraint, from_min_y)
	FLOAT_PROPERTY(TransformConstraint, from_min_z)
	FLOAT_PROPERTY(TransformConstraint, from_max_x)
	FLOAT_PROPERTY(TransformConstraint, from_max_y)
	FLOAT_PROPERTY(TransformConstraint, from_max_z)
	FLOAT_PROPERTY(TransformConstraint, to_min_x)
	FLOAT_PROPERTY(TransformConstraint, to_min_y)
	FLOAT_PROPERTY(TransformConstraint, to_min_z)
	FLOAT_PROPERTY(TransformConstraint, to_max_x)
	FLOAT_PROPERTY(TransformConstraint, to_max_y)
	FLOAT_PROPERTY(TransformConstraint, to_max_z)
	FLOAT_PROPERTY(TransformConstraint, from_min_x_rot)
	FLOAT_PROPERTY(TransformConstraint, from_min_y_rot)
	FLOAT_PROPERTY(TransformConstraint, from_min_z_rot)
	FLOAT_PROPERTY(TransformConstraint, from_max_x_rot)
	FLOAT_PROPERTY(TransformConstraint, from_max_y_rot)
	FLOAT_PROPERTY(TransformConstraint, from_max_z_rot)
	FLOAT_PROPERTY(TransformConstraint, to_min_x_rot)
	FLOAT_PROPERTY(TransformConstraint, to_min_y_rot)
	FLOAT_PROPERTY(TransformConstraint, to_min_z_rot)
	FLOAT_PROPERTY(TransformConstraint, to_max_x_rot)
	FLOAT_PROPERTY(TransformConstraint, to_max_y_rot)
	FLOAT_PROPERTY(TransformConstraint, to_max_z_rot)
	FLOAT_PROPERTY(TransformConstraint, from_min_x_scale)
	FLOAT_PROPERTY(TransformConstraint, from_min_y_scale)
	FLOAT_PROPERTY(TransformConstraint, from_min_z_scale)
	FLOAT_PROPERTY(TransformConstraint, from_max_x_scale)
	FLOAT_PROPERTY(TransformConstraint, from_max_y_scale)
	FLOAT_PROPERTY(TransformConstraint, from_max_z_scale)
	FLOAT_PROPERTY(TransformConstraint, to_min_x_scale)
	FLOAT_PROPERTY(TransformConstraint, to_min_y_scale)
	FLOAT_PROPERTY(TransformConstraint, to_min_z_scale)
	FLOAT_PROPERTY(TransformConstraint, to_max_x_scale)
	FLOAT_PROPERTY(TransformConstraint, to_max_y_scale)
	FLOAT_PROPERTY(TransformConstraint, to_max_z_scale)


	POINTER_PROPERTY(Object, ShrinkwrapConstraint, target)
	ENUM_PROPERTY(shrinkwrap_type_enum, ShrinkwrapConstraint, shrinkwrap_type)
	ENUM_PROPERTY(wrap_mode_enum, ShrinkwrapConstraint, wrap_mode)
	FLOAT_PROPERTY(ShrinkwrapConstraint, distance)
	ENUM_PROPERTY(project_axis_enum, ShrinkwrapConstraint, project_axis)
	ENUM_PROPERTY(project_axis_space_enum, ShrinkwrapConstraint, project_axis_space)
	FLOAT_PROPERTY(ShrinkwrapConstraint, project_limit)
	BOOLEAN_PROPERTY(ShrinkwrapConstraint, use_project_opposite)
	ENUM_PROPERTY(cull_face_enum, ShrinkwrapConstraint, cull_face)
	BOOLEAN_PROPERTY(ShrinkwrapConstraint, use_invert_cull)
	BOOLEAN_PROPERTY(ShrinkwrapConstraint, use_track_normal)
	ENUM_PROPERTY(track_axis_enum, ShrinkwrapConstraint, track_axis)


	FLOAT_PROPERTY(DampedTrackConstraint, head_tail)
	BOOLEAN_PROPERTY(DampedTrackConstraint, use_bbone_shape)
	POINTER_PROPERTY(Object, DampedTrackConstraint, target)
	STRING_PROPERTY(DampedTrackConstraint, subtarget)
	ENUM_PROPERTY(track_axis_enum, DampedTrackConstraint, track_axis)


	POINTER_PROPERTY(Object, SplineIKConstraint, target)
	INT_PROPERTY(SplineIKConstraint, chain_count)
	FLOAT_ARRAY_PROPERTY(SplineIKConstraint, 32, joint_bindings)
	BOOLEAN_PROPERTY(SplineIKConstraint, use_chain_offset)
	BOOLEAN_PROPERTY(SplineIKConstraint, use_even_divisions)
	BOOLEAN_PROPERTY(SplineIKConstraint, use_y_stretch)
	BOOLEAN_PROPERTY(SplineIKConstraint, use_curve_radius)
	ENUM_PROPERTY(xz_scale_mode_enum, SplineIKConstraint, xz_scale_mode)
	FLOAT_PROPERTY(SplineIKConstraint, bulge)
	BOOLEAN_PROPERTY(SplineIKConstraint, use_bulge_min)
	BOOLEAN_PROPERTY(SplineIKConstraint, use_bulge_max)
	FLOAT_PROPERTY(SplineIKConstraint, bulge_min)
	FLOAT_PROPERTY(SplineIKConstraint, bulge_max)
	FLOAT_PROPERTY(SplineIKConstraint, bulge_smooth)


	FLOAT_PROPERTY(PivotConstraint, head_tail)
	BOOLEAN_PROPERTY(PivotConstraint, use_bbone_shape)
	POINTER_PROPERTY(Object, PivotConstraint, target)
	STRING_PROPERTY(PivotConstraint, subtarget)
	BOOLEAN_PROPERTY(PivotConstraint, use_relative_location)
	FLOAT_ARRAY_PROPERTY(PivotConstraint, 3, offset)
	ENUM_PROPERTY(rotation_range_enum, PivotConstraint, rotation_range)


	POINTER_PROPERTY(MovieClip, FollowTrackConstraint, clip)
	STRING_PROPERTY(FollowTrackConstraint, track)
	BOOLEAN_PROPERTY(FollowTrackConstraint, use_active_clip)
	BOOLEAN_PROPERTY(FollowTrackConstraint, use_3d_position)
	STRING_PROPERTY(FollowTrackConstraint, object)
	POINTER_PROPERTY(Object, FollowTrackConstraint, camera)
	POINTER_PROPERTY(Object, FollowTrackConstraint, depth_object)
	ENUM_PROPERTY(frame_method_enum, FollowTrackConstraint, frame_method)
	BOOLEAN_PROPERTY(FollowTrackConstraint, use_undistorted_position)


	POINTER_PROPERTY(MovieClip, CameraSolverConstraint, clip)
	BOOLEAN_PROPERTY(CameraSolverConstraint, use_active_clip)


	POINTER_PROPERTY(MovieClip, ObjectSolverConstraint, clip)
	BOOLEAN_PROPERTY(ObjectSolverConstraint, use_active_clip)
	STRING_PROPERTY(ObjectSolverConstraint, object)
	POINTER_PROPERTY(Object, ObjectSolverConstraint, camera)


	POINTER_PROPERTY(CacheFile, TransformCacheConstraint, cache_file)
	STRING_PROPERTY(TransformCacheConstraint, object_path)


	POINTER_PROPERTY(Struct, Context, rna_type)
	POINTER_PROPERTY(WindowManager, Context, window_manager)
	POINTER_PROPERTY(Window, Context, window)
	POINTER_PROPERTY(WorkSpace, Context, workspace)
	POINTER_PROPERTY(Screen, Context, screen)
	POINTER_PROPERTY(Area, Context, area)
	POINTER_PROPERTY(Space, Context, space_data)
	POINTER_PROPERTY(Region, Context, region)
	POINTER_PROPERTY(RegionView3D, Context, region_data)
	POINTER_PROPERTY(GizmoGroup, Context, gizmo_group)
	POINTER_PROPERTY(BlendData, Context, blend_data)
	POINTER_PROPERTY(Depsgraph, Context, depsgraph)
	POINTER_PROPERTY(Scene, Context, scene)
	POINTER_PROPERTY(ViewLayer, Context, view_layer)
	STRING_PROPERTY(Context, engine)
	POINTER_PROPERTY(Collection, Context, collection)
	POINTER_PROPERTY(LayerCollection, Context, layer_collection)
	POINTER_PROPERTY(ToolSettings, Context, tool_settings)
	POINTER_PROPERTY(Preferences, Context, preferences)
	ENUM_PROPERTY(mode_enum, Context, mode)


	POINTER_PROPERTY(Key, Curve, shape_keys)

	INT_PROPERTY(Curve, path_duration)
	BOOLEAN_PROPERTY(Curve, use_path)
	BOOLEAN_PROPERTY(Curve, use_path_follow)
	BOOLEAN_PROPERTY(Curve, use_stretch)
	BOOLEAN_PROPERTY(Curve, use_deform_bounds)
	BOOLEAN_PROPERTY(Curve, use_radius)
	INT_PROPERTY(Curve, bevel_resolution)
	FLOAT_PROPERTY(Curve, offset)
	FLOAT_PROPERTY(Curve, extrude)
	FLOAT_PROPERTY(Curve, bevel_depth)
	INT_PROPERTY(Curve, resolution_u)
	INT_PROPERTY(Curve, resolution_v)
	INT_PROPERTY(Curve, render_resolution_u)
	INT_PROPERTY(Curve, render_resolution_v)
	FLOAT_PROPERTY(Curve, eval_time)
	POINTER_PROPERTY(Object, Curve, bevel_object)
	POINTER_PROPERTY(Object, Curve, taper_object)
	ENUM_PROPERTY(dimensions_enum, Curve, dimensions)
	ENUM_PROPERTY(fill_mode_enum, Curve, fill_mode)
	ENUM_PROPERTY(twist_mode_enum, Curve, twist_mode)
	ENUM_PROPERTY(bevel_factor_mapping_start_enum, Curve, bevel_factor_mapping_start)
	ENUM_PROPERTY(bevel_factor_mapping_end_enum, Curve, bevel_factor_mapping_end)
	FLOAT_PROPERTY(Curve, twist_smooth)
	BOOLEAN_PROPERTY(Curve, use_fill_deform)
	BOOLEAN_PROPERTY(Curve, use_fill_caps)
	BOOLEAN_PROPERTY(Curve, use_map_taper)
	BOOLEAN_PROPERTY(Curve, use_auto_texspace)
	FLOAT_ARRAY_PROPERTY(Curve, 3, texspace_location)
	FLOAT_ARRAY_PROPERTY(Curve, 3, texspace_size)
	BOOLEAN_PROPERTY(Curve, use_uv_as_generated)

	FLOAT_PROPERTY(Curve, bevel_factor_start)
	FLOAT_PROPERTY(Curve, bevel_factor_end)
	BOOLEAN_PROPERTY(Curve, is_editmode)
	POINTER_PROPERTY(AnimData, Curve, animation_data)

	inline void Curve::transform(float matrix[16], bool shape_keys) {
		Curve_transform((::Curve *) this->ptr.data, matrix, shape_keys);
	}

	inline bool Curve::validate_material_indices() {
		return Curve_validate_material_indices((::Curve *) this->ptr.data);
	}

	inline void Curve::update_gpu_tag() {
		Curve_update_gpu_tag((::Curve *) this->ptr.data);
	}


	POINTER_PROPERTY(Struct, CurveSplines, rna_type)
	POINTER_PROPERTY(Spline, CurveSplines, active)

	inline Spline CurveSplines::create(int type) {
		PointerRNA result;
		::Nurb *retdata = CurveSplines_new((::Curve *) this->ptr.data, type);
		RNA_pointer_create((::ID *) ptr.id.data, &RNA_Spline, retdata, &result);
		return Spline(result);
	}

	inline void CurveSplines::remove(Spline& spline) {
		CurveSplines_remove((::Curve *) this->ptr.data, NULL, (::PointerRNA *) &spline.ptr);
	}

	inline void CurveSplines::clear() {
		CurveSplines_clear((::Curve *) this->ptr.data);
	}


	BOOLEAN_PROPERTY(SurfaceCurve, use_uv_as_generated)


	ENUM_PROPERTY(align_x_enum, TextCurve, align_x)
	ENUM_PROPERTY(align_y_enum, TextCurve, align_y)
	ENUM_PROPERTY(overflow_enum, TextCurve, overflow)
	FLOAT_PROPERTY(TextCurve, size)
	FLOAT_PROPERTY(TextCurve, small_caps_scale)
	FLOAT_PROPERTY(TextCurve, space_line)
	FLOAT_PROPERTY(TextCurve, space_word)
	FLOAT_PROPERTY(TextCurve, space_character)
	FLOAT_PROPERTY(TextCurve, shear)
	FLOAT_PROPERTY(TextCurve, offset_x)
	FLOAT_PROPERTY(TextCurve, offset_y)
	FLOAT_PROPERTY(TextCurve, underline_position)
	FLOAT_PROPERTY(TextCurve, underline_height)

	INT_PROPERTY(TextCurve, active_textbox)
	STRING_PROPERTY(TextCurve, family)
	STRING_PROPERTY(TextCurve, body)

	POINTER_PROPERTY(Object, TextCurve, follow_curve)
	POINTER_PROPERTY(VectorFont, TextCurve, font)
	POINTER_PROPERTY(VectorFont, TextCurve, font_bold)
	POINTER_PROPERTY(VectorFont, TextCurve, font_italic)
	POINTER_PROPERTY(VectorFont, TextCurve, font_bold_italic)
	POINTER_PROPERTY(TextCharacterFormat, TextCurve, edit_format)
	BOOLEAN_PROPERTY(TextCurve, use_fast_edit)
	BOOLEAN_PROPERTY(TextCurve, use_uv_as_generated)


	POINTER_PROPERTY(Struct, TextBox, rna_type)
	FLOAT_PROPERTY(TextBox, x)
	FLOAT_PROPERTY(TextBox, y)
	FLOAT_PROPERTY(TextBox, width)
	FLOAT_PROPERTY(TextBox, height)


	POINTER_PROPERTY(Struct, TextCharacterFormat, rna_type)
	BOOLEAN_PROPERTY(TextCharacterFormat, use_bold)
	BOOLEAN_PROPERTY(TextCharacterFormat, use_italic)
	BOOLEAN_PROPERTY(TextCharacterFormat, use_underline)
	BOOLEAN_PROPERTY(TextCharacterFormat, use_small_caps)
	INT_PROPERTY(TextCharacterFormat, material_index)
	INT_PROPERTY(TextCharacterFormat, kerning)


	POINTER_PROPERTY(Struct, SplinePoint, rna_type)
	BOOLEAN_PROPERTY(SplinePoint, select)
	BOOLEAN_PROPERTY(SplinePoint, hide)
	FLOAT_ARRAY_PROPERTY(SplinePoint, 4, co)
	FLOAT_PROPERTY(SplinePoint, weight)
	FLOAT_PROPERTY(SplinePoint, tilt)
	FLOAT_PROPERTY(SplinePoint, weight_softbody)
	FLOAT_PROPERTY(SplinePoint, radius)


	POINTER_PROPERTY(Struct, BezierSplinePoint, rna_type)
	BOOLEAN_PROPERTY(BezierSplinePoint, select_left_handle)
	BOOLEAN_PROPERTY(BezierSplinePoint, select_right_handle)
	BOOLEAN_PROPERTY(BezierSplinePoint, select_control_point)
	BOOLEAN_PROPERTY(BezierSplinePoint, hide)
	ENUM_PROPERTY(handle_left_type_enum, BezierSplinePoint, handle_left_type)
	ENUM_PROPERTY(handle_right_type_enum, BezierSplinePoint, handle_right_type)
	FLOAT_ARRAY_PROPERTY(BezierSplinePoint, 3, handle_left)
	FLOAT_ARRAY_PROPERTY(BezierSplinePoint, 3, co)
	FLOAT_ARRAY_PROPERTY(BezierSplinePoint, 3, handle_right)
	FLOAT_PROPERTY(BezierSplinePoint, tilt)
	FLOAT_PROPERTY(BezierSplinePoint, weight_softbody)
	FLOAT_PROPERTY(BezierSplinePoint, radius)


	POINTER_PROPERTY(Struct, Spline, rna_type)


	ENUM_PROPERTY(tilt_interpolation_enum, Spline, tilt_interpolation)
	ENUM_PROPERTY(radius_interpolation_enum, Spline, radius_interpolation)
	ENUM_PROPERTY(type_enum, Spline, type)
	INT_PROPERTY(Spline, point_count_u)
	INT_PROPERTY(Spline, point_count_v)
	INT_PROPERTY(Spline, order_u)
	INT_PROPERTY(Spline, order_v)
	INT_PROPERTY(Spline, resolution_u)
	INT_PROPERTY(Spline, resolution_v)
	BOOLEAN_PROPERTY(Spline, use_cyclic_u)
	BOOLEAN_PROPERTY(Spline, use_cyclic_v)
	BOOLEAN_PROPERTY(Spline, use_endpoint_u)
	BOOLEAN_PROPERTY(Spline, use_endpoint_v)
	BOOLEAN_PROPERTY(Spline, use_bezier_u)
	BOOLEAN_PROPERTY(Spline, use_bezier_v)
	BOOLEAN_PROPERTY(Spline, use_smooth)
	BOOLEAN_PROPERTY(Spline, hide)
	INT_PROPERTY(Spline, material_index)
	INT_PROPERTY(Spline, character_index)

	inline float Spline::calc_length(int resolution) {
		return Spline_calc_length((::Nurb *) this->ptr.data, resolution);
	}


	POINTER_PROPERTY(Struct, SplinePoints, rna_type)

	inline void SplinePoints::add(int count) {
		SplinePoints_add((::ID *) ptr.id.data, (::Nurb *) this->ptr.data, NULL, count);
	}


	POINTER_PROPERTY(Struct, SplineBezierPoints, rna_type)

	inline void SplineBezierPoints::add(int count) {
		SplineBezierPoints_add((::ID *) ptr.id.data, (::Nurb *) this->ptr.data, NULL, count);
	}


	POINTER_PROPERTY(Struct, DynamicPaintCanvasSettings, rna_type)



	POINTER_PROPERTY(Struct, DynamicPaintSurfaces, rna_type)
	INT_PROPERTY(DynamicPaintSurfaces, active_index)
	POINTER_PROPERTY(DynamicPaintSurface, DynamicPaintSurfaces, active)


	POINTER_PROPERTY(Struct, DynamicPaintBrushSettings, rna_type)
	FLOAT_ARRAY_PROPERTY(DynamicPaintBrushSettings, 3, paint_color)
	FLOAT_PROPERTY(DynamicPaintBrushSettings, paint_alpha)
	BOOLEAN_PROPERTY(DynamicPaintBrushSettings, use_absolute_alpha)
	FLOAT_PROPERTY(DynamicPaintBrushSettings, paint_wetness)
	BOOLEAN_PROPERTY(DynamicPaintBrushSettings, use_paint_erase)
	ENUM_PROPERTY(wave_type_enum, DynamicPaintBrushSettings, wave_type)
	FLOAT_PROPERTY(DynamicPaintBrushSettings, wave_factor)
	FLOAT_PROPERTY(DynamicPaintBrushSettings, wave_clamp)
	BOOLEAN_PROPERTY(DynamicPaintBrushSettings, use_smudge)
	FLOAT_PROPERTY(DynamicPaintBrushSettings, smudge_strength)
	FLOAT_PROPERTY(DynamicPaintBrushSettings, velocity_max)
	BOOLEAN_PROPERTY(DynamicPaintBrushSettings, use_velocity_alpha)
	BOOLEAN_PROPERTY(DynamicPaintBrushSettings, use_velocity_depth)
	BOOLEAN_PROPERTY(DynamicPaintBrushSettings, use_velocity_color)
	ENUM_PROPERTY(paint_source_enum, DynamicPaintBrushSettings, paint_source)
	FLOAT_PROPERTY(DynamicPaintBrushSettings, paint_distance)
	BOOLEAN_PROPERTY(DynamicPaintBrushSettings, use_proximity_ramp_alpha)
	ENUM_PROPERTY(proximity_falloff_enum, DynamicPaintBrushSettings, proximity_falloff)
	BOOLEAN_PROPERTY(DynamicPaintBrushSettings, use_proximity_project)
	ENUM_PROPERTY(ray_direction_enum, DynamicPaintBrushSettings, ray_direction)
	BOOLEAN_PROPERTY(DynamicPaintBrushSettings, invert_proximity)
	BOOLEAN_PROPERTY(DynamicPaintBrushSettings, use_negative_volume)
	POINTER_PROPERTY(ParticleSystem, DynamicPaintBrushSettings, particle_system)
	BOOLEAN_PROPERTY(DynamicPaintBrushSettings, use_particle_radius)
	FLOAT_PROPERTY(DynamicPaintBrushSettings, solid_radius)
	FLOAT_PROPERTY(DynamicPaintBrushSettings, smooth_radius)
	POINTER_PROPERTY(ColorRamp, DynamicPaintBrushSettings, paint_ramp)
	POINTER_PROPERTY(ColorRamp, DynamicPaintBrushSettings, velocity_ramp)


	POINTER_PROPERTY(Struct, DynamicPaintSurface, rna_type)
	ENUM_PROPERTY(surface_format_enum, DynamicPaintSurface, surface_format)
	ENUM_PROPERTY(surface_type_enum, DynamicPaintSurface, surface_type)
	BOOLEAN_PROPERTY(DynamicPaintSurface, is_active)
	BOOLEAN_PROPERTY(DynamicPaintSurface, show_preview)
	STRING_PROPERTY(DynamicPaintSurface, name)
	POINTER_PROPERTY(Collection, DynamicPaintSurface, brush_collection)
	BOOLEAN_PROPERTY(DynamicPaintSurface, use_dissolve)
	INT_PROPERTY(DynamicPaintSurface, dissolve_speed)
	BOOLEAN_PROPERTY(DynamicPaintSurface, use_drying)
	INT_PROPERTY(DynamicPaintSurface, dry_speed)
	INT_PROPERTY(DynamicPaintSurface, image_resolution)
	STRING_PROPERTY(DynamicPaintSurface, uv_layer)
	INT_PROPERTY(DynamicPaintSurface, frame_start)
	INT_PROPERTY(DynamicPaintSurface, frame_end)
	INT_PROPERTY(DynamicPaintSurface, frame_substeps)
	BOOLEAN_PROPERTY(DynamicPaintSurface, use_antialiasing)
	FLOAT_PROPERTY(DynamicPaintSurface, brush_influence_scale)
	FLOAT_PROPERTY(DynamicPaintSurface, brush_radius_scale)
	ENUM_PROPERTY(init_color_type_enum, DynamicPaintSurface, init_color_type)
	FLOAT_ARRAY_PROPERTY(DynamicPaintSurface, 4, init_color)
	POINTER_PROPERTY(Texture, DynamicPaintSurface, init_texture)
	STRING_PROPERTY(DynamicPaintSurface, init_layername)
	ENUM_PROPERTY(effect_ui_enum, DynamicPaintSurface, effect_ui)
	BOOLEAN_PROPERTY(DynamicPaintSurface, use_dry_log)
	BOOLEAN_PROPERTY(DynamicPaintSurface, use_dissolve_log)
	BOOLEAN_PROPERTY(DynamicPaintSurface, use_spread)
	FLOAT_PROPERTY(DynamicPaintSurface, spread_speed)
	FLOAT_PROPERTY(DynamicPaintSurface, color_dry_threshold)
	FLOAT_PROPERTY(DynamicPaintSurface, color_spread_speed)
	BOOLEAN_PROPERTY(DynamicPaintSurface, use_drip)
	BOOLEAN_PROPERTY(DynamicPaintSurface, use_shrink)
	FLOAT_PROPERTY(DynamicPaintSurface, shrink_speed)
	POINTER_PROPERTY(EffectorWeights, DynamicPaintSurface, effector_weights)
	FLOAT_PROPERTY(DynamicPaintSurface, drip_velocity)
	FLOAT_PROPERTY(DynamicPaintSurface, drip_acceleration)
	BOOLEAN_PROPERTY(DynamicPaintSurface, use_premultiply)
	STRING_PROPERTY(DynamicPaintSurface, image_output_path)
	STRING_PROPERTY(DynamicPaintSurface, output_name_a)
	BOOLEAN_PROPERTY(DynamicPaintSurface, use_output_a)
	STRING_PROPERTY(DynamicPaintSurface, output_name_b)
	BOOLEAN_PROPERTY(DynamicPaintSurface, use_output_b)
	ENUM_PROPERTY(preview_id_enum, DynamicPaintSurface, preview_id)
	FLOAT_PROPERTY(DynamicPaintSurface, depth_clamp)
	FLOAT_PROPERTY(DynamicPaintSurface, displace_factor)
	ENUM_PROPERTY(image_fileformat_enum, DynamicPaintSurface, image_fileformat)
	ENUM_PROPERTY(displace_type_enum, DynamicPaintSurface, displace_type)
	BOOLEAN_PROPERTY(DynamicPaintSurface, use_incremental_displace)
	FLOAT_PROPERTY(DynamicPaintSurface, wave_damping)
	FLOAT_PROPERTY(DynamicPaintSurface, wave_speed)
	FLOAT_PROPERTY(DynamicPaintSurface, wave_timescale)
	FLOAT_PROPERTY(DynamicPaintSurface, wave_spring)
	FLOAT_PROPERTY(DynamicPaintSurface, wave_smoothness)
	BOOLEAN_PROPERTY(DynamicPaintSurface, use_wave_open_border)
	POINTER_PROPERTY(PointCache, DynamicPaintSurface, point_cache)
	BOOLEAN_PROPERTY(DynamicPaintSurface, is_cache_user)
	BOOLEAN_PROPERTY(DynamicPaintSurface, use_color_preview)

	inline bool DynamicPaintSurface::output_exists(Object& object, int index) {
		return DynamicPaintSurface_output_exists((::DynamicPaintSurface *) this->ptr.data, (::Object *) object.ptr.data, index);
	}


	POINTER_PROPERTY(Struct, FCurve, rna_type)
	ENUM_PROPERTY(extrapolation_enum, FCurve, extrapolation)
	POINTER_PROPERTY(Driver, FCurve, driver)
	POINTER_PROPERTY(ActionGroup, FCurve, group)
	STRING_PROPERTY(FCurve, data_path)
	INT_PROPERTY(FCurve, array_index)
	ENUM_PROPERTY(color_mode_enum, FCurve, color_mode)
	FLOAT_ARRAY_PROPERTY(FCurve, 3, color)
	BOOLEAN_PROPERTY(FCurve, select)
	BOOLEAN_PROPERTY(FCurve, lock)
	BOOLEAN_PROPERTY(FCurve, mute)
	BOOLEAN_PROPERTY(FCurve, hide)
	ENUM_PROPERTY(auto_smoothing_enum, FCurve, auto_smoothing)
	BOOLEAN_PROPERTY(FCurve, is_valid)




	inline float FCurve::evaluate(float frame) {
		return FCurve_evaluate((::FCurve *) this->ptr.data, frame);
	}

	inline void FCurve::update() {
		FCurve_update((::FCurve *) this->ptr.data);
	}

	inline void FCurve::range(float range[2]) {
		FCurve_range((::FCurve *) this->ptr.data, range);
	}

	inline void FCurve::update_autoflags(Context C, AnyType& data) {
		FCurve_update_autoflags((::FCurve *) this->ptr.data, (::bContext *) C.ptr.data, NULL, (::PointerRNA *) data.ptr.data);
	}

	inline void FCurve::convert_to_samples(int start, int end) {
		FCurve_convert_to_samples((::FCurve *) this->ptr.data, NULL, start, end);
	}

	inline void FCurve::convert_to_keyframes(int start, int end) {
		FCurve_convert_to_keyframes((::FCurve *) this->ptr.data, NULL, start, end);
	}


	POINTER_PROPERTY(Struct, FCurveKeyframePoints, rna_type)

	inline Keyframe FCurveKeyframePoints::insert(float frame, float value, int options, int keyframe_type) {
		PointerRNA result;
		::BezTriple *retdata = FCurveKeyframePoints_insert((::FCurve *) this->ptr.data, frame, value, options, keyframe_type);
		RNA_pointer_create((::ID *) ptr.id.data, &RNA_Keyframe, retdata, &result);
		return Keyframe(result);
	}

	inline void FCurveKeyframePoints::add(int count) {
		FCurveKeyframePoints_add((::FCurve *) this->ptr.data, count);
	}

	inline void FCurveKeyframePoints::remove(Keyframe& keyframe, bool fast) {
		FCurveKeyframePoints_remove((::FCurve *) this->ptr.data, NULL, (::PointerRNA *) &keyframe.ptr, fast);
	}


	POINTER_PROPERTY(Struct, FCurveModifiers, rna_type)
	POINTER_PROPERTY(FModifier, FCurveModifiers, active)

	inline FModifier FCurveModifiers::create(int type) {
		PointerRNA result;
		::FModifier *retdata = FCurveModifiers_new((::FCurve *) this->ptr.data, type);
		RNA_pointer_create((::ID *) ptr.id.data, &RNA_FModifier, retdata, &result);
		return FModifier(result);
	}

	inline void FCurveModifiers::remove(FModifier& modifier) {
		FCurveModifiers_remove((::FCurve *) this->ptr.data, NULL, (::PointerRNA *) &modifier.ptr);
	}


	POINTER_PROPERTY(Struct, Keyframe, rna_type)
	BOOLEAN_PROPERTY(Keyframe, select_left_handle)
	BOOLEAN_PROPERTY(Keyframe, select_right_handle)
	BOOLEAN_PROPERTY(Keyframe, select_control_point)
	ENUM_PROPERTY(handle_left_type_enum, Keyframe, handle_left_type)
	ENUM_PROPERTY(handle_right_type_enum, Keyframe, handle_right_type)
	ENUM_PROPERTY(interpolation_enum, Keyframe, interpolation)
	ENUM_PROPERTY(type_enum, Keyframe, type)
	ENUM_PROPERTY(easing_enum, Keyframe, easing)
	FLOAT_PROPERTY(Keyframe, back)
	FLOAT_PROPERTY(Keyframe, amplitude)
	FLOAT_PROPERTY(Keyframe, period)
	FLOAT_ARRAY_PROPERTY(Keyframe, 2, handle_left)
	FLOAT_ARRAY_PROPERTY(Keyframe, 2, co)
	FLOAT_ARRAY_PROPERTY(Keyframe, 2, handle_right)


	POINTER_PROPERTY(Struct, FCurveSample, rna_type)
	BOOLEAN_PROPERTY(FCurveSample, select)
	FLOAT_ARRAY_PROPERTY(FCurveSample, 2, co)


	POINTER_PROPERTY(Struct, DriverTarget, rna_type)
	POINTER_PROPERTY(ID, DriverTarget, id)
	ENUM_PROPERTY(id_type_enum, DriverTarget, id_type)
	STRING_PROPERTY(DriverTarget, data_path)
	STRING_PROPERTY(DriverTarget, bone_target)
	ENUM_PROPERTY(transform_type_enum, DriverTarget, transform_type)
	ENUM_PROPERTY(transform_space_enum, DriverTarget, transform_space)


	POINTER_PROPERTY(Struct, DriverVariable, rna_type)
	STRING_PROPERTY(DriverVariable, name)
	ENUM_PROPERTY(type_enum, DriverVariable, type)

	BOOLEAN_PROPERTY(DriverVariable, is_name_valid)


	POINTER_PROPERTY(Struct, Driver, rna_type)
	ENUM_PROPERTY(type_enum, Driver, type)
	STRING_PROPERTY(Driver, expression)

	BOOLEAN_PROPERTY(Driver, use_self)
	BOOLEAN_PROPERTY(Driver, is_valid)
	BOOLEAN_PROPERTY(Driver, is_simple_expression)


	POINTER_PROPERTY(Struct, ChannelDriverVariables, rna_type)

	inline DriverVariable ChannelDriverVariables::create() {
		PointerRNA result;
		::DriverVar *retdata = ChannelDriverVariables_new((::ChannelDriver *) this->ptr.data);
		RNA_pointer_create((::ID *) ptr.id.data, &RNA_DriverVariable, retdata, &result);
		return DriverVariable(result);
	}

	inline void ChannelDriverVariables::remove(DriverVariable& variable) {
		ChannelDriverVariables_remove((::ChannelDriver *) this->ptr.data, NULL, (::PointerRNA *) &variable.ptr);
	}


	POINTER_PROPERTY(Struct, FModifier, rna_type)
	ENUM_PROPERTY(type_enum, FModifier, type)
	BOOLEAN_PROPERTY(FModifier, show_expanded)
	BOOLEAN_PROPERTY(FModifier, mute)
	BOOLEAN_PROPERTY(FModifier, is_valid)
	BOOLEAN_PROPERTY(FModifier, active)
	BOOLEAN_PROPERTY(FModifier, use_restricted_range)
	FLOAT_PROPERTY(FModifier, frame_start)
	FLOAT_PROPERTY(FModifier, frame_end)
	FLOAT_PROPERTY(FModifier, blend_in)
	FLOAT_PROPERTY(FModifier, blend_out)
	BOOLEAN_PROPERTY(FModifier, use_influence)
	FLOAT_PROPERTY(FModifier, influence)


	BOOLEAN_PROPERTY(FModifierGenerator, use_additive)
	ENUM_PROPERTY(mode_enum, FModifierGenerator, mode)
	INT_PROPERTY(FModifierGenerator, poly_order)
	FLOAT_ARRAY_PROPERTY(FModifierGenerator, 32, coefficients)


	FLOAT_PROPERTY(FModifierFunctionGenerator, amplitude)
	FLOAT_PROPERTY(FModifierFunctionGenerator, phase_multiplier)
	FLOAT_PROPERTY(FModifierFunctionGenerator, phase_offset)
	FLOAT_PROPERTY(FModifierFunctionGenerator, value_offset)
	BOOLEAN_PROPERTY(FModifierFunctionGenerator, use_additive)
	ENUM_PROPERTY(function_type_enum, FModifierFunctionGenerator, function_type)



	FLOAT_PROPERTY(FModifierEnvelope, reference_value)
	FLOAT_PROPERTY(FModifierEnvelope, default_min)
	FLOAT_PROPERTY(FModifierEnvelope, default_max)


	POINTER_PROPERTY(Struct, FModifierEnvelopeControlPoints, rna_type)

	inline FModifierEnvelopeControlPoint FModifierEnvelopeControlPoints::add(float frame) {
		PointerRNA result;
		::FCM_EnvelopeData *retdata = FModifierEnvelopeControlPoints_add((::FModifier *) this->ptr.data, NULL, frame);
		RNA_pointer_create((::ID *) ptr.id.data, &RNA_FModifierEnvelopeControlPoint, retdata, &result);
		return FModifierEnvelopeControlPoint(result);
	}

	inline void FModifierEnvelopeControlPoints::remove(FModifierEnvelopeControlPoint& point) {
		FModifierEnvelopeControlPoints_remove((::FModifier *) this->ptr.data, NULL, (::PointerRNA *) point.ptr.data);
	}


	POINTER_PROPERTY(Struct, FModifierEnvelopeControlPoint, rna_type)
	FLOAT_PROPERTY(FModifierEnvelopeControlPoint, min)
	FLOAT_PROPERTY(FModifierEnvelopeControlPoint, max)
	FLOAT_PROPERTY(FModifierEnvelopeControlPoint, frame)


	ENUM_PROPERTY(mode_before_enum, FModifierCycles, mode_before)
	INT_PROPERTY(FModifierCycles, cycles_before)
	ENUM_PROPERTY(mode_after_enum, FModifierCycles, mode_after)
	INT_PROPERTY(FModifierCycles, cycles_after)




	BOOLEAN_PROPERTY(FModifierLimits, use_min_x)
	BOOLEAN_PROPERTY(FModifierLimits, use_min_y)
	BOOLEAN_PROPERTY(FModifierLimits, use_max_x)
	BOOLEAN_PROPERTY(FModifierLimits, use_max_y)
	FLOAT_PROPERTY(FModifierLimits, min_x)
	FLOAT_PROPERTY(FModifierLimits, min_y)
	FLOAT_PROPERTY(FModifierLimits, max_x)
	FLOAT_PROPERTY(FModifierLimits, max_y)


	ENUM_PROPERTY(blend_type_enum, FModifierNoise, blend_type)
	FLOAT_PROPERTY(FModifierNoise, scale)
	FLOAT_PROPERTY(FModifierNoise, strength)
	FLOAT_PROPERTY(FModifierNoise, phase)
	FLOAT_PROPERTY(FModifierNoise, offset)
	INT_PROPERTY(FModifierNoise, depth)


	FLOAT_PROPERTY(FModifierStepped, frame_step)
	FLOAT_PROPERTY(FModifierStepped, frame_offset)
	BOOLEAN_PROPERTY(FModifierStepped, use_frame_start)
	BOOLEAN_PROPERTY(FModifierStepped, use_frame_end)
	FLOAT_PROPERTY(FModifierStepped, frame_start)
	FLOAT_PROPERTY(FModifierStepped, frame_end)


	POINTER_PROPERTY(Struct, FluidSettings, rna_type)
	ENUM_PROPERTY(type_enum, FluidSettings, type)


	INT_PROPERTY(DomainFluidSettings, threads)
	INT_PROPERTY(DomainFluidSettings, resolution)
	INT_PROPERTY(DomainFluidSettings, preview_resolution)
	ENUM_PROPERTY(viewport_display_mode_enum, DomainFluidSettings, viewport_display_mode)
	ENUM_PROPERTY(render_display_mode_enum, DomainFluidSettings, render_display_mode)
	BOOLEAN_PROPERTY(DomainFluidSettings, use_reverse_frames)
	STRING_PROPERTY(DomainFluidSettings, filepath)
	STRING_PROPERTY(DomainFluidSettings, memory_estimate)
	FLOAT_ARRAY_PROPERTY(DomainFluidSettings, 3, gravity)
	BOOLEAN_PROPERTY(DomainFluidSettings, use_time_override)
	FLOAT_PROPERTY(DomainFluidSettings, start_time)
	FLOAT_PROPERTY(DomainFluidSettings, end_time)
	INT_PROPERTY(DomainFluidSettings, frame_offset)
	FLOAT_PROPERTY(DomainFluidSettings, simulation_scale)
	FLOAT_PROPERTY(DomainFluidSettings, simulation_rate)
	FLOAT_PROPERTY(DomainFluidSettings, viscosity_base)
	INT_PROPERTY(DomainFluidSettings, viscosity_exponent)
	INT_PROPERTY(DomainFluidSettings, grid_levels)
	FLOAT_PROPERTY(DomainFluidSettings, compressibility)
	ENUM_PROPERTY(slip_type_enum, DomainFluidSettings, slip_type)
	FLOAT_PROPERTY(DomainFluidSettings, partial_slip_factor)
	FLOAT_PROPERTY(DomainFluidSettings, surface_smooth)
	INT_PROPERTY(DomainFluidSettings, surface_subdivisions)
	BOOLEAN_PROPERTY(DomainFluidSettings, use_speed_vectors)
	BOOLEAN_PROPERTY(DomainFluidSettings, use_surface_noobs)
	INT_PROPERTY(DomainFluidSettings, tracer_particles)
	FLOAT_PROPERTY(DomainFluidSettings, generate_particles)



	POINTER_PROPERTY(Struct, FluidVertexVelocity, rna_type)
	FLOAT_ARRAY_PROPERTY(FluidVertexVelocity, 3, velocity)


	BOOLEAN_PROPERTY(FluidFluidSettings, use)
	ENUM_PROPERTY(volume_initialization_enum, FluidFluidSettings, volume_initialization)
	BOOLEAN_PROPERTY(FluidFluidSettings, use_animated_mesh)
	FLOAT_ARRAY_PROPERTY(FluidFluidSettings, 3, initial_velocity)


	BOOLEAN_PROPERTY(ObstacleFluidSettings, use)
	ENUM_PROPERTY(volume_initialization_enum, ObstacleFluidSettings, volume_initialization)
	BOOLEAN_PROPERTY(ObstacleFluidSettings, use_animated_mesh)
	ENUM_PROPERTY(slip_type_enum, ObstacleFluidSettings, slip_type)
	FLOAT_PROPERTY(ObstacleFluidSettings, partial_slip_factor)
	FLOAT_PROPERTY(ObstacleFluidSettings, impact_factor)


	BOOLEAN_PROPERTY(InflowFluidSettings, use)
	ENUM_PROPERTY(volume_initialization_enum, InflowFluidSettings, volume_initialization)
	BOOLEAN_PROPERTY(InflowFluidSettings, use_animated_mesh)
	FLOAT_ARRAY_PROPERTY(InflowFluidSettings, 3, inflow_velocity)
	BOOLEAN_PROPERTY(InflowFluidSettings, use_local_coords)


	BOOLEAN_PROPERTY(OutflowFluidSettings, use)
	ENUM_PROPERTY(volume_initialization_enum, OutflowFluidSettings, volume_initialization)
	BOOLEAN_PROPERTY(OutflowFluidSettings, use_animated_mesh)


	BOOLEAN_PROPERTY(ParticleFluidSettings, use_drops)
	BOOLEAN_PROPERTY(ParticleFluidSettings, use_floats)
	BOOLEAN_PROPERTY(ParticleFluidSettings, show_tracer)
	FLOAT_PROPERTY(ParticleFluidSettings, particle_influence)
	FLOAT_PROPERTY(ParticleFluidSettings, alpha_influence)
	STRING_PROPERTY(ParticleFluidSettings, filepath)


	BOOLEAN_PROPERTY(ControlFluidSettings, use)
	FLOAT_PROPERTY(ControlFluidSettings, start_time)
	FLOAT_PROPERTY(ControlFluidSettings, end_time)
	FLOAT_PROPERTY(ControlFluidSettings, attraction_strength)
	FLOAT_PROPERTY(ControlFluidSettings, attraction_radius)
	FLOAT_PROPERTY(ControlFluidSettings, velocity_strength)
	FLOAT_PROPERTY(ControlFluidSettings, velocity_radius)
	FLOAT_PROPERTY(ControlFluidSettings, quality)
	BOOLEAN_PROPERTY(ControlFluidSettings, use_reverse_frames)



	POINTER_PROPERTY(AnimData, GreasePencil, animation_data)

	ENUM_PROPERTY(stroke_depth_order_enum, GreasePencil, stroke_depth_order)
	BOOLEAN_PROPERTY(GreasePencil, use_stroke_edit_mode)
	BOOLEAN_PROPERTY(GreasePencil, is_stroke_paint_mode)
	BOOLEAN_PROPERTY(GreasePencil, is_stroke_sculpt_mode)
	BOOLEAN_PROPERTY(GreasePencil, is_stroke_weight_mode)
	BOOLEAN_PROPERTY(GreasePencil, use_onion_skinning)
	BOOLEAN_PROPERTY(GreasePencil, show_stroke_direction)
	ENUM_PROPERTY(stroke_thickness_space_enum, GreasePencil, stroke_thickness_space)
	FLOAT_PROPERTY(GreasePencil, pixel_factor)
	BOOLEAN_PROPERTY(GreasePencil, use_multiedit)
	BOOLEAN_PROPERTY(GreasePencil, use_force_fill_recalc)
	BOOLEAN_PROPERTY(GreasePencil, use_adaptive_uv)
	BOOLEAN_PROPERTY(GreasePencil, use_autolock_layers)
	FLOAT_ARRAY_PROPERTY(GreasePencil, 4, edit_line_color)
	INT_PROPERTY(GreasePencil, ghost_before_range)
	INT_PROPERTY(GreasePencil, ghost_after_range)
	BOOLEAN_PROPERTY(GreasePencil, use_ghost_custom_colors)
	FLOAT_ARRAY_PROPERTY(GreasePencil, 3, before_color)
	FLOAT_ARRAY_PROPERTY(GreasePencil, 3, after_color)
	BOOLEAN_PROPERTY(GreasePencil, use_ghosts_always)
	ENUM_PROPERTY(onion_mode_enum, GreasePencil, onion_mode)
	BOOLEAN_PROPERTY(GreasePencil, use_onion_fade)
	BOOLEAN_PROPERTY(GreasePencil, use_onion_loop)
	FLOAT_PROPERTY(GreasePencil, onion_factor)
	FLOAT_PROPERTY(GreasePencil, zdepth_offset)
	POINTER_PROPERTY(GreasePencilGrid, GreasePencil, grid)

	inline void GreasePencil::clear() {
		GreasePencil_clear((::bGPdata *) this->ptr.data);
	}


	POINTER_PROPERTY(Struct, GreasePencilLayers, rna_type)
	POINTER_PROPERTY(GPencilLayer, GreasePencilLayers, active)
	INT_PROPERTY(GreasePencilLayers, active_index)
	ENUM_PROPERTY(active_note_enum, GreasePencilLayers, active_note)

	inline GPencilLayer GreasePencilLayers::create(const char * name, bool set_active) {
		PointerRNA result;
		::bGPDlayer *retdata = GreasePencilLayers_new((::bGPdata *) this->ptr.data, name, set_active);
		RNA_pointer_create((::ID *) ptr.id.data, &RNA_GPencilLayer, retdata, &result);
		return GPencilLayer(result);
	}

	inline void GreasePencilLayers::remove(GPencilLayer& layer) {
		GreasePencilLayers_remove((::bGPdata *) this->ptr.data, NULL, (::PointerRNA *) &layer.ptr);
	}

	inline void GreasePencilLayers::move(GPencilLayer& layer, int type) {
		GreasePencilLayers_move((::bGPdata *) this->ptr.data, NULL, (::PointerRNA *) &layer.ptr, type);
	}


	POINTER_PROPERTY(Struct, GreasePencilGrid, rna_type)
	FLOAT_ARRAY_PROPERTY(GreasePencilGrid, 2, scale)
	FLOAT_ARRAY_PROPERTY(GreasePencilGrid, 3, color)
	INT_PROPERTY(GreasePencilGrid, lines)
	FLOAT_ARRAY_PROPERTY(GreasePencilGrid, 2, offset)


	POINTER_PROPERTY(Struct, GPencilLayer, rna_type)
	STRING_PROPERTY(GPencilLayer, info)

	POINTER_PROPERTY(GPencilFrame, GPencilLayer, active_frame)
	FLOAT_PROPERTY(GPencilLayer, opacity)
	FLOAT_ARRAY_PROPERTY(GPencilLayer, 3, channel_color)
	FLOAT_ARRAY_PROPERTY(GPencilLayer, 3, color)
	INT_PROPERTY(GPencilLayer, thickness)
	FLOAT_ARRAY_PROPERTY(GPencilLayer, 3, tint_color)
	FLOAT_PROPERTY(GPencilLayer, tint_factor)
	INT_PROPERTY(GPencilLayer, line_change)
	BOOLEAN_PROPERTY(GPencilLayer, use_onion_skinning)
	BOOLEAN_PROPERTY(GPencilLayer, use_annotation_onion_skinning)
	INT_PROPERTY(GPencilLayer, annotation_onion_before_range)
	INT_PROPERTY(GPencilLayer, annotation_onion_after_range)
	FLOAT_ARRAY_PROPERTY(GPencilLayer, 3, annotation_onion_before_color)
	FLOAT_ARRAY_PROPERTY(GPencilLayer, 3, annotation_onion_after_color)
	INT_PROPERTY(GPencilLayer, pass_index)
	STRING_PROPERTY(GPencilLayer, viewlayer_render)
	ENUM_PROPERTY(blend_mode_enum, GPencilLayer, blend_mode)
	BOOLEAN_PROPERTY(GPencilLayer, hide)
	BOOLEAN_PROPERTY(GPencilLayer, annotation_hide)
	BOOLEAN_PROPERTY(GPencilLayer, lock)
	BOOLEAN_PROPERTY(GPencilLayer, lock_frame)
	BOOLEAN_PROPERTY(GPencilLayer, lock_material)
	BOOLEAN_PROPERTY(GPencilLayer, clamp_layer)
	BOOLEAN_PROPERTY(GPencilLayer, use_solo_mode)
	BOOLEAN_PROPERTY(GPencilLayer, select)
	BOOLEAN_PROPERTY(GPencilLayer, show_points)
	BOOLEAN_PROPERTY(GPencilLayer, show_in_front)
	POINTER_PROPERTY(Object, GPencilLayer, parent)
	ENUM_PROPERTY(parent_type_enum, GPencilLayer, parent_type)
	STRING_PROPERTY(GPencilLayer, parent_bone)
	FLOAT_ARRAY_PROPERTY(GPencilLayer, 16, matrix_inverse)
	BOOLEAN_PROPERTY(GPencilLayer, is_parented)

	inline void GPencilLayer::clear() {
		GPencilLayer_clear((::bGPDlayer *) this->ptr.data);
	}


	POINTER_PROPERTY(Struct, GPencilFrames, rna_type)

	inline GPencilFrame GPencilFrames::create(int frame_number) {
		PointerRNA result;
		::bGPDframe *retdata = GPencilFrames_new((::bGPDlayer *) this->ptr.data, NULL, frame_number);
		RNA_pointer_create((::ID *) ptr.id.data, &RNA_GPencilFrame, retdata, &result);
		return GPencilFrame(result);
	}

	inline void GPencilFrames::remove(GPencilFrame& frame) {
		GPencilFrames_remove((::bGPDlayer *) this->ptr.data, NULL, (::PointerRNA *) &frame.ptr);
	}

	inline GPencilFrame GPencilFrames::copy(GPencilFrame& source) {
		PointerRNA result;
		::bGPDframe *retdata = GPencilFrames_copy((::bGPDlayer *) this->ptr.data, (::bGPDframe *) source.ptr.data);
		RNA_pointer_create((::ID *) ptr.id.data, &RNA_GPencilFrame, retdata, &result);
		return GPencilFrame(result);
	}


	POINTER_PROPERTY(Struct, GPencilFrame, rna_type)

	INT_PROPERTY(GPencilFrame, frame_number)
	BOOLEAN_PROPERTY(GPencilFrame, is_edited)
	BOOLEAN_PROPERTY(GPencilFrame, select)

	inline void GPencilFrame::clear() {
		GPencilFrame_clear((::bGPDframe *) this->ptr.data);
	}


	POINTER_PROPERTY(Struct, GPencilStrokes, rna_type)

	inline GPencilStroke GPencilStrokes::create() {
		PointerRNA result;
		::bGPDstroke *retdata = GPencilStrokes_new((::bGPDframe *) this->ptr.data);
		RNA_pointer_create((::ID *) ptr.id.data, &RNA_GPencilStroke, retdata, &result);
		return GPencilStroke(result);
	}

	inline void GPencilStrokes::remove(GPencilStroke& stroke) {
		GPencilStrokes_remove((::bGPDframe *) this->ptr.data, NULL, (::PointerRNA *) &stroke.ptr);
	}


	POINTER_PROPERTY(Struct, GPencilStroke, rna_type)



	INT_PROPERTY(GPencilStroke, material_index)
	ENUM_PROPERTY(display_mode_enum, GPencilStroke, display_mode)
	BOOLEAN_PROPERTY(GPencilStroke, select)
	BOOLEAN_PROPERTY(GPencilStroke, draw_cyclic)
	ENUM_PROPERTY(start_cap_mode_enum, GPencilStroke, start_cap_mode)
	ENUM_PROPERTY(end_cap_mode_enum, GPencilStroke, end_cap_mode)
	BOOLEAN_PROPERTY(GPencilStroke, is_nofill_stroke)
	INT_PROPERTY(GPencilStroke, line_width)


	POINTER_PROPERTY(Struct, GPencilStrokePoints, rna_type)

	inline void GPencilStrokePoints::add(int count, float pressure, float strength) {
		GPencilStrokePoints_add((::ID *) ptr.id.data, (::bGPDstroke *) this->ptr.data, count, pressure, strength);
	}

	inline void GPencilStrokePoints::pop(int index) {
		GPencilStrokePoints_pop((::ID *) ptr.id.data, (::bGPDstroke *) this->ptr.data, NULL, index);
	}


	POINTER_PROPERTY(Struct, GPencilStrokePoint, rna_type)
	FLOAT_ARRAY_PROPERTY(GPencilStrokePoint, 3, co)
	FLOAT_PROPERTY(GPencilStrokePoint, pressure)
	FLOAT_PROPERTY(GPencilStrokePoint, strength)
	FLOAT_PROPERTY(GPencilStrokePoint, uv_factor)
	FLOAT_PROPERTY(GPencilStrokePoint, uv_rotation)
	BOOLEAN_PROPERTY(GPencilStrokePoint, select)


	POINTER_PROPERTY(Struct, GPencilTriangle, rna_type)
	INT_PROPERTY(GPencilTriangle, v1)
	INT_PROPERTY(GPencilTriangle, v2)
	INT_PROPERTY(GPencilTriangle, v3)
	FLOAT_ARRAY_PROPERTY(GPencilTriangle, 2, uv1)
	FLOAT_ARRAY_PROPERTY(GPencilTriangle, 2, uv2)
	FLOAT_ARRAY_PROPERTY(GPencilTriangle, 2, uv3)


	POINTER_PROPERTY(Struct, GpencilVertexGroupElement, rna_type)
	INT_PROPERTY(GpencilVertexGroupElement, group)
	FLOAT_PROPERTY(GpencilVertexGroupElement, weight)


	POINTER_PROPERTY(Struct, RenderSlot, rna_type)
	STRING_PROPERTY(RenderSlot, name)

	inline void RenderSlot::clear(ImageUser& iuser) {
		RenderSlot_clear((::ID *) ptr.id.data, (::RenderSlot *) this->ptr.data, (::ImageUser *) iuser.ptr.data);
	}


	STRING_PROPERTY(Image, filepath)
	STRING_PROPERTY(Image, filepath_raw)
	ENUM_PROPERTY(file_format_enum, Image, file_format)
	ENUM_PROPERTY(source_enum, Image, source)
	ENUM_PROPERTY(type_enum, Image, type)
	POINTER_PROPERTY(PackedFile, Image, packed_file)

	BOOLEAN_PROPERTY(Image, use_view_as_render)
	BOOLEAN_PROPERTY(Image, use_alpha)
	BOOLEAN_PROPERTY(Image, use_deinterlace)
	BOOLEAN_PROPERTY(Image, use_multiview)
	BOOLEAN_PROPERTY(Image, is_stereo_3d)
	BOOLEAN_PROPERTY(Image, is_multiview)
	BOOLEAN_PROPERTY(Image, is_dirty)
	ENUM_PROPERTY(generated_type_enum, Image, generated_type)
	INT_PROPERTY(Image, generated_width)
	INT_PROPERTY(Image, generated_height)
	BOOLEAN_PROPERTY(Image, use_generated_float)
	FLOAT_ARRAY_PROPERTY(Image, 4, generated_color)
	FLOAT_ARRAY_PROPERTY(Image, 2, display_aspect)
	INT_PROPERTY(Image, bindcode)

	BOOLEAN_PROPERTY(Image, has_data)
	INT_PROPERTY(Image, depth)
	INT_ARRAY_PROPERTY(Image, 2, size)
	FLOAT_ARRAY_PROPERTY(Image, 2, resolution)
	INT_PROPERTY(Image, frame_duration)
	FLOAT_DYNAMIC_ARRAY_PROPERTY(Image, pixels)
	INT_PROPERTY(Image, channels)
	BOOLEAN_PROPERTY(Image, is_float)
	POINTER_PROPERTY(ColorManagedInputColorspaceSettings, Image, colorspace_settings)
	ENUM_PROPERTY(alpha_mode_enum, Image, alpha_mode)
	ENUM_PROPERTY(views_format_enum, Image, views_format)
	POINTER_PROPERTY(Stereo3dFormat, Image, stereo_3d_format)

	inline void Image::save_render(Context C, const char * filepath, Scene& scene) {
		Image_save_render((::Image *) this->ptr.data, (::bContext *) C.ptr.data, NULL, filepath, (::Scene *) scene.ptr.data);
	}

	inline void Image::save(void *main, Context C) {
		Image_save((::Image *) this->ptr.data, (::Main *) main, (::bContext *) C.ptr.data, NULL);
	}

	inline void Image::pack(void *main, Context C, bool as_png, const char * data, int data_len) {
		Image_pack((::Image *) this->ptr.data, (::Main *) main, (::bContext *) C.ptr.data, NULL, as_png, data, data_len);
	}

	inline void Image::unpack(void *main, int method) {
		Image_unpack((::Image *) this->ptr.data, (::Main *) main, NULL, method);
	}

	inline void Image::reload(void *main) {
		Image_reload((::Image *) this->ptr.data, (::Main *) main);
	}

	inline void Image::update() {
		Image_update((::Image *) this->ptr.data, NULL);
	}

	inline void Image::scale(int width, int height) {
		Image_scale((::Image *) this->ptr.data, NULL, width, height);
	}

	inline int Image::gl_touch(int frame, int filter, int mag) {
		return Image_gl_touch((::Image *) this->ptr.data, NULL, frame, filter, mag);
	}

	inline int Image::gl_load(int frame, int filter, int mag) {
		return Image_gl_load((::Image *) this->ptr.data, NULL, frame, filter, mag);
	}

	inline void Image::gl_free() {
		Image_gl_free((::Image *) this->ptr.data);
	}

	inline void Image::filepath_from_user(ImageUser& image_user, char * filepath) {
		Image_filepath_from_user((::Image *) this->ptr.data, (::ImageUser *) image_user.ptr.data, filepath);
	}

	inline void Image::buffers_free() {
		Image_buffers_free((::Image *) this->ptr.data);
	}


	POINTER_PROPERTY(Struct, RenderSlots, rna_type)
	INT_PROPERTY(RenderSlots, active_index)
	POINTER_PROPERTY(RenderSlot, RenderSlots, active)

	inline RenderSlot RenderSlots::create(const char * name) {
		PointerRNA result;
		::RenderSlot *retdata = RenderSlots_new((::Image *) this->ptr.data, name);
		RNA_pointer_create((::ID *) ptr.id.data, &RNA_RenderSlot, retdata, &result);
		return RenderSlot(result);
	}


	POINTER_PROPERTY(Struct, ImageUser, rna_type)
	BOOLEAN_PROPERTY(ImageUser, use_auto_refresh)
	INT_PROPERTY(ImageUser, frame_current)
	BOOLEAN_PROPERTY(ImageUser, use_cyclic)
	INT_PROPERTY(ImageUser, frame_duration)
	INT_PROPERTY(ImageUser, frame_offset)
	INT_PROPERTY(ImageUser, frame_start)
	INT_PROPERTY(ImageUser, multilayer_layer)
	INT_PROPERTY(ImageUser, multilayer_pass)
	INT_PROPERTY(ImageUser, multilayer_view)


	POINTER_PROPERTY(Struct, ImagePackedFile, rna_type)
	POINTER_PROPERTY(PackedFile, ImagePackedFile, packed_file)
	STRING_PROPERTY(ImagePackedFile, filepath)

	inline void ImagePackedFile::save(void *main) {
		ImagePackedFile_save((::ImagePackedFile *) this->ptr.data, (::Main *) main, NULL);
	}


	POINTER_PROPERTY(ShapeKey, Key, reference_key)

	POINTER_PROPERTY(AnimData, Key, animation_data)
	POINTER_PROPERTY(ID, Key, user)
	BOOLEAN_PROPERTY(Key, use_relative)
	FLOAT_PROPERTY(Key, eval_time)


	POINTER_PROPERTY(Struct, ShapeKey, rna_type)
	STRING_PROPERTY(ShapeKey, name)
	FLOAT_PROPERTY(ShapeKey, frame)
	FLOAT_PROPERTY(ShapeKey, value)
	ENUM_PROPERTY(interpolation_enum, ShapeKey, interpolation)
	STRING_PROPERTY(ShapeKey, vertex_group)
	POINTER_PROPERTY(ShapeKey, ShapeKey, relative_key)
	BOOLEAN_PROPERTY(ShapeKey, mute)
	FLOAT_PROPERTY(ShapeKey, slider_min)
	FLOAT_PROPERTY(ShapeKey, slider_max)


	inline void ShapeKey::normals_vertex_get(int *normals_len, float **normals) {
		ShapeKey_normals_vertex_get((::ID *) ptr.id.data, (::KeyBlock *) this->ptr.data, normals_len, normals);
	}

	inline void ShapeKey::normals_polygon_get(int *normals_len, float **normals) {
		ShapeKey_normals_polygon_get((::ID *) ptr.id.data, (::KeyBlock *) this->ptr.data, normals_len, normals);
	}

	inline void ShapeKey::normals_split_get(int *normals_len, float **normals) {
		ShapeKey_normals_split_get((::ID *) ptr.id.data, (::KeyBlock *) this->ptr.data, normals_len, normals);
	}


	POINTER_PROPERTY(Struct, ShapeKeyPoint, rna_type)
	FLOAT_ARRAY_PROPERTY(ShapeKeyPoint, 3, co)


	POINTER_PROPERTY(Struct, ShapeKeyCurvePoint, rna_type)
	FLOAT_ARRAY_PROPERTY(ShapeKeyCurvePoint, 3, co)
	FLOAT_PROPERTY(ShapeKeyCurvePoint, tilt)
	FLOAT_PROPERTY(ShapeKeyCurvePoint, radius)


	POINTER_PROPERTY(Struct, ShapeKeyBezierPoint, rna_type)
	FLOAT_ARRAY_PROPERTY(ShapeKeyBezierPoint, 3, co)
	FLOAT_ARRAY_PROPERTY(ShapeKeyBezierPoint, 3, handle_left)
	FLOAT_ARRAY_PROPERTY(ShapeKeyBezierPoint, 3, handle_right)
	FLOAT_PROPERTY(ShapeKeyBezierPoint, tilt)
	FLOAT_PROPERTY(ShapeKeyBezierPoint, radius)


	ENUM_PROPERTY(type_enum, Light, type)
	FLOAT_PROPERTY(Light, distance)
	FLOAT_ARRAY_PROPERTY(Light, 3, color)
	FLOAT_PROPERTY(Light, specular_factor)
	BOOLEAN_PROPERTY(Light, use_custom_distance)
	FLOAT_PROPERTY(Light, cutoff_distance)
	POINTER_PROPERTY(NodeTree, Light, node_tree)
	BOOLEAN_PROPERTY(Light, use_nodes)
	POINTER_PROPERTY(AnimData, Light, animation_data)


	FLOAT_PROPERTY(PointLight, energy)
	ENUM_PROPERTY(falloff_type_enum, PointLight, falloff_type)
	POINTER_PROPERTY(CurveMapping, PointLight, falloff_curve)
	FLOAT_PROPERTY(PointLight, linear_attenuation)
	FLOAT_PROPERTY(PointLight, quadratic_attenuation)
	FLOAT_PROPERTY(PointLight, constant_coefficient)
	FLOAT_PROPERTY(PointLight, linear_coefficient)
	FLOAT_PROPERTY(PointLight, quadratic_coefficient)
	BOOLEAN_PROPERTY(PointLight, use_shadow)
	INT_PROPERTY(PointLight, shadow_buffer_size)
	FLOAT_PROPERTY(PointLight, shadow_buffer_clip_start)
	FLOAT_PROPERTY(PointLight, shadow_buffer_clip_end)
	FLOAT_PROPERTY(PointLight, shadow_buffer_bias)
	FLOAT_PROPERTY(PointLight, shadow_buffer_bleed_bias)
	FLOAT_PROPERTY(PointLight, shadow_buffer_exp)
	FLOAT_PROPERTY(PointLight, shadow_buffer_soft)
	INT_PROPERTY(PointLight, shadow_buffer_samples)
	FLOAT_ARRAY_PROPERTY(PointLight, 3, shadow_color)
	FLOAT_PROPERTY(PointLight, shadow_soft_size)
	BOOLEAN_PROPERTY(PointLight, use_contact_shadow)
	FLOAT_PROPERTY(PointLight, contact_shadow_distance)
	FLOAT_PROPERTY(PointLight, contact_shadow_bias)
	FLOAT_PROPERTY(PointLight, contact_shadow_soft_size)
	FLOAT_PROPERTY(PointLight, contact_shadow_thickness)


	FLOAT_PROPERTY(AreaLight, energy)
	BOOLEAN_PROPERTY(AreaLight, use_shadow)
	INT_PROPERTY(AreaLight, shadow_buffer_size)
	FLOAT_PROPERTY(AreaLight, shadow_buffer_clip_start)
	FLOAT_PROPERTY(AreaLight, shadow_buffer_clip_end)
	FLOAT_PROPERTY(AreaLight, shadow_buffer_bias)
	FLOAT_PROPERTY(AreaLight, shadow_buffer_bleed_bias)
	FLOAT_PROPERTY(AreaLight, shadow_buffer_exp)
	FLOAT_PROPERTY(AreaLight, shadow_buffer_soft)
	INT_PROPERTY(AreaLight, shadow_buffer_samples)
	FLOAT_ARRAY_PROPERTY(AreaLight, 3, shadow_color)
	FLOAT_PROPERTY(AreaLight, shadow_soft_size)
	BOOLEAN_PROPERTY(AreaLight, use_contact_shadow)
	FLOAT_PROPERTY(AreaLight, contact_shadow_distance)
	FLOAT_PROPERTY(AreaLight, contact_shadow_bias)
	FLOAT_PROPERTY(AreaLight, contact_shadow_soft_size)
	FLOAT_PROPERTY(AreaLight, contact_shadow_thickness)
	ENUM_PROPERTY(falloff_type_enum, AreaLight, falloff_type)
	POINTER_PROPERTY(CurveMapping, AreaLight, falloff_curve)
	FLOAT_PROPERTY(AreaLight, linear_attenuation)
	FLOAT_PROPERTY(AreaLight, quadratic_attenuation)
	FLOAT_PROPERTY(AreaLight, constant_coefficient)
	FLOAT_PROPERTY(AreaLight, linear_coefficient)
	FLOAT_PROPERTY(AreaLight, quadratic_coefficient)
	ENUM_PROPERTY(shape_enum, AreaLight, shape)
	FLOAT_PROPERTY(AreaLight, size)
	FLOAT_PROPERTY(AreaLight, size_y)


	FLOAT_PROPERTY(SpotLight, energy)
	ENUM_PROPERTY(falloff_type_enum, SpotLight, falloff_type)
	POINTER_PROPERTY(CurveMapping, SpotLight, falloff_curve)
	FLOAT_PROPERTY(SpotLight, linear_attenuation)
	FLOAT_PROPERTY(SpotLight, quadratic_attenuation)
	FLOAT_PROPERTY(SpotLight, constant_coefficient)
	FLOAT_PROPERTY(SpotLight, linear_coefficient)
	FLOAT_PROPERTY(SpotLight, quadratic_coefficient)
	BOOLEAN_PROPERTY(SpotLight, use_shadow)
	INT_PROPERTY(SpotLight, shadow_buffer_size)
	FLOAT_PROPERTY(SpotLight, shadow_buffer_clip_start)
	FLOAT_PROPERTY(SpotLight, shadow_buffer_clip_end)
	FLOAT_PROPERTY(SpotLight, shadow_buffer_bias)
	FLOAT_PROPERTY(SpotLight, shadow_buffer_bleed_bias)
	FLOAT_PROPERTY(SpotLight, shadow_buffer_exp)
	FLOAT_PROPERTY(SpotLight, shadow_buffer_soft)
	INT_PROPERTY(SpotLight, shadow_buffer_samples)
	FLOAT_ARRAY_PROPERTY(SpotLight, 3, shadow_color)
	FLOAT_PROPERTY(SpotLight, shadow_soft_size)
	BOOLEAN_PROPERTY(SpotLight, use_contact_shadow)
	FLOAT_PROPERTY(SpotLight, contact_shadow_distance)
	FLOAT_PROPERTY(SpotLight, contact_shadow_bias)
	FLOAT_PROPERTY(SpotLight, contact_shadow_soft_size)
	FLOAT_PROPERTY(SpotLight, contact_shadow_thickness)
	BOOLEAN_PROPERTY(SpotLight, use_square)
	FLOAT_PROPERTY(SpotLight, spot_blend)
	FLOAT_PROPERTY(SpotLight, spot_size)
	BOOLEAN_PROPERTY(SpotLight, show_cone)


	FLOAT_PROPERTY(SunLight, energy)
	BOOLEAN_PROPERTY(SunLight, use_shadow)
	INT_PROPERTY(SunLight, shadow_buffer_size)
	FLOAT_PROPERTY(SunLight, shadow_buffer_clip_start)
	FLOAT_PROPERTY(SunLight, shadow_buffer_clip_end)
	FLOAT_PROPERTY(SunLight, shadow_buffer_bias)
	FLOAT_PROPERTY(SunLight, shadow_buffer_bleed_bias)
	FLOAT_PROPERTY(SunLight, shadow_buffer_exp)
	FLOAT_PROPERTY(SunLight, shadow_buffer_soft)
	INT_PROPERTY(SunLight, shadow_buffer_samples)
	FLOAT_ARRAY_PROPERTY(SunLight, 3, shadow_color)
	FLOAT_PROPERTY(SunLight, shadow_soft_size)
	BOOLEAN_PROPERTY(SunLight, use_contact_shadow)
	FLOAT_PROPERTY(SunLight, contact_shadow_distance)
	FLOAT_PROPERTY(SunLight, contact_shadow_bias)
	FLOAT_PROPERTY(SunLight, contact_shadow_soft_size)
	FLOAT_PROPERTY(SunLight, contact_shadow_thickness)
	FLOAT_PROPERTY(SunLight, shadow_cascade_max_distance)
	INT_PROPERTY(SunLight, shadow_cascade_count)
	FLOAT_PROPERTY(SunLight, shadow_cascade_exponent)
	FLOAT_PROPERTY(SunLight, shadow_cascade_fade)


	INT_PROPERTY(Lattice, points_u)
	INT_PROPERTY(Lattice, points_v)
	INT_PROPERTY(Lattice, points_w)
	ENUM_PROPERTY(interpolation_type_u_enum, Lattice, interpolation_type_u)
	ENUM_PROPERTY(interpolation_type_v_enum, Lattice, interpolation_type_v)
	ENUM_PROPERTY(interpolation_type_w_enum, Lattice, interpolation_type_w)
	BOOLEAN_PROPERTY(Lattice, use_outside)
	STRING_PROPERTY(Lattice, vertex_group)
	POINTER_PROPERTY(Key, Lattice, shape_keys)

	BOOLEAN_PROPERTY(Lattice, is_editmode)
	POINTER_PROPERTY(AnimData, Lattice, animation_data)

	inline void Lattice::transform(float matrix[16], bool shape_keys) {
		Lattice_transform((::Lattice *) this->ptr.data, matrix, shape_keys);
	}

	inline void Lattice::update_gpu_tag() {
		Lattice_update_gpu_tag((::Lattice *) this->ptr.data);
	}


	POINTER_PROPERTY(Struct, LatticePoint, rna_type)
	BOOLEAN_PROPERTY(LatticePoint, select)
	FLOAT_ARRAY_PROPERTY(LatticePoint, 3, co)
	FLOAT_ARRAY_PROPERTY(LatticePoint, 3, co_deform)
	FLOAT_PROPERTY(LatticePoint, weight_softbody)



	POINTER_PROPERTY(Struct, ViewLayer, rna_type)
	STRING_PROPERTY(ViewLayer, name)
	POINTER_PROPERTY(Material, ViewLayer, material_override)
	INT_PROPERTY(ViewLayer, samples)
	FLOAT_PROPERTY(ViewLayer, pass_alpha_threshold)
	BOOLEAN_PROPERTY(ViewLayer, use_zmask)
	BOOLEAN_PROPERTY(ViewLayer, invert_zmask)
	BOOLEAN_PROPERTY(ViewLayer, use_all_z)
	BOOLEAN_PROPERTY(ViewLayer, use_solid)
	BOOLEAN_PROPERTY(ViewLayer, use_halo)
	BOOLEAN_PROPERTY(ViewLayer, use_ztransp)
	BOOLEAN_PROPERTY(ViewLayer, use_sky)
	BOOLEAN_PROPERTY(ViewLayer, use_ao)
	BOOLEAN_PROPERTY(ViewLayer, use_edge_enhance)
	BOOLEAN_PROPERTY(ViewLayer, use_strand)
	BOOLEAN_PROPERTY(ViewLayer, use_pass_combined)
	BOOLEAN_PROPERTY(ViewLayer, use_pass_z)
	BOOLEAN_PROPERTY(ViewLayer, use_pass_vector)
	BOOLEAN_PROPERTY(ViewLayer, use_pass_normal)
	BOOLEAN_PROPERTY(ViewLayer, use_pass_uv)
	BOOLEAN_PROPERTY(ViewLayer, use_pass_mist)
	BOOLEAN_PROPERTY(ViewLayer, use_pass_object_index)
	BOOLEAN_PROPERTY(ViewLayer, use_pass_material_index)
	BOOLEAN_PROPERTY(ViewLayer, use_pass_shadow)
	BOOLEAN_PROPERTY(ViewLayer, use_pass_ambient_occlusion)
	BOOLEAN_PROPERTY(ViewLayer, use_pass_emit)
	BOOLEAN_PROPERTY(ViewLayer, use_pass_environment)
	BOOLEAN_PROPERTY(ViewLayer, use_pass_diffuse_direct)
	BOOLEAN_PROPERTY(ViewLayer, use_pass_diffuse_indirect)
	BOOLEAN_PROPERTY(ViewLayer, use_pass_diffuse_color)
	BOOLEAN_PROPERTY(ViewLayer, use_pass_glossy_direct)
	BOOLEAN_PROPERTY(ViewLayer, use_pass_glossy_indirect)
	BOOLEAN_PROPERTY(ViewLayer, use_pass_glossy_color)
	BOOLEAN_PROPERTY(ViewLayer, use_pass_transmission_direct)
	BOOLEAN_PROPERTY(ViewLayer, use_pass_transmission_indirect)
	BOOLEAN_PROPERTY(ViewLayer, use_pass_transmission_color)
	BOOLEAN_PROPERTY(ViewLayer, use_pass_subsurface_direct)
	BOOLEAN_PROPERTY(ViewLayer, use_pass_subsurface_indirect)
	BOOLEAN_PROPERTY(ViewLayer, use_pass_subsurface_color)
	POINTER_PROPERTY(LayerCollection, ViewLayer, layer_collection)
	POINTER_PROPERTY(LayerCollection, ViewLayer, active_layer_collection)

	BOOLEAN_PROPERTY(ViewLayer, use)
	BOOLEAN_PROPERTY(ViewLayer, use_freestyle)
	POINTER_PROPERTY(FreestyleSettings, ViewLayer, freestyle_settings)
	POINTER_PROPERTY(Depsgraph, ViewLayer, depsgraph)

	inline void ViewLayer::update_render_passes() {
		ViewLayer_update_render_passes((::ID *) ptr.id.data);
	}

	inline void ViewLayer::update(void *main) {
		ViewLayer_update((::ID *) ptr.id.data, (::ViewLayer *) this->ptr.data, (::Main *) main);
	}


	POINTER_PROPERTY(Struct, LayerObjects, rna_type)
	POINTER_PROPERTY(Object, LayerObjects, active)



	POINTER_PROPERTY(Struct, FreestyleLineSet, rna_type)
	POINTER_PROPERTY(FreestyleLineStyle, FreestyleLineSet, linestyle)
	STRING_PROPERTY(FreestyleLineSet, name)
	BOOLEAN_PROPERTY(FreestyleLineSet, show_render)
	BOOLEAN_PROPERTY(FreestyleLineSet, select_by_visibility)
	BOOLEAN_PROPERTY(FreestyleLineSet, select_by_edge_types)
	BOOLEAN_PROPERTY(FreestyleLineSet, select_by_collection)
	BOOLEAN_PROPERTY(FreestyleLineSet, select_by_image_border)
	BOOLEAN_PROPERTY(FreestyleLineSet, select_by_face_marks)
	ENUM_PROPERTY(edge_type_negation_enum, FreestyleLineSet, edge_type_negation)
	ENUM_PROPERTY(edge_type_combination_enum, FreestyleLineSet, edge_type_combination)
	POINTER_PROPERTY(Collection, FreestyleLineSet, collection)
	ENUM_PROPERTY(collection_negation_enum, FreestyleLineSet, collection_negation)
	ENUM_PROPERTY(face_mark_negation_enum, FreestyleLineSet, face_mark_negation)
	ENUM_PROPERTY(face_mark_condition_enum, FreestyleLineSet, face_mark_condition)
	BOOLEAN_PROPERTY(FreestyleLineSet, select_silhouette)
	BOOLEAN_PROPERTY(FreestyleLineSet, select_border)
	BOOLEAN_PROPERTY(FreestyleLineSet, select_crease)
	BOOLEAN_PROPERTY(FreestyleLineSet, select_ridge_valley)
	BOOLEAN_PROPERTY(FreestyleLineSet, select_suggestive_contour)
	BOOLEAN_PROPERTY(FreestyleLineSet, select_material_boundary)
	BOOLEAN_PROPERTY(FreestyleLineSet, select_contour)
	BOOLEAN_PROPERTY(FreestyleLineSet, select_external_contour)
	BOOLEAN_PROPERTY(FreestyleLineSet, select_edge_mark)
	BOOLEAN_PROPERTY(FreestyleLineSet, exclude_silhouette)
	BOOLEAN_PROPERTY(FreestyleLineSet, exclude_border)
	BOOLEAN_PROPERTY(FreestyleLineSet, exclude_crease)
	BOOLEAN_PROPERTY(FreestyleLineSet, exclude_ridge_valley)
	BOOLEAN_PROPERTY(FreestyleLineSet, exclude_suggestive_contour)
	BOOLEAN_PROPERTY(FreestyleLineSet, exclude_material_boundary)
	BOOLEAN_PROPERTY(FreestyleLineSet, exclude_contour)
	BOOLEAN_PROPERTY(FreestyleLineSet, exclude_external_contour)
	BOOLEAN_PROPERTY(FreestyleLineSet, exclude_edge_mark)
	ENUM_PROPERTY(visibility_enum, FreestyleLineSet, visibility)
	INT_PROPERTY(FreestyleLineSet, qi_start)
	INT_PROPERTY(FreestyleLineSet, qi_end)


	POINTER_PROPERTY(Struct, FreestyleModuleSettings, rna_type)
	POINTER_PROPERTY(Text, FreestyleModuleSettings, script)
	BOOLEAN_PROPERTY(FreestyleModuleSettings, use)


	POINTER_PROPERTY(Struct, FreestyleSettings, rna_type)

	ENUM_PROPERTY(mode_enum, FreestyleSettings, mode)
	BOOLEAN_PROPERTY(FreestyleSettings, use_culling)
	BOOLEAN_PROPERTY(FreestyleSettings, use_suggestive_contours)
	BOOLEAN_PROPERTY(FreestyleSettings, use_ridges_and_valleys)
	BOOLEAN_PROPERTY(FreestyleSettings, use_material_boundaries)
	BOOLEAN_PROPERTY(FreestyleSettings, use_smoothness)
	BOOLEAN_PROPERTY(FreestyleSettings, use_advanced_options)
	BOOLEAN_PROPERTY(FreestyleSettings, use_view_map_cache)
	FLOAT_PROPERTY(FreestyleSettings, sphere_radius)
	FLOAT_PROPERTY(FreestyleSettings, kr_derivative_epsilon)
	FLOAT_PROPERTY(FreestyleSettings, crease_angle)



	POINTER_PROPERTY(Struct, FreestyleModules, rna_type)

	inline FreestyleModuleSettings FreestyleModules::create() {
		PointerRNA result;
		::FreestyleModuleConfig *retdata = FreestyleModules_new((::ID *) ptr.id.data, (::FreestyleSettings *) this->ptr.data);
		RNA_pointer_create((::ID *) ptr.id.data, &RNA_FreestyleModuleSettings, retdata, &result);
		return FreestyleModuleSettings(result);
	}

	inline void FreestyleModules::remove(FreestyleModuleSettings& module) {
		FreestyleModules_remove((::ID *) ptr.id.data, (::FreestyleSettings *) this->ptr.data, NULL, (::PointerRNA *) &module.ptr);
	}


	POINTER_PROPERTY(Struct, Linesets, rna_type)
	POINTER_PROPERTY(FreestyleLineSet, Linesets, active)
	INT_PROPERTY(Linesets, active_index)

	inline FreestyleLineSet Linesets::create(void *main, const char * name) {
		PointerRNA result;
		::FreestyleLineSet *retdata = Linesets_new((::ID *) ptr.id.data, (::FreestyleSettings *) this->ptr.data, (::Main *) main, name);
		RNA_pointer_create((::ID *) ptr.id.data, &RNA_FreestyleLineSet, retdata, &result);
		return FreestyleLineSet(result);
	}

	inline void Linesets::remove(FreestyleLineSet& lineset) {
		Linesets_remove((::ID *) ptr.id.data, (::FreestyleSettings *) this->ptr.data, NULL, (::PointerRNA *) &lineset.ptr);
	}


	POINTER_PROPERTY(Struct, LayerCollection, rna_type)
	POINTER_PROPERTY(Collection, LayerCollection, collection)
	STRING_PROPERTY(LayerCollection, name)

	BOOLEAN_PROPERTY(LayerCollection, exclude)
	BOOLEAN_PROPERTY(LayerCollection, holdout)
	BOOLEAN_PROPERTY(LayerCollection, indirect_only)
	BOOLEAN_PROPERTY(LayerCollection, hide_viewport)
	BOOLEAN_PROPERTY(LayerCollection, is_visible)

	inline bool LayerCollection::has_objects() {
		return LayerCollection_has_objects((::LayerCollection *) this->ptr.data);
	}

	inline bool LayerCollection::has_selected_objects(ViewLayer& view_layer) {
		return LayerCollection_has_selected_objects((::LayerCollection *) this->ptr.data, (::ViewLayer *) view_layer.ptr.data);
	}


	POINTER_PROPERTY(Struct, ObjectBase, rna_type)
	POINTER_PROPERTY(Object, ObjectBase, object)
	BOOLEAN_PROPERTY(ObjectBase, select)


	POINTER_PROPERTY(Struct, LineStyleModifier, rna_type)




	ENUM_PROPERTY(type_enum, LineStyleColorModifier_AlongStroke, type)
	STRING_PROPERTY(LineStyleColorModifier_AlongStroke, name)
	ENUM_PROPERTY(blend_enum, LineStyleColorModifier_AlongStroke, blend)
	FLOAT_PROPERTY(LineStyleColorModifier_AlongStroke, influence)
	BOOLEAN_PROPERTY(LineStyleColorModifier_AlongStroke, use)
	BOOLEAN_PROPERTY(LineStyleColorModifier_AlongStroke, expanded)
	POINTER_PROPERTY(ColorRamp, LineStyleColorModifier_AlongStroke, color_ramp)


	ENUM_PROPERTY(type_enum, LineStyleColorModifier_DistanceFromCamera, type)
	STRING_PROPERTY(LineStyleColorModifier_DistanceFromCamera, name)
	ENUM_PROPERTY(blend_enum, LineStyleColorModifier_DistanceFromCamera, blend)
	FLOAT_PROPERTY(LineStyleColorModifier_DistanceFromCamera, influence)
	BOOLEAN_PROPERTY(LineStyleColorModifier_DistanceFromCamera, use)
	BOOLEAN_PROPERTY(LineStyleColorModifier_DistanceFromCamera, expanded)
	POINTER_PROPERTY(ColorRamp, LineStyleColorModifier_DistanceFromCamera, color_ramp)
	FLOAT_PROPERTY(LineStyleColorModifier_DistanceFromCamera, range_min)
	FLOAT_PROPERTY(LineStyleColorModifier_DistanceFromCamera, range_max)


	ENUM_PROPERTY(type_enum, LineStyleColorModifier_DistanceFromObject, type)
	STRING_PROPERTY(LineStyleColorModifier_DistanceFromObject, name)
	ENUM_PROPERTY(blend_enum, LineStyleColorModifier_DistanceFromObject, blend)
	FLOAT_PROPERTY(LineStyleColorModifier_DistanceFromObject, influence)
	BOOLEAN_PROPERTY(LineStyleColorModifier_DistanceFromObject, use)
	BOOLEAN_PROPERTY(LineStyleColorModifier_DistanceFromObject, expanded)
	POINTER_PROPERTY(ColorRamp, LineStyleColorModifier_DistanceFromObject, color_ramp)
	FLOAT_PROPERTY(LineStyleColorModifier_DistanceFromObject, range_min)
	FLOAT_PROPERTY(LineStyleColorModifier_DistanceFromObject, range_max)
	POINTER_PROPERTY(Object, LineStyleColorModifier_DistanceFromObject, target)


	ENUM_PROPERTY(type_enum, LineStyleColorModifier_Material, type)
	STRING_PROPERTY(LineStyleColorModifier_Material, name)
	ENUM_PROPERTY(blend_enum, LineStyleColorModifier_Material, blend)
	FLOAT_PROPERTY(LineStyleColorModifier_Material, influence)
	BOOLEAN_PROPERTY(LineStyleColorModifier_Material, use)
	BOOLEAN_PROPERTY(LineStyleColorModifier_Material, expanded)
	ENUM_PROPERTY(material_attribute_enum, LineStyleColorModifier_Material, material_attribute)
	POINTER_PROPERTY(ColorRamp, LineStyleColorModifier_Material, color_ramp)
	BOOLEAN_PROPERTY(LineStyleColorModifier_Material, use_ramp)


	ENUM_PROPERTY(type_enum, LineStyleColorModifier_Tangent, type)
	STRING_PROPERTY(LineStyleColorModifier_Tangent, name)
	ENUM_PROPERTY(blend_enum, LineStyleColorModifier_Tangent, blend)
	FLOAT_PROPERTY(LineStyleColorModifier_Tangent, influence)
	BOOLEAN_PROPERTY(LineStyleColorModifier_Tangent, use)
	BOOLEAN_PROPERTY(LineStyleColorModifier_Tangent, expanded)
	POINTER_PROPERTY(ColorRamp, LineStyleColorModifier_Tangent, color_ramp)


	ENUM_PROPERTY(type_enum, LineStyleColorModifier_Noise, type)
	STRING_PROPERTY(LineStyleColorModifier_Noise, name)
	ENUM_PROPERTY(blend_enum, LineStyleColorModifier_Noise, blend)
	FLOAT_PROPERTY(LineStyleColorModifier_Noise, influence)
	BOOLEAN_PROPERTY(LineStyleColorModifier_Noise, use)
	BOOLEAN_PROPERTY(LineStyleColorModifier_Noise, expanded)
	POINTER_PROPERTY(ColorRamp, LineStyleColorModifier_Noise, color_ramp)
	FLOAT_PROPERTY(LineStyleColorModifier_Noise, amplitude)
	FLOAT_PROPERTY(LineStyleColorModifier_Noise, period)
	INT_PROPERTY(LineStyleColorModifier_Noise, seed)


	ENUM_PROPERTY(type_enum, LineStyleColorModifier_CreaseAngle, type)
	STRING_PROPERTY(LineStyleColorModifier_CreaseAngle, name)
	ENUM_PROPERTY(blend_enum, LineStyleColorModifier_CreaseAngle, blend)
	FLOAT_PROPERTY(LineStyleColorModifier_CreaseAngle, influence)
	BOOLEAN_PROPERTY(LineStyleColorModifier_CreaseAngle, use)
	BOOLEAN_PROPERTY(LineStyleColorModifier_CreaseAngle, expanded)
	POINTER_PROPERTY(ColorRamp, LineStyleColorModifier_CreaseAngle, color_ramp)
	FLOAT_PROPERTY(LineStyleColorModifier_CreaseAngle, angle_min)
	FLOAT_PROPERTY(LineStyleColorModifier_CreaseAngle, angle_max)


	ENUM_PROPERTY(type_enum, LineStyleColorModifier_Curvature_3D, type)
	STRING_PROPERTY(LineStyleColorModifier_Curvature_3D, name)
	ENUM_PROPERTY(blend_enum, LineStyleColorModifier_Curvature_3D, blend)
	FLOAT_PROPERTY(LineStyleColorModifier_Curvature_3D, influence)
	BOOLEAN_PROPERTY(LineStyleColorModifier_Curvature_3D, use)
	BOOLEAN_PROPERTY(LineStyleColorModifier_Curvature_3D, expanded)
	POINTER_PROPERTY(ColorRamp, LineStyleColorModifier_Curvature_3D, color_ramp)
	FLOAT_PROPERTY(LineStyleColorModifier_Curvature_3D, curvature_min)
	FLOAT_PROPERTY(LineStyleColorModifier_Curvature_3D, curvature_max)




	ENUM_PROPERTY(type_enum, LineStyleAlphaModifier_AlongStroke, type)
	STRING_PROPERTY(LineStyleAlphaModifier_AlongStroke, name)
	ENUM_PROPERTY(blend_enum, LineStyleAlphaModifier_AlongStroke, blend)
	FLOAT_PROPERTY(LineStyleAlphaModifier_AlongStroke, influence)
	BOOLEAN_PROPERTY(LineStyleAlphaModifier_AlongStroke, use)
	BOOLEAN_PROPERTY(LineStyleAlphaModifier_AlongStroke, expanded)
	ENUM_PROPERTY(mapping_enum, LineStyleAlphaModifier_AlongStroke, mapping)
	BOOLEAN_PROPERTY(LineStyleAlphaModifier_AlongStroke, invert)
	POINTER_PROPERTY(CurveMapping, LineStyleAlphaModifier_AlongStroke, curve)


	ENUM_PROPERTY(type_enum, LineStyleAlphaModifier_DistanceFromCamera, type)
	STRING_PROPERTY(LineStyleAlphaModifier_DistanceFromCamera, name)
	ENUM_PROPERTY(blend_enum, LineStyleAlphaModifier_DistanceFromCamera, blend)
	FLOAT_PROPERTY(LineStyleAlphaModifier_DistanceFromCamera, influence)
	BOOLEAN_PROPERTY(LineStyleAlphaModifier_DistanceFromCamera, use)
	BOOLEAN_PROPERTY(LineStyleAlphaModifier_DistanceFromCamera, expanded)
	ENUM_PROPERTY(mapping_enum, LineStyleAlphaModifier_DistanceFromCamera, mapping)
	BOOLEAN_PROPERTY(LineStyleAlphaModifier_DistanceFromCamera, invert)
	POINTER_PROPERTY(CurveMapping, LineStyleAlphaModifier_DistanceFromCamera, curve)
	FLOAT_PROPERTY(LineStyleAlphaModifier_DistanceFromCamera, range_min)
	FLOAT_PROPERTY(LineStyleAlphaModifier_DistanceFromCamera, range_max)


	ENUM_PROPERTY(type_enum, LineStyleAlphaModifier_DistanceFromObject, type)
	STRING_PROPERTY(LineStyleAlphaModifier_DistanceFromObject, name)
	ENUM_PROPERTY(blend_enum, LineStyleAlphaModifier_DistanceFromObject, blend)
	FLOAT_PROPERTY(LineStyleAlphaModifier_DistanceFromObject, influence)
	BOOLEAN_PROPERTY(LineStyleAlphaModifier_DistanceFromObject, use)
	BOOLEAN_PROPERTY(LineStyleAlphaModifier_DistanceFromObject, expanded)
	ENUM_PROPERTY(mapping_enum, LineStyleAlphaModifier_DistanceFromObject, mapping)
	BOOLEAN_PROPERTY(LineStyleAlphaModifier_DistanceFromObject, invert)
	POINTER_PROPERTY(CurveMapping, LineStyleAlphaModifier_DistanceFromObject, curve)
	FLOAT_PROPERTY(LineStyleAlphaModifier_DistanceFromObject, range_min)
	FLOAT_PROPERTY(LineStyleAlphaModifier_DistanceFromObject, range_max)
	POINTER_PROPERTY(Object, LineStyleAlphaModifier_DistanceFromObject, target)


	ENUM_PROPERTY(type_enum, LineStyleAlphaModifier_Material, type)
	STRING_PROPERTY(LineStyleAlphaModifier_Material, name)
	ENUM_PROPERTY(blend_enum, LineStyleAlphaModifier_Material, blend)
	FLOAT_PROPERTY(LineStyleAlphaModifier_Material, influence)
	BOOLEAN_PROPERTY(LineStyleAlphaModifier_Material, use)
	BOOLEAN_PROPERTY(LineStyleAlphaModifier_Material, expanded)
	ENUM_PROPERTY(material_attribute_enum, LineStyleAlphaModifier_Material, material_attribute)
	ENUM_PROPERTY(mapping_enum, LineStyleAlphaModifier_Material, mapping)
	BOOLEAN_PROPERTY(LineStyleAlphaModifier_Material, invert)
	POINTER_PROPERTY(CurveMapping, LineStyleAlphaModifier_Material, curve)


	ENUM_PROPERTY(type_enum, LineStyleAlphaModifier_Tangent, type)
	STRING_PROPERTY(LineStyleAlphaModifier_Tangent, name)
	ENUM_PROPERTY(blend_enum, LineStyleAlphaModifier_Tangent, blend)
	FLOAT_PROPERTY(LineStyleAlphaModifier_Tangent, influence)
	BOOLEAN_PROPERTY(LineStyleAlphaModifier_Tangent, use)
	BOOLEAN_PROPERTY(LineStyleAlphaModifier_Tangent, expanded)
	ENUM_PROPERTY(mapping_enum, LineStyleAlphaModifier_Tangent, mapping)
	BOOLEAN_PROPERTY(LineStyleAlphaModifier_Tangent, invert)
	POINTER_PROPERTY(CurveMapping, LineStyleAlphaModifier_Tangent, curve)


	ENUM_PROPERTY(type_enum, LineStyleAlphaModifier_Noise, type)
	STRING_PROPERTY(LineStyleAlphaModifier_Noise, name)
	ENUM_PROPERTY(blend_enum, LineStyleAlphaModifier_Noise, blend)
	FLOAT_PROPERTY(LineStyleAlphaModifier_Noise, influence)
	BOOLEAN_PROPERTY(LineStyleAlphaModifier_Noise, use)
	BOOLEAN_PROPERTY(LineStyleAlphaModifier_Noise, expanded)
	ENUM_PROPERTY(mapping_enum, LineStyleAlphaModifier_Noise, mapping)
	BOOLEAN_PROPERTY(LineStyleAlphaModifier_Noise, invert)
	POINTER_PROPERTY(CurveMapping, LineStyleAlphaModifier_Noise, curve)
	FLOAT_PROPERTY(LineStyleAlphaModifier_Noise, amplitude)
	FLOAT_PROPERTY(LineStyleAlphaModifier_Noise, period)
	INT_PROPERTY(LineStyleAlphaModifier_Noise, seed)


	ENUM_PROPERTY(type_enum, LineStyleAlphaModifier_CreaseAngle, type)
	STRING_PROPERTY(LineStyleAlphaModifier_CreaseAngle, name)
	ENUM_PROPERTY(blend_enum, LineStyleAlphaModifier_CreaseAngle, blend)
	FLOAT_PROPERTY(LineStyleAlphaModifier_CreaseAngle, influence)
	BOOLEAN_PROPERTY(LineStyleAlphaModifier_CreaseAngle, use)
	BOOLEAN_PROPERTY(LineStyleAlphaModifier_CreaseAngle, expanded)
	ENUM_PROPERTY(mapping_enum, LineStyleAlphaModifier_CreaseAngle, mapping)
	BOOLEAN_PROPERTY(LineStyleAlphaModifier_CreaseAngle, invert)
	POINTER_PROPERTY(CurveMapping, LineStyleAlphaModifier_CreaseAngle, curve)
	FLOAT_PROPERTY(LineStyleAlphaModifier_CreaseAngle, angle_min)
	FLOAT_PROPERTY(LineStyleAlphaModifier_CreaseAngle, angle_max)


	ENUM_PROPERTY(type_enum, LineStyleAlphaModifier_Curvature_3D, type)
	STRING_PROPERTY(LineStyleAlphaModifier_Curvature_3D, name)
	ENUM_PROPERTY(blend_enum, LineStyleAlphaModifier_Curvature_3D, blend)
	FLOAT_PROPERTY(LineStyleAlphaModifier_Curvature_3D, influence)
	BOOLEAN_PROPERTY(LineStyleAlphaModifier_Curvature_3D, use)
	BOOLEAN_PROPERTY(LineStyleAlphaModifier_Curvature_3D, expanded)
	ENUM_PROPERTY(mapping_enum, LineStyleAlphaModifier_Curvature_3D, mapping)
	BOOLEAN_PROPERTY(LineStyleAlphaModifier_Curvature_3D, invert)
	POINTER_PROPERTY(CurveMapping, LineStyleAlphaModifier_Curvature_3D, curve)
	FLOAT_PROPERTY(LineStyleAlphaModifier_Curvature_3D, curvature_min)
	FLOAT_PROPERTY(LineStyleAlphaModifier_Curvature_3D, curvature_max)




	ENUM_PROPERTY(type_enum, LineStyleThicknessModifier_Tangent, type)
	STRING_PROPERTY(LineStyleThicknessModifier_Tangent, name)
	ENUM_PROPERTY(blend_enum, LineStyleThicknessModifier_Tangent, blend)
	FLOAT_PROPERTY(LineStyleThicknessModifier_Tangent, influence)
	BOOLEAN_PROPERTY(LineStyleThicknessModifier_Tangent, use)
	BOOLEAN_PROPERTY(LineStyleThicknessModifier_Tangent, expanded)
	ENUM_PROPERTY(mapping_enum, LineStyleThicknessModifier_Tangent, mapping)
	BOOLEAN_PROPERTY(LineStyleThicknessModifier_Tangent, invert)
	POINTER_PROPERTY(CurveMapping, LineStyleThicknessModifier_Tangent, curve)
	FLOAT_PROPERTY(LineStyleThicknessModifier_Tangent, thickness_min)
	FLOAT_PROPERTY(LineStyleThicknessModifier_Tangent, thickness_max)


	ENUM_PROPERTY(type_enum, LineStyleThicknessModifier_AlongStroke, type)
	STRING_PROPERTY(LineStyleThicknessModifier_AlongStroke, name)
	ENUM_PROPERTY(blend_enum, LineStyleThicknessModifier_AlongStroke, blend)
	FLOAT_PROPERTY(LineStyleThicknessModifier_AlongStroke, influence)
	BOOLEAN_PROPERTY(LineStyleThicknessModifier_AlongStroke, use)
	BOOLEAN_PROPERTY(LineStyleThicknessModifier_AlongStroke, expanded)
	ENUM_PROPERTY(mapping_enum, LineStyleThicknessModifier_AlongStroke, mapping)
	BOOLEAN_PROPERTY(LineStyleThicknessModifier_AlongStroke, invert)
	POINTER_PROPERTY(CurveMapping, LineStyleThicknessModifier_AlongStroke, curve)
	FLOAT_PROPERTY(LineStyleThicknessModifier_AlongStroke, value_min)
	FLOAT_PROPERTY(LineStyleThicknessModifier_AlongStroke, value_max)


	ENUM_PROPERTY(type_enum, LineStyleThicknessModifier_DistanceFromCamera, type)
	STRING_PROPERTY(LineStyleThicknessModifier_DistanceFromCamera, name)
	ENUM_PROPERTY(blend_enum, LineStyleThicknessModifier_DistanceFromCamera, blend)
	FLOAT_PROPERTY(LineStyleThicknessModifier_DistanceFromCamera, influence)
	BOOLEAN_PROPERTY(LineStyleThicknessModifier_DistanceFromCamera, use)
	BOOLEAN_PROPERTY(LineStyleThicknessModifier_DistanceFromCamera, expanded)
	ENUM_PROPERTY(mapping_enum, LineStyleThicknessModifier_DistanceFromCamera, mapping)
	BOOLEAN_PROPERTY(LineStyleThicknessModifier_DistanceFromCamera, invert)
	POINTER_PROPERTY(CurveMapping, LineStyleThicknessModifier_DistanceFromCamera, curve)
	FLOAT_PROPERTY(LineStyleThicknessModifier_DistanceFromCamera, range_min)
	FLOAT_PROPERTY(LineStyleThicknessModifier_DistanceFromCamera, range_max)
	FLOAT_PROPERTY(LineStyleThicknessModifier_DistanceFromCamera, value_min)
	FLOAT_PROPERTY(LineStyleThicknessModifier_DistanceFromCamera, value_max)


	ENUM_PROPERTY(type_enum, LineStyleThicknessModifier_DistanceFromObject, type)
	STRING_PROPERTY(LineStyleThicknessModifier_DistanceFromObject, name)
	ENUM_PROPERTY(blend_enum, LineStyleThicknessModifier_DistanceFromObject, blend)
	FLOAT_PROPERTY(LineStyleThicknessModifier_DistanceFromObject, influence)
	BOOLEAN_PROPERTY(LineStyleThicknessModifier_DistanceFromObject, use)
	BOOLEAN_PROPERTY(LineStyleThicknessModifier_DistanceFromObject, expanded)
	ENUM_PROPERTY(mapping_enum, LineStyleThicknessModifier_DistanceFromObject, mapping)
	BOOLEAN_PROPERTY(LineStyleThicknessModifier_DistanceFromObject, invert)
	POINTER_PROPERTY(CurveMapping, LineStyleThicknessModifier_DistanceFromObject, curve)
	FLOAT_PROPERTY(LineStyleThicknessModifier_DistanceFromObject, range_min)
	FLOAT_PROPERTY(LineStyleThicknessModifier_DistanceFromObject, range_max)
	FLOAT_PROPERTY(LineStyleThicknessModifier_DistanceFromObject, value_min)
	FLOAT_PROPERTY(LineStyleThicknessModifier_DistanceFromObject, value_max)
	POINTER_PROPERTY(Object, LineStyleThicknessModifier_DistanceFromObject, target)


	ENUM_PROPERTY(type_enum, LineStyleThicknessModifier_Material, type)
	STRING_PROPERTY(LineStyleThicknessModifier_Material, name)
	ENUM_PROPERTY(blend_enum, LineStyleThicknessModifier_Material, blend)
	FLOAT_PROPERTY(LineStyleThicknessModifier_Material, influence)
	BOOLEAN_PROPERTY(LineStyleThicknessModifier_Material, use)
	BOOLEAN_PROPERTY(LineStyleThicknessModifier_Material, expanded)
	ENUM_PROPERTY(material_attribute_enum, LineStyleThicknessModifier_Material, material_attribute)
	ENUM_PROPERTY(mapping_enum, LineStyleThicknessModifier_Material, mapping)
	BOOLEAN_PROPERTY(LineStyleThicknessModifier_Material, invert)
	POINTER_PROPERTY(CurveMapping, LineStyleThicknessModifier_Material, curve)
	FLOAT_PROPERTY(LineStyleThicknessModifier_Material, value_min)
	FLOAT_PROPERTY(LineStyleThicknessModifier_Material, value_max)


	ENUM_PROPERTY(type_enum, LineStyleThicknessModifier_Calligraphy, type)
	STRING_PROPERTY(LineStyleThicknessModifier_Calligraphy, name)
	ENUM_PROPERTY(blend_enum, LineStyleThicknessModifier_Calligraphy, blend)
	FLOAT_PROPERTY(LineStyleThicknessModifier_Calligraphy, influence)
	BOOLEAN_PROPERTY(LineStyleThicknessModifier_Calligraphy, use)
	BOOLEAN_PROPERTY(LineStyleThicknessModifier_Calligraphy, expanded)
	FLOAT_PROPERTY(LineStyleThicknessModifier_Calligraphy, orientation)
	FLOAT_PROPERTY(LineStyleThicknessModifier_Calligraphy, thickness_min)
	FLOAT_PROPERTY(LineStyleThicknessModifier_Calligraphy, thickness_max)


	ENUM_PROPERTY(type_enum, LineStyleThicknessModifier_Noise, type)
	STRING_PROPERTY(LineStyleThicknessModifier_Noise, name)
	ENUM_PROPERTY(blend_enum, LineStyleThicknessModifier_Noise, blend)
	FLOAT_PROPERTY(LineStyleThicknessModifier_Noise, influence)
	BOOLEAN_PROPERTY(LineStyleThicknessModifier_Noise, use)
	BOOLEAN_PROPERTY(LineStyleThicknessModifier_Noise, expanded)
	FLOAT_PROPERTY(LineStyleThicknessModifier_Noise, amplitude)
	FLOAT_PROPERTY(LineStyleThicknessModifier_Noise, period)
	INT_PROPERTY(LineStyleThicknessModifier_Noise, seed)
	BOOLEAN_PROPERTY(LineStyleThicknessModifier_Noise, use_asymmetric)


	ENUM_PROPERTY(type_enum, LineStyleThicknessModifier_Curvature_3D, type)
	STRING_PROPERTY(LineStyleThicknessModifier_Curvature_3D, name)
	ENUM_PROPERTY(blend_enum, LineStyleThicknessModifier_Curvature_3D, blend)
	FLOAT_PROPERTY(LineStyleThicknessModifier_Curvature_3D, influence)
	BOOLEAN_PROPERTY(LineStyleThicknessModifier_Curvature_3D, use)
	BOOLEAN_PROPERTY(LineStyleThicknessModifier_Curvature_3D, expanded)
	ENUM_PROPERTY(mapping_enum, LineStyleThicknessModifier_Curvature_3D, mapping)
	BOOLEAN_PROPERTY(LineStyleThicknessModifier_Curvature_3D, invert)
	POINTER_PROPERTY(CurveMapping, LineStyleThicknessModifier_Curvature_3D, curve)
	FLOAT_PROPERTY(LineStyleThicknessModifier_Curvature_3D, thickness_min)
	FLOAT_PROPERTY(LineStyleThicknessModifier_Curvature_3D, thickness_max)
	FLOAT_PROPERTY(LineStyleThicknessModifier_Curvature_3D, curvature_min)
	FLOAT_PROPERTY(LineStyleThicknessModifier_Curvature_3D, curvature_max)


	ENUM_PROPERTY(type_enum, LineStyleThicknessModifier_CreaseAngle, type)
	STRING_PROPERTY(LineStyleThicknessModifier_CreaseAngle, name)
	ENUM_PROPERTY(blend_enum, LineStyleThicknessModifier_CreaseAngle, blend)
	FLOAT_PROPERTY(LineStyleThicknessModifier_CreaseAngle, influence)
	BOOLEAN_PROPERTY(LineStyleThicknessModifier_CreaseAngle, use)
	BOOLEAN_PROPERTY(LineStyleThicknessModifier_CreaseAngle, expanded)
	ENUM_PROPERTY(mapping_enum, LineStyleThicknessModifier_CreaseAngle, mapping)
	BOOLEAN_PROPERTY(LineStyleThicknessModifier_CreaseAngle, invert)
	POINTER_PROPERTY(CurveMapping, LineStyleThicknessModifier_CreaseAngle, curve)
	FLOAT_PROPERTY(LineStyleThicknessModifier_CreaseAngle, angle_min)
	FLOAT_PROPERTY(LineStyleThicknessModifier_CreaseAngle, angle_max)
	FLOAT_PROPERTY(LineStyleThicknessModifier_CreaseAngle, thickness_min)
	FLOAT_PROPERTY(LineStyleThicknessModifier_CreaseAngle, thickness_max)




	ENUM_PROPERTY(type_enum, LineStyleGeometryModifier_Sampling, type)
	STRING_PROPERTY(LineStyleGeometryModifier_Sampling, name)
	BOOLEAN_PROPERTY(LineStyleGeometryModifier_Sampling, use)
	BOOLEAN_PROPERTY(LineStyleGeometryModifier_Sampling, expanded)
	FLOAT_PROPERTY(LineStyleGeometryModifier_Sampling, sampling)


	ENUM_PROPERTY(type_enum, LineStyleGeometryModifier_BezierCurve, type)
	STRING_PROPERTY(LineStyleGeometryModifier_BezierCurve, name)
	BOOLEAN_PROPERTY(LineStyleGeometryModifier_BezierCurve, use)
	BOOLEAN_PROPERTY(LineStyleGeometryModifier_BezierCurve, expanded)
	FLOAT_PROPERTY(LineStyleGeometryModifier_BezierCurve, error)


	ENUM_PROPERTY(type_enum, LineStyleGeometryModifier_SinusDisplacement, type)
	STRING_PROPERTY(LineStyleGeometryModifier_SinusDisplacement, name)
	BOOLEAN_PROPERTY(LineStyleGeometryModifier_SinusDisplacement, use)
	BOOLEAN_PROPERTY(LineStyleGeometryModifier_SinusDisplacement, expanded)
	FLOAT_PROPERTY(LineStyleGeometryModifier_SinusDisplacement, wavelength)
	FLOAT_PROPERTY(LineStyleGeometryModifier_SinusDisplacement, amplitude)
	FLOAT_PROPERTY(LineStyleGeometryModifier_SinusDisplacement, phase)


	ENUM_PROPERTY(type_enum, LineStyleGeometryModifier_SpatialNoise, type)
	STRING_PROPERTY(LineStyleGeometryModifier_SpatialNoise, name)
	BOOLEAN_PROPERTY(LineStyleGeometryModifier_SpatialNoise, use)
	BOOLEAN_PROPERTY(LineStyleGeometryModifier_SpatialNoise, expanded)
	FLOAT_PROPERTY(LineStyleGeometryModifier_SpatialNoise, amplitude)
	FLOAT_PROPERTY(LineStyleGeometryModifier_SpatialNoise, scale)
	INT_PROPERTY(LineStyleGeometryModifier_SpatialNoise, octaves)
	BOOLEAN_PROPERTY(LineStyleGeometryModifier_SpatialNoise, smooth)
	BOOLEAN_PROPERTY(LineStyleGeometryModifier_SpatialNoise, use_pure_random)


	ENUM_PROPERTY(type_enum, LineStyleGeometryModifier_PerlinNoise1D, type)
	STRING_PROPERTY(LineStyleGeometryModifier_PerlinNoise1D, name)
	BOOLEAN_PROPERTY(LineStyleGeometryModifier_PerlinNoise1D, use)
	BOOLEAN_PROPERTY(LineStyleGeometryModifier_PerlinNoise1D, expanded)
	FLOAT_PROPERTY(LineStyleGeometryModifier_PerlinNoise1D, frequency)
	FLOAT_PROPERTY(LineStyleGeometryModifier_PerlinNoise1D, amplitude)
	INT_PROPERTY(LineStyleGeometryModifier_PerlinNoise1D, octaves)
	FLOAT_PROPERTY(LineStyleGeometryModifier_PerlinNoise1D, angle)
	INT_PROPERTY(LineStyleGeometryModifier_PerlinNoise1D, seed)


	ENUM_PROPERTY(type_enum, LineStyleGeometryModifier_PerlinNoise2D, type)
	STRING_PROPERTY(LineStyleGeometryModifier_PerlinNoise2D, name)
	BOOLEAN_PROPERTY(LineStyleGeometryModifier_PerlinNoise2D, use)
	BOOLEAN_PROPERTY(LineStyleGeometryModifier_PerlinNoise2D, expanded)
	FLOAT_PROPERTY(LineStyleGeometryModifier_PerlinNoise2D, frequency)
	FLOAT_PROPERTY(LineStyleGeometryModifier_PerlinNoise2D, amplitude)
	INT_PROPERTY(LineStyleGeometryModifier_PerlinNoise2D, octaves)
	FLOAT_PROPERTY(LineStyleGeometryModifier_PerlinNoise2D, angle)
	INT_PROPERTY(LineStyleGeometryModifier_PerlinNoise2D, seed)


	ENUM_PROPERTY(type_enum, LineStyleGeometryModifier_BackboneStretcher, type)
	STRING_PROPERTY(LineStyleGeometryModifier_BackboneStretcher, name)
	BOOLEAN_PROPERTY(LineStyleGeometryModifier_BackboneStretcher, use)
	BOOLEAN_PROPERTY(LineStyleGeometryModifier_BackboneStretcher, expanded)
	FLOAT_PROPERTY(LineStyleGeometryModifier_BackboneStretcher, backbone_length)


	ENUM_PROPERTY(type_enum, LineStyleGeometryModifier_TipRemover, type)
	STRING_PROPERTY(LineStyleGeometryModifier_TipRemover, name)
	BOOLEAN_PROPERTY(LineStyleGeometryModifier_TipRemover, use)
	BOOLEAN_PROPERTY(LineStyleGeometryModifier_TipRemover, expanded)
	FLOAT_PROPERTY(LineStyleGeometryModifier_TipRemover, tip_length)


	ENUM_PROPERTY(type_enum, LineStyleGeometryModifier_Polygonalization, type)
	STRING_PROPERTY(LineStyleGeometryModifier_Polygonalization, name)
	BOOLEAN_PROPERTY(LineStyleGeometryModifier_Polygonalization, use)
	BOOLEAN_PROPERTY(LineStyleGeometryModifier_Polygonalization, expanded)
	FLOAT_PROPERTY(LineStyleGeometryModifier_Polygonalization, error)


	ENUM_PROPERTY(type_enum, LineStyleGeometryModifier_GuidingLines, type)
	STRING_PROPERTY(LineStyleGeometryModifier_GuidingLines, name)
	BOOLEAN_PROPERTY(LineStyleGeometryModifier_GuidingLines, use)
	BOOLEAN_PROPERTY(LineStyleGeometryModifier_GuidingLines, expanded)
	FLOAT_PROPERTY(LineStyleGeometryModifier_GuidingLines, offset)


	ENUM_PROPERTY(type_enum, LineStyleGeometryModifier_Blueprint, type)
	STRING_PROPERTY(LineStyleGeometryModifier_Blueprint, name)
	BOOLEAN_PROPERTY(LineStyleGeometryModifier_Blueprint, use)
	BOOLEAN_PROPERTY(LineStyleGeometryModifier_Blueprint, expanded)
	ENUM_PROPERTY(shape_enum, LineStyleGeometryModifier_Blueprint, shape)
	INT_PROPERTY(LineStyleGeometryModifier_Blueprint, rounds)
	FLOAT_PROPERTY(LineStyleGeometryModifier_Blueprint, backbone_length)
	INT_PROPERTY(LineStyleGeometryModifier_Blueprint, random_radius)
	INT_PROPERTY(LineStyleGeometryModifier_Blueprint, random_center)
	INT_PROPERTY(LineStyleGeometryModifier_Blueprint, random_backbone)


	ENUM_PROPERTY(type_enum, LineStyleGeometryModifier_2DOffset, type)
	STRING_PROPERTY(LineStyleGeometryModifier_2DOffset, name)
	BOOLEAN_PROPERTY(LineStyleGeometryModifier_2DOffset, use)
	BOOLEAN_PROPERTY(LineStyleGeometryModifier_2DOffset, expanded)
	FLOAT_PROPERTY(LineStyleGeometryModifier_2DOffset, start)
	FLOAT_PROPERTY(LineStyleGeometryModifier_2DOffset, end)
	FLOAT_PROPERTY(LineStyleGeometryModifier_2DOffset, x)
	FLOAT_PROPERTY(LineStyleGeometryModifier_2DOffset, y)


	ENUM_PROPERTY(type_enum, LineStyleGeometryModifier_2DTransform, type)
	STRING_PROPERTY(LineStyleGeometryModifier_2DTransform, name)
	BOOLEAN_PROPERTY(LineStyleGeometryModifier_2DTransform, use)
	BOOLEAN_PROPERTY(LineStyleGeometryModifier_2DTransform, expanded)
	ENUM_PROPERTY(pivot_enum, LineStyleGeometryModifier_2DTransform, pivot)
	FLOAT_PROPERTY(LineStyleGeometryModifier_2DTransform, scale_x)
	FLOAT_PROPERTY(LineStyleGeometryModifier_2DTransform, scale_y)
	FLOAT_PROPERTY(LineStyleGeometryModifier_2DTransform, angle)
	FLOAT_PROPERTY(LineStyleGeometryModifier_2DTransform, pivot_u)
	FLOAT_PROPERTY(LineStyleGeometryModifier_2DTransform, pivot_x)
	FLOAT_PROPERTY(LineStyleGeometryModifier_2DTransform, pivot_y)


	ENUM_PROPERTY(type_enum, LineStyleGeometryModifier_Simplification, type)
	STRING_PROPERTY(LineStyleGeometryModifier_Simplification, name)
	BOOLEAN_PROPERTY(LineStyleGeometryModifier_Simplification, use)
	BOOLEAN_PROPERTY(LineStyleGeometryModifier_Simplification, expanded)
	FLOAT_PROPERTY(LineStyleGeometryModifier_Simplification, tolerance)



	POINTER_PROPERTY(Texture, FreestyleLineStyle, active_texture)
	INT_PROPERTY(FreestyleLineStyle, active_texture_index)
	ENUM_PROPERTY(panel_enum, FreestyleLineStyle, panel)
	FLOAT_ARRAY_PROPERTY(FreestyleLineStyle, 3, color)
	FLOAT_PROPERTY(FreestyleLineStyle, alpha)
	FLOAT_PROPERTY(FreestyleLineStyle, thickness)
	ENUM_PROPERTY(thickness_position_enum, FreestyleLineStyle, thickness_position)
	FLOAT_PROPERTY(FreestyleLineStyle, thickness_ratio)




	BOOLEAN_PROPERTY(FreestyleLineStyle, use_chaining)
	ENUM_PROPERTY(chaining_enum, FreestyleLineStyle, chaining)
	INT_PROPERTY(FreestyleLineStyle, rounds)
	BOOLEAN_PROPERTY(FreestyleLineStyle, use_same_object)
	BOOLEAN_PROPERTY(FreestyleLineStyle, use_split_length)
	FLOAT_PROPERTY(FreestyleLineStyle, split_length)
	BOOLEAN_PROPERTY(FreestyleLineStyle, use_angle_min)
	FLOAT_PROPERTY(FreestyleLineStyle, angle_min)
	BOOLEAN_PROPERTY(FreestyleLineStyle, use_angle_max)
	FLOAT_PROPERTY(FreestyleLineStyle, angle_max)
	BOOLEAN_PROPERTY(FreestyleLineStyle, use_length_min)
	FLOAT_PROPERTY(FreestyleLineStyle, length_min)
	BOOLEAN_PROPERTY(FreestyleLineStyle, use_length_max)
	FLOAT_PROPERTY(FreestyleLineStyle, length_max)
	BOOLEAN_PROPERTY(FreestyleLineStyle, use_chain_count)
	INT_PROPERTY(FreestyleLineStyle, chain_count)
	BOOLEAN_PROPERTY(FreestyleLineStyle, use_split_pattern)
	INT_PROPERTY(FreestyleLineStyle, split_dash1)
	INT_PROPERTY(FreestyleLineStyle, split_gap1)
	INT_PROPERTY(FreestyleLineStyle, split_dash2)
	INT_PROPERTY(FreestyleLineStyle, split_gap2)
	INT_PROPERTY(FreestyleLineStyle, split_dash3)
	INT_PROPERTY(FreestyleLineStyle, split_gap3)
	BOOLEAN_PROPERTY(FreestyleLineStyle, material_boundary)
	BOOLEAN_PROPERTY(FreestyleLineStyle, use_sorting)
	ENUM_PROPERTY(sort_key_enum, FreestyleLineStyle, sort_key)
	ENUM_PROPERTY(sort_order_enum, FreestyleLineStyle, sort_order)
	ENUM_PROPERTY(integration_type_enum, FreestyleLineStyle, integration_type)
	BOOLEAN_PROPERTY(FreestyleLineStyle, use_dashed_line)
	ENUM_PROPERTY(caps_enum, FreestyleLineStyle, caps)
	INT_PROPERTY(FreestyleLineStyle, dash1)
	INT_PROPERTY(FreestyleLineStyle, gap1)
	INT_PROPERTY(FreestyleLineStyle, dash2)
	INT_PROPERTY(FreestyleLineStyle, gap2)
	INT_PROPERTY(FreestyleLineStyle, dash3)
	INT_PROPERTY(FreestyleLineStyle, gap3)
	BOOLEAN_PROPERTY(FreestyleLineStyle, use_texture)
	FLOAT_PROPERTY(FreestyleLineStyle, texture_spacing)
	POINTER_PROPERTY(AnimData, FreestyleLineStyle, animation_data)
	POINTER_PROPERTY(NodeTree, FreestyleLineStyle, node_tree)
	BOOLEAN_PROPERTY(FreestyleLineStyle, use_nodes)


	POINTER_PROPERTY(Struct, LineStyleTextureSlots, rna_type)

	inline LineStyleTextureSlot LineStyleTextureSlots::add(Context C) {
		PointerRNA result;
		::MTex *retdata = LineStyleTextureSlots_add((::ID *) ptr.id.data, (::bContext *) C.ptr.data, NULL);
		RNA_pointer_create((::ID *) ptr.id.data, &RNA_LineStyleTextureSlot, retdata, &result);
		return LineStyleTextureSlot(result);
	}

	inline LineStyleTextureSlot LineStyleTextureSlots::create(Context C, int index) {
		PointerRNA result;
		::MTex *retdata = LineStyleTextureSlots_create((::ID *) ptr.id.data, (::bContext *) C.ptr.data, NULL, index);
		RNA_pointer_create((::ID *) ptr.id.data, &RNA_LineStyleTextureSlot, retdata, &result);
		return LineStyleTextureSlot(result);
	}

	inline void LineStyleTextureSlots::clear(Context C, int index) {
		LineStyleTextureSlots_clear((::ID *) ptr.id.data, (::bContext *) C.ptr.data, NULL, index);
	}


	POINTER_PROPERTY(Struct, LineStyleColorModifiers, rna_type)

	inline LineStyleColorModifier LineStyleColorModifiers::create(const char * name, int type) {
		PointerRNA result;
		::LineStyleModifier *retdata = LineStyleColorModifiers_new((::FreestyleLineStyle *) this->ptr.data, NULL, name, type);
		RNA_pointer_create((::ID *) ptr.id.data, &RNA_LineStyleColorModifier, retdata, &result);
		return LineStyleColorModifier(result);
	}

	inline void LineStyleColorModifiers::remove(LineStyleColorModifier& modifier) {
		LineStyleColorModifiers_remove((::FreestyleLineStyle *) this->ptr.data, NULL, (::PointerRNA *) &modifier.ptr);
	}


	POINTER_PROPERTY(Struct, LineStyleAlphaModifiers, rna_type)

	inline LineStyleAlphaModifier LineStyleAlphaModifiers::create(const char * name, int type) {
		PointerRNA result;
		::LineStyleModifier *retdata = LineStyleAlphaModifiers_new((::FreestyleLineStyle *) this->ptr.data, NULL, name, type);
		RNA_pointer_create((::ID *) ptr.id.data, &RNA_LineStyleAlphaModifier, retdata, &result);
		return LineStyleAlphaModifier(result);
	}

	inline void LineStyleAlphaModifiers::remove(LineStyleAlphaModifier& modifier) {
		LineStyleAlphaModifiers_remove((::FreestyleLineStyle *) this->ptr.data, NULL, (::PointerRNA *) &modifier.ptr);
	}


	POINTER_PROPERTY(Struct, LineStyleThicknessModifiers, rna_type)

	inline LineStyleThicknessModifier LineStyleThicknessModifiers::create(const char * name, int type) {
		PointerRNA result;
		::LineStyleModifier *retdata = LineStyleThicknessModifiers_new((::FreestyleLineStyle *) this->ptr.data, NULL, name, type);
		RNA_pointer_create((::ID *) ptr.id.data, &RNA_LineStyleThicknessModifier, retdata, &result);
		return LineStyleThicknessModifier(result);
	}

	inline void LineStyleThicknessModifiers::remove(LineStyleThicknessModifier& modifier) {
		LineStyleThicknessModifiers_remove((::FreestyleLineStyle *) this->ptr.data, NULL, (::PointerRNA *) &modifier.ptr);
	}


	POINTER_PROPERTY(Struct, LineStyleGeometryModifiers, rna_type)

	inline LineStyleGeometryModifier LineStyleGeometryModifiers::create(const char * name, int type) {
		PointerRNA result;
		::LineStyleModifier *retdata = LineStyleGeometryModifiers_new((::FreestyleLineStyle *) this->ptr.data, NULL, name, type);
		RNA_pointer_create((::ID *) ptr.id.data, &RNA_LineStyleGeometryModifier, retdata, &result);
		return LineStyleGeometryModifier(result);
	}

	inline void LineStyleGeometryModifiers::remove(LineStyleGeometryModifier& modifier) {
		LineStyleGeometryModifiers_remove((::FreestyleLineStyle *) this->ptr.data, NULL, (::PointerRNA *) &modifier.ptr);
	}


	ENUM_PROPERTY(mapping_x_enum, LineStyleTextureSlot, mapping_x)
	ENUM_PROPERTY(mapping_y_enum, LineStyleTextureSlot, mapping_y)
	ENUM_PROPERTY(mapping_z_enum, LineStyleTextureSlot, mapping_z)
	ENUM_PROPERTY(mapping_enum, LineStyleTextureSlot, mapping)
	BOOLEAN_PROPERTY(LineStyleTextureSlot, use_map_color_diffuse)
	BOOLEAN_PROPERTY(LineStyleTextureSlot, use_map_alpha)
	ENUM_PROPERTY(texture_coords_enum, LineStyleTextureSlot, texture_coords)
	FLOAT_PROPERTY(LineStyleTextureSlot, alpha_factor)
	FLOAT_PROPERTY(LineStyleTextureSlot, diffuse_color_factor)


	POINTER_PROPERTY(Struct, BlendData, rna_type)
	STRING_PROPERTY(BlendData, filepath)
	BOOLEAN_PROPERTY(BlendData, is_dirty)
	BOOLEAN_PROPERTY(BlendData, is_saved)
	BOOLEAN_PROPERTY(BlendData, use_autopack)
	INT_ARRAY_PROPERTY(BlendData, 3, version)





































	POINTER_PROPERTY(Struct, BlendDataCameras, rna_type)

	inline Camera BlendDataCameras::create(const char * name) {
		PointerRNA result;
		::Camera *retdata = BlendDataCameras_new((::Main *) this->ptr.data, name);
		RNA_id_pointer_create((::ID *) retdata, &result);
		return Camera(result);
	}

	inline void BlendDataCameras::remove(Camera& camera, bool do_unlink, bool do_id_user, bool do_ui_user) {
		BlendDataCameras_remove((::Main *) this->ptr.data, NULL, (::PointerRNA *) &camera.ptr, do_unlink, do_id_user, do_ui_user);
	}

	inline void BlendDataCameras::tag(bool value) {
		BlendDataCameras_tag((::Main *) this->ptr.data, value);
	}


	POINTER_PROPERTY(Struct, BlendDataScenes, rna_type)

	inline Scene BlendDataScenes::create(const char * name) {
		PointerRNA result;
		::Scene *retdata = BlendDataScenes_new((::Main *) this->ptr.data, name);
		RNA_id_pointer_create((::ID *) retdata, &result);
		return Scene(result);
	}

	inline void BlendDataScenes::remove(Context C, Scene& scene, bool do_unlink) {
		BlendDataScenes_remove((::Main *) this->ptr.data, (::bContext *) C.ptr.data, NULL, (::PointerRNA *) &scene.ptr, do_unlink);
	}

	inline void BlendDataScenes::tag(bool value) {
		BlendDataScenes_tag((::Main *) this->ptr.data, value);
	}


	POINTER_PROPERTY(Struct, BlendDataObjects, rna_type)

	inline Object BlendDataObjects::create(const char * name, ID& object_data) {
		PointerRNA result;
		::Object *retdata = BlendDataObjects_new((::Main *) this->ptr.data, NULL, name, (::ID *) object_data.ptr.data);
		RNA_id_pointer_create((::ID *) retdata, &result);
		return Object(result);
	}

	inline void BlendDataObjects::remove(Object& object, bool do_unlink, bool do_id_user, bool do_ui_user) {
		BlendDataObjects_remove((::Main *) this->ptr.data, NULL, (::PointerRNA *) &object.ptr, do_unlink, do_id_user, do_ui_user);
	}

	inline void BlendDataObjects::tag(bool value) {
		BlendDataObjects_tag((::Main *) this->ptr.data, value);
	}


	POINTER_PROPERTY(Struct, BlendDataMaterials, rna_type)

	inline Material BlendDataMaterials::create(const char * name) {
		PointerRNA result;
		::Material *retdata = BlendDataMaterials_new((::Main *) this->ptr.data, name);
		RNA_id_pointer_create((::ID *) retdata, &result);
		return Material(result);
	}

	inline void BlendDataMaterials::create_gpencil_data(Material& material) {
		BlendDataMaterials_create_gpencil_data((::Main *) this->ptr.data, (::PointerRNA *) material.ptr.data);
	}

	inline void BlendDataMaterials::remove(Material& material, bool do_unlink, bool do_id_user, bool do_ui_user) {
		BlendDataMaterials_remove((::Main *) this->ptr.data, NULL, (::PointerRNA *) &material.ptr, do_unlink, do_id_user, do_ui_user);
	}

	inline void BlendDataMaterials::tag(bool value) {
		BlendDataMaterials_tag((::Main *) this->ptr.data, value);
	}


	POINTER_PROPERTY(Struct, BlendDataNodeTrees, rna_type)

	inline NodeTree BlendDataNodeTrees::create(const char * name, int type) {
		PointerRNA result;
		::bNodeTree *retdata = BlendDataNodeTrees_new((::Main *) this->ptr.data, name, type);
		RNA_id_pointer_create((::ID *) retdata, &result);
		return NodeTree(result);
	}

	inline void BlendDataNodeTrees::remove(NodeTree& tree, bool do_unlink, bool do_id_user, bool do_ui_user) {
		BlendDataNodeTrees_remove((::Main *) this->ptr.data, NULL, (::PointerRNA *) &tree.ptr, do_unlink, do_id_user, do_ui_user);
	}

	inline void BlendDataNodeTrees::tag(bool value) {
		BlendDataNodeTrees_tag((::Main *) this->ptr.data, value);
	}


	POINTER_PROPERTY(Struct, BlendDataMeshes, rna_type)

	inline Mesh BlendDataMeshes::create(const char * name) {
		PointerRNA result;
		::Mesh *retdata = BlendDataMeshes_new((::Main *) this->ptr.data, name);
		RNA_id_pointer_create((::ID *) retdata, &result);
		return Mesh(result);
	}

	inline Mesh BlendDataMeshes::new_from_object(Depsgraph& depsgraph, Object& object, bool apply_modifiers, bool calc_undeformed) {
		PointerRNA result;
		::Mesh *retdata = BlendDataMeshes_new_from_object((::Main *) this->ptr.data, NULL, (::Depsgraph *) depsgraph.ptr.data, (::Object *) object.ptr.data, apply_modifiers, calc_undeformed);
		RNA_id_pointer_create((::ID *) retdata, &result);
		return Mesh(result);
	}

	inline void BlendDataMeshes::remove(Mesh& mesh, bool do_unlink, bool do_id_user, bool do_ui_user) {
		BlendDataMeshes_remove((::Main *) this->ptr.data, NULL, (::PointerRNA *) &mesh.ptr, do_unlink, do_id_user, do_ui_user);
	}

	inline void BlendDataMeshes::tag(bool value) {
		BlendDataMeshes_tag((::Main *) this->ptr.data, value);
	}


	POINTER_PROPERTY(Struct, BlendDataLights, rna_type)

	inline Light BlendDataLights::create(const char * name, int type) {
		PointerRNA result;
		::Light *retdata = BlendDataLights_new((::Main *) this->ptr.data, name, type);
		RNA_id_pointer_create((::ID *) retdata, &result);
		return Light(result);
	}

	inline void BlendDataLights::remove(Light& light, bool do_unlink, bool do_id_user, bool do_ui_user) {
		BlendDataLights_remove((::Main *) this->ptr.data, NULL, (::PointerRNA *) &light.ptr, do_unlink, do_id_user, do_ui_user);
	}

	inline void BlendDataLights::tag(bool value) {
		BlendDataLights_tag((::Main *) this->ptr.data, value);
	}


	POINTER_PROPERTY(Struct, BlendDataLibraries, rna_type)

	inline void BlendDataLibraries::tag(bool value) {
		BlendDataLibraries_tag((::Main *) this->ptr.data, value);
	}


	POINTER_PROPERTY(Struct, BlendDataScreens, rna_type)

	inline void BlendDataScreens::tag(bool value) {
		BlendDataScreens_tag((::Main *) this->ptr.data, value);
	}


	POINTER_PROPERTY(Struct, BlendDataWindowManagers, rna_type)

	inline void BlendDataWindowManagers::tag(bool value) {
		BlendDataWindowManagers_tag((::Main *) this->ptr.data, value);
	}


	POINTER_PROPERTY(Struct, BlendDataImages, rna_type)

	inline Image BlendDataImages::create(const char * name, int width, int height, bool alpha, bool float_buffer, bool stereo3d) {
		PointerRNA result;
		::Image *retdata = BlendDataImages_new((::Main *) this->ptr.data, name, width, height, alpha, float_buffer, stereo3d);
		RNA_id_pointer_create((::ID *) retdata, &result);
		return Image(result);
	}

	inline Image BlendDataImages::load(const char * filepath, bool check_existing) {
		PointerRNA result;
		::Image *retdata = BlendDataImages_load((::Main *) this->ptr.data, NULL, filepath, check_existing);
		RNA_id_pointer_create((::ID *) retdata, &result);
		return Image(result);
	}

	inline void BlendDataImages::remove(Image& image, bool do_unlink, bool do_id_user, bool do_ui_user) {
		BlendDataImages_remove((::Main *) this->ptr.data, NULL, (::PointerRNA *) &image.ptr, do_unlink, do_id_user, do_ui_user);
	}

	inline void BlendDataImages::tag(bool value) {
		BlendDataImages_tag((::Main *) this->ptr.data, value);
	}


	POINTER_PROPERTY(Struct, BlendDataLattices, rna_type)

	inline Lattice BlendDataLattices::create(const char * name) {
		PointerRNA result;
		::Lattice *retdata = BlendDataLattices_new((::Main *) this->ptr.data, name);
		RNA_id_pointer_create((::ID *) retdata, &result);
		return Lattice(result);
	}

	inline void BlendDataLattices::remove(Lattice& lattice, bool do_unlink, bool do_id_user, bool do_ui_user) {
		BlendDataLattices_remove((::Main *) this->ptr.data, NULL, (::PointerRNA *) &lattice.ptr, do_unlink, do_id_user, do_ui_user);
	}

	inline void BlendDataLattices::tag(bool value) {
		BlendDataLattices_tag((::Main *) this->ptr.data, value);
	}


	POINTER_PROPERTY(Struct, BlendDataCurves, rna_type)

	inline Curve BlendDataCurves::create(const char * name, int type) {
		PointerRNA result;
		::Curve *retdata = BlendDataCurves_new((::Main *) this->ptr.data, name, type);
		RNA_id_pointer_create((::ID *) retdata, &result);
		return Curve(result);
	}

	inline void BlendDataCurves::remove(Curve& curve, bool do_unlink, bool do_id_user, bool do_ui_user) {
		BlendDataCurves_remove((::Main *) this->ptr.data, NULL, (::PointerRNA *) &curve.ptr, do_unlink, do_id_user, do_ui_user);
	}

	inline void BlendDataCurves::tag(bool value) {
		BlendDataCurves_tag((::Main *) this->ptr.data, value);
	}


	POINTER_PROPERTY(Struct, BlendDataMetaBalls, rna_type)

	inline MetaBall BlendDataMetaBalls::create(const char * name) {
		PointerRNA result;
		::MetaBall *retdata = BlendDataMetaBalls_new((::Main *) this->ptr.data, name);
		RNA_id_pointer_create((::ID *) retdata, &result);
		return MetaBall(result);
	}

	inline void BlendDataMetaBalls::remove(MetaBall& metaball, bool do_unlink, bool do_id_user, bool do_ui_user) {
		BlendDataMetaBalls_remove((::Main *) this->ptr.data, NULL, (::PointerRNA *) &metaball.ptr, do_unlink, do_id_user, do_ui_user);
	}

	inline void BlendDataMetaBalls::tag(bool value) {
		BlendDataMetaBalls_tag((::Main *) this->ptr.data, value);
	}


	POINTER_PROPERTY(Struct, BlendDataFonts, rna_type)

	inline VectorFont BlendDataFonts::load(const char * filepath, bool check_existing) {
		PointerRNA result;
		::VFont *retdata = BlendDataFonts_load((::Main *) this->ptr.data, NULL, filepath, check_existing);
		RNA_id_pointer_create((::ID *) retdata, &result);
		return VectorFont(result);
	}

	inline void BlendDataFonts::remove(VectorFont& vfont, bool do_unlink, bool do_id_user, bool do_ui_user) {
		BlendDataFonts_remove((::Main *) this->ptr.data, NULL, (::PointerRNA *) &vfont.ptr, do_unlink, do_id_user, do_ui_user);
	}

	inline void BlendDataFonts::tag(bool value) {
		BlendDataFonts_tag((::Main *) this->ptr.data, value);
	}


	POINTER_PROPERTY(Struct, BlendDataTextures, rna_type)

	inline Texture BlendDataTextures::create(const char * name, int type) {
		PointerRNA result;
		::Tex *retdata = BlendDataTextures_new((::Main *) this->ptr.data, name, type);
		RNA_id_pointer_create((::ID *) retdata, &result);
		return Texture(result);
	}

	inline void BlendDataTextures::remove(Texture& texture, bool do_unlink, bool do_id_user, bool do_ui_user) {
		BlendDataTextures_remove((::Main *) this->ptr.data, NULL, (::PointerRNA *) &texture.ptr, do_unlink, do_id_user, do_ui_user);
	}

	inline void BlendDataTextures::tag(bool value) {
		BlendDataTextures_tag((::Main *) this->ptr.data, value);
	}


	POINTER_PROPERTY(Struct, BlendDataBrushes, rna_type)

	inline Brush BlendDataBrushes::create(const char * name, int mode) {
		PointerRNA result;
		::Brush *retdata = BlendDataBrushes_new((::Main *) this->ptr.data, name, mode);
		RNA_id_pointer_create((::ID *) retdata, &result);
		return Brush(result);
	}

	inline void BlendDataBrushes::remove(Brush& brush, bool do_unlink, bool do_id_user, bool do_ui_user) {
		BlendDataBrushes_remove((::Main *) this->ptr.data, NULL, (::PointerRNA *) &brush.ptr, do_unlink, do_id_user, do_ui_user);
	}

	inline void BlendDataBrushes::tag(bool value) {
		BlendDataBrushes_tag((::Main *) this->ptr.data, value);
	}

	inline void BlendDataBrushes::create_gpencil_data(Brush& brush) {
		BlendDataBrushes_create_gpencil_data((::Main *) this->ptr.data, (::PointerRNA *) brush.ptr.data);
	}


	POINTER_PROPERTY(Struct, BlendDataWorlds, rna_type)

	inline World BlendDataWorlds::create(const char * name) {
		PointerRNA result;
		::World *retdata = BlendDataWorlds_new((::Main *) this->ptr.data, name);
		RNA_id_pointer_create((::ID *) retdata, &result);
		return World(result);
	}

	inline void BlendDataWorlds::remove(World& world, bool do_unlink, bool do_id_user, bool do_ui_user) {
		BlendDataWorlds_remove((::Main *) this->ptr.data, NULL, (::PointerRNA *) &world.ptr, do_unlink, do_id_user, do_ui_user);
	}

	inline void BlendDataWorlds::tag(bool value) {
		BlendDataWorlds_tag((::Main *) this->ptr.data, value);
	}


	POINTER_PROPERTY(Struct, BlendDataCollections, rna_type)

	inline Collection BlendDataCollections::create(const char * name) {
		PointerRNA result;
		::Collection *retdata = BlendDataCollections_new((::Main *) this->ptr.data, name);
		RNA_id_pointer_create((::ID *) retdata, &result);
		return Collection(result);
	}

	inline void BlendDataCollections::remove(Collection& collection, bool do_unlink, bool do_id_user, bool do_ui_user) {
		BlendDataCollections_remove((::Main *) this->ptr.data, NULL, (::PointerRNA *) &collection.ptr, do_unlink, do_id_user, do_ui_user);
	}

	inline void BlendDataCollections::tag(bool value) {
		BlendDataCollections_tag((::Main *) this->ptr.data, value);
	}


	POINTER_PROPERTY(Struct, BlendDataTexts, rna_type)

	inline Text BlendDataTexts::create(const char * name) {
		PointerRNA result;
		::Text *retdata = BlendDataTexts_new((::Main *) this->ptr.data, name);
		RNA_id_pointer_create((::ID *) retdata, &result);
		return Text(result);
	}

	inline void BlendDataTexts::remove(Text& text, bool do_unlink, bool do_id_user, bool do_ui_user) {
		BlendDataTexts_remove((::Main *) this->ptr.data, NULL, (::PointerRNA *) &text.ptr, do_unlink, do_id_user, do_ui_user);
	}

	inline Text BlendDataTexts::load(const char * filepath, bool internal) {
		PointerRNA result;
		::Text *retdata = BlendDataTexts_load((::Main *) this->ptr.data, NULL, filepath, internal);
		RNA_id_pointer_create((::ID *) retdata, &result);
		return Text(result);
	}

	inline void BlendDataTexts::tag(bool value) {
		BlendDataTexts_tag((::Main *) this->ptr.data, value);
	}


	POINTER_PROPERTY(Struct, BlendDataSpeakers, rna_type)

	inline Speaker BlendDataSpeakers::create(const char * name) {
		PointerRNA result;
		::Speaker *retdata = BlendDataSpeakers_new((::Main *) this->ptr.data, name);
		RNA_id_pointer_create((::ID *) retdata, &result);
		return Speaker(result);
	}

	inline void BlendDataSpeakers::remove(Speaker& speaker, bool do_unlink, bool do_id_user, bool do_ui_user) {
		BlendDataSpeakers_remove((::Main *) this->ptr.data, NULL, (::PointerRNA *) &speaker.ptr, do_unlink, do_id_user, do_ui_user);
	}

	inline void BlendDataSpeakers::tag(bool value) {
		BlendDataSpeakers_tag((::Main *) this->ptr.data, value);
	}


	POINTER_PROPERTY(Struct, BlendDataSounds, rna_type)

	inline Sound BlendDataSounds::load(const char * filepath, bool check_existing) {
		PointerRNA result;
		::bSound *retdata = BlendDataSounds_load((::Main *) this->ptr.data, filepath, check_existing);
		RNA_id_pointer_create((::ID *) retdata, &result);
		return Sound(result);
	}

	inline void BlendDataSounds::remove(Sound& sound, bool do_unlink, bool do_id_user, bool do_ui_user) {
		BlendDataSounds_remove((::Main *) this->ptr.data, NULL, (::PointerRNA *) &sound.ptr, do_unlink, do_id_user, do_ui_user);
	}

	inline void BlendDataSounds::tag(bool value) {
		BlendDataSounds_tag((::Main *) this->ptr.data, value);
	}


	POINTER_PROPERTY(Struct, BlendDataArmatures, rna_type)

	inline Armature BlendDataArmatures::create(const char * name) {
		PointerRNA result;
		::bArmature *retdata = BlendDataArmatures_new((::Main *) this->ptr.data, name);
		RNA_id_pointer_create((::ID *) retdata, &result);
		return Armature(result);
	}

	inline void BlendDataArmatures::remove(Armature& armature, bool do_unlink, bool do_id_user, bool do_ui_user) {
		BlendDataArmatures_remove((::Main *) this->ptr.data, NULL, (::PointerRNA *) &armature.ptr, do_unlink, do_id_user, do_ui_user);
	}

	inline void BlendDataArmatures::tag(bool value) {
		BlendDataArmatures_tag((::Main *) this->ptr.data, value);
	}


	POINTER_PROPERTY(Struct, BlendDataActions, rna_type)

	inline Action BlendDataActions::create(const char * name) {
		PointerRNA result;
		::bAction *retdata = BlendDataActions_new((::Main *) this->ptr.data, name);
		RNA_id_pointer_create((::ID *) retdata, &result);
		return Action(result);
	}

	inline void BlendDataActions::remove(Action& action, bool do_unlink, bool do_id_user, bool do_ui_user) {
		BlendDataActions_remove((::Main *) this->ptr.data, NULL, (::PointerRNA *) &action.ptr, do_unlink, do_id_user, do_ui_user);
	}

	inline void BlendDataActions::tag(bool value) {
		BlendDataActions_tag((::Main *) this->ptr.data, value);
	}


	POINTER_PROPERTY(Struct, BlendDataParticles, rna_type)

	inline ParticleSettings BlendDataParticles::create(const char * name) {
		PointerRNA result;
		::ParticleSettings *retdata = BlendDataParticles_new((::Main *) this->ptr.data, name);
		RNA_id_pointer_create((::ID *) retdata, &result);
		return ParticleSettings(result);
	}

	inline void BlendDataParticles::remove(ParticleSettings& particle, bool do_unlink, bool do_id_user, bool do_ui_user) {
		BlendDataParticles_remove((::Main *) this->ptr.data, NULL, (::PointerRNA *) &particle.ptr, do_unlink, do_id_user, do_ui_user);
	}

	inline void BlendDataParticles::tag(bool value) {
		BlendDataParticles_tag((::Main *) this->ptr.data, value);
	}


	POINTER_PROPERTY(Struct, BlendDataPalettes, rna_type)

	inline Palette BlendDataPalettes::create(const char * name) {
		PointerRNA result;
		::Palette *retdata = BlendDataPalettes_new((::Main *) this->ptr.data, name);
		RNA_id_pointer_create((::ID *) retdata, &result);
		return Palette(result);
	}

	inline void BlendDataPalettes::remove(Palette& palette, bool do_unlink, bool do_id_user, bool do_ui_user) {
		BlendDataPalettes_remove((::Main *) this->ptr.data, NULL, (::PointerRNA *) &palette.ptr, do_unlink, do_id_user, do_ui_user);
	}

	inline void BlendDataPalettes::tag(bool value) {
		BlendDataPalettes_tag((::Main *) this->ptr.data, value);
	}


	POINTER_PROPERTY(Struct, BlendDataGreasePencils, rna_type)

	inline void BlendDataGreasePencils::tag(bool value) {
		BlendDataGreasePencils_tag((::Main *) this->ptr.data, value);
	}

	inline GreasePencil BlendDataGreasePencils::create(void *main, const char * name) {
		PointerRNA result;
		::bGPdata *retdata = BlendDataGreasePencils_new((::Main *) main, name);
		RNA_id_pointer_create((::ID *) retdata, &result);
		return GreasePencil(result);
	}

	inline void BlendDataGreasePencils::remove(GreasePencil& grease_pencil, bool do_unlink, bool do_id_user, bool do_ui_user) {
		BlendDataGreasePencils_remove((::Main *) this->ptr.data, NULL, (::PointerRNA *) &grease_pencil.ptr, do_unlink, do_id_user, do_ui_user);
	}


	POINTER_PROPERTY(Struct, BlendDataMovieClips, rna_type)

	inline void BlendDataMovieClips::tag(bool value) {
		BlendDataMovieClips_tag((::Main *) this->ptr.data, value);
	}

	inline void BlendDataMovieClips::remove(MovieClip& clip, bool do_unlink, bool do_id_user, bool do_ui_user) {
		BlendDataMovieClips_remove((::Main *) this->ptr.data, NULL, (::PointerRNA *) &clip.ptr, do_unlink, do_id_user, do_ui_user);
	}

	inline MovieClip BlendDataMovieClips::load(const char * filepath, bool check_existing) {
		PointerRNA result;
		::MovieClip *retdata = BlendDataMovieClips_load((::Main *) this->ptr.data, NULL, filepath, check_existing);
		RNA_id_pointer_create((::ID *) retdata, &result);
		return MovieClip(result);
	}


	POINTER_PROPERTY(Struct, BlendDataMasks, rna_type)

	inline void BlendDataMasks::tag(bool value) {
		BlendDataMasks_tag((::Main *) this->ptr.data, value);
	}

	inline Mask BlendDataMasks::create(const char * name) {
		PointerRNA result;
		::Mask *retdata = BlendDataMasks_new((::Main *) this->ptr.data, name);
		RNA_id_pointer_create((::ID *) retdata, &result);
		return Mask(result);
	}

	inline void BlendDataMasks::remove(Mask& mask, bool do_unlink, bool do_id_user, bool do_ui_user) {
		BlendDataMasks_remove((::Main *) this->ptr.data, NULL, (::PointerRNA *) &mask.ptr, do_unlink, do_id_user, do_ui_user);
	}


	POINTER_PROPERTY(Struct, BlendDataLineStyles, rna_type)

	inline void BlendDataLineStyles::tag(bool value) {
		BlendDataLineStyles_tag((::Main *) this->ptr.data, value);
	}

	inline FreestyleLineStyle BlendDataLineStyles::create(const char * name) {
		PointerRNA result;
		::FreestyleLineStyle *retdata = BlendDataLineStyles_new((::Main *) this->ptr.data, name);
		RNA_id_pointer_create((::ID *) retdata, &result);
		return FreestyleLineStyle(result);
	}

	inline void BlendDataLineStyles::remove(FreestyleLineStyle& linestyle, bool do_unlink, bool do_id_user, bool do_ui_user) {
		BlendDataLineStyles_remove((::Main *) this->ptr.data, NULL, (::PointerRNA *) &linestyle.ptr, do_unlink, do_id_user, do_ui_user);
	}


	POINTER_PROPERTY(Struct, BlendDataCacheFiles, rna_type)

	inline void BlendDataCacheFiles::tag(bool value) {
		BlendDataCacheFiles_tag((::Main *) this->ptr.data, value);
	}


	POINTER_PROPERTY(Struct, BlendDataPaintCurves, rna_type)

	inline void BlendDataPaintCurves::tag(bool value) {
		BlendDataPaintCurves_tag((::Main *) this->ptr.data, value);
	}


	POINTER_PROPERTY(Struct, BlendDataWorkSpaces, rna_type)

	inline void BlendDataWorkSpaces::tag(bool value) {
		BlendDataWorkSpaces_tag((::Main *) this->ptr.data, value);
	}


	POINTER_PROPERTY(Struct, BlendDataProbes, rna_type)

	inline LightProbe BlendDataProbes::create(const char * name) {
		PointerRNA result;
		::LightProbe *retdata = BlendDataProbes_new((::Main *) this->ptr.data, name);
		RNA_id_pointer_create((::ID *) retdata, &result);
		return LightProbe(result);
	}

	inline void BlendDataProbes::remove(LightProbe& lightprobe, bool do_unlink, bool do_id_user, bool do_ui_user) {
		BlendDataProbes_remove((::Main *) this->ptr.data, NULL, (::PointerRNA *) &lightprobe.ptr, do_unlink, do_id_user, do_ui_user);
	}

	inline void BlendDataProbes::tag(bool value) {
		BlendDataProbes_tag((::Main *) this->ptr.data, value);
	}


	ENUM_PROPERTY(blend_method_enum, Material, blend_method)
	ENUM_PROPERTY(shadow_method_enum, Material, shadow_method)
	FLOAT_PROPERTY(Material, alpha_threshold)
	BOOLEAN_PROPERTY(Material, show_transparent_back)
	BOOLEAN_PROPERTY(Material, use_screen_refraction)
	BOOLEAN_PROPERTY(Material, use_sss_translucency)
	FLOAT_PROPERTY(Material, refraction_depth)
	ENUM_PROPERTY(preview_render_type_enum, Material, preview_render_type)
	INT_PROPERTY(Material, pass_index)
	POINTER_PROPERTY(NodeTree, Material, node_tree)
	BOOLEAN_PROPERTY(Material, use_nodes)
	POINTER_PROPERTY(AnimData, Material, animation_data)


	INT_PROPERTY(Material, paint_active_slot)
	INT_PROPERTY(Material, paint_clone_slot)
	FLOAT_ARRAY_PROPERTY(Material, 4, diffuse_color)
	FLOAT_ARRAY_PROPERTY(Material, 3, specular_color)
	FLOAT_PROPERTY(Material, roughness)
	FLOAT_PROPERTY(Material, specular_intensity)
	FLOAT_PROPERTY(Material, metallic)
	FLOAT_ARRAY_PROPERTY(Material, 4, line_color)
	INT_PROPERTY(Material, line_priority)
	POINTER_PROPERTY(MaterialGPencilStyle, Material, grease_pencil)
	BOOLEAN_PROPERTY(Material, is_grease_pencil)


	POINTER_PROPERTY(Struct, TexPaintSlot, rna_type)
	STRING_PROPERTY(TexPaintSlot, uv_layer)
	BOOLEAN_PROPERTY(TexPaintSlot, is_valid)


	POINTER_PROPERTY(Struct, MaterialGPencilStyle, rna_type)
	FLOAT_ARRAY_PROPERTY(MaterialGPencilStyle, 4, color)
	FLOAT_ARRAY_PROPERTY(MaterialGPencilStyle, 4, fill_color)
	FLOAT_ARRAY_PROPERTY(MaterialGPencilStyle, 4, mix_color)
	FLOAT_PROPERTY(MaterialGPencilStyle, mix_factor)
	FLOAT_ARRAY_PROPERTY(MaterialGPencilStyle, 2, pattern_scale)
	FLOAT_ARRAY_PROPERTY(MaterialGPencilStyle, 2, pattern_shift)
	FLOAT_PROPERTY(MaterialGPencilStyle, pattern_angle)
	FLOAT_PROPERTY(MaterialGPencilStyle, pattern_radius)
	FLOAT_PROPERTY(MaterialGPencilStyle, pattern_gridsize)
	FLOAT_PROPERTY(MaterialGPencilStyle, texture_angle)
	FLOAT_ARRAY_PROPERTY(MaterialGPencilStyle, 2, texture_scale)
	FLOAT_ARRAY_PROPERTY(MaterialGPencilStyle, 2, texture_offset)
	FLOAT_PROPERTY(MaterialGPencilStyle, texture_opacity)
	FLOAT_PROPERTY(MaterialGPencilStyle, pixel_size)
	BOOLEAN_PROPERTY(MaterialGPencilStyle, hide)
	BOOLEAN_PROPERTY(MaterialGPencilStyle, lock)
	BOOLEAN_PROPERTY(MaterialGPencilStyle, ghost)
	BOOLEAN_PROPERTY(MaterialGPencilStyle, texture_clamp)
	BOOLEAN_PROPERTY(MaterialGPencilStyle, texture_mix)
	BOOLEAN_PROPERTY(MaterialGPencilStyle, flip)
	BOOLEAN_PROPERTY(MaterialGPencilStyle, use_stroke_pattern)
	BOOLEAN_PROPERTY(MaterialGPencilStyle, use_fill_pattern)
	BOOLEAN_PROPERTY(MaterialGPencilStyle, show_stroke)
	BOOLEAN_PROPERTY(MaterialGPencilStyle, show_fill)
	INT_PROPERTY(MaterialGPencilStyle, pass_index)
	ENUM_PROPERTY(mode_enum, MaterialGPencilStyle, mode)
	ENUM_PROPERTY(stroke_style_enum, MaterialGPencilStyle, stroke_style)
	POINTER_PROPERTY(Image, MaterialGPencilStyle, stroke_image)
	ENUM_PROPERTY(fill_style_enum, MaterialGPencilStyle, fill_style)
	ENUM_PROPERTY(gradient_type_enum, MaterialGPencilStyle, gradient_type)
	POINTER_PROPERTY(Image, MaterialGPencilStyle, fill_image)
	BOOLEAN_PROPERTY(MaterialGPencilStyle, is_stroke_visible)
	BOOLEAN_PROPERTY(MaterialGPencilStyle, is_fill_visible)







	POINTER_PROPERTY(Mesh, Mesh, texture_mesh)

	POINTER_PROPERTY(MeshUVLoopLayer, Mesh, uv_layer_clone)
	INT_PROPERTY(Mesh, uv_layer_clone_index)
	POINTER_PROPERTY(MeshUVLoopLayer, Mesh, uv_layer_stencil)
	INT_PROPERTY(Mesh, uv_layer_stencil_index)










	BOOLEAN_PROPERTY(Mesh, use_auto_smooth)
	FLOAT_PROPERTY(Mesh, auto_smooth_angle)
	BOOLEAN_PROPERTY(Mesh, has_custom_normals)
	BOOLEAN_PROPERTY(Mesh, show_double_sided)
	POINTER_PROPERTY(Mesh, Mesh, texco_mesh)
	POINTER_PROPERTY(Key, Mesh, shape_keys)
	BOOLEAN_PROPERTY(Mesh, use_auto_texspace)
	BOOLEAN_PROPERTY(Mesh, use_mirror_x)
	BOOLEAN_PROPERTY(Mesh, use_mirror_topology)
	BOOLEAN_PROPERTY(Mesh, use_paint_mask)
	BOOLEAN_PROPERTY(Mesh, use_paint_mask_vertex)
	BOOLEAN_PROPERTY(Mesh, use_customdata_vertex_bevel)
	BOOLEAN_PROPERTY(Mesh, use_customdata_edge_bevel)
	BOOLEAN_PROPERTY(Mesh, use_customdata_edge_crease)
	INT_PROPERTY(Mesh, total_vert_sel)
	INT_PROPERTY(Mesh, total_edge_sel)
	INT_PROPERTY(Mesh, total_face_sel)
	BOOLEAN_PROPERTY(Mesh, is_editmode)
	POINTER_PROPERTY(AnimData, Mesh, animation_data)
	BOOLEAN_PROPERTY(Mesh, auto_texspace)
	FLOAT_ARRAY_PROPERTY(Mesh, 3, texspace_location)
	FLOAT_ARRAY_PROPERTY(Mesh, 3, texspace_size)


	inline void Mesh::transform(float matrix[16], bool shape_keys) {
		Mesh_transform((::Mesh *) this->ptr.data, matrix, shape_keys);
	}

	inline void Mesh::flip_normals() {
		Mesh_flip_normals((::Mesh *) this->ptr.data);
	}

	inline void Mesh::calc_normals() {
		Mesh_calc_normals((::Mesh *) this->ptr.data);
	}

	inline void Mesh::create_normals_split() {
		Mesh_create_normals_split((::Mesh *) this->ptr.data);
	}

	inline void Mesh::calc_normals_split() {
		Mesh_calc_normals_split((::Mesh *) this->ptr.data);
	}

	inline void Mesh::free_normals_split() {
		Mesh_free_normals_split((::Mesh *) this->ptr.data);
	}

	inline void Mesh::split_faces(bool free_loop_normals) {
		Mesh_split_faces((::Mesh *) this->ptr.data, free_loop_normals);
	}

	inline void Mesh::calc_tangents(const char * uvmap) {
		Mesh_calc_tangents((::Mesh *) this->ptr.data, NULL, uvmap);
	}

	inline void Mesh::free_tangents() {
		Mesh_free_tangents((::Mesh *) this->ptr.data);
	}

	inline void Mesh::calc_loop_triangles() {
		Mesh_calc_loop_triangles((::Mesh *) this->ptr.data);
	}

	inline void Mesh::calc_smooth_groups(bool use_bitflags, int *poly_groups_len, int **poly_groups, int *groups) {
		Mesh_calc_smooth_groups((::Mesh *) this->ptr.data, use_bitflags, poly_groups_len, poly_groups, groups);
	}

	inline void Mesh::normals_split_custom_set(int normals_len, float *normals) {
		Mesh_normals_split_custom_set((::Mesh *) this->ptr.data, NULL, normals_len, normals);
	}

	inline void Mesh::normals_split_custom_set_from_vertices(int normals_len, float *normals) {
		Mesh_normals_split_custom_set_from_vertices((::Mesh *) this->ptr.data, NULL, normals_len, normals);
	}

	inline void Mesh::update(Context C, bool calc_edges, bool calc_edges_loose, bool calc_loop_triangles) {
		Mesh_update((::Mesh *) this->ptr.data, (::bContext *) C.ptr.data, calc_edges, calc_edges_loose, calc_loop_triangles);
	}

	inline void Mesh::update_gpu_tag() {
		Mesh_update_gpu_tag((::Mesh *) this->ptr.data);
	}

	inline const char * Mesh::unit_test_compare(Mesh& mesh) {
		return Mesh_unit_test_compare((::Mesh *) this->ptr.data, (::Mesh *) mesh.ptr.data);
	}

	inline bool Mesh::validate(bool verbose, bool clean_customdata) {
		return Mesh_validate((::Mesh *) this->ptr.data, verbose, clean_customdata);
	}

	inline bool Mesh::validate_material_indices() {
		return Mesh_validate_material_indices((::Mesh *) this->ptr.data);
	}

	inline void Mesh::count_selected_items(int result[3]) {
		Mesh_count_selected_items((::Mesh *) this->ptr.data, result);
	}


	POINTER_PROPERTY(Struct, MeshVertices, rna_type)

	inline void MeshVertices::add(int count) {
		MeshVertices_add((::Mesh *) this->ptr.data, NULL, count);
	}


	POINTER_PROPERTY(Struct, MeshEdges, rna_type)

	inline void MeshEdges::add(int count) {
		MeshEdges_add((::Mesh *) this->ptr.data, NULL, count);
	}


	POINTER_PROPERTY(Struct, MeshLoops, rna_type)

	inline void MeshLoops::add(int count) {
		MeshLoops_add((::Mesh *) this->ptr.data, NULL, count);
	}


	POINTER_PROPERTY(Struct, MeshPolygons, rna_type)
	INT_PROPERTY(MeshPolygons, active)

	inline void MeshPolygons::add(int count) {
		MeshPolygons_add((::Mesh *) this->ptr.data, NULL, count);
	}


	POINTER_PROPERTY(Struct, MeshLoopTriangles, rna_type)


	POINTER_PROPERTY(Struct, UVLoopLayers, rna_type)
	POINTER_PROPERTY(MeshUVLoopLayer, UVLoopLayers, active)
	INT_PROPERTY(UVLoopLayers, active_index)

	inline MeshUVLoopLayer UVLoopLayers::create(const char * name, bool do_init) {
		PointerRNA result;
		result = UVLoopLayers_new((::Mesh *) this->ptr.data, name, do_init);
		return MeshUVLoopLayer(result);
	}

	inline void UVLoopLayers::remove(MeshUVLoopLayer& layer) {
		UVLoopLayers_remove((::Mesh *) this->ptr.data, NULL, (::CustomDataLayer *) layer.ptr.data);
	}


	POINTER_PROPERTY(Struct, LoopColors, rna_type)
	POINTER_PROPERTY(MeshLoopColorLayer, LoopColors, active)
	INT_PROPERTY(LoopColors, active_index)

	inline MeshLoopColorLayer LoopColors::create(const char * name, bool do_init) {
		PointerRNA result;
		result = LoopColors_new((::Mesh *) this->ptr.data, name, do_init);
		return MeshLoopColorLayer(result);
	}

	inline void LoopColors::remove(MeshLoopColorLayer& layer) {
		LoopColors_remove((::Mesh *) this->ptr.data, NULL, (::CustomDataLayer *) layer.ptr.data);
	}


	POINTER_PROPERTY(Struct, VertexFloatProperties, rna_type)

	inline MeshVertexFloatPropertyLayer VertexFloatProperties::create(const char * name) {
		PointerRNA result;
		result = VertexFloatProperties_new((::Mesh *) this->ptr.data, name);
		return MeshVertexFloatPropertyLayer(result);
	}


	POINTER_PROPERTY(Struct, VertexIntProperties, rna_type)

	inline MeshVertexIntPropertyLayer VertexIntProperties::create(const char * name) {
		PointerRNA result;
		result = VertexIntProperties_new((::Mesh *) this->ptr.data, name);
		return MeshVertexIntPropertyLayer(result);
	}


	POINTER_PROPERTY(Struct, VertexStringProperties, rna_type)

	inline MeshVertexStringPropertyLayer VertexStringProperties::create(const char * name) {
		PointerRNA result;
		result = VertexStringProperties_new((::Mesh *) this->ptr.data, name);
		return MeshVertexStringPropertyLayer(result);
	}


	POINTER_PROPERTY(Struct, PolygonFloatProperties, rna_type)

	inline MeshPolygonFloatPropertyLayer PolygonFloatProperties::create(const char * name) {
		PointerRNA result;
		result = PolygonFloatProperties_new((::Mesh *) this->ptr.data, name);
		return MeshPolygonFloatPropertyLayer(result);
	}


	POINTER_PROPERTY(Struct, PolygonIntProperties, rna_type)

	inline MeshPolygonIntPropertyLayer PolygonIntProperties::create(const char * name) {
		PointerRNA result;
		result = PolygonIntProperties_new((::Mesh *) this->ptr.data, name);
		return MeshPolygonIntPropertyLayer(result);
	}


	POINTER_PROPERTY(Struct, PolygonStringProperties, rna_type)

	inline MeshPolygonStringPropertyLayer PolygonStringProperties::create(const char * name) {
		PointerRNA result;
		result = PolygonStringProperties_new((::Mesh *) this->ptr.data, name);
		return MeshPolygonStringPropertyLayer(result);
	}


	POINTER_PROPERTY(Struct, MeshFaceMapLayers, rna_type)
	POINTER_PROPERTY(MeshFaceMapLayer, MeshFaceMapLayers, active)

	inline MeshFaceMapLayer MeshFaceMapLayers::create(const char * name) {
		PointerRNA result;
		result = MeshFaceMapLayers_new((::Mesh *) this->ptr.data, NULL, name);
		return MeshFaceMapLayer(result);
	}

	inline void MeshFaceMapLayers::remove(MeshFaceMapLayer& layer) {
		MeshFaceMapLayers_remove((::Mesh *) this->ptr.data, NULL, (::CustomDataLayer *) layer.ptr.data);
	}


	POINTER_PROPERTY(Struct, MeshSkinVertexLayer, rna_type)
	STRING_PROPERTY(MeshSkinVertexLayer, name)



	POINTER_PROPERTY(Struct, MeshSkinVertex, rna_type)
	FLOAT_ARRAY_PROPERTY(MeshSkinVertex, 2, radius)
	BOOLEAN_PROPERTY(MeshSkinVertex, use_root)
	BOOLEAN_PROPERTY(MeshSkinVertex, use_loose)


	POINTER_PROPERTY(Struct, MeshPaintMaskLayer, rna_type)



	POINTER_PROPERTY(Struct, MeshPaintMaskProperty, rna_type)
	FLOAT_PROPERTY(MeshPaintMaskProperty, value)


	POINTER_PROPERTY(Struct, MeshVertex, rna_type)
	FLOAT_ARRAY_PROPERTY(MeshVertex, 3, co)
	FLOAT_ARRAY_PROPERTY(MeshVertex, 3, normal)
	BOOLEAN_PROPERTY(MeshVertex, select)
	BOOLEAN_PROPERTY(MeshVertex, hide)
	FLOAT_PROPERTY(MeshVertex, bevel_weight)

	INT_PROPERTY(MeshVertex, index)
	FLOAT_ARRAY_PROPERTY(MeshVertex, 3, undeformed_co)


	POINTER_PROPERTY(Struct, VertexGroupElement, rna_type)
	INT_PROPERTY(VertexGroupElement, group)
	FLOAT_PROPERTY(VertexGroupElement, weight)


	POINTER_PROPERTY(Struct, MeshEdge, rna_type)
	INT_ARRAY_PROPERTY(MeshEdge, 2, vertices)
	FLOAT_PROPERTY(MeshEdge, crease)
	FLOAT_PROPERTY(MeshEdge, bevel_weight)
	BOOLEAN_PROPERTY(MeshEdge, select)
	BOOLEAN_PROPERTY(MeshEdge, hide)
	BOOLEAN_PROPERTY(MeshEdge, use_seam)
	BOOLEAN_PROPERTY(MeshEdge, use_edge_sharp)
	BOOLEAN_PROPERTY(MeshEdge, is_loose)
	BOOLEAN_PROPERTY(MeshEdge, use_freestyle_mark)
	INT_PROPERTY(MeshEdge, index)


	POINTER_PROPERTY(Struct, MeshLoopTriangle, rna_type)
	INT_ARRAY_PROPERTY(MeshLoopTriangle, 3, vertices)
	INT_ARRAY_PROPERTY(MeshLoopTriangle, 3, loops)
	INT_PROPERTY(MeshLoopTriangle, polygon_index)
	FLOAT_ARRAY_PROPERTY(MeshLoopTriangle, 3, normal)
	FLOAT_ARRAY_PROPERTY(MeshLoopTriangle, 9, split_normals)
	FLOAT_PROPERTY(MeshLoopTriangle, area)
	INT_PROPERTY(MeshLoopTriangle, index)
	INT_PROPERTY(MeshLoopTriangle, material_index)
	BOOLEAN_PROPERTY(MeshLoopTriangle, use_smooth)


	POINTER_PROPERTY(Struct, MeshLoop, rna_type)
	INT_PROPERTY(MeshLoop, vertex_index)
	INT_PROPERTY(MeshLoop, edge_index)
	INT_PROPERTY(MeshLoop, index)
	FLOAT_ARRAY_PROPERTY(MeshLoop, 3, normal)
	FLOAT_ARRAY_PROPERTY(MeshLoop, 3, tangent)
	FLOAT_PROPERTY(MeshLoop, bitangent_sign)
	FLOAT_ARRAY_PROPERTY(MeshLoop, 3, bitangent)


	POINTER_PROPERTY(Struct, MeshPolygon, rna_type)
	INT_ARRAY_PROPERTY(MeshPolygon, 3, vertices)
	INT_PROPERTY(MeshPolygon, loop_start)
	INT_PROPERTY(MeshPolygon, loop_total)
	INT_PROPERTY(MeshPolygon, material_index)
	BOOLEAN_PROPERTY(MeshPolygon, select)
	BOOLEAN_PROPERTY(MeshPolygon, hide)
	BOOLEAN_PROPERTY(MeshPolygon, use_smooth)
	BOOLEAN_PROPERTY(MeshPolygon, use_freestyle_mark)
	FLOAT_ARRAY_PROPERTY(MeshPolygon, 3, normal)
	FLOAT_ARRAY_PROPERTY(MeshPolygon, 3, center)
	FLOAT_PROPERTY(MeshPolygon, area)
	INT_PROPERTY(MeshPolygon, index)

	inline void MeshPolygon::flip() {
		MeshPolygon_flip((::ID *) ptr.id.data, (::MPoly *) this->ptr.data);
	}


	POINTER_PROPERTY(Struct, MeshUVLoopLayer, rna_type)

	STRING_PROPERTY(MeshUVLoopLayer, name)
	BOOLEAN_PROPERTY(MeshUVLoopLayer, active)
	BOOLEAN_PROPERTY(MeshUVLoopLayer, active_render)
	BOOLEAN_PROPERTY(MeshUVLoopLayer, active_clone)


	POINTER_PROPERTY(Struct, MeshUVLoop, rna_type)
	FLOAT_ARRAY_PROPERTY(MeshUVLoop, 2, uv)
	BOOLEAN_PROPERTY(MeshUVLoop, pin_uv)
	BOOLEAN_PROPERTY(MeshUVLoop, select)
	BOOLEAN_PROPERTY(MeshUVLoop, select_edge)


	POINTER_PROPERTY(Struct, MeshLoopColorLayer, rna_type)
	STRING_PROPERTY(MeshLoopColorLayer, name)
	BOOLEAN_PROPERTY(MeshLoopColorLayer, active)
	BOOLEAN_PROPERTY(MeshLoopColorLayer, active_render)



	POINTER_PROPERTY(Struct, MeshLoopColor, rna_type)
	FLOAT_ARRAY_PROPERTY(MeshLoopColor, 4, color)


	POINTER_PROPERTY(Struct, MeshVertexFloatPropertyLayer, rna_type)
	STRING_PROPERTY(MeshVertexFloatPropertyLayer, name)



	POINTER_PROPERTY(Struct, MeshVertexFloatProperty, rna_type)
	FLOAT_PROPERTY(MeshVertexFloatProperty, value)


	POINTER_PROPERTY(Struct, MeshPolygonFloatPropertyLayer, rna_type)
	STRING_PROPERTY(MeshPolygonFloatPropertyLayer, name)



	POINTER_PROPERTY(Struct, MeshPolygonFloatProperty, rna_type)
	FLOAT_PROPERTY(MeshPolygonFloatProperty, value)


	POINTER_PROPERTY(Struct, MeshVertexIntPropertyLayer, rna_type)
	STRING_PROPERTY(MeshVertexIntPropertyLayer, name)



	POINTER_PROPERTY(Struct, MeshVertexIntProperty, rna_type)
	INT_PROPERTY(MeshVertexIntProperty, value)


	POINTER_PROPERTY(Struct, MeshPolygonIntPropertyLayer, rna_type)
	STRING_PROPERTY(MeshPolygonIntPropertyLayer, name)



	POINTER_PROPERTY(Struct, MeshPolygonIntProperty, rna_type)
	INT_PROPERTY(MeshPolygonIntProperty, value)


	POINTER_PROPERTY(Struct, MeshVertexStringPropertyLayer, rna_type)
	STRING_PROPERTY(MeshVertexStringPropertyLayer, name)



	POINTER_PROPERTY(Struct, MeshVertexStringProperty, rna_type)
	STRING_PROPERTY(MeshVertexStringProperty, value)


	POINTER_PROPERTY(Struct, MeshPolygonStringPropertyLayer, rna_type)
	STRING_PROPERTY(MeshPolygonStringPropertyLayer, name)



	POINTER_PROPERTY(Struct, MeshPolygonStringProperty, rna_type)
	STRING_PROPERTY(MeshPolygonStringProperty, value)


	POINTER_PROPERTY(Struct, MeshFaceMapLayer, rna_type)
	STRING_PROPERTY(MeshFaceMapLayer, name)



	POINTER_PROPERTY(Struct, MeshFaceMap, rna_type)
	INT_PROPERTY(MeshFaceMap, value)


	POINTER_PROPERTY(Struct, MetaElement, rna_type)
	ENUM_PROPERTY(type_enum, MetaElement, type)
	FLOAT_ARRAY_PROPERTY(MetaElement, 3, co)
	FLOAT_ARRAY_PROPERTY(MetaElement, 4, rotation)
	FLOAT_PROPERTY(MetaElement, radius)
	FLOAT_PROPERTY(MetaElement, size_x)
	FLOAT_PROPERTY(MetaElement, size_y)
	FLOAT_PROPERTY(MetaElement, size_z)
	FLOAT_PROPERTY(MetaElement, stiffness)
	BOOLEAN_PROPERTY(MetaElement, use_negative)
	BOOLEAN_PROPERTY(MetaElement, hide)



	ENUM_PROPERTY(update_method_enum, MetaBall, update_method)
	FLOAT_PROPERTY(MetaBall, resolution)
	FLOAT_PROPERTY(MetaBall, render_resolution)
	FLOAT_PROPERTY(MetaBall, threshold)
	BOOLEAN_PROPERTY(MetaBall, use_auto_texspace)
	FLOAT_ARRAY_PROPERTY(MetaBall, 3, texspace_location)
	FLOAT_ARRAY_PROPERTY(MetaBall, 3, texspace_size)

	BOOLEAN_PROPERTY(MetaBall, is_editmode)
	POINTER_PROPERTY(AnimData, MetaBall, animation_data)

	inline void MetaBall::transform(float matrix[16]) {
		MetaBall_transform((::MetaBall *) this->ptr.data, matrix);
	}

	inline void MetaBall::update_gpu_tag() {
		MetaBall_update_gpu_tag((::MetaBall *) this->ptr.data);
	}


	POINTER_PROPERTY(Struct, MetaBallElements, rna_type)
	POINTER_PROPERTY(MetaElement, MetaBallElements, active)

	inline MetaElement MetaBallElements::create(int type) {
		PointerRNA result;
		::MetaElem *retdata = MetaBallElements_new((::MetaBall *) this->ptr.data, type);
		RNA_pointer_create((::ID *) ptr.id.data, &RNA_MetaElement, retdata, &result);
		return MetaElement(result);
	}

	inline void MetaBallElements::remove(MetaElement& element) {
		MetaBallElements_remove((::MetaBall *) this->ptr.data, NULL, (::PointerRNA *) &element.ptr);
	}

	inline void MetaBallElements::clear() {
		MetaBallElements_clear((::MetaBall *) this->ptr.data);
	}


	POINTER_PROPERTY(Struct, Modifier, rna_type)
	STRING_PROPERTY(Modifier, name)
	ENUM_PROPERTY(type_enum, Modifier, type)
	BOOLEAN_PROPERTY(Modifier, show_viewport)
	BOOLEAN_PROPERTY(Modifier, show_render)
	BOOLEAN_PROPERTY(Modifier, show_in_editmode)
	BOOLEAN_PROPERTY(Modifier, show_on_cage)
	BOOLEAN_PROPERTY(Modifier, show_expanded)
	BOOLEAN_PROPERTY(Modifier, use_apply_on_spline)


	ENUM_PROPERTY(uv_smooth_enum, SubsurfModifier, uv_smooth)
	INT_PROPERTY(SubsurfModifier, quality)
	ENUM_PROPERTY(subdivision_type_enum, SubsurfModifier, subdivision_type)
	INT_PROPERTY(SubsurfModifier, levels)
	INT_PROPERTY(SubsurfModifier, render_levels)
	BOOLEAN_PROPERTY(SubsurfModifier, show_only_control_edges)
	BOOLEAN_PROPERTY(SubsurfModifier, use_creases)


	POINTER_PROPERTY(Object, LatticeModifier, object)
	STRING_PROPERTY(LatticeModifier, vertex_group)
	FLOAT_PROPERTY(LatticeModifier, strength)


	POINTER_PROPERTY(Object, CurveModifier, object)
	STRING_PROPERTY(CurveModifier, vertex_group)
	ENUM_PROPERTY(deform_axis_enum, CurveModifier, deform_axis)


	FLOAT_PROPERTY(BuildModifier, frame_start)
	FLOAT_PROPERTY(BuildModifier, frame_duration)
	BOOLEAN_PROPERTY(BuildModifier, use_reverse)
	BOOLEAN_PROPERTY(BuildModifier, use_random_order)
	INT_PROPERTY(BuildModifier, seed)


	BOOLEAN_ARRAY_PROPERTY(MirrorModifier, 3, use_axis)
	BOOLEAN_ARRAY_PROPERTY(MirrorModifier, 3, use_bisect_axis)
	BOOLEAN_ARRAY_PROPERTY(MirrorModifier, 3, use_bisect_flip_axis)
	BOOLEAN_PROPERTY(MirrorModifier, use_clip)
	BOOLEAN_PROPERTY(MirrorModifier, use_mirror_vertex_groups)
	BOOLEAN_PROPERTY(MirrorModifier, use_mirror_merge)
	BOOLEAN_PROPERTY(MirrorModifier, use_mirror_u)
	BOOLEAN_PROPERTY(MirrorModifier, use_mirror_v)
	FLOAT_PROPERTY(MirrorModifier, mirror_offset_u)
	FLOAT_PROPERTY(MirrorModifier, mirror_offset_v)
	FLOAT_PROPERTY(MirrorModifier, offset_u)
	FLOAT_PROPERTY(MirrorModifier, offset_v)
	FLOAT_PROPERTY(MirrorModifier, merge_threshold)
	POINTER_PROPERTY(Object, MirrorModifier, mirror_object)


	ENUM_PROPERTY(decimate_type_enum, DecimateModifier, decimate_type)
	FLOAT_PROPERTY(DecimateModifier, ratio)
	INT_PROPERTY(DecimateModifier, iterations)
	FLOAT_PROPERTY(DecimateModifier, angle_limit)
	STRING_PROPERTY(DecimateModifier, vertex_group)
	BOOLEAN_PROPERTY(DecimateModifier, invert_vertex_group)
	BOOLEAN_PROPERTY(DecimateModifier, use_collapse_triangulate)
	BOOLEAN_PROPERTY(DecimateModifier, use_symmetry)
	ENUM_PROPERTY(symmetry_axis_enum, DecimateModifier, symmetry_axis)
	FLOAT_PROPERTY(DecimateModifier, vertex_group_factor)
	BOOLEAN_PROPERTY(DecimateModifier, use_dissolve_boundaries)
	ENUM_PROPERTY(delimit_enum, DecimateModifier, delimit)
	INT_PROPERTY(DecimateModifier, face_count)


	BOOLEAN_PROPERTY(WaveModifier, use_x)
	BOOLEAN_PROPERTY(WaveModifier, use_y)
	BOOLEAN_PROPERTY(WaveModifier, use_cyclic)
	BOOLEAN_PROPERTY(WaveModifier, use_normal)
	BOOLEAN_PROPERTY(WaveModifier, use_normal_x)
	BOOLEAN_PROPERTY(WaveModifier, use_normal_y)
	BOOLEAN_PROPERTY(WaveModifier, use_normal_z)
	FLOAT_PROPERTY(WaveModifier, time_offset)
	FLOAT_PROPERTY(WaveModifier, lifetime)
	FLOAT_PROPERTY(WaveModifier, damping_time)
	FLOAT_PROPERTY(WaveModifier, falloff_radius)
	FLOAT_PROPERTY(WaveModifier, start_position_x)
	FLOAT_PROPERTY(WaveModifier, start_position_y)
	POINTER_PROPERTY(Object, WaveModifier, start_position_object)
	STRING_PROPERTY(WaveModifier, vertex_group)
	FLOAT_PROPERTY(WaveModifier, speed)
	FLOAT_PROPERTY(WaveModifier, height)
	FLOAT_PROPERTY(WaveModifier, width)
	FLOAT_PROPERTY(WaveModifier, narrowness)
	POINTER_PROPERTY(Texture, WaveModifier, texture)
	ENUM_PROPERTY(texture_coords_enum, WaveModifier, texture_coords)
	STRING_PROPERTY(WaveModifier, uv_layer)
	POINTER_PROPERTY(Object, WaveModifier, texture_coords_object)


	POINTER_PROPERTY(Object, ArmatureModifier, object)
	BOOLEAN_PROPERTY(ArmatureModifier, use_bone_envelopes)
	BOOLEAN_PROPERTY(ArmatureModifier, use_vertex_groups)
	BOOLEAN_PROPERTY(ArmatureModifier, use_deform_preserve_volume)
	BOOLEAN_PROPERTY(ArmatureModifier, use_multi_modifier)
	STRING_PROPERTY(ArmatureModifier, vertex_group)
	BOOLEAN_PROPERTY(ArmatureModifier, invert_vertex_group)


	FLOAT_PROPERTY(HookModifier, strength)
	ENUM_PROPERTY(falloff_type_enum, HookModifier, falloff_type)
	FLOAT_PROPERTY(HookModifier, falloff_radius)
	POINTER_PROPERTY(CurveMapping, HookModifier, falloff_curve)
	FLOAT_ARRAY_PROPERTY(HookModifier, 3, center)
	FLOAT_ARRAY_PROPERTY(HookModifier, 16, matrix_inverse)
	POINTER_PROPERTY(Object, HookModifier, object)
	STRING_PROPERTY(HookModifier, subtarget)
	BOOLEAN_PROPERTY(HookModifier, use_falloff_uniform)
	STRING_PROPERTY(HookModifier, vertex_group)


	POINTER_PROPERTY(SoftBodySettings, SoftBodyModifier, settings)
	POINTER_PROPERTY(PointCache, SoftBodyModifier, point_cache)


	POINTER_PROPERTY(Object, BooleanModifier, object)
	ENUM_PROPERTY(operation_enum, BooleanModifier, operation)
	FLOAT_PROPERTY(BooleanModifier, double_threshold)
	ENUM_PROPERTY(debug_options_enum, BooleanModifier, debug_options)


	ENUM_PROPERTY(fit_type_enum, ArrayModifier, fit_type)
	INT_PROPERTY(ArrayModifier, count)
	FLOAT_PROPERTY(ArrayModifier, fit_length)
	POINTER_PROPERTY(Object, ArrayModifier, curve)
	BOOLEAN_PROPERTY(ArrayModifier, use_constant_offset)
	FLOAT_ARRAY_PROPERTY(ArrayModifier, 3, constant_offset_displace)
	BOOLEAN_PROPERTY(ArrayModifier, use_relative_offset)
	FLOAT_ARRAY_PROPERTY(ArrayModifier, 3, relative_offset_displace)
	BOOLEAN_PROPERTY(ArrayModifier, use_merge_vertices)
	BOOLEAN_PROPERTY(ArrayModifier, use_merge_vertices_cap)
	FLOAT_PROPERTY(ArrayModifier, merge_threshold)
	BOOLEAN_PROPERTY(ArrayModifier, use_object_offset)
	POINTER_PROPERTY(Object, ArrayModifier, offset_object)
	POINTER_PROPERTY(Object, ArrayModifier, start_cap)
	POINTER_PROPERTY(Object, ArrayModifier, end_cap)
	FLOAT_PROPERTY(ArrayModifier, offset_u)
	FLOAT_PROPERTY(ArrayModifier, offset_v)


	FLOAT_PROPERTY(EdgeSplitModifier, split_angle)
	BOOLEAN_PROPERTY(EdgeSplitModifier, use_edge_angle)
	BOOLEAN_PROPERTY(EdgeSplitModifier, use_edge_sharp)


	STRING_PROPERTY(DisplaceModifier, vertex_group)
	FLOAT_PROPERTY(DisplaceModifier, mid_level)
	FLOAT_PROPERTY(DisplaceModifier, strength)
	ENUM_PROPERTY(direction_enum, DisplaceModifier, direction)
	ENUM_PROPERTY(space_enum, DisplaceModifier, space)
	POINTER_PROPERTY(Texture, DisplaceModifier, texture)
	ENUM_PROPERTY(texture_coords_enum, DisplaceModifier, texture_coords)
	STRING_PROPERTY(DisplaceModifier, uv_layer)
	POINTER_PROPERTY(Object, DisplaceModifier, texture_coords_object)


	STRING_PROPERTY(UVProjectModifier, uv_layer)
	INT_PROPERTY(UVProjectModifier, projector_count)

	FLOAT_PROPERTY(UVProjectModifier, aspect_x)
	FLOAT_PROPERTY(UVProjectModifier, aspect_y)
	FLOAT_PROPERTY(UVProjectModifier, scale_x)
	FLOAT_PROPERTY(UVProjectModifier, scale_y)


	POINTER_PROPERTY(Struct, UVProjector, rna_type)
	POINTER_PROPERTY(Object, UVProjector, object)


	BOOLEAN_PROPERTY(SmoothModifier, use_x)
	BOOLEAN_PROPERTY(SmoothModifier, use_y)
	BOOLEAN_PROPERTY(SmoothModifier, use_z)
	FLOAT_PROPERTY(SmoothModifier, factor)
	INT_PROPERTY(SmoothModifier, iterations)
	STRING_PROPERTY(SmoothModifier, vertex_group)


	FLOAT_PROPERTY(CorrectiveSmoothModifier, factor)
	INT_PROPERTY(CorrectiveSmoothModifier, iterations)
	ENUM_PROPERTY(rest_source_enum, CorrectiveSmoothModifier, rest_source)
	ENUM_PROPERTY(smooth_type_enum, CorrectiveSmoothModifier, smooth_type)
	BOOLEAN_PROPERTY(CorrectiveSmoothModifier, invert_vertex_group)
	STRING_PROPERTY(CorrectiveSmoothModifier, vertex_group)
	BOOLEAN_PROPERTY(CorrectiveSmoothModifier, is_bind)
	BOOLEAN_PROPERTY(CorrectiveSmoothModifier, use_only_smooth)
	BOOLEAN_PROPERTY(CorrectiveSmoothModifier, use_pin_boundary)


	ENUM_PROPERTY(cast_type_enum, CastModifier, cast_type)
	POINTER_PROPERTY(Object, CastModifier, object)
	BOOLEAN_PROPERTY(CastModifier, use_x)
	BOOLEAN_PROPERTY(CastModifier, use_y)
	BOOLEAN_PROPERTY(CastModifier, use_z)
	BOOLEAN_PROPERTY(CastModifier, use_radius_as_size)
	BOOLEAN_PROPERTY(CastModifier, use_transform)
	FLOAT_PROPERTY(CastModifier, factor)
	FLOAT_PROPERTY(CastModifier, radius)
	FLOAT_PROPERTY(CastModifier, size)
	STRING_PROPERTY(CastModifier, vertex_group)


	POINTER_PROPERTY(Object, MeshDeformModifier, object)
	BOOLEAN_PROPERTY(MeshDeformModifier, is_bound)
	BOOLEAN_PROPERTY(MeshDeformModifier, invert_vertex_group)
	STRING_PROPERTY(MeshDeformModifier, vertex_group)
	INT_PROPERTY(MeshDeformModifier, precision)
	BOOLEAN_PROPERTY(MeshDeformModifier, use_dynamic_bind)


	POINTER_PROPERTY(ParticleSystem, ParticleSystemModifier, particle_system)


	POINTER_PROPERTY(Object, ParticleInstanceModifier, object)
	INT_PROPERTY(ParticleInstanceModifier, particle_system_index)
	POINTER_PROPERTY(ParticleSystem, ParticleInstanceModifier, particle_system)
	ENUM_PROPERTY(axis_enum, ParticleInstanceModifier, axis)
	ENUM_PROPERTY(space_enum, ParticleInstanceModifier, space)
	BOOLEAN_PROPERTY(ParticleInstanceModifier, use_normal)
	BOOLEAN_PROPERTY(ParticleInstanceModifier, use_children)
	BOOLEAN_PROPERTY(ParticleInstanceModifier, use_path)
	BOOLEAN_PROPERTY(ParticleInstanceModifier, show_unborn)
	BOOLEAN_PROPERTY(ParticleInstanceModifier, show_alive)
	BOOLEAN_PROPERTY(ParticleInstanceModifier, show_dead)
	BOOLEAN_PROPERTY(ParticleInstanceModifier, use_preserve_shape)
	BOOLEAN_PROPERTY(ParticleInstanceModifier, use_size)
	FLOAT_PROPERTY(ParticleInstanceModifier, position)
	FLOAT_PROPERTY(ParticleInstanceModifier, random_position)
	FLOAT_PROPERTY(ParticleInstanceModifier, rotation)
	FLOAT_PROPERTY(ParticleInstanceModifier, random_rotation)
	FLOAT_PROPERTY(ParticleInstanceModifier, particle_amount)
	FLOAT_PROPERTY(ParticleInstanceModifier, particle_offset)
	STRING_PROPERTY(ParticleInstanceModifier, index_layer_name)
	STRING_PROPERTY(ParticleInstanceModifier, value_layer_name)


	STRING_PROPERTY(ExplodeModifier, vertex_group)
	FLOAT_PROPERTY(ExplodeModifier, protect)
	BOOLEAN_PROPERTY(ExplodeModifier, use_edge_cut)
	BOOLEAN_PROPERTY(ExplodeModifier, show_unborn)
	BOOLEAN_PROPERTY(ExplodeModifier, show_alive)
	BOOLEAN_PROPERTY(ExplodeModifier, show_dead)
	BOOLEAN_PROPERTY(ExplodeModifier, use_size)
	STRING_PROPERTY(ExplodeModifier, particle_uv)


	POINTER_PROPERTY(ClothSettings, ClothModifier, settings)
	POINTER_PROPERTY(ClothCollisionSettings, ClothModifier, collision_settings)
	POINTER_PROPERTY(ClothSolverResult, ClothModifier, solver_result)
	POINTER_PROPERTY(PointCache, ClothModifier, point_cache)
	FLOAT_ARRAY_PROPERTY(ClothModifier, 3, hair_grid_min)
	FLOAT_ARRAY_PROPERTY(ClothModifier, 3, hair_grid_max)
	INT_ARRAY_PROPERTY(ClothModifier, 3, hair_grid_resolution)


	POINTER_PROPERTY(CollisionSettings, CollisionModifier, settings)


	FLOAT_PROPERTY(BevelModifier, width)
	FLOAT_PROPERTY(BevelModifier, width_pct)
	INT_PROPERTY(BevelModifier, segments)
	BOOLEAN_PROPERTY(BevelModifier, use_only_vertices)
	ENUM_PROPERTY(limit_method_enum, BevelModifier, limit_method)
	FLOAT_PROPERTY(BevelModifier, angle_limit)
	STRING_PROPERTY(BevelModifier, vertex_group)
	BOOLEAN_PROPERTY(BevelModifier, use_clamp_overlap)
	ENUM_PROPERTY(offset_type_enum, BevelModifier, offset_type)
	FLOAT_PROPERTY(BevelModifier, profile)
	INT_PROPERTY(BevelModifier, material)
	BOOLEAN_PROPERTY(BevelModifier, loop_slide)
	BOOLEAN_PROPERTY(BevelModifier, mark_seam)
	BOOLEAN_PROPERTY(BevelModifier, mark_sharp)
	BOOLEAN_PROPERTY(BevelModifier, harden_normals)
	ENUM_PROPERTY(face_strength_mode_enum, BevelModifier, face_strength_mode)
	ENUM_PROPERTY(miter_outer_enum, BevelModifier, miter_outer)
	ENUM_PROPERTY(miter_inner_enum, BevelModifier, miter_inner)
	FLOAT_PROPERTY(BevelModifier, spread)


	ENUM_PROPERTY(wrap_method_enum, ShrinkwrapModifier, wrap_method)
	ENUM_PROPERTY(wrap_mode_enum, ShrinkwrapModifier, wrap_mode)
	ENUM_PROPERTY(cull_face_enum, ShrinkwrapModifier, cull_face)
	POINTER_PROPERTY(Object, ShrinkwrapModifier, target)
	POINTER_PROPERTY(Object, ShrinkwrapModifier, auxiliary_target)
	STRING_PROPERTY(ShrinkwrapModifier, vertex_group)
	FLOAT_PROPERTY(ShrinkwrapModifier, offset)
	FLOAT_PROPERTY(ShrinkwrapModifier, project_limit)
	BOOLEAN_PROPERTY(ShrinkwrapModifier, use_project_x)
	BOOLEAN_PROPERTY(ShrinkwrapModifier, use_project_y)
	BOOLEAN_PROPERTY(ShrinkwrapModifier, use_project_z)
	INT_PROPERTY(ShrinkwrapModifier, subsurf_levels)
	BOOLEAN_PROPERTY(ShrinkwrapModifier, use_negative_direction)
	BOOLEAN_PROPERTY(ShrinkwrapModifier, use_positive_direction)
	BOOLEAN_PROPERTY(ShrinkwrapModifier, use_invert_cull)
	BOOLEAN_PROPERTY(ShrinkwrapModifier, invert_vertex_group)


	POINTER_PROPERTY(FluidSettings, FluidSimulationModifier, settings)


	ENUM_PROPERTY(mode_enum, MaskModifier, mode)
	POINTER_PROPERTY(Object, MaskModifier, armature)
	STRING_PROPERTY(MaskModifier, vertex_group)
	BOOLEAN_PROPERTY(MaskModifier, invert_vertex_group)
	FLOAT_PROPERTY(MaskModifier, threshold)


	ENUM_PROPERTY(deform_method_enum, SimpleDeformModifier, deform_method)
	STRING_PROPERTY(SimpleDeformModifier, vertex_group)
	ENUM_PROPERTY(deform_axis_enum, SimpleDeformModifier, deform_axis)
	POINTER_PROPERTY(Object, SimpleDeformModifier, origin)
	FLOAT_PROPERTY(SimpleDeformModifier, factor)
	FLOAT_PROPERTY(SimpleDeformModifier, angle)
	FLOAT_ARRAY_PROPERTY(SimpleDeformModifier, 2, limits)
	BOOLEAN_PROPERTY(SimpleDeformModifier, lock_x)
	BOOLEAN_PROPERTY(SimpleDeformModifier, lock_y)
	BOOLEAN_PROPERTY(SimpleDeformModifier, lock_z)
	BOOLEAN_PROPERTY(SimpleDeformModifier, invert_vertex_group)


	POINTER_PROPERTY(Object, WarpModifier, object_from)
	POINTER_PROPERTY(Object, WarpModifier, object_to)
	FLOAT_PROPERTY(WarpModifier, strength)
	ENUM_PROPERTY(falloff_type_enum, WarpModifier, falloff_type)
	FLOAT_PROPERTY(WarpModifier, falloff_radius)
	POINTER_PROPERTY(CurveMapping, WarpModifier, falloff_curve)
	BOOLEAN_PROPERTY(WarpModifier, use_volume_preserve)
	STRING_PROPERTY(WarpModifier, vertex_group)
	POINTER_PROPERTY(Texture, WarpModifier, texture)
	ENUM_PROPERTY(texture_coords_enum, WarpModifier, texture_coords)
	STRING_PROPERTY(WarpModifier, uv_layer)
	POINTER_PROPERTY(Object, WarpModifier, texture_coords_object)


	ENUM_PROPERTY(uv_smooth_enum, MultiresModifier, uv_smooth)
	INT_PROPERTY(MultiresModifier, quality)
	ENUM_PROPERTY(subdivision_type_enum, MultiresModifier, subdivision_type)
	INT_PROPERTY(MultiresModifier, levels)
	INT_PROPERTY(MultiresModifier, sculpt_levels)
	INT_PROPERTY(MultiresModifier, render_levels)
	INT_PROPERTY(MultiresModifier, total_levels)
	BOOLEAN_PROPERTY(MultiresModifier, is_external)
	STRING_PROPERTY(MultiresModifier, filepath)
	BOOLEAN_PROPERTY(MultiresModifier, show_only_control_edges)
	BOOLEAN_PROPERTY(MultiresModifier, use_creases)




	POINTER_PROPERTY(SmokeDomainSettings, SmokeModifier, domain_settings)
	POINTER_PROPERTY(SmokeFlowSettings, SmokeModifier, flow_settings)
	POINTER_PROPERTY(SmokeCollSettings, SmokeModifier, coll_settings)
	ENUM_PROPERTY(smoke_type_enum, SmokeModifier, smoke_type)


	FLOAT_PROPERTY(SolidifyModifier, thickness)
	FLOAT_PROPERTY(SolidifyModifier, thickness_clamp)
	FLOAT_PROPERTY(SolidifyModifier, thickness_vertex_group)
	FLOAT_PROPERTY(SolidifyModifier, offset)
	FLOAT_PROPERTY(SolidifyModifier, edge_crease_inner)
	FLOAT_PROPERTY(SolidifyModifier, edge_crease_outer)
	FLOAT_PROPERTY(SolidifyModifier, edge_crease_rim)
	INT_PROPERTY(SolidifyModifier, material_offset)
	INT_PROPERTY(SolidifyModifier, material_offset_rim)
	STRING_PROPERTY(SolidifyModifier, vertex_group)
	BOOLEAN_PROPERTY(SolidifyModifier, use_rim)
	BOOLEAN_PROPERTY(SolidifyModifier, use_even_offset)
	BOOLEAN_PROPERTY(SolidifyModifier, use_quality_normals)
	BOOLEAN_PROPERTY(SolidifyModifier, invert_vertex_group)
	BOOLEAN_PROPERTY(SolidifyModifier, use_flip_normals)
	BOOLEAN_PROPERTY(SolidifyModifier, use_rim_only)


	POINTER_PROPERTY(Object, ScrewModifier, object)
	INT_PROPERTY(ScrewModifier, steps)
	INT_PROPERTY(ScrewModifier, render_steps)
	INT_PROPERTY(ScrewModifier, iterations)
	ENUM_PROPERTY(axis_enum, ScrewModifier, axis)
	FLOAT_PROPERTY(ScrewModifier, angle)
	FLOAT_PROPERTY(ScrewModifier, screw_offset)
	FLOAT_PROPERTY(ScrewModifier, merge_threshold)
	BOOLEAN_PROPERTY(ScrewModifier, use_normal_flip)
	BOOLEAN_PROPERTY(ScrewModifier, use_normal_calculate)
	BOOLEAN_PROPERTY(ScrewModifier, use_object_screw_offset)
	BOOLEAN_PROPERTY(ScrewModifier, use_merge_vertices)
	BOOLEAN_PROPERTY(ScrewModifier, use_smooth_shade)
	BOOLEAN_PROPERTY(ScrewModifier, use_stretch_u)
	BOOLEAN_PROPERTY(ScrewModifier, use_stretch_v)


	ENUM_PROPERTY(axis_u_enum, UVWarpModifier, axis_u)
	ENUM_PROPERTY(axis_v_enum, UVWarpModifier, axis_v)
	FLOAT_ARRAY_PROPERTY(UVWarpModifier, 2, center)
	POINTER_PROPERTY(Object, UVWarpModifier, object_from)
	STRING_PROPERTY(UVWarpModifier, bone_from)
	POINTER_PROPERTY(Object, UVWarpModifier, object_to)
	STRING_PROPERTY(UVWarpModifier, bone_to)
	STRING_PROPERTY(UVWarpModifier, vertex_group)
	STRING_PROPERTY(UVWarpModifier, uv_layer)


	STRING_PROPERTY(VertexWeightEditModifier, vertex_group)
	ENUM_PROPERTY(falloff_type_enum, VertexWeightEditModifier, falloff_type)
	BOOLEAN_PROPERTY(VertexWeightEditModifier, use_add)
	BOOLEAN_PROPERTY(VertexWeightEditModifier, use_remove)
	FLOAT_PROPERTY(VertexWeightEditModifier, default_weight)
	POINTER_PROPERTY(CurveMapping, VertexWeightEditModifier, map_curve)
	FLOAT_PROPERTY(VertexWeightEditModifier, add_threshold)
	FLOAT_PROPERTY(VertexWeightEditModifier, remove_threshold)
	FLOAT_PROPERTY(VertexWeightEditModifier, mask_constant)
	STRING_PROPERTY(VertexWeightEditModifier, mask_vertex_group)
	POINTER_PROPERTY(Texture, VertexWeightEditModifier, mask_texture)
	ENUM_PROPERTY(mask_tex_use_channel_enum, VertexWeightEditModifier, mask_tex_use_channel)
	ENUM_PROPERTY(mask_tex_mapping_enum, VertexWeightEditModifier, mask_tex_mapping)
	STRING_PROPERTY(VertexWeightEditModifier, mask_tex_uv_layer)
	POINTER_PROPERTY(Object, VertexWeightEditModifier, mask_tex_map_object)


	STRING_PROPERTY(VertexWeightMixModifier, vertex_group_a)
	STRING_PROPERTY(VertexWeightMixModifier, vertex_group_b)
	FLOAT_PROPERTY(VertexWeightMixModifier, default_weight_a)
	FLOAT_PROPERTY(VertexWeightMixModifier, default_weight_b)
	ENUM_PROPERTY(mix_mode_enum, VertexWeightMixModifier, mix_mode)
	ENUM_PROPERTY(mix_set_enum, VertexWeightMixModifier, mix_set)
	FLOAT_PROPERTY(VertexWeightMixModifier, mask_constant)
	STRING_PROPERTY(VertexWeightMixModifier, mask_vertex_group)
	POINTER_PROPERTY(Texture, VertexWeightMixModifier, mask_texture)
	ENUM_PROPERTY(mask_tex_use_channel_enum, VertexWeightMixModifier, mask_tex_use_channel)
	ENUM_PROPERTY(mask_tex_mapping_enum, VertexWeightMixModifier, mask_tex_mapping)
	STRING_PROPERTY(VertexWeightMixModifier, mask_tex_uv_layer)
	POINTER_PROPERTY(Object, VertexWeightMixModifier, mask_tex_map_object)


	STRING_PROPERTY(VertexWeightProximityModifier, vertex_group)
	ENUM_PROPERTY(proximity_mode_enum, VertexWeightProximityModifier, proximity_mode)
	ENUM_PROPERTY(proximity_geometry_enum, VertexWeightProximityModifier, proximity_geometry)
	POINTER_PROPERTY(Object, VertexWeightProximityModifier, target)
	FLOAT_PROPERTY(VertexWeightProximityModifier, min_dist)
	FLOAT_PROPERTY(VertexWeightProximityModifier, max_dist)
	ENUM_PROPERTY(falloff_type_enum, VertexWeightProximityModifier, falloff_type)
	FLOAT_PROPERTY(VertexWeightProximityModifier, mask_constant)
	STRING_PROPERTY(VertexWeightProximityModifier, mask_vertex_group)
	POINTER_PROPERTY(Texture, VertexWeightProximityModifier, mask_texture)
	ENUM_PROPERTY(mask_tex_use_channel_enum, VertexWeightProximityModifier, mask_tex_use_channel)
	ENUM_PROPERTY(mask_tex_mapping_enum, VertexWeightProximityModifier, mask_tex_mapping)
	STRING_PROPERTY(VertexWeightProximityModifier, mask_tex_uv_layer)
	POINTER_PROPERTY(Object, VertexWeightProximityModifier, mask_tex_map_object)


	POINTER_PROPERTY(DynamicPaintCanvasSettings, DynamicPaintModifier, canvas_settings)
	POINTER_PROPERTY(DynamicPaintBrushSettings, DynamicPaintModifier, brush_settings)
	ENUM_PROPERTY(ui_type_enum, DynamicPaintModifier, ui_type)


	ENUM_PROPERTY(geometry_mode_enum, OceanModifier, geometry_mode)
	FLOAT_PROPERTY(OceanModifier, size)
	INT_PROPERTY(OceanModifier, repeat_x)
	INT_PROPERTY(OceanModifier, repeat_y)
	BOOLEAN_PROPERTY(OceanModifier, use_normals)
	BOOLEAN_PROPERTY(OceanModifier, use_foam)
	INT_PROPERTY(OceanModifier, resolution)
	INT_PROPERTY(OceanModifier, spatial_size)
	FLOAT_PROPERTY(OceanModifier, wind_velocity)
	FLOAT_PROPERTY(OceanModifier, damping)
	FLOAT_PROPERTY(OceanModifier, wave_scale_min)
	FLOAT_PROPERTY(OceanModifier, wave_alignment)
	FLOAT_PROPERTY(OceanModifier, wave_direction)
	FLOAT_PROPERTY(OceanModifier, wave_scale)
	FLOAT_PROPERTY(OceanModifier, depth)
	FLOAT_PROPERTY(OceanModifier, foam_coverage)
	FLOAT_PROPERTY(OceanModifier, bake_foam_fade)
	STRING_PROPERTY(OceanModifier, foam_layer_name)
	FLOAT_PROPERTY(OceanModifier, choppiness)
	FLOAT_PROPERTY(OceanModifier, time)
	INT_PROPERTY(OceanModifier, random_seed)
	INT_PROPERTY(OceanModifier, frame_start)
	INT_PROPERTY(OceanModifier, frame_end)
	BOOLEAN_PROPERTY(OceanModifier, is_cached)
	STRING_PROPERTY(OceanModifier, filepath)


	ENUM_PROPERTY(mode_enum, RemeshModifier, mode)
	FLOAT_PROPERTY(RemeshModifier, scale)
	FLOAT_PROPERTY(RemeshModifier, threshold)
	INT_PROPERTY(RemeshModifier, octree_depth)
	FLOAT_PROPERTY(RemeshModifier, sharpness)
	BOOLEAN_PROPERTY(RemeshModifier, use_remove_disconnected)
	BOOLEAN_PROPERTY(RemeshModifier, use_smooth_shade)


	FLOAT_PROPERTY(SkinModifier, branch_smoothing)
	BOOLEAN_PROPERTY(SkinModifier, use_smooth_shade)
	BOOLEAN_PROPERTY(SkinModifier, use_x_symmetry)
	BOOLEAN_PROPERTY(SkinModifier, use_y_symmetry)
	BOOLEAN_PROPERTY(SkinModifier, use_z_symmetry)


	BOOLEAN_PROPERTY(LaplacianSmoothModifier, use_x)
	BOOLEAN_PROPERTY(LaplacianSmoothModifier, use_y)
	BOOLEAN_PROPERTY(LaplacianSmoothModifier, use_z)
	BOOLEAN_PROPERTY(LaplacianSmoothModifier, use_volume_preserve)
	BOOLEAN_PROPERTY(LaplacianSmoothModifier, use_normalized)
	FLOAT_PROPERTY(LaplacianSmoothModifier, lambda_factor)
	FLOAT_PROPERTY(LaplacianSmoothModifier, lambda_border)
	INT_PROPERTY(LaplacianSmoothModifier, iterations)
	STRING_PROPERTY(LaplacianSmoothModifier, vertex_group)


	ENUM_PROPERTY(quad_method_enum, TriangulateModifier, quad_method)
	ENUM_PROPERTY(ngon_method_enum, TriangulateModifier, ngon_method)
	INT_PROPERTY(TriangulateModifier, min_vertices)
	BOOLEAN_PROPERTY(TriangulateModifier, keep_custom_normals)


	ENUM_PROPERTY(cache_format_enum, MeshCacheModifier, cache_format)
	ENUM_PROPERTY(interpolation_enum, MeshCacheModifier, interpolation)
	ENUM_PROPERTY(time_mode_enum, MeshCacheModifier, time_mode)
	ENUM_PROPERTY(play_mode_enum, MeshCacheModifier, play_mode)
	ENUM_PROPERTY(deform_mode_enum, MeshCacheModifier, deform_mode)
	STRING_PROPERTY(MeshCacheModifier, filepath)
	FLOAT_PROPERTY(MeshCacheModifier, factor)
	ENUM_PROPERTY(forward_axis_enum, MeshCacheModifier, forward_axis)
	ENUM_PROPERTY(up_axis_enum, MeshCacheModifier, up_axis)
	ENUM_PROPERTY(flip_axis_enum, MeshCacheModifier, flip_axis)
	FLOAT_PROPERTY(MeshCacheModifier, frame_start)
	FLOAT_PROPERTY(MeshCacheModifier, frame_scale)
	FLOAT_PROPERTY(MeshCacheModifier, eval_frame)
	FLOAT_PROPERTY(MeshCacheModifier, eval_time)
	FLOAT_PROPERTY(MeshCacheModifier, eval_factor)


	STRING_PROPERTY(LaplacianDeformModifier, vertex_group)
	INT_PROPERTY(LaplacianDeformModifier, iterations)
	BOOLEAN_PROPERTY(LaplacianDeformModifier, is_bind)


	FLOAT_PROPERTY(WireframeModifier, thickness)
	FLOAT_PROPERTY(WireframeModifier, thickness_vertex_group)
	FLOAT_PROPERTY(WireframeModifier, offset)
	BOOLEAN_PROPERTY(WireframeModifier, use_replace)
	BOOLEAN_PROPERTY(WireframeModifier, use_boundary)
	BOOLEAN_PROPERTY(WireframeModifier, use_even_offset)
	BOOLEAN_PROPERTY(WireframeModifier, use_relative_offset)
	BOOLEAN_PROPERTY(WireframeModifier, use_crease)
	FLOAT_PROPERTY(WireframeModifier, crease_weight)
	INT_PROPERTY(WireframeModifier, material_offset)
	STRING_PROPERTY(WireframeModifier, vertex_group)
	BOOLEAN_PROPERTY(WireframeModifier, invert_vertex_group)


	POINTER_PROPERTY(Object, DataTransferModifier, object)
	BOOLEAN_PROPERTY(DataTransferModifier, use_object_transform)
	BOOLEAN_PROPERTY(DataTransferModifier, use_vert_data)
	BOOLEAN_PROPERTY(DataTransferModifier, use_edge_data)
	BOOLEAN_PROPERTY(DataTransferModifier, use_loop_data)
	BOOLEAN_PROPERTY(DataTransferModifier, use_poly_data)
	ENUM_PROPERTY(data_types_verts_enum, DataTransferModifier, data_types_verts)
	ENUM_PROPERTY(data_types_edges_enum, DataTransferModifier, data_types_edges)
	ENUM_PROPERTY(data_types_loops_enum, DataTransferModifier, data_types_loops)
	ENUM_PROPERTY(data_types_polys_enum, DataTransferModifier, data_types_polys)
	ENUM_PROPERTY(vert_mapping_enum, DataTransferModifier, vert_mapping)
	ENUM_PROPERTY(edge_mapping_enum, DataTransferModifier, edge_mapping)
	ENUM_PROPERTY(loop_mapping_enum, DataTransferModifier, loop_mapping)
	ENUM_PROPERTY(poly_mapping_enum, DataTransferModifier, poly_mapping)
	BOOLEAN_PROPERTY(DataTransferModifier, use_max_distance)
	FLOAT_PROPERTY(DataTransferModifier, max_distance)
	FLOAT_PROPERTY(DataTransferModifier, ray_radius)
	FLOAT_PROPERTY(DataTransferModifier, islands_precision)
	ENUM_PROPERTY(layers_vgroup_select_src_enum, DataTransferModifier, layers_vgroup_select_src)
	ENUM_PROPERTY(layers_vcol_select_src_enum, DataTransferModifier, layers_vcol_select_src)
	ENUM_PROPERTY(layers_uv_select_src_enum, DataTransferModifier, layers_uv_select_src)
	ENUM_PROPERTY(layers_vgroup_select_dst_enum, DataTransferModifier, layers_vgroup_select_dst)
	ENUM_PROPERTY(layers_vcol_select_dst_enum, DataTransferModifier, layers_vcol_select_dst)
	ENUM_PROPERTY(layers_uv_select_dst_enum, DataTransferModifier, layers_uv_select_dst)
	ENUM_PROPERTY(mix_mode_enum, DataTransferModifier, mix_mode)
	FLOAT_PROPERTY(DataTransferModifier, mix_factor)
	STRING_PROPERTY(DataTransferModifier, vertex_group)
	BOOLEAN_PROPERTY(DataTransferModifier, invert_vertex_group)


	ENUM_PROPERTY(mode_enum, NormalEditModifier, mode)
	FLOAT_ARRAY_PROPERTY(NormalEditModifier, 3, offset)
	ENUM_PROPERTY(mix_mode_enum, NormalEditModifier, mix_mode)
	FLOAT_PROPERTY(NormalEditModifier, mix_factor)
	FLOAT_PROPERTY(NormalEditModifier, mix_limit)
	BOOLEAN_PROPERTY(NormalEditModifier, no_polynors_fix)
	STRING_PROPERTY(NormalEditModifier, vertex_group)
	BOOLEAN_PROPERTY(NormalEditModifier, invert_vertex_group)
	POINTER_PROPERTY(Object, NormalEditModifier, target)
	BOOLEAN_PROPERTY(NormalEditModifier, use_direction_parallel)


	POINTER_PROPERTY(CacheFile, MeshSequenceCacheModifier, cache_file)
	STRING_PROPERTY(MeshSequenceCacheModifier, object_path)
	ENUM_PROPERTY(read_data_enum, MeshSequenceCacheModifier, read_data)


	POINTER_PROPERTY(Object, SurfaceDeformModifier, target)
	FLOAT_PROPERTY(SurfaceDeformModifier, falloff)
	BOOLEAN_PROPERTY(SurfaceDeformModifier, is_bound)


	INT_PROPERTY(WeightedNormalModifier, weight)
	ENUM_PROPERTY(mode_enum, WeightedNormalModifier, mode)
	FLOAT_PROPERTY(WeightedNormalModifier, thresh)
	BOOLEAN_PROPERTY(WeightedNormalModifier, keep_sharp)
	STRING_PROPERTY(WeightedNormalModifier, vertex_group)
	BOOLEAN_PROPERTY(WeightedNormalModifier, invert_vertex_group)
	BOOLEAN_PROPERTY(WeightedNormalModifier, face_influence)


	POINTER_PROPERTY(Struct, GpencilModifier, rna_type)
	STRING_PROPERTY(GpencilModifier, name)
	ENUM_PROPERTY(type_enum, GpencilModifier, type)
	BOOLEAN_PROPERTY(GpencilModifier, show_viewport)
	BOOLEAN_PROPERTY(GpencilModifier, show_render)
	BOOLEAN_PROPERTY(GpencilModifier, show_in_editmode)
	BOOLEAN_PROPERTY(GpencilModifier, show_expanded)


	STRING_PROPERTY(NoiseGpencilModifier, layer)
	STRING_PROPERTY(NoiseGpencilModifier, vertex_group)
	FLOAT_PROPERTY(NoiseGpencilModifier, factor)
	BOOLEAN_PROPERTY(NoiseGpencilModifier, random)
	BOOLEAN_PROPERTY(NoiseGpencilModifier, use_edit_position)
	BOOLEAN_PROPERTY(NoiseGpencilModifier, use_edit_strength)
	BOOLEAN_PROPERTY(NoiseGpencilModifier, use_edit_thickness)
	BOOLEAN_PROPERTY(NoiseGpencilModifier, use_edit_uv)
	BOOLEAN_PROPERTY(NoiseGpencilModifier, full_stroke)
	BOOLEAN_PROPERTY(NoiseGpencilModifier, move_extreme)
	INT_PROPERTY(NoiseGpencilModifier, pass_index)
	INT_PROPERTY(NoiseGpencilModifier, step)
	BOOLEAN_PROPERTY(NoiseGpencilModifier, invert_layers)
	BOOLEAN_PROPERTY(NoiseGpencilModifier, invert_material_pass)
	BOOLEAN_PROPERTY(NoiseGpencilModifier, invert_vertex)
	INT_PROPERTY(NoiseGpencilModifier, layer_pass)
	BOOLEAN_PROPERTY(NoiseGpencilModifier, invert_layer_pass)


	STRING_PROPERTY(SmoothGpencilModifier, layer)
	STRING_PROPERTY(SmoothGpencilModifier, vertex_group)
	FLOAT_PROPERTY(SmoothGpencilModifier, factor)
	BOOLEAN_PROPERTY(SmoothGpencilModifier, use_edit_position)
	BOOLEAN_PROPERTY(SmoothGpencilModifier, use_edit_strength)
	BOOLEAN_PROPERTY(SmoothGpencilModifier, use_edit_thickness)
	BOOLEAN_PROPERTY(SmoothGpencilModifier, use_edit_uv)
	INT_PROPERTY(SmoothGpencilModifier, pass_index)
	INT_PROPERTY(SmoothGpencilModifier, step)
	BOOLEAN_PROPERTY(SmoothGpencilModifier, invert_layers)
	BOOLEAN_PROPERTY(SmoothGpencilModifier, invert_material_pass)
	BOOLEAN_PROPERTY(SmoothGpencilModifier, invert_vertex)
	INT_PROPERTY(SmoothGpencilModifier, layer_pass)
	BOOLEAN_PROPERTY(SmoothGpencilModifier, invert_layer_pass)


	STRING_PROPERTY(SubdivGpencilModifier, layer)
	INT_PROPERTY(SubdivGpencilModifier, level)
	BOOLEAN_PROPERTY(SubdivGpencilModifier, simple)
	INT_PROPERTY(SubdivGpencilModifier, pass_index)
	BOOLEAN_PROPERTY(SubdivGpencilModifier, invert_layers)
	BOOLEAN_PROPERTY(SubdivGpencilModifier, invert_material_pass)
	INT_PROPERTY(SubdivGpencilModifier, layer_pass)
	BOOLEAN_PROPERTY(SubdivGpencilModifier, invert_layer_pass)


	STRING_PROPERTY(SimplifyGpencilModifier, layer)
	FLOAT_PROPERTY(SimplifyGpencilModifier, factor)
	INT_PROPERTY(SimplifyGpencilModifier, pass_index)
	BOOLEAN_PROPERTY(SimplifyGpencilModifier, invert_layers)
	BOOLEAN_PROPERTY(SimplifyGpencilModifier, invert_material_pass)
	INT_PROPERTY(SimplifyGpencilModifier, layer_pass)
	BOOLEAN_PROPERTY(SimplifyGpencilModifier, invert_layer_pass)
	ENUM_PROPERTY(mode_enum, SimplifyGpencilModifier, mode)
	INT_PROPERTY(SimplifyGpencilModifier, step)


	STRING_PROPERTY(ThickGpencilModifier, layer)
	STRING_PROPERTY(ThickGpencilModifier, vertex_group)
	INT_PROPERTY(ThickGpencilModifier, thickness)
	INT_PROPERTY(ThickGpencilModifier, pass_index)
	BOOLEAN_PROPERTY(ThickGpencilModifier, invert_layers)
	BOOLEAN_PROPERTY(ThickGpencilModifier, invert_material_pass)
	BOOLEAN_PROPERTY(ThickGpencilModifier, invert_vertex)
	INT_PROPERTY(ThickGpencilModifier, layer_pass)
	BOOLEAN_PROPERTY(ThickGpencilModifier, invert_layer_pass)
	BOOLEAN_PROPERTY(ThickGpencilModifier, use_custom_curve)
	BOOLEAN_PROPERTY(ThickGpencilModifier, normalize_thickness)
	POINTER_PROPERTY(CurveMapping, ThickGpencilModifier, curve)


	STRING_PROPERTY(OffsetGpencilModifier, layer)
	STRING_PROPERTY(OffsetGpencilModifier, vertex_group)
	INT_PROPERTY(OffsetGpencilModifier, pass_index)
	BOOLEAN_PROPERTY(OffsetGpencilModifier, invert_layers)
	BOOLEAN_PROPERTY(OffsetGpencilModifier, invert_material_pass)
	BOOLEAN_PROPERTY(OffsetGpencilModifier, invert_vertex)
	INT_PROPERTY(OffsetGpencilModifier, layer_pass)
	BOOLEAN_PROPERTY(OffsetGpencilModifier, invert_layer_pass)
	FLOAT_ARRAY_PROPERTY(OffsetGpencilModifier, 3, location)
	FLOAT_ARRAY_PROPERTY(OffsetGpencilModifier, 3, rotation)
	FLOAT_ARRAY_PROPERTY(OffsetGpencilModifier, 3, scale)


	ENUM_PROPERTY(modify_color_enum, TintGpencilModifier, modify_color)
	STRING_PROPERTY(TintGpencilModifier, layer)
	FLOAT_ARRAY_PROPERTY(TintGpencilModifier, 3, color)
	FLOAT_PROPERTY(TintGpencilModifier, factor)
	BOOLEAN_PROPERTY(TintGpencilModifier, create_materials)
	INT_PROPERTY(TintGpencilModifier, pass_index)
	BOOLEAN_PROPERTY(TintGpencilModifier, invert_layers)
	BOOLEAN_PROPERTY(TintGpencilModifier, invert_material_pass)
	INT_PROPERTY(TintGpencilModifier, layer_pass)
	BOOLEAN_PROPERTY(TintGpencilModifier, invert_layer_pass)


	ENUM_PROPERTY(mode_enum, TimeGpencilModifier, mode)
	STRING_PROPERTY(TimeGpencilModifier, layer)
	BOOLEAN_PROPERTY(TimeGpencilModifier, invert_layers)
	INT_PROPERTY(TimeGpencilModifier, layer_pass)
	BOOLEAN_PROPERTY(TimeGpencilModifier, invert_layer_pass)
	INT_PROPERTY(TimeGpencilModifier, offset)
	FLOAT_PROPERTY(TimeGpencilModifier, frame_scale)
	INT_PROPERTY(TimeGpencilModifier, frame_start)
	INT_PROPERTY(TimeGpencilModifier, frame_end)
	BOOLEAN_PROPERTY(TimeGpencilModifier, use_keep_loop)
	BOOLEAN_PROPERTY(TimeGpencilModifier, use_custom_frame_range)


	ENUM_PROPERTY(modify_color_enum, ColorGpencilModifier, modify_color)
	STRING_PROPERTY(ColorGpencilModifier, layer)
	FLOAT_PROPERTY(ColorGpencilModifier, hue)
	FLOAT_PROPERTY(ColorGpencilModifier, saturation)
	FLOAT_PROPERTY(ColorGpencilModifier, value)
	BOOLEAN_PROPERTY(ColorGpencilModifier, create_materials)
	INT_PROPERTY(ColorGpencilModifier, pass_index)
	BOOLEAN_PROPERTY(ColorGpencilModifier, invert_layers)
	BOOLEAN_PROPERTY(ColorGpencilModifier, invert_material_pass)
	INT_PROPERTY(ColorGpencilModifier, layer_pass)
	BOOLEAN_PROPERTY(ColorGpencilModifier, invert_layer_pass)


	STRING_PROPERTY(ArrayGpencilModifier, layer)
	INT_PROPERTY(ArrayGpencilModifier, pass_index)
	INT_PROPERTY(ArrayGpencilModifier, count)
	POINTER_PROPERTY(Object, ArrayGpencilModifier, offset_object)
	FLOAT_ARRAY_PROPERTY(ArrayGpencilModifier, 3, offset)
	FLOAT_ARRAY_PROPERTY(ArrayGpencilModifier, 3, shift)
	FLOAT_ARRAY_PROPERTY(ArrayGpencilModifier, 3, rotation)
	FLOAT_ARRAY_PROPERTY(ArrayGpencilModifier, 3, scale)
	BOOLEAN_PROPERTY(ArrayGpencilModifier, random_rot)
	FLOAT_PROPERTY(ArrayGpencilModifier, rot_factor)
	BOOLEAN_PROPERTY(ArrayGpencilModifier, random_scale)
	FLOAT_PROPERTY(ArrayGpencilModifier, scale_factor)
	INT_PROPERTY(ArrayGpencilModifier, replace_material)
	BOOLEAN_PROPERTY(ArrayGpencilModifier, invert_layers)
	BOOLEAN_PROPERTY(ArrayGpencilModifier, invert_material_pass)
	INT_PROPERTY(ArrayGpencilModifier, layer_pass)
	BOOLEAN_PROPERTY(ArrayGpencilModifier, invert_layer_pass)
	BOOLEAN_PROPERTY(ArrayGpencilModifier, keep_on_top)


	ENUM_PROPERTY(mode_enum, BuildGpencilModifier, mode)
	ENUM_PROPERTY(transition_enum, BuildGpencilModifier, transition)
	FLOAT_PROPERTY(BuildGpencilModifier, start_delay)
	FLOAT_PROPERTY(BuildGpencilModifier, length)
	ENUM_PROPERTY(concurrent_time_alignment_enum, BuildGpencilModifier, concurrent_time_alignment)
	BOOLEAN_PROPERTY(BuildGpencilModifier, use_restrict_frame_range)
	FLOAT_PROPERTY(BuildGpencilModifier, frame_start)
	FLOAT_PROPERTY(BuildGpencilModifier, frame_end)
	STRING_PROPERTY(BuildGpencilModifier, layer)
	BOOLEAN_PROPERTY(BuildGpencilModifier, invert_layers)
	INT_PROPERTY(BuildGpencilModifier, layer_pass)
	BOOLEAN_PROPERTY(BuildGpencilModifier, invert_layer_pass)


	ENUM_PROPERTY(modify_color_enum, OpacityGpencilModifier, modify_color)
	STRING_PROPERTY(OpacityGpencilModifier, layer)
	STRING_PROPERTY(OpacityGpencilModifier, vertex_group)
	FLOAT_PROPERTY(OpacityGpencilModifier, factor)
	BOOLEAN_PROPERTY(OpacityGpencilModifier, create_materials)
	INT_PROPERTY(OpacityGpencilModifier, pass_index)
	BOOLEAN_PROPERTY(OpacityGpencilModifier, invert_layers)
	BOOLEAN_PROPERTY(OpacityGpencilModifier, invert_material_pass)
	BOOLEAN_PROPERTY(OpacityGpencilModifier, invert_vertex)
	INT_PROPERTY(OpacityGpencilModifier, layer_pass)
	BOOLEAN_PROPERTY(OpacityGpencilModifier, invert_layer_pass)


	STRING_PROPERTY(LatticeGpencilModifier, layer)
	STRING_PROPERTY(LatticeGpencilModifier, vertex_group)
	INT_PROPERTY(LatticeGpencilModifier, pass_index)
	BOOLEAN_PROPERTY(LatticeGpencilModifier, invert_layers)
	BOOLEAN_PROPERTY(LatticeGpencilModifier, invert_material_pass)
	BOOLEAN_PROPERTY(LatticeGpencilModifier, invert_vertex)
	INT_PROPERTY(LatticeGpencilModifier, layer_pass)
	BOOLEAN_PROPERTY(LatticeGpencilModifier, invert_layer_pass)
	POINTER_PROPERTY(Object, LatticeGpencilModifier, object)
	FLOAT_PROPERTY(LatticeGpencilModifier, strength)


	STRING_PROPERTY(MirrorGpencilModifier, layer)
	INT_PROPERTY(MirrorGpencilModifier, pass_index)
	BOOLEAN_PROPERTY(MirrorGpencilModifier, invert_layers)
	BOOLEAN_PROPERTY(MirrorGpencilModifier, invert_material_pass)
	INT_PROPERTY(MirrorGpencilModifier, layer_pass)
	BOOLEAN_PROPERTY(MirrorGpencilModifier, invert_layer_pass)
	POINTER_PROPERTY(Object, MirrorGpencilModifier, object)
	BOOLEAN_PROPERTY(MirrorGpencilModifier, use_clip)
	BOOLEAN_PROPERTY(MirrorGpencilModifier, x_axis)
	BOOLEAN_PROPERTY(MirrorGpencilModifier, y_axis)
	BOOLEAN_PROPERTY(MirrorGpencilModifier, z_axis)


	POINTER_PROPERTY(Object, HookGpencilModifier, object)
	STRING_PROPERTY(HookGpencilModifier, subtarget)
	STRING_PROPERTY(HookGpencilModifier, layer)
	STRING_PROPERTY(HookGpencilModifier, vertex_group)
	INT_PROPERTY(HookGpencilModifier, pass_index)
	BOOLEAN_PROPERTY(HookGpencilModifier, invert_layers)
	BOOLEAN_PROPERTY(HookGpencilModifier, invert_material_pass)
	BOOLEAN_PROPERTY(HookGpencilModifier, invert_vertex)
	INT_PROPERTY(HookGpencilModifier, layer_pass)
	BOOLEAN_PROPERTY(HookGpencilModifier, invert_layer_pass)
	FLOAT_PROPERTY(HookGpencilModifier, strength)
	ENUM_PROPERTY(falloff_type_enum, HookGpencilModifier, falloff_type)
	FLOAT_PROPERTY(HookGpencilModifier, falloff_radius)
	POINTER_PROPERTY(CurveMapping, HookGpencilModifier, falloff_curve)
	FLOAT_ARRAY_PROPERTY(HookGpencilModifier, 3, center)
	FLOAT_ARRAY_PROPERTY(HookGpencilModifier, 16, matrix_inverse)
	BOOLEAN_PROPERTY(HookGpencilModifier, use_falloff_uniform)


	POINTER_PROPERTY(Object, ArmatureGpencilModifier, object)
	BOOLEAN_PROPERTY(ArmatureGpencilModifier, use_bone_envelopes)
	BOOLEAN_PROPERTY(ArmatureGpencilModifier, use_vertex_groups)
	BOOLEAN_PROPERTY(ArmatureGpencilModifier, use_deform_preserve_volume)
	STRING_PROPERTY(ArmatureGpencilModifier, vertex_group)
	BOOLEAN_PROPERTY(ArmatureGpencilModifier, invert_vertex_group)


	POINTER_PROPERTY(Struct, ShaderFx, rna_type)
	STRING_PROPERTY(ShaderFx, name)
	ENUM_PROPERTY(type_enum, ShaderFx, type)
	BOOLEAN_PROPERTY(ShaderFx, show_viewport)
	BOOLEAN_PROPERTY(ShaderFx, show_render)
	BOOLEAN_PROPERTY(ShaderFx, show_in_editmode)
	BOOLEAN_PROPERTY(ShaderFx, show_expanded)


	INT_ARRAY_PROPERTY(ShaderFxBlur, 2, factor)
	INT_PROPERTY(ShaderFxBlur, samples)
	FLOAT_PROPERTY(ShaderFxBlur, coc)
	BOOLEAN_PROPERTY(ShaderFxBlur, use_dof_mode)


	FLOAT_PROPERTY(ShaderFxColorize, factor)
	FLOAT_ARRAY_PROPERTY(ShaderFxColorize, 4, low_color)
	FLOAT_ARRAY_PROPERTY(ShaderFxColorize, 4, high_color)
	ENUM_PROPERTY(mode_enum, ShaderFxColorize, mode)


	ENUM_PROPERTY(orientation_enum, ShaderFxWave, orientation)
	FLOAT_PROPERTY(ShaderFxWave, amplitude)
	FLOAT_PROPERTY(ShaderFxWave, period)
	FLOAT_PROPERTY(ShaderFxWave, phase)


	INT_ARRAY_PROPERTY(ShaderFxPixel, 2, size)
	FLOAT_ARRAY_PROPERTY(ShaderFxPixel, 4, color)
	BOOLEAN_PROPERTY(ShaderFxPixel, use_lines)


	INT_ARRAY_PROPERTY(ShaderFxRim, 2, offset)
	FLOAT_ARRAY_PROPERTY(ShaderFxRim, 3, rim_color)
	FLOAT_ARRAY_PROPERTY(ShaderFxRim, 3, mask_color)
	ENUM_PROPERTY(mode_enum, ShaderFxRim, mode)
	INT_ARRAY_PROPERTY(ShaderFxRim, 2, blur)
	INT_PROPERTY(ShaderFxRim, samples)


	POINTER_PROPERTY(Object, ShaderFxShadow, object)
	INT_ARRAY_PROPERTY(ShaderFxShadow, 2, offset)
	FLOAT_ARRAY_PROPERTY(ShaderFxShadow, 2, scale)
	FLOAT_ARRAY_PROPERTY(ShaderFxShadow, 4, shadow_color)
	ENUM_PROPERTY(orientation_enum, ShaderFxShadow, orientation)
	FLOAT_PROPERTY(ShaderFxShadow, amplitude)
	FLOAT_PROPERTY(ShaderFxShadow, period)
	FLOAT_PROPERTY(ShaderFxShadow, phase)
	FLOAT_PROPERTY(ShaderFxShadow, rotation)
	INT_ARRAY_PROPERTY(ShaderFxShadow, 2, blur)
	INT_PROPERTY(ShaderFxShadow, samples)
	BOOLEAN_PROPERTY(ShaderFxShadow, use_object)
	BOOLEAN_PROPERTY(ShaderFxShadow, use_wave)


	FLOAT_ARRAY_PROPERTY(ShaderFxGlow, 3, glow_color)
	FLOAT_ARRAY_PROPERTY(ShaderFxGlow, 3, select_color)
	ENUM_PROPERTY(mode_enum, ShaderFxGlow, mode)
	FLOAT_PROPERTY(ShaderFxGlow, threshold)
	INT_PROPERTY(ShaderFxGlow, radius)
	INT_PROPERTY(ShaderFxGlow, samples)
	BOOLEAN_PROPERTY(ShaderFxGlow, use_alpha_mode)


	INT_PROPERTY(ShaderFxSwirl, radius)
	FLOAT_PROPERTY(ShaderFxSwirl, angle)
	BOOLEAN_PROPERTY(ShaderFxSwirl, use_transparent)
	POINTER_PROPERTY(Object, ShaderFxSwirl, object)


	BOOLEAN_PROPERTY(ShaderFxFlip, flip_horizontal)
	BOOLEAN_PROPERTY(ShaderFxFlip, flip_vertical)


	FLOAT_PROPERTY(ShaderFxLight, energy)
	FLOAT_PROPERTY(ShaderFxLight, ambient)
	POINTER_PROPERTY(Object, ShaderFxLight, object)


	POINTER_PROPERTY(Struct, NlaTrack, rna_type)

	STRING_PROPERTY(NlaTrack, name)
	BOOLEAN_PROPERTY(NlaTrack, active)
	BOOLEAN_PROPERTY(NlaTrack, is_solo)
	BOOLEAN_PROPERTY(NlaTrack, select)
	BOOLEAN_PROPERTY(NlaTrack, mute)
	BOOLEAN_PROPERTY(NlaTrack, lock)


	POINTER_PROPERTY(Struct, NlaStrips, rna_type)

	inline NlaStrip NlaStrips::create(void *main, Context C, const char * name, int start, Action& action) {
		PointerRNA result;
		::NlaStrip *retdata = NlaStrips_new((::ID *) ptr.id.data, (::NlaTrack *) this->ptr.data, (::Main *) main, (::bContext *) C.ptr.data, NULL, name, start, (::bAction *) action.ptr.data);
		RNA_pointer_create((::ID *) ptr.id.data, &RNA_NlaStrip, retdata, &result);
		return NlaStrip(result);
	}

	inline void NlaStrips::remove(void *main, Context C, NlaStrip& strip) {
		NlaStrips_remove((::ID *) ptr.id.data, (::NlaTrack *) this->ptr.data, (::Main *) main, (::bContext *) C.ptr.data, NULL, (::PointerRNA *) &strip.ptr);
	}


	POINTER_PROPERTY(Struct, NlaStrip, rna_type)
	STRING_PROPERTY(NlaStrip, name)
	ENUM_PROPERTY(type_enum, NlaStrip, type)
	ENUM_PROPERTY(extrapolation_enum, NlaStrip, extrapolation)
	ENUM_PROPERTY(blend_type_enum, NlaStrip, blend_type)
	FLOAT_PROPERTY(NlaStrip, frame_start)
	FLOAT_PROPERTY(NlaStrip, frame_end)
	FLOAT_PROPERTY(NlaStrip, blend_in)
	FLOAT_PROPERTY(NlaStrip, blend_out)
	BOOLEAN_PROPERTY(NlaStrip, use_auto_blend)
	POINTER_PROPERTY(Action, NlaStrip, action)
	FLOAT_PROPERTY(NlaStrip, action_frame_start)
	FLOAT_PROPERTY(NlaStrip, action_frame_end)
	FLOAT_PROPERTY(NlaStrip, repeat)
	FLOAT_PROPERTY(NlaStrip, scale)



	FLOAT_PROPERTY(NlaStrip, influence)
	FLOAT_PROPERTY(NlaStrip, strip_time)
	BOOLEAN_PROPERTY(NlaStrip, use_animated_influence)
	BOOLEAN_PROPERTY(NlaStrip, use_animated_time)
	BOOLEAN_PROPERTY(NlaStrip, use_animated_time_cyclic)
	BOOLEAN_PROPERTY(NlaStrip, active)
	BOOLEAN_PROPERTY(NlaStrip, select)
	BOOLEAN_PROPERTY(NlaStrip, mute)
	BOOLEAN_PROPERTY(NlaStrip, use_reverse)
	BOOLEAN_PROPERTY(NlaStrip, use_sync_length)


	POINTER_PROPERTY(Struct, NlaStripFCurves, rna_type)

	inline FCurve NlaStripFCurves::find(const char * data_path, int index) {
		PointerRNA result;
		::FCurve *retdata = NlaStripFCurves_find((::NlaStrip *) this->ptr.data, NULL, data_path, index);
		RNA_pointer_create((::ID *) ptr.id.data, &RNA_FCurve, retdata, &result);
		return FCurve(result);
	}


	POINTER_PROPERTY(Struct, NodeSocket, rna_type)
	STRING_PROPERTY(NodeSocket, name)
	STRING_PROPERTY(NodeSocket, identifier)
	BOOLEAN_PROPERTY(NodeSocket, is_output)
	BOOLEAN_PROPERTY(NodeSocket, hide)
	BOOLEAN_PROPERTY(NodeSocket, enabled)
	INT_PROPERTY(NodeSocket, link_limit)
	BOOLEAN_PROPERTY(NodeSocket, is_linked)
	BOOLEAN_PROPERTY(NodeSocket, show_expanded)
	BOOLEAN_PROPERTY(NodeSocket, hide_value)
	POINTER_PROPERTY(Node, NodeSocket, node)
	ENUM_PROPERTY(type_enum, NodeSocket, type)
	ENUM_PROPERTY(draw_shape_enum, NodeSocket, draw_shape)
	STRING_PROPERTY(NodeSocket, bl_idname)


	POINTER_PROPERTY(Struct, NodeSocketInterface, rna_type)
	STRING_PROPERTY(NodeSocketInterface, name)
	STRING_PROPERTY(NodeSocketInterface, identifier)
	BOOLEAN_PROPERTY(NodeSocketInterface, is_output)
	STRING_PROPERTY(NodeSocketInterface, bl_socket_idname)


	POINTER_PROPERTY(Struct, Node, rna_type)
	ENUM_PROPERTY(type_enum, Node, type)
	FLOAT_ARRAY_PROPERTY(Node, 2, location)
	FLOAT_PROPERTY(Node, width)
	FLOAT_PROPERTY(Node, width_hidden)
	FLOAT_PROPERTY(Node, height)
	FLOAT_ARRAY_PROPERTY(Node, 2, dimensions)
	STRING_PROPERTY(Node, name)
	STRING_PROPERTY(Node, label)



	POINTER_PROPERTY(Node, Node, parent)
	BOOLEAN_PROPERTY(Node, use_custom_color)
	FLOAT_ARRAY_PROPERTY(Node, 3, color)
	BOOLEAN_PROPERTY(Node, select)
	BOOLEAN_PROPERTY(Node, show_options)
	BOOLEAN_PROPERTY(Node, show_preview)
	BOOLEAN_PROPERTY(Node, hide)
	BOOLEAN_PROPERTY(Node, mute)
	BOOLEAN_PROPERTY(Node, show_texture)
	STRING_PROPERTY(Node, bl_idname)
	STRING_PROPERTY(Node, bl_label)
	STRING_PROPERTY(Node, bl_description)
	ENUM_PROPERTY(bl_icon_enum, Node, bl_icon)
	ENUM_PROPERTY(bl_static_type_enum, Node, bl_static_type)
	FLOAT_PROPERTY(Node, bl_width_default)
	FLOAT_PROPERTY(Node, bl_width_min)
	FLOAT_PROPERTY(Node, bl_width_max)
	FLOAT_PROPERTY(Node, bl_height_default)
	FLOAT_PROPERTY(Node, bl_height_min)
	FLOAT_PROPERTY(Node, bl_height_max)

	inline void Node::socket_value_update(Context& context) {
		Node_socket_value_update((::ID *) ptr.id.data, (::bNode *) this->ptr.data, (::bContext *) context.ptr.data);
	}

	inline bool Node::is_registered_node_type() {
		return Node_is_registered_node_type(this->ptr.type);
	}


	POINTER_PROPERTY(Struct, NodeInputs, rna_type)

	inline NodeSocket NodeInputs::create(void *main, const char * type, const char * name, const char * identifier) {
		PointerRNA result;
		::bNodeSocket *retdata = NodeInputs_new((::ID *) ptr.id.data, (::bNode *) this->ptr.data, (::Main *) main, NULL, type, name, identifier);
		RNA_pointer_create((::ID *) ptr.id.data, &RNA_NodeSocket, retdata, &result);
		return NodeSocket(result);
	}

	inline void NodeInputs::remove(void *main, NodeSocket& socket) {
		NodeInputs_remove((::ID *) ptr.id.data, (::bNode *) this->ptr.data, (::Main *) main, NULL, (::bNodeSocket *) socket.ptr.data);
	}

	inline void NodeInputs::clear(void *main) {
		NodeInputs_clear((::ID *) ptr.id.data, (::bNode *) this->ptr.data, (::Main *) main);
	}

	inline void NodeInputs::move(void *main, int from_index, int to_index) {
		NodeInputs_move((::ID *) ptr.id.data, (::bNode *) this->ptr.data, (::Main *) main, from_index, to_index);
	}


	POINTER_PROPERTY(Struct, NodeOutputs, rna_type)

	inline NodeSocket NodeOutputs::create(void *main, const char * type, const char * name, const char * identifier) {
		PointerRNA result;
		::bNodeSocket *retdata = NodeOutputs_new((::ID *) ptr.id.data, (::bNode *) this->ptr.data, (::Main *) main, NULL, type, name, identifier);
		RNA_pointer_create((::ID *) ptr.id.data, &RNA_NodeSocket, retdata, &result);
		return NodeSocket(result);
	}

	inline void NodeOutputs::remove(void *main, NodeSocket& socket) {
		NodeOutputs_remove((::ID *) ptr.id.data, (::bNode *) this->ptr.data, (::Main *) main, NULL, (::bNodeSocket *) socket.ptr.data);
	}

	inline void NodeOutputs::clear(void *main) {
		NodeOutputs_clear((::ID *) ptr.id.data, (::bNode *) this->ptr.data, (::Main *) main);
	}

	inline void NodeOutputs::move(void *main, int from_index, int to_index) {
		NodeOutputs_move((::ID *) ptr.id.data, (::bNode *) this->ptr.data, (::Main *) main, from_index, to_index);
	}


	POINTER_PROPERTY(Struct, NodeLink, rna_type)
	BOOLEAN_PROPERTY(NodeLink, is_valid)
	POINTER_PROPERTY(Node, NodeLink, from_node)
	POINTER_PROPERTY(Node, NodeLink, to_node)
	POINTER_PROPERTY(NodeSocket, NodeLink, from_socket)
	POINTER_PROPERTY(NodeSocket, NodeLink, to_socket)
	BOOLEAN_PROPERTY(NodeLink, is_hidden)


	POINTER_PROPERTY(Struct, NodeInternalSocketTemplate, rna_type)
	STRING_PROPERTY(NodeInternalSocketTemplate, name)
	STRING_PROPERTY(NodeInternalSocketTemplate, identifier)
	ENUM_PROPERTY(type_enum, NodeInternalSocketTemplate, type)



	inline bool NodeInternal::poll(NodeTree& node_tree) {
		return NodeInternal_poll(this->ptr.type, (::bNodeTree *) node_tree.ptr.data);
	}

	inline bool NodeInternal::poll_instance(NodeTree& node_tree) {
		return NodeInternal_poll_instance((::bNode *) this->ptr.data, (::bNodeTree *) node_tree.ptr.data);
	}

	inline void NodeInternal::update() {
		NodeInternal_update((::ID *) ptr.id.data, (::bNode *) this->ptr.data);
	}

	inline void NodeInternal::draw_buttons(Context& context, UILayout& layout) {
		NodeInternal_draw_buttons((::ID *) ptr.id.data, (::bNode *) this->ptr.data, (::bContext *) context.ptr.data, (::uiLayout *) layout.ptr.data);
	}

	inline void NodeInternal::draw_buttons_ext(Context& context, UILayout& layout) {
		NodeInternal_draw_buttons_ext((::ID *) ptr.id.data, (::bNode *) this->ptr.data, (::bContext *) context.ptr.data, (::uiLayout *) layout.ptr.data);
	}





	inline void CompositorNode::tag_need_exec() {
		CompositorNode_tag_need_exec((::bNode *) this->ptr.data);
	}




	FLOAT_ARRAY_PROPERTY(NodeTree, 2, view_center)
	POINTER_PROPERTY(AnimData, NodeTree, animation_data)


	POINTER_PROPERTY(GreasePencil, NodeTree, grease_pencil)
	ENUM_PROPERTY(type_enum, NodeTree, type)

	INT_PROPERTY(NodeTree, active_input)

	INT_PROPERTY(NodeTree, active_output)
	STRING_PROPERTY(NodeTree, bl_idname)
	STRING_PROPERTY(NodeTree, bl_label)
	STRING_PROPERTY(NodeTree, bl_description)
	ENUM_PROPERTY(bl_icon_enum, NodeTree, bl_icon)

	inline void NodeTree::interface_update(Context& context) {
		NodeTree_interface_update((::bNodeTree *) this->ptr.data, (::bContext *) context.ptr.data);
	}


	POINTER_PROPERTY(Struct, Nodes, rna_type)
	POINTER_PROPERTY(Node, Nodes, active)

	inline Node Nodes::create(Context C, const char * type) {
		PointerRNA result;
		::bNode *retdata = Nodes_new((::bNodeTree *) this->ptr.data, (::bContext *) C.ptr.data, NULL, type);
		RNA_pointer_create((::ID *) ptr.id.data, &RNA_Node, retdata, &result);
		return Node(result);
	}

	inline void Nodes::remove(void *main, Node& node) {
		Nodes_remove((::bNodeTree *) this->ptr.data, (::Main *) main, NULL, (::PointerRNA *) &node.ptr);
	}

	inline void Nodes::clear(void *main) {
		Nodes_clear((::bNodeTree *) this->ptr.data, (::Main *) main, NULL);
	}


	POINTER_PROPERTY(Struct, NodeLinks, rna_type)

	inline NodeLink NodeLinks::create(void *main, NodeSocket& input, NodeSocket& output, bool verify_limits) {
		PointerRNA result;
		::bNodeLink *retdata = NodeLinks_new((::bNodeTree *) this->ptr.data, (::Main *) main, NULL, (::bNodeSocket *) input.ptr.data, (::bNodeSocket *) output.ptr.data, verify_limits);
		RNA_pointer_create((::ID *) ptr.id.data, &RNA_NodeLink, retdata, &result);
		return NodeLink(result);
	}

	inline void NodeLinks::remove(void *main, NodeLink& link) {
		NodeLinks_remove((::bNodeTree *) this->ptr.data, (::Main *) main, NULL, (::PointerRNA *) &link.ptr);
	}

	inline void NodeLinks::clear(void *main) {
		NodeLinks_clear((::bNodeTree *) this->ptr.data, (::Main *) main, NULL);
	}


	POINTER_PROPERTY(Struct, NodeTreeInputs, rna_type)

	inline NodeSocketInterface NodeTreeInputs::create(void *main, const char * type, const char * name) {
		PointerRNA result;
		::bNodeSocket *retdata = NodeTreeInputs_new((::bNodeTree *) this->ptr.data, (::Main *) main, NULL, type, name);
		RNA_pointer_create((::ID *) ptr.id.data, &RNA_NodeSocketInterface, retdata, &result);
		return NodeSocketInterface(result);
	}

	inline void NodeTreeInputs::remove(void *main, NodeSocketInterface& socket) {
		NodeTreeInputs_remove((::bNodeTree *) this->ptr.data, (::Main *) main, NULL, (::bNodeSocket *) socket.ptr.data);
	}

	inline void NodeTreeInputs::clear(void *main) {
		NodeTreeInputs_clear((::bNodeTree *) this->ptr.data, (::Main *) main, NULL);
	}

	inline void NodeTreeInputs::move(void *main, int from_index, int to_index) {
		NodeTreeInputs_move((::bNodeTree *) this->ptr.data, (::Main *) main, from_index, to_index);
	}


	POINTER_PROPERTY(Struct, NodeTreeOutputs, rna_type)

	inline NodeSocketInterface NodeTreeOutputs::create(void *main, const char * type, const char * name) {
		PointerRNA result;
		::bNodeSocket *retdata = NodeTreeOutputs_new((::bNodeTree *) this->ptr.data, (::Main *) main, NULL, type, name);
		RNA_pointer_create((::ID *) ptr.id.data, &RNA_NodeSocketInterface, retdata, &result);
		return NodeSocketInterface(result);
	}

	inline void NodeTreeOutputs::remove(void *main, NodeSocketInterface& socket) {
		NodeTreeOutputs_remove((::bNodeTree *) this->ptr.data, (::Main *) main, NULL, (::bNodeSocket *) socket.ptr.data);
	}

	inline void NodeTreeOutputs::clear(void *main) {
		NodeTreeOutputs_clear((::bNodeTree *) this->ptr.data, (::Main *) main, NULL);
	}

	inline void NodeTreeOutputs::move(void *main, int from_index, int to_index) {
		NodeTreeOutputs_move((::bNodeTree *) this->ptr.data, (::Main *) main, from_index, to_index);
	}



	inline void NodeSocketStandard::draw(Context& context, UILayout& layout, Node& node, const char * text) {
		NodeSocketStandard_draw((::ID *) ptr.id.data, (::bNodeSocket *) this->ptr.data, (::bContext *) context.ptr.data, (::uiLayout *) layout.ptr.data, (::PointerRNA *) node.ptr.data, text);
	}

	inline void NodeSocketStandard::draw_color(Context& context, Node& node, float color[4]) {
		NodeSocketStandard_draw_color((::ID *) ptr.id.data, (::bNodeSocket *) this->ptr.data, (::bContext *) context.ptr.data, (::PointerRNA *) node.ptr.data, color);
	}


	ENUM_PROPERTY(type_enum, NodeSocketInterfaceStandard, type)

	inline void NodeSocketInterfaceStandard::draw(Context& context, UILayout& layout) {
		NodeSocketInterfaceStandard_draw((::ID *) ptr.id.data, (::bNodeSocket *) this->ptr.data, (::bContext *) context.ptr.data, (::uiLayout *) layout.ptr.data);
	}

	inline void NodeSocketInterfaceStandard::draw_color(Context& context, float color[4]) {
		NodeSocketInterfaceStandard_draw_color((::ID *) ptr.id.data, (::bNodeSocket *) this->ptr.data, (::bContext *) context.ptr.data, color);
	}


	FLOAT_PROPERTY(NodeSocketFloat, default_value)


	FLOAT_PROPERTY(NodeSocketInterfaceFloat, default_value)
	FLOAT_PROPERTY(NodeSocketInterfaceFloat, min_value)
	FLOAT_PROPERTY(NodeSocketInterfaceFloat, max_value)


	FLOAT_PROPERTY(NodeSocketFloatUnsigned, default_value)


	FLOAT_PROPERTY(NodeSocketInterfaceFloatUnsigned, default_value)
	FLOAT_PROPERTY(NodeSocketInterfaceFloatUnsigned, min_value)
	FLOAT_PROPERTY(NodeSocketInterfaceFloatUnsigned, max_value)


	FLOAT_PROPERTY(NodeSocketFloatPercentage, default_value)


	FLOAT_PROPERTY(NodeSocketInterfaceFloatPercentage, default_value)
	FLOAT_PROPERTY(NodeSocketInterfaceFloatPercentage, min_value)
	FLOAT_PROPERTY(NodeSocketInterfaceFloatPercentage, max_value)


	FLOAT_PROPERTY(NodeSocketFloatFactor, default_value)


	FLOAT_PROPERTY(NodeSocketInterfaceFloatFactor, default_value)
	FLOAT_PROPERTY(NodeSocketInterfaceFloatFactor, min_value)
	FLOAT_PROPERTY(NodeSocketInterfaceFloatFactor, max_value)


	FLOAT_PROPERTY(NodeSocketFloatAngle, default_value)


	FLOAT_PROPERTY(NodeSocketInterfaceFloatAngle, default_value)
	FLOAT_PROPERTY(NodeSocketInterfaceFloatAngle, min_value)
	FLOAT_PROPERTY(NodeSocketInterfaceFloatAngle, max_value)


	FLOAT_PROPERTY(NodeSocketFloatTime, default_value)


	FLOAT_PROPERTY(NodeSocketInterfaceFloatTime, default_value)
	FLOAT_PROPERTY(NodeSocketInterfaceFloatTime, min_value)
	FLOAT_PROPERTY(NodeSocketInterfaceFloatTime, max_value)


	INT_PROPERTY(NodeSocketInt, default_value)


	INT_PROPERTY(NodeSocketInterfaceInt, default_value)
	INT_PROPERTY(NodeSocketInterfaceInt, min_value)
	INT_PROPERTY(NodeSocketInterfaceInt, max_value)


	INT_PROPERTY(NodeSocketIntUnsigned, default_value)


	INT_PROPERTY(NodeSocketInterfaceIntUnsigned, default_value)
	INT_PROPERTY(NodeSocketInterfaceIntUnsigned, min_value)
	INT_PROPERTY(NodeSocketInterfaceIntUnsigned, max_value)


	INT_PROPERTY(NodeSocketIntPercentage, default_value)


	INT_PROPERTY(NodeSocketInterfaceIntPercentage, default_value)
	INT_PROPERTY(NodeSocketInterfaceIntPercentage, min_value)
	INT_PROPERTY(NodeSocketInterfaceIntPercentage, max_value)


	INT_PROPERTY(NodeSocketIntFactor, default_value)


	INT_PROPERTY(NodeSocketInterfaceIntFactor, default_value)
	INT_PROPERTY(NodeSocketInterfaceIntFactor, min_value)
	INT_PROPERTY(NodeSocketInterfaceIntFactor, max_value)


	BOOLEAN_PROPERTY(NodeSocketBool, default_value)


	BOOLEAN_PROPERTY(NodeSocketInterfaceBool, default_value)


	FLOAT_ARRAY_PROPERTY(NodeSocketVector, 3, default_value)


	FLOAT_ARRAY_PROPERTY(NodeSocketInterfaceVector, 3, default_value)
	FLOAT_PROPERTY(NodeSocketInterfaceVector, min_value)
	FLOAT_PROPERTY(NodeSocketInterfaceVector, max_value)


	FLOAT_ARRAY_PROPERTY(NodeSocketVectorTranslation, 3, default_value)


	FLOAT_ARRAY_PROPERTY(NodeSocketInterfaceVectorTranslation, 3, default_value)
	FLOAT_PROPERTY(NodeSocketInterfaceVectorTranslation, min_value)
	FLOAT_PROPERTY(NodeSocketInterfaceVectorTranslation, max_value)


	FLOAT_ARRAY_PROPERTY(NodeSocketVectorDirection, 3, default_value)


	FLOAT_ARRAY_PROPERTY(NodeSocketInterfaceVectorDirection, 3, default_value)
	FLOAT_PROPERTY(NodeSocketInterfaceVectorDirection, min_value)
	FLOAT_PROPERTY(NodeSocketInterfaceVectorDirection, max_value)


	FLOAT_ARRAY_PROPERTY(NodeSocketVectorVelocity, 3, default_value)


	FLOAT_ARRAY_PROPERTY(NodeSocketInterfaceVectorVelocity, 3, default_value)
	FLOAT_PROPERTY(NodeSocketInterfaceVectorVelocity, min_value)
	FLOAT_PROPERTY(NodeSocketInterfaceVectorVelocity, max_value)


	FLOAT_ARRAY_PROPERTY(NodeSocketVectorAcceleration, 3, default_value)


	FLOAT_ARRAY_PROPERTY(NodeSocketInterfaceVectorAcceleration, 3, default_value)
	FLOAT_PROPERTY(NodeSocketInterfaceVectorAcceleration, min_value)
	FLOAT_PROPERTY(NodeSocketInterfaceVectorAcceleration, max_value)


	FLOAT_ARRAY_PROPERTY(NodeSocketVectorEuler, 3, default_value)


	FLOAT_ARRAY_PROPERTY(NodeSocketInterfaceVectorEuler, 3, default_value)
	FLOAT_PROPERTY(NodeSocketInterfaceVectorEuler, min_value)
	FLOAT_PROPERTY(NodeSocketInterfaceVectorEuler, max_value)


	FLOAT_ARRAY_PROPERTY(NodeSocketVectorXYZ, 3, default_value)


	FLOAT_ARRAY_PROPERTY(NodeSocketInterfaceVectorXYZ, 3, default_value)
	FLOAT_PROPERTY(NodeSocketInterfaceVectorXYZ, min_value)
	FLOAT_PROPERTY(NodeSocketInterfaceVectorXYZ, max_value)


	FLOAT_ARRAY_PROPERTY(NodeSocketColor, 4, default_value)


	FLOAT_ARRAY_PROPERTY(NodeSocketInterfaceColor, 4, default_value)


	STRING_PROPERTY(NodeSocketString, default_value)


	STRING_PROPERTY(NodeSocketInterfaceString, default_value)








	ENUM_PROPERTY(render_quality_enum, CompositorNodeTree, render_quality)
	ENUM_PROPERTY(edit_quality_enum, CompositorNodeTree, edit_quality)
	ENUM_PROPERTY(chunk_size_enum, CompositorNodeTree, chunk_size)
	BOOLEAN_PROPERTY(CompositorNodeTree, use_opencl)
	BOOLEAN_PROPERTY(CompositorNodeTree, use_groupnode_buffer)
	BOOLEAN_PROPERTY(CompositorNodeTree, use_two_pass)
	BOOLEAN_PROPERTY(CompositorNodeTree, use_viewer_border)



	inline ShaderNode ShaderNodeTree::get_output_node(int target) {
		PointerRNA result;
		::bNode *retdata = ShaderNodeTree_get_output_node((::bNodeTree *) this->ptr.data, target);
		RNA_pointer_create((::ID *) ptr.id.data, &RNA_ShaderNode, retdata, &result);
		return ShaderNode(result);
	}




	POINTER_PROPERTY(Text, NodeFrame, text)
	BOOLEAN_PROPERTY(NodeFrame, shrink)
	INT_PROPERTY(NodeFrame, label_size)

	inline bool NodeFrame::is_registered_node_type() {
		return NodeFrame_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate NodeFrame::input_template(int index) {
		PointerRNA result;
		result = NodeFrame_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate NodeFrame::output_template(int index) {
		PointerRNA result;
		result = NodeFrame_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	POINTER_PROPERTY(NodeTree, NodeGroup, node_tree)

	inline bool NodeGroup::is_registered_node_type() {
		return NodeGroup_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate NodeGroup::input_template(int index) {
		PointerRNA result;
		result = NodeGroup_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate NodeGroup::output_template(int index) {
		PointerRNA result;
		result = NodeGroup_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool NodeGroupInput::is_registered_node_type() {
		return NodeGroupInput_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate NodeGroupInput::input_template(int index) {
		PointerRNA result;
		result = NodeGroupInput_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate NodeGroupInput::output_template(int index) {
		PointerRNA result;
		result = NodeGroupInput_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	BOOLEAN_PROPERTY(NodeGroupOutput, is_active_output)

	inline bool NodeGroupOutput::is_registered_node_type() {
		return NodeGroupOutput_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate NodeGroupOutput::input_template(int index) {
		PointerRNA result;
		result = NodeGroupOutput_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate NodeGroupOutput::output_template(int index) {
		PointerRNA result;
		result = NodeGroupOutput_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool NodeReroute::is_registered_node_type() {
		return NodeReroute_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate NodeReroute::input_template(int index) {
		PointerRNA result;
		result = NodeReroute_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate NodeReroute::output_template(int index) {
		PointerRNA result;
		result = NodeReroute_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool ShaderNodeRGB::is_registered_node_type() {
		return ShaderNodeRGB_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeRGB::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeRGB_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeRGB::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeRGB_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool ShaderNodeValue::is_registered_node_type() {
		return ShaderNodeValue_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeValue::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeValue_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeValue::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeValue_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	ENUM_PROPERTY(blend_type_enum, ShaderNodeMixRGB, blend_type)
	BOOLEAN_PROPERTY(ShaderNodeMixRGB, use_alpha)
	BOOLEAN_PROPERTY(ShaderNodeMixRGB, use_clamp)

	inline bool ShaderNodeMixRGB::is_registered_node_type() {
		return ShaderNodeMixRGB_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeMixRGB::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeMixRGB_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeMixRGB::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeMixRGB_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	POINTER_PROPERTY(ColorRamp, ShaderNodeValToRGB, color_ramp)

	inline bool ShaderNodeValToRGB::is_registered_node_type() {
		return ShaderNodeValToRGB_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeValToRGB::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeValToRGB_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeValToRGB::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeValToRGB_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool ShaderNodeRGBToBW::is_registered_node_type() {
		return ShaderNodeRGBToBW_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeRGBToBW::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeRGBToBW_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeRGBToBW::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeRGBToBW_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool ShaderNodeShaderToRGB::is_registered_node_type() {
		return ShaderNodeShaderToRGB_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeShaderToRGB::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeShaderToRGB_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeShaderToRGB::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeShaderToRGB_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool ShaderNodeNormal::is_registered_node_type() {
		return ShaderNodeNormal_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeNormal::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeNormal_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeNormal::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeNormal_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool ShaderNodeGamma::is_registered_node_type() {
		return ShaderNodeGamma_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeGamma::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeGamma_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeGamma::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeGamma_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool ShaderNodeBrightContrast::is_registered_node_type() {
		return ShaderNodeBrightContrast_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeBrightContrast::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeBrightContrast_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeBrightContrast::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeBrightContrast_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	ENUM_PROPERTY(vector_type_enum, ShaderNodeMapping, vector_type)
	FLOAT_ARRAY_PROPERTY(ShaderNodeMapping, 3, translation)
	FLOAT_ARRAY_PROPERTY(ShaderNodeMapping, 3, rotation)
	FLOAT_ARRAY_PROPERTY(ShaderNodeMapping, 3, scale)
	FLOAT_ARRAY_PROPERTY(ShaderNodeMapping, 3, min)
	FLOAT_ARRAY_PROPERTY(ShaderNodeMapping, 3, max)
	BOOLEAN_PROPERTY(ShaderNodeMapping, use_min)
	BOOLEAN_PROPERTY(ShaderNodeMapping, use_max)

	inline bool ShaderNodeMapping::is_registered_node_type() {
		return ShaderNodeMapping_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeMapping::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeMapping_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeMapping::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeMapping_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	POINTER_PROPERTY(CurveMapping, ShaderNodeVectorCurve, mapping)

	inline bool ShaderNodeVectorCurve::is_registered_node_type() {
		return ShaderNodeVectorCurve_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeVectorCurve::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeVectorCurve_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeVectorCurve::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeVectorCurve_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	POINTER_PROPERTY(CurveMapping, ShaderNodeRGBCurve, mapping)

	inline bool ShaderNodeRGBCurve::is_registered_node_type() {
		return ShaderNodeRGBCurve_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeRGBCurve::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeRGBCurve_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeRGBCurve::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeRGBCurve_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool ShaderNodeCameraData::is_registered_node_type() {
		return ShaderNodeCameraData_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeCameraData::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeCameraData_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeCameraData::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeCameraData_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	ENUM_PROPERTY(operation_enum, ShaderNodeMath, operation)
	BOOLEAN_PROPERTY(ShaderNodeMath, use_clamp)

	inline bool ShaderNodeMath::is_registered_node_type() {
		return ShaderNodeMath_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeMath::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeMath_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeMath::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeMath_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	ENUM_PROPERTY(operation_enum, ShaderNodeVectorMath, operation)

	inline bool ShaderNodeVectorMath::is_registered_node_type() {
		return ShaderNodeVectorMath_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeVectorMath::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeVectorMath_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeVectorMath::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeVectorMath_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool ShaderNodeSqueeze::is_registered_node_type() {
		return ShaderNodeSqueeze_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeSqueeze::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeSqueeze_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeSqueeze::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeSqueeze_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool ShaderNodeInvert::is_registered_node_type() {
		return ShaderNodeInvert_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeInvert::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeInvert_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeInvert::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeInvert_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool ShaderNodeSeparateRGB::is_registered_node_type() {
		return ShaderNodeSeparateRGB_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeSeparateRGB::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeSeparateRGB_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeSeparateRGB::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeSeparateRGB_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool ShaderNodeCombineRGB::is_registered_node_type() {
		return ShaderNodeCombineRGB_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeCombineRGB::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeCombineRGB_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeCombineRGB::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeCombineRGB_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool ShaderNodeHueSaturation::is_registered_node_type() {
		return ShaderNodeHueSaturation_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeHueSaturation::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeHueSaturation_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeHueSaturation::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeHueSaturation_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	BOOLEAN_PROPERTY(ShaderNodeOutputMaterial, is_active_output)
	ENUM_PROPERTY(target_enum, ShaderNodeOutputMaterial, target)

	inline bool ShaderNodeOutputMaterial::is_registered_node_type() {
		return ShaderNodeOutputMaterial_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeOutputMaterial::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeOutputMaterial_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeOutputMaterial::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeOutputMaterial_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool ShaderNodeEeveeSpecular::is_registered_node_type() {
		return ShaderNodeEeveeSpecular_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeEeveeSpecular::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeEeveeSpecular_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeEeveeSpecular::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeEeveeSpecular_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	BOOLEAN_PROPERTY(ShaderNodeOutputLight, is_active_output)
	ENUM_PROPERTY(target_enum, ShaderNodeOutputLight, target)

	inline bool ShaderNodeOutputLight::is_registered_node_type() {
		return ShaderNodeOutputLight_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeOutputLight::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeOutputLight_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeOutputLight::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeOutputLight_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	BOOLEAN_PROPERTY(ShaderNodeOutputWorld, is_active_output)
	ENUM_PROPERTY(target_enum, ShaderNodeOutputWorld, target)

	inline bool ShaderNodeOutputWorld::is_registered_node_type() {
		return ShaderNodeOutputWorld_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeOutputWorld::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeOutputWorld_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeOutputWorld::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeOutputWorld_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	BOOLEAN_PROPERTY(ShaderNodeOutputLineStyle, is_active_output)
	ENUM_PROPERTY(target_enum, ShaderNodeOutputLineStyle, target)
	ENUM_PROPERTY(blend_type_enum, ShaderNodeOutputLineStyle, blend_type)
	BOOLEAN_PROPERTY(ShaderNodeOutputLineStyle, use_alpha)
	BOOLEAN_PROPERTY(ShaderNodeOutputLineStyle, use_clamp)

	inline bool ShaderNodeOutputLineStyle::is_registered_node_type() {
		return ShaderNodeOutputLineStyle_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeOutputLineStyle::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeOutputLineStyle_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeOutputLineStyle::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeOutputLineStyle_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool ShaderNodeFresnel::is_registered_node_type() {
		return ShaderNodeFresnel_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeFresnel::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeFresnel_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeFresnel::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeFresnel_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool ShaderNodeLayerWeight::is_registered_node_type() {
		return ShaderNodeLayerWeight_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeLayerWeight::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeLayerWeight_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeLayerWeight::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeLayerWeight_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool ShaderNodeMixShader::is_registered_node_type() {
		return ShaderNodeMixShader_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeMixShader::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeMixShader_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeMixShader::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeMixShader_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool ShaderNodeAddShader::is_registered_node_type() {
		return ShaderNodeAddShader_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeAddShader::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeAddShader_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeAddShader::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeAddShader_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	STRING_PROPERTY(ShaderNodeAttribute, attribute_name)

	inline bool ShaderNodeAttribute::is_registered_node_type() {
		return ShaderNodeAttribute_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeAttribute::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeAttribute_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeAttribute::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeAttribute_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	INT_PROPERTY(ShaderNodeAmbientOcclusion, samples)
	BOOLEAN_PROPERTY(ShaderNodeAmbientOcclusion, inside)
	BOOLEAN_PROPERTY(ShaderNodeAmbientOcclusion, only_local)

	inline bool ShaderNodeAmbientOcclusion::is_registered_node_type() {
		return ShaderNodeAmbientOcclusion_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeAmbientOcclusion::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeAmbientOcclusion_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeAmbientOcclusion::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeAmbientOcclusion_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool ShaderNodeBackground::is_registered_node_type() {
		return ShaderNodeBackground_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeBackground::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeBackground_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeBackground::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeBackground_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool ShaderNodeHoldout::is_registered_node_type() {
		return ShaderNodeHoldout_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeHoldout::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeHoldout_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeHoldout::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeHoldout_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	ENUM_PROPERTY(distribution_enum, ShaderNodeBsdfAnisotropic, distribution)

	inline bool ShaderNodeBsdfAnisotropic::is_registered_node_type() {
		return ShaderNodeBsdfAnisotropic_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeBsdfAnisotropic::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeBsdfAnisotropic_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeBsdfAnisotropic::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeBsdfAnisotropic_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool ShaderNodeBsdfDiffuse::is_registered_node_type() {
		return ShaderNodeBsdfDiffuse_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeBsdfDiffuse::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeBsdfDiffuse_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeBsdfDiffuse::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeBsdfDiffuse_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	ENUM_PROPERTY(distribution_enum, ShaderNodeBsdfPrincipled, distribution)
	ENUM_PROPERTY(subsurface_method_enum, ShaderNodeBsdfPrincipled, subsurface_method)

	inline bool ShaderNodeBsdfPrincipled::is_registered_node_type() {
		return ShaderNodeBsdfPrincipled_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeBsdfPrincipled::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeBsdfPrincipled_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeBsdfPrincipled::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeBsdfPrincipled_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	ENUM_PROPERTY(distribution_enum, ShaderNodeBsdfGlossy, distribution)

	inline bool ShaderNodeBsdfGlossy::is_registered_node_type() {
		return ShaderNodeBsdfGlossy_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeBsdfGlossy::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeBsdfGlossy_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeBsdfGlossy::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeBsdfGlossy_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	ENUM_PROPERTY(distribution_enum, ShaderNodeBsdfGlass, distribution)

	inline bool ShaderNodeBsdfGlass::is_registered_node_type() {
		return ShaderNodeBsdfGlass_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeBsdfGlass::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeBsdfGlass_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeBsdfGlass::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeBsdfGlass_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	ENUM_PROPERTY(distribution_enum, ShaderNodeBsdfRefraction, distribution)

	inline bool ShaderNodeBsdfRefraction::is_registered_node_type() {
		return ShaderNodeBsdfRefraction_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeBsdfRefraction::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeBsdfRefraction_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeBsdfRefraction::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeBsdfRefraction_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool ShaderNodeBsdfTranslucent::is_registered_node_type() {
		return ShaderNodeBsdfTranslucent_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeBsdfTranslucent::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeBsdfTranslucent_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeBsdfTranslucent::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeBsdfTranslucent_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool ShaderNodeBsdfTransparent::is_registered_node_type() {
		return ShaderNodeBsdfTransparent_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeBsdfTransparent::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeBsdfTransparent_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeBsdfTransparent::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeBsdfTransparent_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool ShaderNodeBsdfVelvet::is_registered_node_type() {
		return ShaderNodeBsdfVelvet_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeBsdfVelvet::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeBsdfVelvet_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeBsdfVelvet::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeBsdfVelvet_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	ENUM_PROPERTY(component_enum, ShaderNodeBsdfToon, component)

	inline bool ShaderNodeBsdfToon::is_registered_node_type() {
		return ShaderNodeBsdfToon_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeBsdfToon::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeBsdfToon_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeBsdfToon::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeBsdfToon_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	ENUM_PROPERTY(component_enum, ShaderNodeBsdfHair, component)

	inline bool ShaderNodeBsdfHair::is_registered_node_type() {
		return ShaderNodeBsdfHair_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeBsdfHair::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeBsdfHair_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeBsdfHair::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeBsdfHair_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	ENUM_PROPERTY(parametrization_enum, ShaderNodeBsdfHairPrincipled, parametrization)

	inline bool ShaderNodeBsdfHairPrincipled::is_registered_node_type() {
		return ShaderNodeBsdfHairPrincipled_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeBsdfHairPrincipled::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeBsdfHairPrincipled_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeBsdfHairPrincipled::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeBsdfHairPrincipled_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	ENUM_PROPERTY(falloff_enum, ShaderNodeSubsurfaceScattering, falloff)

	inline bool ShaderNodeSubsurfaceScattering::is_registered_node_type() {
		return ShaderNodeSubsurfaceScattering_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeSubsurfaceScattering::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeSubsurfaceScattering_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeSubsurfaceScattering::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeSubsurfaceScattering_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool ShaderNodeVolumeAbsorption::is_registered_node_type() {
		return ShaderNodeVolumeAbsorption_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeVolumeAbsorption::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeVolumeAbsorption_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeVolumeAbsorption::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeVolumeAbsorption_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool ShaderNodeVolumeScatter::is_registered_node_type() {
		return ShaderNodeVolumeScatter_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeVolumeScatter::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeVolumeScatter_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeVolumeScatter::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeVolumeScatter_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool ShaderNodeVolumePrincipled::is_registered_node_type() {
		return ShaderNodeVolumePrincipled_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeVolumePrincipled::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeVolumePrincipled_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeVolumePrincipled::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeVolumePrincipled_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool ShaderNodeEmission::is_registered_node_type() {
		return ShaderNodeEmission_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeEmission::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeEmission_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeEmission::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeEmission_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool ShaderNodeNewGeometry::is_registered_node_type() {
		return ShaderNodeNewGeometry_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeNewGeometry::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeNewGeometry_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeNewGeometry::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeNewGeometry_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool ShaderNodeLightPath::is_registered_node_type() {
		return ShaderNodeLightPath_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeLightPath::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeLightPath_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeLightPath::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeLightPath_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool ShaderNodeLightFalloff::is_registered_node_type() {
		return ShaderNodeLightFalloff_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeLightFalloff::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeLightFalloff_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeLightFalloff::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeLightFalloff_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool ShaderNodeObjectInfo::is_registered_node_type() {
		return ShaderNodeObjectInfo_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeObjectInfo::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeObjectInfo_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeObjectInfo::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeObjectInfo_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool ShaderNodeParticleInfo::is_registered_node_type() {
		return ShaderNodeParticleInfo_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeParticleInfo::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeParticleInfo_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeParticleInfo::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeParticleInfo_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool ShaderNodeHairInfo::is_registered_node_type() {
		return ShaderNodeHairInfo_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeHairInfo::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeHairInfo_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeHairInfo::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeHairInfo_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	BOOLEAN_PROPERTY(ShaderNodeWireframe, use_pixel_size)

	inline bool ShaderNodeWireframe::is_registered_node_type() {
		return ShaderNodeWireframe_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeWireframe::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeWireframe_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeWireframe::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeWireframe_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool ShaderNodeWavelength::is_registered_node_type() {
		return ShaderNodeWavelength_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeWavelength::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeWavelength_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeWavelength::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeWavelength_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool ShaderNodeBlackbody::is_registered_node_type() {
		return ShaderNodeBlackbody_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeBlackbody::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeBlackbody_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeBlackbody::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeBlackbody_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	BOOLEAN_PROPERTY(ShaderNodeBump, invert)

	inline bool ShaderNodeBump::is_registered_node_type() {
		return ShaderNodeBump_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeBump::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeBump_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeBump::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeBump_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	ENUM_PROPERTY(space_enum, ShaderNodeNormalMap, space)
	STRING_PROPERTY(ShaderNodeNormalMap, uv_map)

	inline bool ShaderNodeNormalMap::is_registered_node_type() {
		return ShaderNodeNormalMap_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeNormalMap::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeNormalMap_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeNormalMap::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeNormalMap_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	ENUM_PROPERTY(direction_type_enum, ShaderNodeTangent, direction_type)
	ENUM_PROPERTY(axis_enum, ShaderNodeTangent, axis)
	STRING_PROPERTY(ShaderNodeTangent, uv_map)

	inline bool ShaderNodeTangent::is_registered_node_type() {
		return ShaderNodeTangent_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeTangent::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeTangent_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeTangent::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeTangent_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	POINTER_PROPERTY(Text, ShaderNodeScript, script)
	STRING_PROPERTY(ShaderNodeScript, filepath)
	ENUM_PROPERTY(mode_enum, ShaderNodeScript, mode)
	BOOLEAN_PROPERTY(ShaderNodeScript, use_auto_update)
	STRING_PROPERTY(ShaderNodeScript, bytecode)
	STRING_PROPERTY(ShaderNodeScript, bytecode_hash)

	inline bool ShaderNodeScript::is_registered_node_type() {
		return ShaderNodeScript_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeScript::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeScript_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeScript::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeScript_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	POINTER_PROPERTY(Image, ShaderNodeTexImage, image)
	POINTER_PROPERTY(TexMapping, ShaderNodeTexImage, texture_mapping)
	POINTER_PROPERTY(ColorMapping, ShaderNodeTexImage, color_mapping)
	ENUM_PROPERTY(color_space_enum, ShaderNodeTexImage, color_space)
	ENUM_PROPERTY(projection_enum, ShaderNodeTexImage, projection)
	ENUM_PROPERTY(interpolation_enum, ShaderNodeTexImage, interpolation)
	FLOAT_PROPERTY(ShaderNodeTexImage, projection_blend)
	ENUM_PROPERTY(extension_enum, ShaderNodeTexImage, extension)
	POINTER_PROPERTY(ImageUser, ShaderNodeTexImage, image_user)

	inline bool ShaderNodeTexImage::is_registered_node_type() {
		return ShaderNodeTexImage_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeTexImage::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeTexImage_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeTexImage::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeTexImage_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	POINTER_PROPERTY(Image, ShaderNodeTexEnvironment, image)
	POINTER_PROPERTY(TexMapping, ShaderNodeTexEnvironment, texture_mapping)
	POINTER_PROPERTY(ColorMapping, ShaderNodeTexEnvironment, color_mapping)
	ENUM_PROPERTY(color_space_enum, ShaderNodeTexEnvironment, color_space)
	ENUM_PROPERTY(projection_enum, ShaderNodeTexEnvironment, projection)
	ENUM_PROPERTY(interpolation_enum, ShaderNodeTexEnvironment, interpolation)
	POINTER_PROPERTY(ImageUser, ShaderNodeTexEnvironment, image_user)

	inline bool ShaderNodeTexEnvironment::is_registered_node_type() {
		return ShaderNodeTexEnvironment_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeTexEnvironment::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeTexEnvironment_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeTexEnvironment::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeTexEnvironment_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	POINTER_PROPERTY(TexMapping, ShaderNodeTexSky, texture_mapping)
	POINTER_PROPERTY(ColorMapping, ShaderNodeTexSky, color_mapping)
	ENUM_PROPERTY(sky_type_enum, ShaderNodeTexSky, sky_type)
	FLOAT_ARRAY_PROPERTY(ShaderNodeTexSky, 3, sun_direction)
	FLOAT_PROPERTY(ShaderNodeTexSky, turbidity)
	FLOAT_PROPERTY(ShaderNodeTexSky, ground_albedo)

	inline bool ShaderNodeTexSky::is_registered_node_type() {
		return ShaderNodeTexSky_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeTexSky::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeTexSky_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeTexSky::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeTexSky_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	POINTER_PROPERTY(TexMapping, ShaderNodeTexGradient, texture_mapping)
	POINTER_PROPERTY(ColorMapping, ShaderNodeTexGradient, color_mapping)
	ENUM_PROPERTY(gradient_type_enum, ShaderNodeTexGradient, gradient_type)

	inline bool ShaderNodeTexGradient::is_registered_node_type() {
		return ShaderNodeTexGradient_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeTexGradient::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeTexGradient_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeTexGradient::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeTexGradient_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	POINTER_PROPERTY(TexMapping, ShaderNodeTexNoise, texture_mapping)
	POINTER_PROPERTY(ColorMapping, ShaderNodeTexNoise, color_mapping)

	inline bool ShaderNodeTexNoise::is_registered_node_type() {
		return ShaderNodeTexNoise_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeTexNoise::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeTexNoise_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeTexNoise::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeTexNoise_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	POINTER_PROPERTY(TexMapping, ShaderNodeTexMagic, texture_mapping)
	POINTER_PROPERTY(ColorMapping, ShaderNodeTexMagic, color_mapping)
	INT_PROPERTY(ShaderNodeTexMagic, turbulence_depth)

	inline bool ShaderNodeTexMagic::is_registered_node_type() {
		return ShaderNodeTexMagic_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeTexMagic::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeTexMagic_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeTexMagic::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeTexMagic_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	POINTER_PROPERTY(TexMapping, ShaderNodeTexWave, texture_mapping)
	POINTER_PROPERTY(ColorMapping, ShaderNodeTexWave, color_mapping)
	ENUM_PROPERTY(wave_type_enum, ShaderNodeTexWave, wave_type)
	ENUM_PROPERTY(wave_profile_enum, ShaderNodeTexWave, wave_profile)

	inline bool ShaderNodeTexWave::is_registered_node_type() {
		return ShaderNodeTexWave_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeTexWave::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeTexWave_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeTexWave::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeTexWave_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	POINTER_PROPERTY(TexMapping, ShaderNodeTexMusgrave, texture_mapping)
	POINTER_PROPERTY(ColorMapping, ShaderNodeTexMusgrave, color_mapping)
	ENUM_PROPERTY(musgrave_type_enum, ShaderNodeTexMusgrave, musgrave_type)

	inline bool ShaderNodeTexMusgrave::is_registered_node_type() {
		return ShaderNodeTexMusgrave_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeTexMusgrave::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeTexMusgrave_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeTexMusgrave::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeTexMusgrave_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	POINTER_PROPERTY(TexMapping, ShaderNodeTexVoronoi, texture_mapping)
	POINTER_PROPERTY(ColorMapping, ShaderNodeTexVoronoi, color_mapping)
	ENUM_PROPERTY(coloring_enum, ShaderNodeTexVoronoi, coloring)
	ENUM_PROPERTY(distance_enum, ShaderNodeTexVoronoi, distance)
	ENUM_PROPERTY(feature_enum, ShaderNodeTexVoronoi, feature)

	inline bool ShaderNodeTexVoronoi::is_registered_node_type() {
		return ShaderNodeTexVoronoi_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeTexVoronoi::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeTexVoronoi_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeTexVoronoi::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeTexVoronoi_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	POINTER_PROPERTY(TexMapping, ShaderNodeTexChecker, texture_mapping)
	POINTER_PROPERTY(ColorMapping, ShaderNodeTexChecker, color_mapping)

	inline bool ShaderNodeTexChecker::is_registered_node_type() {
		return ShaderNodeTexChecker_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeTexChecker::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeTexChecker_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeTexChecker::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeTexChecker_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	POINTER_PROPERTY(TexMapping, ShaderNodeTexBrick, texture_mapping)
	POINTER_PROPERTY(ColorMapping, ShaderNodeTexBrick, color_mapping)
	INT_PROPERTY(ShaderNodeTexBrick, offset_frequency)
	INT_PROPERTY(ShaderNodeTexBrick, squash_frequency)
	FLOAT_PROPERTY(ShaderNodeTexBrick, offset)
	FLOAT_PROPERTY(ShaderNodeTexBrick, squash)

	inline bool ShaderNodeTexBrick::is_registered_node_type() {
		return ShaderNodeTexBrick_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeTexBrick::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeTexBrick_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeTexBrick::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeTexBrick_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	POINTER_PROPERTY(Object, ShaderNodeTexPointDensity, object)
	ENUM_PROPERTY(point_source_enum, ShaderNodeTexPointDensity, point_source)
	POINTER_PROPERTY(ParticleSystem, ShaderNodeTexPointDensity, particle_system)
	INT_PROPERTY(ShaderNodeTexPointDensity, resolution)
	FLOAT_PROPERTY(ShaderNodeTexPointDensity, radius)
	ENUM_PROPERTY(space_enum, ShaderNodeTexPointDensity, space)
	ENUM_PROPERTY(interpolation_enum, ShaderNodeTexPointDensity, interpolation)
	ENUM_PROPERTY(particle_color_source_enum, ShaderNodeTexPointDensity, particle_color_source)
	ENUM_PROPERTY(vertex_color_source_enum, ShaderNodeTexPointDensity, vertex_color_source)
	STRING_PROPERTY(ShaderNodeTexPointDensity, vertex_attribute_name)

	inline bool ShaderNodeTexPointDensity::is_registered_node_type() {
		return ShaderNodeTexPointDensity_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeTexPointDensity::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeTexPointDensity_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeTexPointDensity::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeTexPointDensity_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline void ShaderNodeTexPointDensity::cache_point_density(Depsgraph& depsgraph) {
		ShaderNodeTexPointDensity_cache_point_density((::bNode *) this->ptr.data, (::Depsgraph *) depsgraph.ptr.data);
	}

	inline void ShaderNodeTexPointDensity::calc_point_density(Depsgraph& depsgraph, int *rgba_values_len, float **rgba_values) {
		ShaderNodeTexPointDensity_calc_point_density((::bNode *) this->ptr.data, (::Depsgraph *) depsgraph.ptr.data, rgba_values_len, rgba_values);
	}

	inline void ShaderNodeTexPointDensity::calc_point_density_minmax(Depsgraph& depsgraph, float min[3], float max[3]) {
		ShaderNodeTexPointDensity_calc_point_density_minmax((::bNode *) this->ptr.data, (::Depsgraph *) depsgraph.ptr.data, min, max);
	}


	POINTER_PROPERTY(Object, ShaderNodeTexCoord, object)
	BOOLEAN_PROPERTY(ShaderNodeTexCoord, from_instancer)

	inline bool ShaderNodeTexCoord::is_registered_node_type() {
		return ShaderNodeTexCoord_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeTexCoord::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeTexCoord_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeTexCoord::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeTexCoord_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	ENUM_PROPERTY(vector_type_enum, ShaderNodeVectorTransform, vector_type)
	ENUM_PROPERTY(convert_from_enum, ShaderNodeVectorTransform, convert_from)
	ENUM_PROPERTY(convert_to_enum, ShaderNodeVectorTransform, convert_to)

	inline bool ShaderNodeVectorTransform::is_registered_node_type() {
		return ShaderNodeVectorTransform_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeVectorTransform::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeVectorTransform_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeVectorTransform::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeVectorTransform_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool ShaderNodeSeparateHSV::is_registered_node_type() {
		return ShaderNodeSeparateHSV_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeSeparateHSV::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeSeparateHSV_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeSeparateHSV::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeSeparateHSV_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool ShaderNodeCombineHSV::is_registered_node_type() {
		return ShaderNodeCombineHSV_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeCombineHSV::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeCombineHSV_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeCombineHSV::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeCombineHSV_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	BOOLEAN_PROPERTY(ShaderNodeUVMap, from_instancer)
	STRING_PROPERTY(ShaderNodeUVMap, uv_map)

	inline bool ShaderNodeUVMap::is_registered_node_type() {
		return ShaderNodeUVMap_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeUVMap::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeUVMap_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeUVMap::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeUVMap_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	BOOLEAN_PROPERTY(ShaderNodeUVAlongStroke, use_tips)

	inline bool ShaderNodeUVAlongStroke::is_registered_node_type() {
		return ShaderNodeUVAlongStroke_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeUVAlongStroke::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeUVAlongStroke_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeUVAlongStroke::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeUVAlongStroke_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool ShaderNodeSeparateXYZ::is_registered_node_type() {
		return ShaderNodeSeparateXYZ_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeSeparateXYZ::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeSeparateXYZ_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeSeparateXYZ::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeSeparateXYZ_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool ShaderNodeCombineXYZ::is_registered_node_type() {
		return ShaderNodeCombineXYZ_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeCombineXYZ::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeCombineXYZ_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeCombineXYZ::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeCombineXYZ_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	INT_PROPERTY(ShaderNodeBevel, samples)

	inline bool ShaderNodeBevel::is_registered_node_type() {
		return ShaderNodeBevel_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeBevel::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeBevel_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeBevel::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeBevel_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	ENUM_PROPERTY(space_enum, ShaderNodeDisplacement, space)

	inline bool ShaderNodeDisplacement::is_registered_node_type() {
		return ShaderNodeDisplacement_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeDisplacement::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeDisplacement_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeDisplacement::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeDisplacement_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	ENUM_PROPERTY(space_enum, ShaderNodeVectorDisplacement, space)

	inline bool ShaderNodeVectorDisplacement::is_registered_node_type() {
		return ShaderNodeVectorDisplacement_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeVectorDisplacement::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeVectorDisplacement_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeVectorDisplacement::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeVectorDisplacement_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	POINTER_PROPERTY(Text, ShaderNodeTexIES, ies)
	STRING_PROPERTY(ShaderNodeTexIES, filepath)
	ENUM_PROPERTY(mode_enum, ShaderNodeTexIES, mode)

	inline bool ShaderNodeTexIES::is_registered_node_type() {
		return ShaderNodeTexIES_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeTexIES::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeTexIES_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeTexIES::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeTexIES_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	ENUM_PROPERTY(tile_order_enum, CompositorNodeViewer, tile_order)
	FLOAT_PROPERTY(CompositorNodeViewer, center_x)
	FLOAT_PROPERTY(CompositorNodeViewer, center_y)
	BOOLEAN_PROPERTY(CompositorNodeViewer, use_alpha)

	inline bool CompositorNodeViewer::is_registered_node_type() {
		return CompositorNodeViewer_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeViewer::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeViewer_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeViewer::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeViewer_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool CompositorNodeRGB::is_registered_node_type() {
		return CompositorNodeRGB_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeRGB::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeRGB_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeRGB::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeRGB_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool CompositorNodeValue::is_registered_node_type() {
		return CompositorNodeValue_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeValue::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeValue_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeValue::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeValue_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	ENUM_PROPERTY(blend_type_enum, CompositorNodeMixRGB, blend_type)
	BOOLEAN_PROPERTY(CompositorNodeMixRGB, use_alpha)
	BOOLEAN_PROPERTY(CompositorNodeMixRGB, use_clamp)

	inline bool CompositorNodeMixRGB::is_registered_node_type() {
		return CompositorNodeMixRGB_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeMixRGB::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeMixRGB_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeMixRGB::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeMixRGB_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	POINTER_PROPERTY(ColorRamp, CompositorNodeValToRGB, color_ramp)

	inline bool CompositorNodeValToRGB::is_registered_node_type() {
		return CompositorNodeValToRGB_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeValToRGB::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeValToRGB_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeValToRGB::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeValToRGB_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool CompositorNodeRGBToBW::is_registered_node_type() {
		return CompositorNodeRGBToBW_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeRGBToBW::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeRGBToBW_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeRGBToBW::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeRGBToBW_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool CompositorNodeNormal::is_registered_node_type() {
		return CompositorNodeNormal_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeNormal::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeNormal_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeNormal::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeNormal_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	POINTER_PROPERTY(CurveMapping, CompositorNodeCurveVec, mapping)

	inline bool CompositorNodeCurveVec::is_registered_node_type() {
		return CompositorNodeCurveVec_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeCurveVec::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeCurveVec_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeCurveVec::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeCurveVec_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	POINTER_PROPERTY(CurveMapping, CompositorNodeCurveRGB, mapping)

	inline bool CompositorNodeCurveRGB::is_registered_node_type() {
		return CompositorNodeCurveRGB_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeCurveRGB::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeCurveRGB_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeCurveRGB::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeCurveRGB_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	BOOLEAN_PROPERTY(CompositorNodeAlphaOver, use_premultiply)
	FLOAT_PROPERTY(CompositorNodeAlphaOver, premul)

	inline bool CompositorNodeAlphaOver::is_registered_node_type() {
		return CompositorNodeAlphaOver_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeAlphaOver::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeAlphaOver_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeAlphaOver::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeAlphaOver_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	BOOLEAN_PROPERTY(CompositorNodeBlur, use_variable_size)
	BOOLEAN_PROPERTY(CompositorNodeBlur, use_extended_bounds)
	INT_PROPERTY(CompositorNodeBlur, size_x)
	INT_PROPERTY(CompositorNodeBlur, size_y)
	BOOLEAN_PROPERTY(CompositorNodeBlur, use_relative)
	ENUM_PROPERTY(aspect_correction_enum, CompositorNodeBlur, aspect_correction)
	FLOAT_PROPERTY(CompositorNodeBlur, factor)
	FLOAT_PROPERTY(CompositorNodeBlur, factor_x)
	FLOAT_PROPERTY(CompositorNodeBlur, factor_y)
	ENUM_PROPERTY(filter_type_enum, CompositorNodeBlur, filter_type)
	BOOLEAN_PROPERTY(CompositorNodeBlur, use_bokeh)
	BOOLEAN_PROPERTY(CompositorNodeBlur, use_gamma_correction)

	inline bool CompositorNodeBlur::is_registered_node_type() {
		return CompositorNodeBlur_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeBlur::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeBlur_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeBlur::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeBlur_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	ENUM_PROPERTY(filter_type_enum, CompositorNodeFilter, filter_type)

	inline bool CompositorNodeFilter::is_registered_node_type() {
		return CompositorNodeFilter_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeFilter::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeFilter_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeFilter::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeFilter_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	FLOAT_ARRAY_PROPERTY(CompositorNodeMapValue, 1, offset)
	FLOAT_ARRAY_PROPERTY(CompositorNodeMapValue, 1, size)
	BOOLEAN_PROPERTY(CompositorNodeMapValue, use_min)
	BOOLEAN_PROPERTY(CompositorNodeMapValue, use_max)
	FLOAT_ARRAY_PROPERTY(CompositorNodeMapValue, 1, min)
	FLOAT_ARRAY_PROPERTY(CompositorNodeMapValue, 1, max)

	inline bool CompositorNodeMapValue::is_registered_node_type() {
		return CompositorNodeMapValue_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeMapValue::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeMapValue_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeMapValue::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeMapValue_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	BOOLEAN_PROPERTY(CompositorNodeMapRange, use_clamp)

	inline bool CompositorNodeMapRange::is_registered_node_type() {
		return CompositorNodeMapRange_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeMapRange::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeMapRange_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeMapRange::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeMapRange_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	POINTER_PROPERTY(CurveMapping, CompositorNodeTime, curve)
	INT_PROPERTY(CompositorNodeTime, frame_start)
	INT_PROPERTY(CompositorNodeTime, frame_end)

	inline bool CompositorNodeTime::is_registered_node_type() {
		return CompositorNodeTime_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeTime::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeTime_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeTime::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeTime_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	INT_PROPERTY(CompositorNodeVecBlur, samples)
	INT_PROPERTY(CompositorNodeVecBlur, speed_min)
	INT_PROPERTY(CompositorNodeVecBlur, speed_max)
	FLOAT_PROPERTY(CompositorNodeVecBlur, factor)
	BOOLEAN_PROPERTY(CompositorNodeVecBlur, use_curved)

	inline bool CompositorNodeVecBlur::is_registered_node_type() {
		return CompositorNodeVecBlur_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeVecBlur::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeVecBlur_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeVecBlur::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeVecBlur_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool CompositorNodeSepRGBA::is_registered_node_type() {
		return CompositorNodeSepRGBA_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeSepRGBA::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeSepRGBA_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeSepRGBA::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeSepRGBA_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool CompositorNodeSepHSVA::is_registered_node_type() {
		return CompositorNodeSepHSVA_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeSepHSVA::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeSepHSVA_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeSepHSVA::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeSepHSVA_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool CompositorNodeSetAlpha::is_registered_node_type() {
		return CompositorNodeSetAlpha_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeSetAlpha::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeSetAlpha_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeSetAlpha::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeSetAlpha_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool CompositorNodeHueSat::is_registered_node_type() {
		return CompositorNodeHueSat_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeHueSat::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeHueSat_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeHueSat::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeHueSat_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	POINTER_PROPERTY(Image, CompositorNodeImage, image)
	BOOLEAN_PROPERTY(CompositorNodeImage, use_straight_alpha_output)
	INT_PROPERTY(CompositorNodeImage, frame_duration)
	INT_PROPERTY(CompositorNodeImage, frame_start)
	INT_PROPERTY(CompositorNodeImage, frame_offset)
	BOOLEAN_PROPERTY(CompositorNodeImage, use_cyclic)
	BOOLEAN_PROPERTY(CompositorNodeImage, use_auto_refresh)
	ENUM_PROPERTY(layer_enum, CompositorNodeImage, layer)
	BOOLEAN_PROPERTY(CompositorNodeImage, has_layers)
	ENUM_PROPERTY(view_enum, CompositorNodeImage, view)
	BOOLEAN_PROPERTY(CompositorNodeImage, has_views)

	inline bool CompositorNodeImage::is_registered_node_type() {
		return CompositorNodeImage_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeImage::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeImage_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeImage::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeImage_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	POINTER_PROPERTY(Scene, CompositorNodeRLayers, scene)
	ENUM_PROPERTY(layer_enum, CompositorNodeRLayers, layer)

	inline bool CompositorNodeRLayers::is_registered_node_type() {
		return CompositorNodeRLayers_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeRLayers::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeRLayers_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeRLayers::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeRLayers_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	BOOLEAN_PROPERTY(CompositorNodeComposite, use_alpha)

	inline bool CompositorNodeComposite::is_registered_node_type() {
		return CompositorNodeComposite_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeComposite::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeComposite_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeComposite::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeComposite_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	STRING_PROPERTY(CompositorNodeOutputFile, base_path)
	INT_PROPERTY(CompositorNodeOutputFile, active_input_index)
	POINTER_PROPERTY(ImageFormatSettings, CompositorNodeOutputFile, format)



	inline bool CompositorNodeOutputFile::is_registered_node_type() {
		return CompositorNodeOutputFile_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeOutputFile::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeOutputFile_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeOutputFile::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeOutputFile_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	POINTER_PROPERTY(Struct, CompositorNodeOutputFileFileSlots, rna_type)

	inline NodeSocket CompositorNodeOutputFileFileSlots::create(Context C, const char * name) {
		PointerRNA result;
		::bNodeSocket *retdata = CompositorNodeOutputFileFileSlots_new((::ID *) ptr.id.data, (::bNode *) this->ptr.data, (::bContext *) C.ptr.data, NULL, name);
		RNA_pointer_create((::ID *) ptr.id.data, &RNA_NodeSocket, retdata, &result);
		return NodeSocket(result);
	}

	inline void CompositorNodeOutputFileFileSlots::remove(void *main, NodeSocket& socket) {
		CompositorNodeOutputFileFileSlots_remove((::ID *) ptr.id.data, (::bNode *) this->ptr.data, (::Main *) main, NULL, (::bNodeSocket *) socket.ptr.data);
	}

	inline void CompositorNodeOutputFileFileSlots::clear(void *main) {
		CompositorNodeOutputFileFileSlots_clear((::ID *) ptr.id.data, (::bNode *) this->ptr.data, (::Main *) main);
	}

	inline void CompositorNodeOutputFileFileSlots::move(void *main, int from_index, int to_index) {
		CompositorNodeOutputFileFileSlots_move((::ID *) ptr.id.data, (::bNode *) this->ptr.data, (::Main *) main, from_index, to_index);
	}


	POINTER_PROPERTY(Struct, CompositorNodeOutputFileLayerSlots, rna_type)

	inline NodeSocket CompositorNodeOutputFileLayerSlots::create(Context C, const char * name) {
		PointerRNA result;
		::bNodeSocket *retdata = CompositorNodeOutputFileLayerSlots_new((::ID *) ptr.id.data, (::bNode *) this->ptr.data, (::bContext *) C.ptr.data, NULL, name);
		RNA_pointer_create((::ID *) ptr.id.data, &RNA_NodeSocket, retdata, &result);
		return NodeSocket(result);
	}

	inline void CompositorNodeOutputFileLayerSlots::remove(void *main, NodeSocket& socket) {
		CompositorNodeOutputFileLayerSlots_remove((::ID *) ptr.id.data, (::bNode *) this->ptr.data, (::Main *) main, NULL, (::bNodeSocket *) socket.ptr.data);
	}

	inline void CompositorNodeOutputFileLayerSlots::clear(void *main) {
		CompositorNodeOutputFileLayerSlots_clear((::ID *) ptr.id.data, (::bNode *) this->ptr.data, (::Main *) main);
	}

	inline void CompositorNodeOutputFileLayerSlots::move(void *main, int from_index, int to_index) {
		CompositorNodeOutputFileLayerSlots_move((::ID *) ptr.id.data, (::bNode *) this->ptr.data, (::Main *) main, from_index, to_index);
	}


	POINTER_PROPERTY(Texture, CompositorNodeTexture, texture)
	INT_PROPERTY(CompositorNodeTexture, node_output)

	inline bool CompositorNodeTexture::is_registered_node_type() {
		return CompositorNodeTexture_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeTexture::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeTexture_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeTexture::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeTexture_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	BOOLEAN_PROPERTY(CompositorNodeTranslate, use_relative)
	ENUM_PROPERTY(wrap_axis_enum, CompositorNodeTranslate, wrap_axis)

	inline bool CompositorNodeTranslate::is_registered_node_type() {
		return CompositorNodeTranslate_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeTranslate::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeTranslate_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeTranslate::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeTranslate_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	BOOLEAN_PROPERTY(CompositorNodeZcombine, use_alpha)
	BOOLEAN_PROPERTY(CompositorNodeZcombine, use_antialias_z)

	inline bool CompositorNodeZcombine::is_registered_node_type() {
		return CompositorNodeZcombine_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeZcombine::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeZcombine_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeZcombine::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeZcombine_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool CompositorNodeCombRGBA::is_registered_node_type() {
		return CompositorNodeCombRGBA_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeCombRGBA::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeCombRGBA_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeCombRGBA::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeCombRGBA_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	ENUM_PROPERTY(mode_enum, CompositorNodeDilateErode, mode)
	INT_PROPERTY(CompositorNodeDilateErode, distance)
	FLOAT_PROPERTY(CompositorNodeDilateErode, edge)
	ENUM_PROPERTY(falloff_enum, CompositorNodeDilateErode, falloff)

	inline bool CompositorNodeDilateErode::is_registered_node_type() {
		return CompositorNodeDilateErode_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeDilateErode::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeDilateErode_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeDilateErode::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeDilateErode_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	INT_PROPERTY(CompositorNodeInpaint, distance)

	inline bool CompositorNodeInpaint::is_registered_node_type() {
		return CompositorNodeInpaint_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeInpaint::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeInpaint_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeInpaint::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeInpaint_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	FLOAT_PROPERTY(CompositorNodeDespeckle, threshold)
	FLOAT_PROPERTY(CompositorNodeDespeckle, threshold_neighbor)

	inline bool CompositorNodeDespeckle::is_registered_node_type() {
		return CompositorNodeDespeckle_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeDespeckle::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeDespeckle_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeDespeckle::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeDespeckle_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	ENUM_PROPERTY(filter_type_enum, CompositorNodeRotate, filter_type)

	inline bool CompositorNodeRotate::is_registered_node_type() {
		return CompositorNodeRotate_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeRotate::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeRotate_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeRotate::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeRotate_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	ENUM_PROPERTY(space_enum, CompositorNodeScale, space)
	ENUM_PROPERTY(frame_method_enum, CompositorNodeScale, frame_method)
	FLOAT_PROPERTY(CompositorNodeScale, offset_x)
	FLOAT_PROPERTY(CompositorNodeScale, offset_y)

	inline bool CompositorNodeScale::is_registered_node_type() {
		return CompositorNodeScale_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeScale::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeScale_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeScale::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeScale_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	ENUM_PROPERTY(mode_enum, CompositorNodeSepYCCA, mode)

	inline bool CompositorNodeSepYCCA::is_registered_node_type() {
		return CompositorNodeSepYCCA_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeSepYCCA::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeSepYCCA_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeSepYCCA::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeSepYCCA_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	ENUM_PROPERTY(mode_enum, CompositorNodeCombYCCA, mode)

	inline bool CompositorNodeCombYCCA::is_registered_node_type() {
		return CompositorNodeCombYCCA_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeCombYCCA::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeCombYCCA_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeCombYCCA::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeCombYCCA_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool CompositorNodeSepYUVA::is_registered_node_type() {
		return CompositorNodeSepYUVA_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeSepYUVA::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeSepYUVA_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeSepYUVA::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeSepYUVA_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool CompositorNodeCombYUVA::is_registered_node_type() {
		return CompositorNodeCombYUVA_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeCombYUVA::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeCombYUVA_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeCombYUVA::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeCombYUVA_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	FLOAT_PROPERTY(CompositorNodeDiffMatte, tolerance)
	FLOAT_PROPERTY(CompositorNodeDiffMatte, falloff)

	inline bool CompositorNodeDiffMatte::is_registered_node_type() {
		return CompositorNodeDiffMatte_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeDiffMatte::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeDiffMatte_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeDiffMatte::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeDiffMatte_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	ENUM_PROPERTY(channel_enum, CompositorNodeColorSpill, channel)
	ENUM_PROPERTY(limit_method_enum, CompositorNodeColorSpill, limit_method)
	ENUM_PROPERTY(limit_channel_enum, CompositorNodeColorSpill, limit_channel)
	FLOAT_PROPERTY(CompositorNodeColorSpill, ratio)
	BOOLEAN_PROPERTY(CompositorNodeColorSpill, use_unspill)
	FLOAT_PROPERTY(CompositorNodeColorSpill, unspill_red)
	FLOAT_PROPERTY(CompositorNodeColorSpill, unspill_green)
	FLOAT_PROPERTY(CompositorNodeColorSpill, unspill_blue)

	inline bool CompositorNodeColorSpill::is_registered_node_type() {
		return CompositorNodeColorSpill_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeColorSpill::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeColorSpill_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeColorSpill::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeColorSpill_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	FLOAT_PROPERTY(CompositorNodeChromaMatte, tolerance)
	FLOAT_PROPERTY(CompositorNodeChromaMatte, threshold)
	FLOAT_PROPERTY(CompositorNodeChromaMatte, lift)
	FLOAT_PROPERTY(CompositorNodeChromaMatte, gain)
	FLOAT_PROPERTY(CompositorNodeChromaMatte, shadow_adjust)

	inline bool CompositorNodeChromaMatte::is_registered_node_type() {
		return CompositorNodeChromaMatte_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeChromaMatte::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeChromaMatte_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeChromaMatte::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeChromaMatte_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	ENUM_PROPERTY(color_space_enum, CompositorNodeChannelMatte, color_space)
	ENUM_PROPERTY(matte_channel_enum, CompositorNodeChannelMatte, matte_channel)
	ENUM_PROPERTY(limit_method_enum, CompositorNodeChannelMatte, limit_method)
	ENUM_PROPERTY(limit_channel_enum, CompositorNodeChannelMatte, limit_channel)
	FLOAT_PROPERTY(CompositorNodeChannelMatte, limit_max)
	FLOAT_PROPERTY(CompositorNodeChannelMatte, limit_min)

	inline bool CompositorNodeChannelMatte::is_registered_node_type() {
		return CompositorNodeChannelMatte_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeChannelMatte::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeChannelMatte_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeChannelMatte::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeChannelMatte_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	ENUM_PROPERTY(axis_enum, CompositorNodeFlip, axis)

	inline bool CompositorNodeFlip::is_registered_node_type() {
		return CompositorNodeFlip_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeFlip::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeFlip_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeFlip::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeFlip_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	ENUM_PROPERTY(axis_enum, CompositorNodeSplitViewer, axis)
	INT_PROPERTY(CompositorNodeSplitViewer, factor)

	inline bool CompositorNodeSplitViewer::is_registered_node_type() {
		return CompositorNodeSplitViewer_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeSplitViewer::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeSplitViewer_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeSplitViewer::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeSplitViewer_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	INT_PROPERTY(CompositorNodeMapUV, alpha)

	inline bool CompositorNodeMapUV::is_registered_node_type() {
		return CompositorNodeMapUV_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeMapUV::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeMapUV_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeMapUV::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeMapUV_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	INT_PROPERTY(CompositorNodeIDMask, index)
	BOOLEAN_PROPERTY(CompositorNodeIDMask, use_antialiasing)

	inline bool CompositorNodeIDMask::is_registered_node_type() {
		return CompositorNodeIDMask_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeIDMask::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeIDMask_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeIDMask::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeIDMask_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	ENUM_PROPERTY(inner_mode_enum, CompositorNodeDoubleEdgeMask, inner_mode)
	ENUM_PROPERTY(edge_mode_enum, CompositorNodeDoubleEdgeMask, edge_mode)

	inline bool CompositorNodeDoubleEdgeMask::is_registered_node_type() {
		return CompositorNodeDoubleEdgeMask_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeDoubleEdgeMask::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeDoubleEdgeMask_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeDoubleEdgeMask::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeDoubleEdgeMask_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	POINTER_PROPERTY(Scene, CompositorNodeDefocus, scene)
	ENUM_PROPERTY(bokeh_enum, CompositorNodeDefocus, bokeh)
	FLOAT_PROPERTY(CompositorNodeDefocus, angle)
	BOOLEAN_PROPERTY(CompositorNodeDefocus, use_gamma_correction)
	FLOAT_PROPERTY(CompositorNodeDefocus, f_stop)
	FLOAT_PROPERTY(CompositorNodeDefocus, blur_max)
	FLOAT_PROPERTY(CompositorNodeDefocus, threshold)
	BOOLEAN_PROPERTY(CompositorNodeDefocus, use_preview)
	BOOLEAN_PROPERTY(CompositorNodeDefocus, use_zbuffer)
	FLOAT_PROPERTY(CompositorNodeDefocus, z_scale)

	inline bool CompositorNodeDefocus::is_registered_node_type() {
		return CompositorNodeDefocus_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeDefocus::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeDefocus_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeDefocus::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeDefocus_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool CompositorNodeDisplace::is_registered_node_type() {
		return CompositorNodeDisplace_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeDisplace::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeDisplace_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeDisplace::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeDisplace_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool CompositorNodeCombHSVA::is_registered_node_type() {
		return CompositorNodeCombHSVA_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeCombHSVA::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeCombHSVA_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeCombHSVA::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeCombHSVA_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	ENUM_PROPERTY(operation_enum, CompositorNodeMath, operation)
	BOOLEAN_PROPERTY(CompositorNodeMath, use_clamp)

	inline bool CompositorNodeMath::is_registered_node_type() {
		return CompositorNodeMath_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeMath::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeMath_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeMath::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeMath_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	FLOAT_PROPERTY(CompositorNodeLumaMatte, limit_max)
	FLOAT_PROPERTY(CompositorNodeLumaMatte, limit_min)

	inline bool CompositorNodeLumaMatte::is_registered_node_type() {
		return CompositorNodeLumaMatte_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeLumaMatte::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeLumaMatte_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeLumaMatte::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeLumaMatte_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	BOOLEAN_PROPERTY(CompositorNodeBrightContrast, use_premultiply)

	inline bool CompositorNodeBrightContrast::is_registered_node_type() {
		return CompositorNodeBrightContrast_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeBrightContrast::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeBrightContrast_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeBrightContrast::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeBrightContrast_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool CompositorNodeGamma::is_registered_node_type() {
		return CompositorNodeGamma_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeGamma::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeGamma_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeGamma::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeGamma_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	BOOLEAN_PROPERTY(CompositorNodeInvert, invert_rgb)
	BOOLEAN_PROPERTY(CompositorNodeInvert, invert_alpha)

	inline bool CompositorNodeInvert::is_registered_node_type() {
		return CompositorNodeInvert_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeInvert::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeInvert_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeInvert::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeInvert_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool CompositorNodeNormalize::is_registered_node_type() {
		return CompositorNodeNormalize_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeNormalize::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeNormalize_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeNormalize::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeNormalize_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	BOOLEAN_PROPERTY(CompositorNodeCrop, use_crop_size)
	BOOLEAN_PROPERTY(CompositorNodeCrop, relative)
	INT_PROPERTY(CompositorNodeCrop, min_x)
	INT_PROPERTY(CompositorNodeCrop, max_x)
	INT_PROPERTY(CompositorNodeCrop, min_y)
	INT_PROPERTY(CompositorNodeCrop, max_y)
	FLOAT_PROPERTY(CompositorNodeCrop, rel_min_x)
	FLOAT_PROPERTY(CompositorNodeCrop, rel_max_x)
	FLOAT_PROPERTY(CompositorNodeCrop, rel_min_y)
	FLOAT_PROPERTY(CompositorNodeCrop, rel_max_y)

	inline bool CompositorNodeCrop::is_registered_node_type() {
		return CompositorNodeCrop_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeCrop::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeCrop_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeCrop::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeCrop_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	INT_PROPERTY(CompositorNodeDBlur, iterations)
	BOOLEAN_PROPERTY(CompositorNodeDBlur, use_wrap)
	FLOAT_PROPERTY(CompositorNodeDBlur, center_x)
	FLOAT_PROPERTY(CompositorNodeDBlur, center_y)
	FLOAT_PROPERTY(CompositorNodeDBlur, distance)
	FLOAT_PROPERTY(CompositorNodeDBlur, angle)
	FLOAT_PROPERTY(CompositorNodeDBlur, spin)
	FLOAT_PROPERTY(CompositorNodeDBlur, zoom)

	inline bool CompositorNodeDBlur::is_registered_node_type() {
		return CompositorNodeDBlur_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeDBlur::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeDBlur_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeDBlur::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeDBlur_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	INT_PROPERTY(CompositorNodeBilateralblur, iterations)
	FLOAT_PROPERTY(CompositorNodeBilateralblur, sigma_color)
	FLOAT_PROPERTY(CompositorNodeBilateralblur, sigma_space)

	inline bool CompositorNodeBilateralblur::is_registered_node_type() {
		return CompositorNodeBilateralblur_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeBilateralblur::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeBilateralblur_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeBilateralblur::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeBilateralblur_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	ENUM_PROPERTY(mapping_enum, CompositorNodePremulKey, mapping)

	inline bool CompositorNodePremulKey::is_registered_node_type() {
		return CompositorNodePremulKey_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodePremulKey::input_template(int index) {
		PointerRNA result;
		result = CompositorNodePremulKey_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodePremulKey::output_template(int index) {
		PointerRNA result;
		result = CompositorNodePremulKey_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	ENUM_PROPERTY(glare_type_enum, CompositorNodeGlare, glare_type)
	ENUM_PROPERTY(quality_enum, CompositorNodeGlare, quality)
	INT_PROPERTY(CompositorNodeGlare, iterations)
	FLOAT_PROPERTY(CompositorNodeGlare, color_modulation)
	FLOAT_PROPERTY(CompositorNodeGlare, mix)
	FLOAT_PROPERTY(CompositorNodeGlare, threshold)
	INT_PROPERTY(CompositorNodeGlare, streaks)
	FLOAT_PROPERTY(CompositorNodeGlare, angle_offset)
	FLOAT_PROPERTY(CompositorNodeGlare, fade)
	BOOLEAN_PROPERTY(CompositorNodeGlare, use_rotate_45)
	INT_PROPERTY(CompositorNodeGlare, size)

	inline bool CompositorNodeGlare::is_registered_node_type() {
		return CompositorNodeGlare_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeGlare::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeGlare_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeGlare::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeGlare_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	ENUM_PROPERTY(tonemap_type_enum, CompositorNodeTonemap, tonemap_type)
	FLOAT_PROPERTY(CompositorNodeTonemap, key)
	FLOAT_PROPERTY(CompositorNodeTonemap, offset)
	FLOAT_PROPERTY(CompositorNodeTonemap, gamma)
	FLOAT_PROPERTY(CompositorNodeTonemap, intensity)
	FLOAT_PROPERTY(CompositorNodeTonemap, contrast)
	FLOAT_PROPERTY(CompositorNodeTonemap, adaptation)
	FLOAT_PROPERTY(CompositorNodeTonemap, correction)

	inline bool CompositorNodeTonemap::is_registered_node_type() {
		return CompositorNodeTonemap_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeTonemap::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeTonemap_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeTonemap::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeTonemap_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	BOOLEAN_PROPERTY(CompositorNodeLensdist, use_projector)
	BOOLEAN_PROPERTY(CompositorNodeLensdist, use_jitter)
	BOOLEAN_PROPERTY(CompositorNodeLensdist, use_fit)

	inline bool CompositorNodeLensdist::is_registered_node_type() {
		return CompositorNodeLensdist_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeLensdist::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeLensdist_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeLensdist::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeLensdist_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	ENUM_PROPERTY(channel_enum, CompositorNodeLevels, channel)

	inline bool CompositorNodeLevels::is_registered_node_type() {
		return CompositorNodeLevels_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeLevels::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeLevels_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeLevels::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeLevels_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	FLOAT_PROPERTY(CompositorNodeColorMatte, color_hue)
	FLOAT_PROPERTY(CompositorNodeColorMatte, color_saturation)
	FLOAT_PROPERTY(CompositorNodeColorMatte, color_value)

	inline bool CompositorNodeColorMatte::is_registered_node_type() {
		return CompositorNodeColorMatte_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeColorMatte::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeColorMatte_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeColorMatte::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeColorMatte_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	ENUM_PROPERTY(channel_enum, CompositorNodeDistanceMatte, channel)
	FLOAT_PROPERTY(CompositorNodeDistanceMatte, tolerance)
	FLOAT_PROPERTY(CompositorNodeDistanceMatte, falloff)

	inline bool CompositorNodeDistanceMatte::is_registered_node_type() {
		return CompositorNodeDistanceMatte_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeDistanceMatte::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeDistanceMatte_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeDistanceMatte::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeDistanceMatte_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	ENUM_PROPERTY(correction_method_enum, CompositorNodeColorBalance, correction_method)
	FLOAT_ARRAY_PROPERTY(CompositorNodeColorBalance, 3, lift)
	FLOAT_ARRAY_PROPERTY(CompositorNodeColorBalance, 3, gamma)
	FLOAT_ARRAY_PROPERTY(CompositorNodeColorBalance, 3, gain)
	FLOAT_ARRAY_PROPERTY(CompositorNodeColorBalance, 3, offset)
	FLOAT_ARRAY_PROPERTY(CompositorNodeColorBalance, 3, power)
	FLOAT_ARRAY_PROPERTY(CompositorNodeColorBalance, 3, slope)
	FLOAT_PROPERTY(CompositorNodeColorBalance, offset_basis)

	inline bool CompositorNodeColorBalance::is_registered_node_type() {
		return CompositorNodeColorBalance_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeColorBalance::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeColorBalance_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeColorBalance::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeColorBalance_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	POINTER_PROPERTY(CurveMapping, CompositorNodeHueCorrect, mapping)

	inline bool CompositorNodeHueCorrect::is_registered_node_type() {
		return CompositorNodeHueCorrect_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeHueCorrect::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeHueCorrect_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeHueCorrect::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeHueCorrect_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	POINTER_PROPERTY(MovieClip, CompositorNodeMovieClip, clip)

	inline bool CompositorNodeMovieClip::is_registered_node_type() {
		return CompositorNodeMovieClip_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeMovieClip::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeMovieClip_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeMovieClip::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeMovieClip_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	ENUM_PROPERTY(filter_type_enum, CompositorNodeTransform, filter_type)

	inline bool CompositorNodeTransform::is_registered_node_type() {
		return CompositorNodeTransform_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeTransform::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeTransform_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeTransform::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeTransform_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	POINTER_PROPERTY(MovieClip, CompositorNodeStabilize, clip)
	ENUM_PROPERTY(filter_type_enum, CompositorNodeStabilize, filter_type)
	BOOLEAN_PROPERTY(CompositorNodeStabilize, invert)

	inline bool CompositorNodeStabilize::is_registered_node_type() {
		return CompositorNodeStabilize_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeStabilize::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeStabilize_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeStabilize::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeStabilize_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	POINTER_PROPERTY(MovieClip, CompositorNodeMovieDistortion, clip)
	ENUM_PROPERTY(distortion_type_enum, CompositorNodeMovieDistortion, distortion_type)

	inline bool CompositorNodeMovieDistortion::is_registered_node_type() {
		return CompositorNodeMovieDistortion_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeMovieDistortion::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeMovieDistortion_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeMovieDistortion::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeMovieDistortion_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	ENUM_PROPERTY(mask_type_enum, CompositorNodeBoxMask, mask_type)
	FLOAT_PROPERTY(CompositorNodeBoxMask, x)
	FLOAT_PROPERTY(CompositorNodeBoxMask, y)
	FLOAT_PROPERTY(CompositorNodeBoxMask, width)
	FLOAT_PROPERTY(CompositorNodeBoxMask, height)
	FLOAT_PROPERTY(CompositorNodeBoxMask, rotation)

	inline bool CompositorNodeBoxMask::is_registered_node_type() {
		return CompositorNodeBoxMask_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeBoxMask::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeBoxMask_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeBoxMask::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeBoxMask_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	ENUM_PROPERTY(mask_type_enum, CompositorNodeEllipseMask, mask_type)
	FLOAT_PROPERTY(CompositorNodeEllipseMask, x)
	FLOAT_PROPERTY(CompositorNodeEllipseMask, y)
	FLOAT_PROPERTY(CompositorNodeEllipseMask, width)
	FLOAT_PROPERTY(CompositorNodeEllipseMask, height)
	FLOAT_PROPERTY(CompositorNodeEllipseMask, rotation)

	inline bool CompositorNodeEllipseMask::is_registered_node_type() {
		return CompositorNodeEllipseMask_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeEllipseMask::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeEllipseMask_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeEllipseMask::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeEllipseMask_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	FLOAT_PROPERTY(CompositorNodeBokehImage, angle)
	INT_PROPERTY(CompositorNodeBokehImage, flaps)
	FLOAT_PROPERTY(CompositorNodeBokehImage, rounding)
	FLOAT_PROPERTY(CompositorNodeBokehImage, catadioptric)
	FLOAT_PROPERTY(CompositorNodeBokehImage, shift)

	inline bool CompositorNodeBokehImage::is_registered_node_type() {
		return CompositorNodeBokehImage_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeBokehImage::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeBokehImage_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeBokehImage::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeBokehImage_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	BOOLEAN_PROPERTY(CompositorNodeBokehBlur, use_variable_size)
	BOOLEAN_PROPERTY(CompositorNodeBokehBlur, use_extended_bounds)
	FLOAT_PROPERTY(CompositorNodeBokehBlur, blur_max)

	inline bool CompositorNodeBokehBlur::is_registered_node_type() {
		return CompositorNodeBokehBlur_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeBokehBlur::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeBokehBlur_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeBokehBlur::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeBokehBlur_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	BOOLEAN_PROPERTY(CompositorNodeSwitch, check)

	inline bool CompositorNodeSwitch::is_registered_node_type() {
		return CompositorNodeSwitch_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeSwitch::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeSwitch_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeSwitch::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeSwitch_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool CompositorNodeSwitchView::is_registered_node_type() {
		return CompositorNodeSwitchView_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeSwitchView::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeSwitchView_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeSwitchView::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeSwitchView_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	BOOLEAN_PROPERTY(CompositorNodeColorCorrection, red)
	BOOLEAN_PROPERTY(CompositorNodeColorCorrection, green)
	BOOLEAN_PROPERTY(CompositorNodeColorCorrection, blue)
	FLOAT_PROPERTY(CompositorNodeColorCorrection, midtones_start)
	FLOAT_PROPERTY(CompositorNodeColorCorrection, midtones_end)
	FLOAT_PROPERTY(CompositorNodeColorCorrection, master_saturation)
	FLOAT_PROPERTY(CompositorNodeColorCorrection, master_contrast)
	FLOAT_PROPERTY(CompositorNodeColorCorrection, master_gamma)
	FLOAT_PROPERTY(CompositorNodeColorCorrection, master_gain)
	FLOAT_PROPERTY(CompositorNodeColorCorrection, master_lift)
	FLOAT_PROPERTY(CompositorNodeColorCorrection, shadows_saturation)
	FLOAT_PROPERTY(CompositorNodeColorCorrection, shadows_contrast)
	FLOAT_PROPERTY(CompositorNodeColorCorrection, shadows_gamma)
	FLOAT_PROPERTY(CompositorNodeColorCorrection, shadows_gain)
	FLOAT_PROPERTY(CompositorNodeColorCorrection, shadows_lift)
	FLOAT_PROPERTY(CompositorNodeColorCorrection, midtones_saturation)
	FLOAT_PROPERTY(CompositorNodeColorCorrection, midtones_contrast)
	FLOAT_PROPERTY(CompositorNodeColorCorrection, midtones_gamma)
	FLOAT_PROPERTY(CompositorNodeColorCorrection, midtones_gain)
	FLOAT_PROPERTY(CompositorNodeColorCorrection, midtones_lift)
	FLOAT_PROPERTY(CompositorNodeColorCorrection, highlights_saturation)
	FLOAT_PROPERTY(CompositorNodeColorCorrection, highlights_contrast)
	FLOAT_PROPERTY(CompositorNodeColorCorrection, highlights_gamma)
	FLOAT_PROPERTY(CompositorNodeColorCorrection, highlights_gain)
	FLOAT_PROPERTY(CompositorNodeColorCorrection, highlights_lift)

	inline bool CompositorNodeColorCorrection::is_registered_node_type() {
		return CompositorNodeColorCorrection_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeColorCorrection::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeColorCorrection_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeColorCorrection::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeColorCorrection_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	POINTER_PROPERTY(Mask, CompositorNodeMask, mask)
	BOOLEAN_PROPERTY(CompositorNodeMask, use_feather)
	BOOLEAN_PROPERTY(CompositorNodeMask, use_motion_blur)
	INT_PROPERTY(CompositorNodeMask, motion_blur_samples)
	FLOAT_PROPERTY(CompositorNodeMask, motion_blur_shutter)
	ENUM_PROPERTY(size_source_enum, CompositorNodeMask, size_source)
	INT_PROPERTY(CompositorNodeMask, size_x)
	INT_PROPERTY(CompositorNodeMask, size_y)

	inline bool CompositorNodeMask::is_registered_node_type() {
		return CompositorNodeMask_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeMask::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeMask_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeMask::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeMask_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	POINTER_PROPERTY(MovieClip, CompositorNodeKeyingScreen, clip)
	STRING_PROPERTY(CompositorNodeKeyingScreen, tracking_object)

	inline bool CompositorNodeKeyingScreen::is_registered_node_type() {
		return CompositorNodeKeyingScreen_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeKeyingScreen::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeKeyingScreen_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeKeyingScreen::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeKeyingScreen_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	FLOAT_PROPERTY(CompositorNodeKeying, screen_balance)
	FLOAT_PROPERTY(CompositorNodeKeying, despill_factor)
	FLOAT_PROPERTY(CompositorNodeKeying, despill_balance)
	FLOAT_PROPERTY(CompositorNodeKeying, clip_black)
	FLOAT_PROPERTY(CompositorNodeKeying, clip_white)
	INT_PROPERTY(CompositorNodeKeying, blur_pre)
	INT_PROPERTY(CompositorNodeKeying, blur_post)
	INT_PROPERTY(CompositorNodeKeying, dilate_distance)
	INT_PROPERTY(CompositorNodeKeying, edge_kernel_radius)
	FLOAT_PROPERTY(CompositorNodeKeying, edge_kernel_tolerance)
	ENUM_PROPERTY(feather_falloff_enum, CompositorNodeKeying, feather_falloff)
	INT_PROPERTY(CompositorNodeKeying, feather_distance)

	inline bool CompositorNodeKeying::is_registered_node_type() {
		return CompositorNodeKeying_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeKeying::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeKeying_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeKeying::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeKeying_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	POINTER_PROPERTY(MovieClip, CompositorNodeTrackPos, clip)
	ENUM_PROPERTY(position_enum, CompositorNodeTrackPos, position)
	INT_PROPERTY(CompositorNodeTrackPos, frame_relative)
	STRING_PROPERTY(CompositorNodeTrackPos, tracking_object)
	STRING_PROPERTY(CompositorNodeTrackPos, track_name)

	inline bool CompositorNodeTrackPos::is_registered_node_type() {
		return CompositorNodeTrackPos_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeTrackPos::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeTrackPos_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeTrackPos::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeTrackPos_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool CompositorNodePixelate::is_registered_node_type() {
		return CompositorNodePixelate_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodePixelate::input_template(int index) {
		PointerRNA result;
		result = CompositorNodePixelate_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodePixelate::output_template(int index) {
		PointerRNA result;
		result = CompositorNodePixelate_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	POINTER_PROPERTY(MovieClip, CompositorNodePlaneTrackDeform, clip)
	STRING_PROPERTY(CompositorNodePlaneTrackDeform, tracking_object)
	STRING_PROPERTY(CompositorNodePlaneTrackDeform, plane_track_name)
	BOOLEAN_PROPERTY(CompositorNodePlaneTrackDeform, use_motion_blur)
	INT_PROPERTY(CompositorNodePlaneTrackDeform, motion_blur_samples)
	FLOAT_PROPERTY(CompositorNodePlaneTrackDeform, motion_blur_shutter)

	inline bool CompositorNodePlaneTrackDeform::is_registered_node_type() {
		return CompositorNodePlaneTrackDeform_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodePlaneTrackDeform::input_template(int index) {
		PointerRNA result;
		result = CompositorNodePlaneTrackDeform_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodePlaneTrackDeform::output_template(int index) {
		PointerRNA result;
		result = CompositorNodePlaneTrackDeform_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool CompositorNodeCornerPin::is_registered_node_type() {
		return CompositorNodeCornerPin_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeCornerPin::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeCornerPin_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeCornerPin::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeCornerPin_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	FLOAT_ARRAY_PROPERTY(CompositorNodeSunBeams, 2, source)
	FLOAT_PROPERTY(CompositorNodeSunBeams, ray_length)

	inline bool CompositorNodeSunBeams::is_registered_node_type() {
		return CompositorNodeSunBeams_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeSunBeams::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeSunBeams_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeSunBeams::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeSunBeams_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	STRING_PROPERTY(CompositorNodeCryptomatte, matte_id)
	FLOAT_ARRAY_PROPERTY(CompositorNodeCryptomatte, 3, add)
	FLOAT_ARRAY_PROPERTY(CompositorNodeCryptomatte, 3, remove)

	inline bool CompositorNodeCryptomatte::is_registered_node_type() {
		return CompositorNodeCryptomatte_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeCryptomatte::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeCryptomatte_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeCryptomatte::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeCryptomatte_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	STRING_PROPERTY(TextureNodeOutput, filepath)

	inline bool TextureNodeOutput::is_registered_node_type() {
		return TextureNodeOutput_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate TextureNodeOutput::input_template(int index) {
		PointerRNA result;
		result = TextureNodeOutput_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate TextureNodeOutput::output_template(int index) {
		PointerRNA result;
		result = TextureNodeOutput_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool TextureNodeChecker::is_registered_node_type() {
		return TextureNodeChecker_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate TextureNodeChecker::input_template(int index) {
		PointerRNA result;
		result = TextureNodeChecker_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate TextureNodeChecker::output_template(int index) {
		PointerRNA result;
		result = TextureNodeChecker_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	POINTER_PROPERTY(Texture, TextureNodeTexture, texture)
	INT_PROPERTY(TextureNodeTexture, node_output)

	inline bool TextureNodeTexture::is_registered_node_type() {
		return TextureNodeTexture_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate TextureNodeTexture::input_template(int index) {
		PointerRNA result;
		result = TextureNodeTexture_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate TextureNodeTexture::output_template(int index) {
		PointerRNA result;
		result = TextureNodeTexture_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	FLOAT_PROPERTY(TextureNodeBricks, offset)
	INT_PROPERTY(TextureNodeBricks, offset_frequency)
	FLOAT_PROPERTY(TextureNodeBricks, squash)
	INT_PROPERTY(TextureNodeBricks, squash_frequency)

	inline bool TextureNodeBricks::is_registered_node_type() {
		return TextureNodeBricks_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate TextureNodeBricks::input_template(int index) {
		PointerRNA result;
		result = TextureNodeBricks_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate TextureNodeBricks::output_template(int index) {
		PointerRNA result;
		result = TextureNodeBricks_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	ENUM_PROPERTY(operation_enum, TextureNodeMath, operation)
	BOOLEAN_PROPERTY(TextureNodeMath, use_clamp)

	inline bool TextureNodeMath::is_registered_node_type() {
		return TextureNodeMath_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate TextureNodeMath::input_template(int index) {
		PointerRNA result;
		result = TextureNodeMath_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate TextureNodeMath::output_template(int index) {
		PointerRNA result;
		result = TextureNodeMath_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	ENUM_PROPERTY(blend_type_enum, TextureNodeMixRGB, blend_type)
	BOOLEAN_PROPERTY(TextureNodeMixRGB, use_alpha)
	BOOLEAN_PROPERTY(TextureNodeMixRGB, use_clamp)

	inline bool TextureNodeMixRGB::is_registered_node_type() {
		return TextureNodeMixRGB_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate TextureNodeMixRGB::input_template(int index) {
		PointerRNA result;
		result = TextureNodeMixRGB_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate TextureNodeMixRGB::output_template(int index) {
		PointerRNA result;
		result = TextureNodeMixRGB_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool TextureNodeRGBToBW::is_registered_node_type() {
		return TextureNodeRGBToBW_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate TextureNodeRGBToBW::input_template(int index) {
		PointerRNA result;
		result = TextureNodeRGBToBW_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate TextureNodeRGBToBW::output_template(int index) {
		PointerRNA result;
		result = TextureNodeRGBToBW_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	POINTER_PROPERTY(ColorRamp, TextureNodeValToRGB, color_ramp)

	inline bool TextureNodeValToRGB::is_registered_node_type() {
		return TextureNodeValToRGB_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate TextureNodeValToRGB::input_template(int index) {
		PointerRNA result;
		result = TextureNodeValToRGB_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate TextureNodeValToRGB::output_template(int index) {
		PointerRNA result;
		result = TextureNodeValToRGB_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	POINTER_PROPERTY(Image, TextureNodeImage, image)
	POINTER_PROPERTY(ImageUser, TextureNodeImage, image_user)

	inline bool TextureNodeImage::is_registered_node_type() {
		return TextureNodeImage_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate TextureNodeImage::input_template(int index) {
		PointerRNA result;
		result = TextureNodeImage_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate TextureNodeImage::output_template(int index) {
		PointerRNA result;
		result = TextureNodeImage_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	POINTER_PROPERTY(CurveMapping, TextureNodeCurveRGB, mapping)

	inline bool TextureNodeCurveRGB::is_registered_node_type() {
		return TextureNodeCurveRGB_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate TextureNodeCurveRGB::input_template(int index) {
		PointerRNA result;
		result = TextureNodeCurveRGB_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate TextureNodeCurveRGB::output_template(int index) {
		PointerRNA result;
		result = TextureNodeCurveRGB_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool TextureNodeInvert::is_registered_node_type() {
		return TextureNodeInvert_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate TextureNodeInvert::input_template(int index) {
		PointerRNA result;
		result = TextureNodeInvert_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate TextureNodeInvert::output_template(int index) {
		PointerRNA result;
		result = TextureNodeInvert_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool TextureNodeHueSaturation::is_registered_node_type() {
		return TextureNodeHueSaturation_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate TextureNodeHueSaturation::input_template(int index) {
		PointerRNA result;
		result = TextureNodeHueSaturation_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate TextureNodeHueSaturation::output_template(int index) {
		PointerRNA result;
		result = TextureNodeHueSaturation_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	POINTER_PROPERTY(CurveMapping, TextureNodeCurveTime, curve)
	INT_PROPERTY(TextureNodeCurveTime, frame_start)
	INT_PROPERTY(TextureNodeCurveTime, frame_end)

	inline bool TextureNodeCurveTime::is_registered_node_type() {
		return TextureNodeCurveTime_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate TextureNodeCurveTime::input_template(int index) {
		PointerRNA result;
		result = TextureNodeCurveTime_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate TextureNodeCurveTime::output_template(int index) {
		PointerRNA result;
		result = TextureNodeCurveTime_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool TextureNodeRotate::is_registered_node_type() {
		return TextureNodeRotate_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate TextureNodeRotate::input_template(int index) {
		PointerRNA result;
		result = TextureNodeRotate_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate TextureNodeRotate::output_template(int index) {
		PointerRNA result;
		result = TextureNodeRotate_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool TextureNodeViewer::is_registered_node_type() {
		return TextureNodeViewer_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate TextureNodeViewer::input_template(int index) {
		PointerRNA result;
		result = TextureNodeViewer_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate TextureNodeViewer::output_template(int index) {
		PointerRNA result;
		result = TextureNodeViewer_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool TextureNodeTranslate::is_registered_node_type() {
		return TextureNodeTranslate_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate TextureNodeTranslate::input_template(int index) {
		PointerRNA result;
		result = TextureNodeTranslate_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate TextureNodeTranslate::output_template(int index) {
		PointerRNA result;
		result = TextureNodeTranslate_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool TextureNodeCoordinates::is_registered_node_type() {
		return TextureNodeCoordinates_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate TextureNodeCoordinates::input_template(int index) {
		PointerRNA result;
		result = TextureNodeCoordinates_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate TextureNodeCoordinates::output_template(int index) {
		PointerRNA result;
		result = TextureNodeCoordinates_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool TextureNodeDistance::is_registered_node_type() {
		return TextureNodeDistance_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate TextureNodeDistance::input_template(int index) {
		PointerRNA result;
		result = TextureNodeDistance_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate TextureNodeDistance::output_template(int index) {
		PointerRNA result;
		result = TextureNodeDistance_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool TextureNodeCompose::is_registered_node_type() {
		return TextureNodeCompose_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate TextureNodeCompose::input_template(int index) {
		PointerRNA result;
		result = TextureNodeCompose_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate TextureNodeCompose::output_template(int index) {
		PointerRNA result;
		result = TextureNodeCompose_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool TextureNodeDecompose::is_registered_node_type() {
		return TextureNodeDecompose_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate TextureNodeDecompose::input_template(int index) {
		PointerRNA result;
		result = TextureNodeDecompose_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate TextureNodeDecompose::output_template(int index) {
		PointerRNA result;
		result = TextureNodeDecompose_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool TextureNodeValToNor::is_registered_node_type() {
		return TextureNodeValToNor_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate TextureNodeValToNor::input_template(int index) {
		PointerRNA result;
		result = TextureNodeValToNor_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate TextureNodeValToNor::output_template(int index) {
		PointerRNA result;
		result = TextureNodeValToNor_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool TextureNodeScale::is_registered_node_type() {
		return TextureNodeScale_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate TextureNodeScale::input_template(int index) {
		PointerRNA result;
		result = TextureNodeScale_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate TextureNodeScale::output_template(int index) {
		PointerRNA result;
		result = TextureNodeScale_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool TextureNodeAt::is_registered_node_type() {
		return TextureNodeAt_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate TextureNodeAt::input_template(int index) {
		PointerRNA result;
		result = TextureNodeAt_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate TextureNodeAt::output_template(int index) {
		PointerRNA result;
		result = TextureNodeAt_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool TextureNodeTexVoronoi::is_registered_node_type() {
		return TextureNodeTexVoronoi_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate TextureNodeTexVoronoi::input_template(int index) {
		PointerRNA result;
		result = TextureNodeTexVoronoi_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate TextureNodeTexVoronoi::output_template(int index) {
		PointerRNA result;
		result = TextureNodeTexVoronoi_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool TextureNodeTexBlend::is_registered_node_type() {
		return TextureNodeTexBlend_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate TextureNodeTexBlend::input_template(int index) {
		PointerRNA result;
		result = TextureNodeTexBlend_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate TextureNodeTexBlend::output_template(int index) {
		PointerRNA result;
		result = TextureNodeTexBlend_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool TextureNodeTexMagic::is_registered_node_type() {
		return TextureNodeTexMagic_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate TextureNodeTexMagic::input_template(int index) {
		PointerRNA result;
		result = TextureNodeTexMagic_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate TextureNodeTexMagic::output_template(int index) {
		PointerRNA result;
		result = TextureNodeTexMagic_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool TextureNodeTexMarble::is_registered_node_type() {
		return TextureNodeTexMarble_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate TextureNodeTexMarble::input_template(int index) {
		PointerRNA result;
		result = TextureNodeTexMarble_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate TextureNodeTexMarble::output_template(int index) {
		PointerRNA result;
		result = TextureNodeTexMarble_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool TextureNodeTexClouds::is_registered_node_type() {
		return TextureNodeTexClouds_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate TextureNodeTexClouds::input_template(int index) {
		PointerRNA result;
		result = TextureNodeTexClouds_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate TextureNodeTexClouds::output_template(int index) {
		PointerRNA result;
		result = TextureNodeTexClouds_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool TextureNodeTexWood::is_registered_node_type() {
		return TextureNodeTexWood_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate TextureNodeTexWood::input_template(int index) {
		PointerRNA result;
		result = TextureNodeTexWood_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate TextureNodeTexWood::output_template(int index) {
		PointerRNA result;
		result = TextureNodeTexWood_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool TextureNodeTexMusgrave::is_registered_node_type() {
		return TextureNodeTexMusgrave_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate TextureNodeTexMusgrave::input_template(int index) {
		PointerRNA result;
		result = TextureNodeTexMusgrave_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate TextureNodeTexMusgrave::output_template(int index) {
		PointerRNA result;
		result = TextureNodeTexMusgrave_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool TextureNodeTexNoise::is_registered_node_type() {
		return TextureNodeTexNoise_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate TextureNodeTexNoise::input_template(int index) {
		PointerRNA result;
		result = TextureNodeTexNoise_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate TextureNodeTexNoise::output_template(int index) {
		PointerRNA result;
		result = TextureNodeTexNoise_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool TextureNodeTexStucci::is_registered_node_type() {
		return TextureNodeTexStucci_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate TextureNodeTexStucci::input_template(int index) {
		PointerRNA result;
		result = TextureNodeTexStucci_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate TextureNodeTexStucci::output_template(int index) {
		PointerRNA result;
		result = TextureNodeTexStucci_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool TextureNodeTexDistNoise::is_registered_node_type() {
		return TextureNodeTexDistNoise_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate TextureNodeTexDistNoise::input_template(int index) {
		PointerRNA result;
		result = TextureNodeTexDistNoise_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate TextureNodeTexDistNoise::output_template(int index) {
		PointerRNA result;
		result = TextureNodeTexDistNoise_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	POINTER_PROPERTY(NodeTree, ShaderNodeGroup, node_tree)

	inline bool ShaderNodeGroup::is_registered_node_type() {
		return ShaderNodeGroup_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeGroup::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeGroup_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeGroup::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeGroup_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	POINTER_PROPERTY(NodeTree, CompositorNodeGroup, node_tree)

	inline bool CompositorNodeGroup::is_registered_node_type() {
		return CompositorNodeGroup_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeGroup::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeGroup_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeGroup::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeGroup_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	POINTER_PROPERTY(NodeTree, TextureNodeGroup, node_tree)

	inline bool TextureNodeGroup::is_registered_node_type() {
		return TextureNodeGroup_is_registered_node_type(this->ptr.type);
	}

	inline NodeInternalSocketTemplate TextureNodeGroup::input_template(int index) {
		PointerRNA result;
		result = TextureNodeGroup_input_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate TextureNodeGroup::output_template(int index) {
		PointerRNA result;
		result = TextureNodeGroup_output_template(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	POINTER_PROPERTY(NodeTree, ShaderNodeCustomGroup, node_tree)


	POINTER_PROPERTY(NodeTree, CompositorNodeCustomGroup, node_tree)


	POINTER_PROPERTY(NodeTree, NodeCustomGroup, node_tree)


	POINTER_PROPERTY(Struct, NodeOutputFileSlotFile, rna_type)
	BOOLEAN_PROPERTY(NodeOutputFileSlotFile, use_node_format)
	POINTER_PROPERTY(ImageFormatSettings, NodeOutputFileSlotFile, format)
	STRING_PROPERTY(NodeOutputFileSlotFile, path)


	POINTER_PROPERTY(Struct, NodeOutputFileSlotLayer, rna_type)
	STRING_PROPERTY(NodeOutputFileSlotLayer, name)


	POINTER_PROPERTY(Struct, NodeInstanceHash, rna_type)


	POINTER_PROPERTY(ID, Object, data)
	ENUM_PROPERTY(type_enum, Object, type)
	ENUM_PROPERTY(mode_enum, Object, mode)
	FLOAT_ARRAY_PROPERTY(Object, 24, bound_box)
	POINTER_PROPERTY(Object, Object, parent)
	ENUM_PROPERTY(parent_type_enum, Object, parent_type)
	INT_ARRAY_PROPERTY(Object, 3, parent_vertices)
	STRING_PROPERTY(Object, parent_bone)
	ENUM_PROPERTY(track_axis_enum, Object, track_axis)
	ENUM_PROPERTY(up_axis_enum, Object, up_axis)
	POINTER_PROPERTY(Object, Object, proxy)
	POINTER_PROPERTY(Object, Object, proxy_collection)

	POINTER_PROPERTY(Material, Object, active_material)
	INT_PROPERTY(Object, active_material_index)
	FLOAT_ARRAY_PROPERTY(Object, 3, location)
	FLOAT_ARRAY_PROPERTY(Object, 4, rotation_quaternion)
	FLOAT_ARRAY_PROPERTY(Object, 4, rotation_axis_angle)
	FLOAT_ARRAY_PROPERTY(Object, 3, rotation_euler)
	ENUM_PROPERTY(rotation_mode_enum, Object, rotation_mode)
	FLOAT_ARRAY_PROPERTY(Object, 3, scale)
	FLOAT_ARRAY_PROPERTY(Object, 3, dimensions)
	FLOAT_ARRAY_PROPERTY(Object, 3, delta_location)
	FLOAT_ARRAY_PROPERTY(Object, 3, delta_rotation_euler)
	FLOAT_ARRAY_PROPERTY(Object, 4, delta_rotation_quaternion)
	FLOAT_ARRAY_PROPERTY(Object, 3, delta_scale)
	BOOLEAN_ARRAY_PROPERTY(Object, 3, lock_location)
	BOOLEAN_ARRAY_PROPERTY(Object, 3, lock_rotation)
	BOOLEAN_PROPERTY(Object, lock_rotation_w)
	BOOLEAN_PROPERTY(Object, lock_rotations_4d)
	BOOLEAN_ARRAY_PROPERTY(Object, 3, lock_scale)
	FLOAT_ARRAY_PROPERTY(Object, 16, matrix_world)
	FLOAT_ARRAY_PROPERTY(Object, 16, matrix_local)
	FLOAT_ARRAY_PROPERTY(Object, 16, matrix_basis)
	FLOAT_ARRAY_PROPERTY(Object, 16, matrix_parent_inverse)






	ENUM_PROPERTY(empty_display_type_enum, Object, empty_display_type)
	FLOAT_PROPERTY(Object, empty_display_size)
	FLOAT_ARRAY_PROPERTY(Object, 2, empty_image_offset)
	POINTER_PROPERTY(ImageUser, Object, image_user)
	ENUM_PROPERTY(empty_image_depth_enum, Object, empty_image_depth)
	BOOLEAN_PROPERTY(Object, show_empty_image_perspective)
	BOOLEAN_PROPERTY(Object, show_empty_image_orthographic)
	BOOLEAN_PROPERTY(Object, use_empty_image_alpha)
	ENUM_PROPERTY(empty_image_side_enum, Object, empty_image_side)
	INT_PROPERTY(Object, pass_index)
	FLOAT_ARRAY_PROPERTY(Object, 4, color)
	POINTER_PROPERTY(FieldSettings, Object, field)
	POINTER_PROPERTY(CollisionSettings, Object, collision)
	POINTER_PROPERTY(SoftBodySettings, Object, soft_body)

	POINTER_PROPERTY(RigidBodyObject, Object, rigid_body)
	POINTER_PROPERTY(RigidBodyConstraint, Object, rigid_body_constraint)
	BOOLEAN_PROPERTY(Object, hide_viewport)
	BOOLEAN_PROPERTY(Object, hide_select)
	BOOLEAN_PROPERTY(Object, hide_render)
	BOOLEAN_PROPERTY(Object, show_instancer_for_render)
	BOOLEAN_PROPERTY(Object, show_instancer_for_viewport)
	POINTER_PROPERTY(AnimData, Object, animation_data)
	POINTER_PROPERTY(AnimViz, Object, animation_visualization)
	POINTER_PROPERTY(MotionPath, Object, motion_path)
	ENUM_PROPERTY(instance_type_enum, Object, instance_type)
	BOOLEAN_PROPERTY(Object, use_instance_vertices_rotation)
	BOOLEAN_PROPERTY(Object, use_instance_faces_scale)
	FLOAT_PROPERTY(Object, instance_faces_scale)
	POINTER_PROPERTY(Collection, Object, instance_collection)
	BOOLEAN_PROPERTY(Object, is_instancer)
	ENUM_PROPERTY(display_type_enum, Object, display_type)
	BOOLEAN_PROPERTY(Object, show_bounds)
	ENUM_PROPERTY(display_bounds_type_enum, Object, display_bounds_type)
	BOOLEAN_PROPERTY(Object, show_name)
	BOOLEAN_PROPERTY(Object, show_axis)
	BOOLEAN_PROPERTY(Object, show_texture_space)
	BOOLEAN_PROPERTY(Object, show_wire)
	BOOLEAN_PROPERTY(Object, show_all_edges)
	BOOLEAN_PROPERTY(Object, show_transparent)
	BOOLEAN_PROPERTY(Object, show_in_front)
	POINTER_PROPERTY(GreasePencil, Object, grease_pencil)
	POINTER_PROPERTY(Action, Object, pose_library)
	POINTER_PROPERTY(Pose, Object, pose)
	BOOLEAN_PROPERTY(Object, show_only_shape_key)
	BOOLEAN_PROPERTY(Object, use_shape_key_edit_mode)
	POINTER_PROPERTY(ShapeKey, Object, active_shape_key)
	INT_PROPERTY(Object, active_shape_key_index)
	BOOLEAN_PROPERTY(Object, use_dynamic_topology_sculpting)
	BOOLEAN_PROPERTY(Object, is_from_instancer)
	BOOLEAN_PROPERTY(Object, is_from_set)
	POINTER_PROPERTY(ObjectDisplay, Object, display)

	inline bool Object::select_get(Context C, ViewLayer& view_layer) {
		return Object_select_get((::Object *) this->ptr.data, (::bContext *) C.ptr.data, NULL, (::ViewLayer *) view_layer.ptr.data);
	}

	inline void Object::select_set(Context C, bool state, ViewLayer& view_layer) {
		Object_select_set((::Object *) this->ptr.data, (::bContext *) C.ptr.data, NULL, state, (::ViewLayer *) view_layer.ptr.data);
	}

	inline bool Object::hide_get(Context C, ViewLayer& view_layer) {
		return Object_hide_get((::Object *) this->ptr.data, (::bContext *) C.ptr.data, NULL, (::ViewLayer *) view_layer.ptr.data);
	}

	inline void Object::hide_set(Context C, bool state, ViewLayer& view_layer) {
		Object_hide_set((::Object *) this->ptr.data, (::bContext *) C.ptr.data, NULL, state, (::ViewLayer *) view_layer.ptr.data);
	}

	inline bool Object::visible_get(Context C, ViewLayer& view_layer, SpaceView3D& viewport) {
		return Object_visible_get((::Object *) this->ptr.data, (::bContext *) C.ptr.data, NULL, (::ViewLayer *) view_layer.ptr.data, (::View3D *) viewport.ptr.data);
	}

	inline bool Object::holdout_get(Context C, ViewLayer& view_layer) {
		return Object_holdout_get((::Object *) this->ptr.data, (::bContext *) C.ptr.data, NULL, (::ViewLayer *) view_layer.ptr.data);
	}

	inline bool Object::indirect_only_get(Context C, ViewLayer& view_layer) {
		return Object_indirect_only_get((::Object *) this->ptr.data, (::bContext *) C.ptr.data, NULL, (::ViewLayer *) view_layer.ptr.data);
	}

	inline bool Object::local_view_get(SpaceView3D& viewport) {
		return Object_local_view_get((::Object *) this->ptr.data, NULL, (::PointerRNA *) viewport.ptr.data);
	}

	inline void Object::local_view_set(SpaceView3D& viewport, bool state) {
		Object_local_view_set((::Object *) this->ptr.data, NULL, (::PointerRNA *) viewport.ptr.data, state);
	}

	inline void Object::convert_space(PoseBone& pose_bone, float matrix[16], float matrix_return[16], int from_space, int to_space) {
		Object_convert_space((::Object *) this->ptr.data, NULL, (::bPoseChannel *) pose_bone.ptr.data, matrix, matrix_return, from_space, to_space);
	}

	inline void Object::calc_matrix_camera(Depsgraph& depsgraph, float result[16], int x, int y, float scale_x, float scale_y) {
		Object_calc_matrix_camera((::Object *) this->ptr.data, (::Depsgraph *) depsgraph.ptr.data, result, x, y, scale_x, scale_y);
	}

	inline void Object::camera_fit_coords(Depsgraph& depsgraph, int coordinates_len, float *coordinates, float coord_return[3], float *scale_return) {
		Object_camera_fit_coords((::Object *) this->ptr.data, (::Depsgraph *) depsgraph.ptr.data, coordinates_len, coordinates, coord_return, scale_return);
	}

	inline Mesh Object::to_mesh(Context C, Depsgraph& depsgraph, bool apply_modifiers, bool calc_undeformed) {
		PointerRNA result;
		::Mesh *retdata = Object_to_mesh((::Object *) this->ptr.data, (::bContext *) C.ptr.data, NULL, (::Depsgraph *) depsgraph.ptr.data, apply_modifiers, calc_undeformed);
		RNA_id_pointer_create((::ID *) retdata, &result);
		return Mesh(result);
	}

	inline Object Object::find_armature() {
		PointerRNA result;
		::Object *retdata = Object_find_armature((::Object *) this->ptr.data);
		RNA_id_pointer_create((::ID *) retdata, &result);
		return Object(result);
	}

	inline ShapeKey Object::shape_key_add(Context C, const char * name, bool from_mix) {
		PointerRNA result;
		result = Object_shape_key_add((::Object *) this->ptr.data, (::bContext *) C.ptr.data, NULL, name, from_mix);
		return ShapeKey(result);
	}

	inline void Object::shape_key_remove(void *main, ShapeKey& key) {
		Object_shape_key_remove((::Object *) this->ptr.data, (::Main *) main, NULL, (::PointerRNA *) &key.ptr);
	}

	inline void Object::ray_cast(Context C, float origin[3], float direction[3], float distance, Depsgraph& depsgraph, bool *result, float location[3], float normal[3], int *index) {
		Object_ray_cast((::Object *) this->ptr.data, (::bContext *) C.ptr.data, NULL, origin, direction, distance, (::PointerRNA *) depsgraph.ptr.data, result, location, normal, index);
	}

	inline void Object::closest_point_on_mesh(Context C, float origin[3], float distance, Depsgraph& depsgraph, bool *result, float location[3], float normal[3], int *index) {
		Object_closest_point_on_mesh((::Object *) this->ptr.data, (::bContext *) C.ptr.data, NULL, origin, distance, (::PointerRNA *) depsgraph.ptr.data, result, location, normal, index);
	}

	inline bool Object::is_modified(Scene& scene, int settings) {
		return Object_is_modified((::Object *) this->ptr.data, (::Scene *) scene.ptr.data, settings);
	}

	inline bool Object::is_deform_modified(Scene& scene, int settings) {
		return Object_is_deform_modified((::Object *) this->ptr.data, (::Scene *) scene.ptr.data, settings);
	}

	inline bool Object::update_from_editmode(void *main) {
		return Object_update_from_editmode((::Object *) this->ptr.data, (::Main *) main);
	}

	inline void Object::cache_release() {
		Object_cache_release((::Object *) this->ptr.data);
	}


	POINTER_PROPERTY(Struct, ObjectModifiers, rna_type)

	inline Modifier ObjectModifiers::create(Context C, const char * name, int type) {
		PointerRNA result;
		::ModifierData *retdata = ObjectModifiers_new((::Object *) this->ptr.data, (::bContext *) C.ptr.data, NULL, name, type);
		RNA_pointer_create((::ID *) ptr.id.data, &RNA_Modifier, retdata, &result);
		return Modifier(result);
	}

	inline void ObjectModifiers::remove(Context C, Modifier& modifier) {
		ObjectModifiers_remove((::Object *) this->ptr.data, (::bContext *) C.ptr.data, NULL, (::PointerRNA *) &modifier.ptr);
	}

	inline void ObjectModifiers::clear(Context C) {
		ObjectModifiers_clear((::Object *) this->ptr.data, (::bContext *) C.ptr.data);
	}


	POINTER_PROPERTY(Struct, ObjectGpencilModifiers, rna_type)

	inline GpencilModifier ObjectGpencilModifiers::create(Context C, const char * name, int type) {
		PointerRNA result;
		::GpencilModifierData *retdata = ObjectGpencilModifiers_new((::Object *) this->ptr.data, (::bContext *) C.ptr.data, NULL, name, type);
		RNA_pointer_create((::ID *) ptr.id.data, &RNA_GpencilModifier, retdata, &result);
		return GpencilModifier(result);
	}

	inline void ObjectGpencilModifiers::remove(Context C, GpencilModifier& greasepencil_modifier) {
		ObjectGpencilModifiers_remove((::Object *) this->ptr.data, (::bContext *) C.ptr.data, NULL, (::PointerRNA *) &greasepencil_modifier.ptr);
	}

	inline void ObjectGpencilModifiers::clear(Context C) {
		ObjectGpencilModifiers_clear((::Object *) this->ptr.data, (::bContext *) C.ptr.data);
	}


	POINTER_PROPERTY(Struct, ObjectShaderFx, rna_type)

	inline ShaderFx ObjectShaderFx::create(Context C, const char * name, int type) {
		PointerRNA result;
		::ShaderFxData *retdata = ObjectShaderFx_new((::Object *) this->ptr.data, (::bContext *) C.ptr.data, NULL, name, type);
		RNA_pointer_create((::ID *) ptr.id.data, &RNA_ShaderFx, retdata, &result);
		return ShaderFx(result);
	}

	inline void ObjectShaderFx::remove(Context C, ShaderFx& shader_fx) {
		ObjectShaderFx_remove((::Object *) this->ptr.data, (::bContext *) C.ptr.data, NULL, (::PointerRNA *) &shader_fx.ptr);
	}

	inline void ObjectShaderFx::clear(Context C) {
		ObjectShaderFx_clear((::Object *) this->ptr.data, (::bContext *) C.ptr.data);
	}


	POINTER_PROPERTY(Struct, ObjectConstraints, rna_type)
	POINTER_PROPERTY(Constraint, ObjectConstraints, active)

	inline Constraint ObjectConstraints::create(void *main, int type) {
		PointerRNA result;
		::bConstraint *retdata = ObjectConstraints_new((::Object *) this->ptr.data, (::Main *) main, type);
		RNA_pointer_create((::ID *) ptr.id.data, &RNA_Constraint, retdata, &result);
		return Constraint(result);
	}

	inline void ObjectConstraints::remove(void *main, Constraint& constraint) {
		ObjectConstraints_remove((::Object *) this->ptr.data, (::Main *) main, NULL, (::PointerRNA *) &constraint.ptr);
	}

	inline void ObjectConstraints::clear(void *main) {
		ObjectConstraints_clear((::Object *) this->ptr.data, (::Main *) main);
	}


	POINTER_PROPERTY(Struct, VertexGroups, rna_type)
	POINTER_PROPERTY(VertexGroup, VertexGroups, active)
	INT_PROPERTY(VertexGroups, active_index)

	inline VertexGroup VertexGroups::create(const char * name) {
		PointerRNA result;
		::bDeformGroup *retdata = VertexGroups_new((::Object *) this->ptr.data, name);
		RNA_pointer_create((::ID *) ptr.id.data, &RNA_VertexGroup, retdata, &result);
		return VertexGroup(result);
	}

	inline void VertexGroups::remove(VertexGroup& group) {
		VertexGroups_remove((::Object *) this->ptr.data, NULL, (::PointerRNA *) &group.ptr);
	}

	inline void VertexGroups::clear() {
		VertexGroups_clear((::Object *) this->ptr.data);
	}


	POINTER_PROPERTY(Struct, FaceMaps, rna_type)
	POINTER_PROPERTY(FaceMap, FaceMaps, active)
	INT_PROPERTY(FaceMaps, active_index)

	inline FaceMap FaceMaps::create(const char * name) {
		PointerRNA result;
		::bFaceMap *retdata = FaceMaps_new((::Object *) this->ptr.data, name);
		RNA_pointer_create((::ID *) ptr.id.data, &RNA_FaceMap, retdata, &result);
		return FaceMap(result);
	}

	inline void FaceMaps::remove(FaceMap& group) {
		FaceMaps_remove((::Object *) this->ptr.data, NULL, (::PointerRNA *) &group.ptr);
	}

	inline void FaceMaps::clear() {
		FaceMaps_clear((::Object *) this->ptr.data);
	}


	POINTER_PROPERTY(Struct, ParticleSystems, rna_type)
	POINTER_PROPERTY(ParticleSystem, ParticleSystems, active)
	INT_PROPERTY(ParticleSystems, active_index)


	POINTER_PROPERTY(Struct, VertexGroup, rna_type)
	STRING_PROPERTY(VertexGroup, name)
	BOOLEAN_PROPERTY(VertexGroup, lock_weight)
	INT_PROPERTY(VertexGroup, index)

	inline void VertexGroup::add(int index_len, int *index, float weight, int type) {
		VertexGroup_add((::ID *) ptr.id.data, (::bDeformGroup *) this->ptr.data, NULL, index_len, index, weight, type);
	}

	inline void VertexGroup::remove(int index_len, int *index) {
		VertexGroup_remove((::ID *) ptr.id.data, (::bDeformGroup *) this->ptr.data, NULL, index_len, index);
	}

	inline float VertexGroup::weight(int index) {
		return VertexGroup_weight((::ID *) ptr.id.data, (::bDeformGroup *) this->ptr.data, NULL, index);
	}


	POINTER_PROPERTY(Struct, FaceMap, rna_type)
	STRING_PROPERTY(FaceMap, name)
	BOOLEAN_PROPERTY(FaceMap, select)
	INT_PROPERTY(FaceMap, index)

	inline void FaceMap::add(int index_len, int *index) {
		FaceMap_add((::ID *) ptr.id.data, (::bFaceMap *) this->ptr.data, NULL, index_len, index);
	}

	inline void FaceMap::remove(int index_len, int *index) {
		FaceMap_remove((::ID *) ptr.id.data, (::bFaceMap *) this->ptr.data, NULL, index_len, index);
	}


	POINTER_PROPERTY(Struct, MaterialSlot, rna_type)
	ENUM_PROPERTY(link_enum, MaterialSlot, link)
	POINTER_PROPERTY(Material, MaterialSlot, material)
	STRING_PROPERTY(MaterialSlot, name)


	POINTER_PROPERTY(Struct, ObjectDisplay, rna_type)
	BOOLEAN_PROPERTY(ObjectDisplay, show_shadows)


	POINTER_PROPERTY(Struct, PointCache, rna_type)
	INT_PROPERTY(PointCache, frame_start)
	INT_PROPERTY(PointCache, frame_end)
	INT_PROPERTY(PointCache, frame_step)
	INT_PROPERTY(PointCache, index)
	ENUM_PROPERTY(compression_enum, PointCache, compression)
	BOOLEAN_PROPERTY(PointCache, is_baked)
	BOOLEAN_PROPERTY(PointCache, is_baking)
	BOOLEAN_PROPERTY(PointCache, use_disk_cache)
	BOOLEAN_PROPERTY(PointCache, is_outdated)
	BOOLEAN_PROPERTY(PointCache, is_frame_skip)
	STRING_PROPERTY(PointCache, name)
	STRING_PROPERTY(PointCache, filepath)
	STRING_PROPERTY(PointCache, info)
	BOOLEAN_PROPERTY(PointCache, use_external)
	BOOLEAN_PROPERTY(PointCache, use_library_path)



	POINTER_PROPERTY(Struct, PointCaches, rna_type)
	INT_PROPERTY(PointCaches, active_index)


	POINTER_PROPERTY(Struct, PointCacheItem, rna_type)
	INT_PROPERTY(PointCacheItem, frame_start)
	INT_PROPERTY(PointCacheItem, frame_end)
	INT_PROPERTY(PointCacheItem, frame_step)
	INT_PROPERTY(PointCacheItem, index)
	ENUM_PROPERTY(compression_enum, PointCacheItem, compression)
	BOOLEAN_PROPERTY(PointCacheItem, is_baked)
	BOOLEAN_PROPERTY(PointCacheItem, is_baking)
	BOOLEAN_PROPERTY(PointCacheItem, use_disk_cache)
	BOOLEAN_PROPERTY(PointCacheItem, is_outdated)
	BOOLEAN_PROPERTY(PointCacheItem, is_frame_skip)
	STRING_PROPERTY(PointCacheItem, name)
	STRING_PROPERTY(PointCacheItem, filepath)
	STRING_PROPERTY(PointCacheItem, info)
	BOOLEAN_PROPERTY(PointCacheItem, use_external)
	BOOLEAN_PROPERTY(PointCacheItem, use_library_path)


	POINTER_PROPERTY(Struct, CollisionSettings, rna_type)
	BOOLEAN_PROPERTY(CollisionSettings, use)
	FLOAT_PROPERTY(CollisionSettings, damping_factor)
	FLOAT_PROPERTY(CollisionSettings, damping_random)
	FLOAT_PROPERTY(CollisionSettings, friction_factor)
	FLOAT_PROPERTY(CollisionSettings, friction_random)
	FLOAT_PROPERTY(CollisionSettings, permeability)
	BOOLEAN_PROPERTY(CollisionSettings, use_particle_kill)
	FLOAT_PROPERTY(CollisionSettings, stickiness)
	FLOAT_PROPERTY(CollisionSettings, thickness_inner)
	FLOAT_PROPERTY(CollisionSettings, thickness_outer)
	FLOAT_PROPERTY(CollisionSettings, damping)
	FLOAT_PROPERTY(CollisionSettings, absorption)
	FLOAT_PROPERTY(CollisionSettings, cloth_friction)
	BOOLEAN_PROPERTY(CollisionSettings, use_culling)
	BOOLEAN_PROPERTY(CollisionSettings, use_normal)


	POINTER_PROPERTY(Struct, EffectorWeights, rna_type)
	BOOLEAN_PROPERTY(EffectorWeights, apply_to_hair_growing)
	POINTER_PROPERTY(Collection, EffectorWeights, collection)
	FLOAT_PROPERTY(EffectorWeights, gravity)
	FLOAT_PROPERTY(EffectorWeights, all)
	FLOAT_PROPERTY(EffectorWeights, force)
	FLOAT_PROPERTY(EffectorWeights, vortex)
	FLOAT_PROPERTY(EffectorWeights, magnetic)
	FLOAT_PROPERTY(EffectorWeights, wind)
	FLOAT_PROPERTY(EffectorWeights, curve_guide)
	FLOAT_PROPERTY(EffectorWeights, texture)
	FLOAT_PROPERTY(EffectorWeights, harmonic)
	FLOAT_PROPERTY(EffectorWeights, charge)
	FLOAT_PROPERTY(EffectorWeights, lennardjones)
	FLOAT_PROPERTY(EffectorWeights, boid)
	FLOAT_PROPERTY(EffectorWeights, turbulence)
	FLOAT_PROPERTY(EffectorWeights, drag)
	FLOAT_PROPERTY(EffectorWeights, smokeflow)


	POINTER_PROPERTY(Struct, FieldSettings, rna_type)
	ENUM_PROPERTY(type_enum, FieldSettings, type)
	ENUM_PROPERTY(shape_enum, FieldSettings, shape)
	ENUM_PROPERTY(falloff_type_enum, FieldSettings, falloff_type)
	ENUM_PROPERTY(texture_mode_enum, FieldSettings, texture_mode)
	ENUM_PROPERTY(z_direction_enum, FieldSettings, z_direction)
	FLOAT_PROPERTY(FieldSettings, strength)
	FLOAT_PROPERTY(FieldSettings, linear_drag)
	FLOAT_PROPERTY(FieldSettings, harmonic_damping)
	FLOAT_PROPERTY(FieldSettings, quadratic_drag)
	FLOAT_PROPERTY(FieldSettings, flow)
	FLOAT_PROPERTY(FieldSettings, inflow)
	FLOAT_PROPERTY(FieldSettings, size)
	FLOAT_PROPERTY(FieldSettings, rest_length)
	FLOAT_PROPERTY(FieldSettings, falloff_power)
	FLOAT_PROPERTY(FieldSettings, distance_min)
	FLOAT_PROPERTY(FieldSettings, distance_max)
	FLOAT_PROPERTY(FieldSettings, radial_min)
	FLOAT_PROPERTY(FieldSettings, radial_max)
	FLOAT_PROPERTY(FieldSettings, radial_falloff)
	FLOAT_PROPERTY(FieldSettings, texture_nabla)
	FLOAT_PROPERTY(FieldSettings, noise)
	INT_PROPERTY(FieldSettings, seed)
	BOOLEAN_PROPERTY(FieldSettings, use_min_distance)
	BOOLEAN_PROPERTY(FieldSettings, use_max_distance)
	BOOLEAN_PROPERTY(FieldSettings, use_radial_min)
	BOOLEAN_PROPERTY(FieldSettings, use_radial_max)
	BOOLEAN_PROPERTY(FieldSettings, use_object_coords)
	BOOLEAN_PROPERTY(FieldSettings, use_global_coords)
	BOOLEAN_PROPERTY(FieldSettings, use_2d_force)
	BOOLEAN_PROPERTY(FieldSettings, use_root_coords)
	BOOLEAN_PROPERTY(FieldSettings, apply_to_location)
	BOOLEAN_PROPERTY(FieldSettings, apply_to_rotation)
	BOOLEAN_PROPERTY(FieldSettings, use_absorption)
	BOOLEAN_PROPERTY(FieldSettings, use_multiple_springs)
	BOOLEAN_PROPERTY(FieldSettings, use_smoke_density)
	BOOLEAN_PROPERTY(FieldSettings, use_gravity_falloff)
	POINTER_PROPERTY(Texture, FieldSettings, texture)
	POINTER_PROPERTY(Object, FieldSettings, source_object)
	FLOAT_PROPERTY(FieldSettings, guide_minimum)
	FLOAT_PROPERTY(FieldSettings, guide_free)
	BOOLEAN_PROPERTY(FieldSettings, use_guide_path_add)
	BOOLEAN_PROPERTY(FieldSettings, use_guide_path_weight)
	FLOAT_PROPERTY(FieldSettings, guide_clump_amount)
	FLOAT_PROPERTY(FieldSettings, guide_clump_shape)
	ENUM_PROPERTY(guide_kink_type_enum, FieldSettings, guide_kink_type)
	ENUM_PROPERTY(guide_kink_axis_enum, FieldSettings, guide_kink_axis)
	FLOAT_PROPERTY(FieldSettings, guide_kink_frequency)
	FLOAT_PROPERTY(FieldSettings, guide_kink_shape)
	FLOAT_PROPERTY(FieldSettings, guide_kink_amplitude)


	POINTER_PROPERTY(Struct, SoftBodySettings, rna_type)
	FLOAT_PROPERTY(SoftBodySettings, friction)
	FLOAT_PROPERTY(SoftBodySettings, mass)
	STRING_PROPERTY(SoftBodySettings, vertex_group_mass)
	FLOAT_PROPERTY(SoftBodySettings, gravity)
	FLOAT_PROPERTY(SoftBodySettings, speed)
	STRING_PROPERTY(SoftBodySettings, vertex_group_goal)
	FLOAT_PROPERTY(SoftBodySettings, goal_min)
	FLOAT_PROPERTY(SoftBodySettings, goal_max)
	FLOAT_PROPERTY(SoftBodySettings, goal_default)
	FLOAT_PROPERTY(SoftBodySettings, goal_spring)
	FLOAT_PROPERTY(SoftBodySettings, goal_friction)
	FLOAT_PROPERTY(SoftBodySettings, pull)
	FLOAT_PROPERTY(SoftBodySettings, push)
	FLOAT_PROPERTY(SoftBodySettings, damping)
	INT_PROPERTY(SoftBodySettings, spring_length)
	INT_PROPERTY(SoftBodySettings, aero)
	INT_PROPERTY(SoftBodySettings, plastic)
	FLOAT_PROPERTY(SoftBodySettings, bend)
	FLOAT_PROPERTY(SoftBodySettings, shear)
	STRING_PROPERTY(SoftBodySettings, vertex_group_spring)
	ENUM_PROPERTY(collision_type_enum, SoftBodySettings, collision_type)
	FLOAT_PROPERTY(SoftBodySettings, ball_size)
	FLOAT_PROPERTY(SoftBodySettings, ball_stiff)
	FLOAT_PROPERTY(SoftBodySettings, ball_damp)
	FLOAT_PROPERTY(SoftBodySettings, error_threshold)
	INT_PROPERTY(SoftBodySettings, step_min)
	INT_PROPERTY(SoftBodySettings, step_max)
	INT_PROPERTY(SoftBodySettings, choke)
	INT_PROPERTY(SoftBodySettings, fuzzy)
	BOOLEAN_PROPERTY(SoftBodySettings, use_auto_step)
	BOOLEAN_PROPERTY(SoftBodySettings, use_diagnose)
	BOOLEAN_PROPERTY(SoftBodySettings, use_estimate_matrix)
	FLOAT_ARRAY_PROPERTY(SoftBodySettings, 3, location_mass_center)
	FLOAT_ARRAY_PROPERTY(SoftBodySettings, 9, rotation_estimate)
	FLOAT_ARRAY_PROPERTY(SoftBodySettings, 9, scale_estimate)
	BOOLEAN_PROPERTY(SoftBodySettings, use_goal)
	BOOLEAN_PROPERTY(SoftBodySettings, use_edges)
	BOOLEAN_PROPERTY(SoftBodySettings, use_stiff_quads)
	BOOLEAN_PROPERTY(SoftBodySettings, use_edge_collision)
	BOOLEAN_PROPERTY(SoftBodySettings, use_face_collision)
	ENUM_PROPERTY(aerodynamics_type_enum, SoftBodySettings, aerodynamics_type)
	BOOLEAN_PROPERTY(SoftBodySettings, use_self_collision)
	POINTER_PROPERTY(Collection, SoftBodySettings, collision_collection)
	POINTER_PROPERTY(EffectorWeights, SoftBodySettings, effector_weights)


	POINTER_PROPERTY(Struct, DepsgraphObjectInstance, rna_type)
	POINTER_PROPERTY(Object, DepsgraphObjectInstance, object)
	BOOLEAN_PROPERTY(DepsgraphObjectInstance, show_self)
	BOOLEAN_PROPERTY(DepsgraphObjectInstance, show_particles)
	BOOLEAN_PROPERTY(DepsgraphObjectInstance, is_instance)
	POINTER_PROPERTY(Object, DepsgraphObjectInstance, instance_object)
	POINTER_PROPERTY(Object, DepsgraphObjectInstance, parent)
	POINTER_PROPERTY(ParticleSystem, DepsgraphObjectInstance, particle_system)
	INT_ARRAY_PROPERTY(DepsgraphObjectInstance, 16, persistent_id)
	INT_PROPERTY(DepsgraphObjectInstance, random_id)
	FLOAT_ARRAY_PROPERTY(DepsgraphObjectInstance, 16, matrix_world)
	FLOAT_ARRAY_PROPERTY(DepsgraphObjectInstance, 3, orco)
	FLOAT_ARRAY_PROPERTY(DepsgraphObjectInstance, 2, uv)


	POINTER_PROPERTY(Struct, DepsgraphUpdate, rna_type)
	POINTER_PROPERTY(ID, DepsgraphUpdate, id)
	BOOLEAN_PROPERTY(DepsgraphUpdate, is_updated_transform)
	BOOLEAN_PROPERTY(DepsgraphUpdate, is_updated_geometry)


	POINTER_PROPERTY(Struct, Depsgraph, rna_type)
	ENUM_PROPERTY(mode_enum, Depsgraph, mode)
	POINTER_PROPERTY(Scene, Depsgraph, scene)
	POINTER_PROPERTY(ViewLayer, Depsgraph, view_layer)
	POINTER_PROPERTY(Scene, Depsgraph, scene_eval)
	POINTER_PROPERTY(ViewLayer, Depsgraph, view_layer_eval)





	inline void Depsgraph::debug_relations_graphviz(const char * filename) {
		Depsgraph_debug_relations_graphviz((::Depsgraph *) this->ptr.data, filename);
	}

	inline void Depsgraph::debug_stats_gnuplot(const char * filename, const char * output_filename) {
		Depsgraph_debug_stats_gnuplot((::Depsgraph *) this->ptr.data, filename, output_filename);
	}

	inline void Depsgraph::debug_tag_update() {
		Depsgraph_debug_tag_update((::Depsgraph *) this->ptr.data);
	}

	inline void Depsgraph::debug_stats(char * result) {
		Depsgraph_debug_stats((::Depsgraph *) this->ptr.data, result);
	}

	inline ID Depsgraph::id_eval_get(ID& id) {
		PointerRNA result;
		::ID *retdata = Depsgraph_id_eval_get((::Depsgraph *) this->ptr.data, (::ID *) id.ptr.data);
		RNA_id_pointer_create((::ID *) retdata, &result);
		return ID(result);
	}

	inline bool Depsgraph::id_type_updated(int id_type) {
		return Depsgraph_id_type_updated((::Depsgraph *) this->ptr.data, id_type);
	}


	POINTER_PROPERTY(Struct, PackedFile, rna_type)
	INT_PROPERTY(PackedFile, size)
	STRING_PROPERTY(PackedFile, data)


	POINTER_PROPERTY(Struct, PaletteColor, rna_type)
	FLOAT_ARRAY_PROPERTY(PaletteColor, 3, color)
	FLOAT_PROPERTY(PaletteColor, strength)
	FLOAT_PROPERTY(PaletteColor, weight)





	POINTER_PROPERTY(Struct, PaletteColors, rna_type)
	POINTER_PROPERTY(PaletteColor, PaletteColors, active)

	inline PaletteColor PaletteColors::create() {
		PointerRNA result;
		::PaletteColor *retdata = PaletteColors_new((::Palette *) this->ptr.data);
		RNA_pointer_create((::ID *) ptr.id.data, &RNA_PaletteColor, retdata, &result);
		return PaletteColor(result);
	}

	inline void PaletteColors::remove(PaletteColor& color) {
		PaletteColors_remove((::Palette *) this->ptr.data, NULL, (::PointerRNA *) &color.ptr);
	}

	inline void PaletteColors::clear() {
		PaletteColors_clear((::Palette *) this->ptr.data);
	}


	POINTER_PROPERTY(Struct, ParticleTarget, rna_type)
	STRING_PROPERTY(ParticleTarget, name)
	POINTER_PROPERTY(Object, ParticleTarget, object)
	INT_PROPERTY(ParticleTarget, system)
	FLOAT_PROPERTY(ParticleTarget, time)
	FLOAT_PROPERTY(ParticleTarget, duration)
	BOOLEAN_PROPERTY(ParticleTarget, is_valid)
	ENUM_PROPERTY(alliance_enum, ParticleTarget, alliance)


	POINTER_PROPERTY(Struct, SPHFluidSettings, rna_type)
	ENUM_PROPERTY(solver_enum, SPHFluidSettings, solver)
	FLOAT_PROPERTY(SPHFluidSettings, spring_force)
	FLOAT_PROPERTY(SPHFluidSettings, fluid_radius)
	FLOAT_PROPERTY(SPHFluidSettings, rest_length)
	BOOLEAN_PROPERTY(SPHFluidSettings, use_viscoelastic_springs)
	BOOLEAN_PROPERTY(SPHFluidSettings, use_initial_rest_length)
	FLOAT_PROPERTY(SPHFluidSettings, plasticity)
	FLOAT_PROPERTY(SPHFluidSettings, yield_ratio)
	INT_PROPERTY(SPHFluidSettings, spring_frames)
	FLOAT_PROPERTY(SPHFluidSettings, linear_viscosity)
	FLOAT_PROPERTY(SPHFluidSettings, stiff_viscosity)
	FLOAT_PROPERTY(SPHFluidSettings, stiffness)
	FLOAT_PROPERTY(SPHFluidSettings, repulsion)
	FLOAT_PROPERTY(SPHFluidSettings, rest_density)
	FLOAT_PROPERTY(SPHFluidSettings, buoyancy)
	BOOLEAN_PROPERTY(SPHFluidSettings, use_factor_repulsion)
	BOOLEAN_PROPERTY(SPHFluidSettings, use_factor_density)
	BOOLEAN_PROPERTY(SPHFluidSettings, use_factor_radius)
	BOOLEAN_PROPERTY(SPHFluidSettings, use_factor_stiff_viscosity)
	BOOLEAN_PROPERTY(SPHFluidSettings, use_factor_rest_length)


	POINTER_PROPERTY(Struct, ParticleHairKey, rna_type)
	FLOAT_PROPERTY(ParticleHairKey, time)
	FLOAT_PROPERTY(ParticleHairKey, weight)
	FLOAT_ARRAY_PROPERTY(ParticleHairKey, 3, co)
	FLOAT_ARRAY_PROPERTY(ParticleHairKey, 3, co_local)

	inline void ParticleHairKey::co_object(Object& object, ParticleSystemModifier& modifier, Particle& particle, float co[3]) {
		ParticleHairKey_co_object((::HairKey *) this->ptr.data, (::Object *) object.ptr.data, (::ParticleSystemModifierData *) modifier.ptr.data, (::ParticleData *) particle.ptr.data, co);
	}


	POINTER_PROPERTY(Struct, ParticleKey, rna_type)
	FLOAT_ARRAY_PROPERTY(ParticleKey, 3, location)
	FLOAT_ARRAY_PROPERTY(ParticleKey, 3, velocity)
	FLOAT_ARRAY_PROPERTY(ParticleKey, 4, rotation)
	FLOAT_ARRAY_PROPERTY(ParticleKey, 3, angular_velocity)
	FLOAT_PROPERTY(ParticleKey, time)


	POINTER_PROPERTY(Struct, ChildParticle, rna_type)


	POINTER_PROPERTY(Struct, Particle, rna_type)
	FLOAT_ARRAY_PROPERTY(Particle, 3, location)
	FLOAT_ARRAY_PROPERTY(Particle, 3, velocity)
	FLOAT_ARRAY_PROPERTY(Particle, 3, angular_velocity)
	FLOAT_ARRAY_PROPERTY(Particle, 4, rotation)
	FLOAT_ARRAY_PROPERTY(Particle, 3, prev_location)
	FLOAT_ARRAY_PROPERTY(Particle, 3, prev_velocity)
	FLOAT_ARRAY_PROPERTY(Particle, 3, prev_angular_velocity)
	FLOAT_ARRAY_PROPERTY(Particle, 4, prev_rotation)


	FLOAT_PROPERTY(Particle, birth_time)
	FLOAT_PROPERTY(Particle, lifetime)
	FLOAT_PROPERTY(Particle, die_time)
	FLOAT_PROPERTY(Particle, size)
	BOOLEAN_PROPERTY(Particle, is_exist)
	BOOLEAN_PROPERTY(Particle, is_visible)
	ENUM_PROPERTY(alive_state_enum, Particle, alive_state)

	inline void Particle::uv_on_emitter(ParticleSystemModifier& modifier, float uv[2]) {
		Particle_uv_on_emitter((::ParticleData *) this->ptr.data, NULL, (::ParticleSystemModifierData *) modifier.ptr.data, uv);
	}


	POINTER_PROPERTY(Struct, ParticleDupliWeight, rna_type)
	STRING_PROPERTY(ParticleDupliWeight, name)
	INT_PROPERTY(ParticleDupliWeight, count)


	POINTER_PROPERTY(Struct, ParticleSystem, rna_type)
	STRING_PROPERTY(ParticleSystem, name)
	POINTER_PROPERTY(ParticleSettings, ParticleSystem, settings)


	INT_PROPERTY(ParticleSystem, seed)
	INT_PROPERTY(ParticleSystem, child_seed)
	BOOLEAN_PROPERTY(ParticleSystem, is_global_hair)
	BOOLEAN_PROPERTY(ParticleSystem, use_hair_dynamics)
	POINTER_PROPERTY(ClothModifier, ParticleSystem, cloth)
	POINTER_PROPERTY(Object, ParticleSystem, reactor_target_object)
	INT_PROPERTY(ParticleSystem, reactor_target_particle_system)
	BOOLEAN_PROPERTY(ParticleSystem, use_keyed_timing)

	POINTER_PROPERTY(ParticleTarget, ParticleSystem, active_particle_target)
	INT_PROPERTY(ParticleSystem, active_particle_target_index)
	STRING_PROPERTY(ParticleSystem, vertex_group_density)
	BOOLEAN_PROPERTY(ParticleSystem, invert_vertex_group_density)
	STRING_PROPERTY(ParticleSystem, vertex_group_velocity)
	BOOLEAN_PROPERTY(ParticleSystem, invert_vertex_group_velocity)
	STRING_PROPERTY(ParticleSystem, vertex_group_length)
	BOOLEAN_PROPERTY(ParticleSystem, invert_vertex_group_length)
	STRING_PROPERTY(ParticleSystem, vertex_group_clump)
	BOOLEAN_PROPERTY(ParticleSystem, invert_vertex_group_clump)
	STRING_PROPERTY(ParticleSystem, vertex_group_kink)
	BOOLEAN_PROPERTY(ParticleSystem, invert_vertex_group_kink)
	STRING_PROPERTY(ParticleSystem, vertex_group_roughness_1)
	BOOLEAN_PROPERTY(ParticleSystem, invert_vertex_group_roughness_1)
	STRING_PROPERTY(ParticleSystem, vertex_group_roughness_2)
	BOOLEAN_PROPERTY(ParticleSystem, invert_vertex_group_roughness_2)
	STRING_PROPERTY(ParticleSystem, vertex_group_roughness_end)
	BOOLEAN_PROPERTY(ParticleSystem, invert_vertex_group_roughness_end)
	STRING_PROPERTY(ParticleSystem, vertex_group_size)
	BOOLEAN_PROPERTY(ParticleSystem, invert_vertex_group_size)
	STRING_PROPERTY(ParticleSystem, vertex_group_tangent)
	BOOLEAN_PROPERTY(ParticleSystem, invert_vertex_group_tangent)
	STRING_PROPERTY(ParticleSystem, vertex_group_rotation)
	BOOLEAN_PROPERTY(ParticleSystem, invert_vertex_group_rotation)
	STRING_PROPERTY(ParticleSystem, vertex_group_field)
	BOOLEAN_PROPERTY(ParticleSystem, invert_vertex_group_field)
	STRING_PROPERTY(ParticleSystem, vertex_group_twist)
	BOOLEAN_PROPERTY(ParticleSystem, invert_vertex_group_twist)
	POINTER_PROPERTY(PointCache, ParticleSystem, point_cache)
	BOOLEAN_PROPERTY(ParticleSystem, has_multiple_caches)
	POINTER_PROPERTY(Object, ParticleSystem, parent)
	BOOLEAN_PROPERTY(ParticleSystem, is_editable)
	BOOLEAN_PROPERTY(ParticleSystem, is_edited)
	FLOAT_PROPERTY(ParticleSystem, dt_frac)

	inline void ParticleSystem::co_hair(Object& object, int particle_no, int step, float co[3]) {
		ParticleSystem_co_hair((::ParticleSystem *) this->ptr.data, (::Object *) object.ptr.data, particle_no, step, co);
	}

	inline void ParticleSystem::uv_on_emitter(ParticleSystemModifier& modifier, Particle& particle, int particle_no, int uv_no, float uv[2]) {
		ParticleSystem_uv_on_emitter((::ParticleSystem *) this->ptr.data, NULL, (::ParticleSystemModifierData *) modifier.ptr.data, (::ParticleData *) particle.ptr.data, particle_no, uv_no, uv);
	}

	inline void ParticleSystem::mcol_on_emitter(ParticleSystemModifier& modifier, Particle& particle, int particle_no, int vcol_no, float mcol[3]) {
		ParticleSystem_mcol_on_emitter((::ParticleSystem *) this->ptr.data, NULL, (::ParticleSystemModifierData *) modifier.ptr.data, (::ParticleData *) particle.ptr.data, particle_no, vcol_no, mcol);
	}


	ENUM_PROPERTY(texture_coords_enum, ParticleSettingsTextureSlot, texture_coords)
	POINTER_PROPERTY(Object, ParticleSettingsTextureSlot, object)
	STRING_PROPERTY(ParticleSettingsTextureSlot, uv_layer)
	ENUM_PROPERTY(mapping_x_enum, ParticleSettingsTextureSlot, mapping_x)
	ENUM_PROPERTY(mapping_y_enum, ParticleSettingsTextureSlot, mapping_y)
	ENUM_PROPERTY(mapping_z_enum, ParticleSettingsTextureSlot, mapping_z)
	ENUM_PROPERTY(mapping_enum, ParticleSettingsTextureSlot, mapping)
	BOOLEAN_PROPERTY(ParticleSettingsTextureSlot, use_map_time)
	BOOLEAN_PROPERTY(ParticleSettingsTextureSlot, use_map_life)
	BOOLEAN_PROPERTY(ParticleSettingsTextureSlot, use_map_density)
	BOOLEAN_PROPERTY(ParticleSettingsTextureSlot, use_map_size)
	BOOLEAN_PROPERTY(ParticleSettingsTextureSlot, use_map_velocity)
	BOOLEAN_PROPERTY(ParticleSettingsTextureSlot, use_map_field)
	BOOLEAN_PROPERTY(ParticleSettingsTextureSlot, use_map_gravity)
	BOOLEAN_PROPERTY(ParticleSettingsTextureSlot, use_map_damp)
	BOOLEAN_PROPERTY(ParticleSettingsTextureSlot, use_map_clump)
	BOOLEAN_PROPERTY(ParticleSettingsTextureSlot, use_map_kink_amp)
	BOOLEAN_PROPERTY(ParticleSettingsTextureSlot, use_map_kink_freq)
	BOOLEAN_PROPERTY(ParticleSettingsTextureSlot, use_map_rough)
	BOOLEAN_PROPERTY(ParticleSettingsTextureSlot, use_map_length)
	BOOLEAN_PROPERTY(ParticleSettingsTextureSlot, use_map_twist)
	FLOAT_PROPERTY(ParticleSettingsTextureSlot, time_factor)
	FLOAT_PROPERTY(ParticleSettingsTextureSlot, life_factor)
	FLOAT_PROPERTY(ParticleSettingsTextureSlot, density_factor)
	FLOAT_PROPERTY(ParticleSettingsTextureSlot, size_factor)
	FLOAT_PROPERTY(ParticleSettingsTextureSlot, velocity_factor)
	FLOAT_PROPERTY(ParticleSettingsTextureSlot, field_factor)
	FLOAT_PROPERTY(ParticleSettingsTextureSlot, gravity_factor)
	FLOAT_PROPERTY(ParticleSettingsTextureSlot, damp_factor)
	FLOAT_PROPERTY(ParticleSettingsTextureSlot, length_factor)
	FLOAT_PROPERTY(ParticleSettingsTextureSlot, clump_factor)
	FLOAT_PROPERTY(ParticleSettingsTextureSlot, kink_amp_factor)
	FLOAT_PROPERTY(ParticleSettingsTextureSlot, kink_freq_factor)
	FLOAT_PROPERTY(ParticleSettingsTextureSlot, rough_factor)
	FLOAT_PROPERTY(ParticleSettingsTextureSlot, twist_factor)



	POINTER_PROPERTY(Texture, ParticleSettings, active_texture)
	INT_PROPERTY(ParticleSettings, active_texture_index)
	BOOLEAN_PROPERTY(ParticleSettings, is_fluid)
	BOOLEAN_PROPERTY(ParticleSettings, use_react_start_end)
	BOOLEAN_PROPERTY(ParticleSettings, use_react_multiple)
	BOOLEAN_PROPERTY(ParticleSettings, use_regrow_hair)
	BOOLEAN_PROPERTY(ParticleSettings, show_unborn)
	BOOLEAN_PROPERTY(ParticleSettings, use_dead)
	BOOLEAN_PROPERTY(ParticleSettings, use_emit_random)
	BOOLEAN_PROPERTY(ParticleSettings, use_even_distribution)
	BOOLEAN_PROPERTY(ParticleSettings, use_die_on_collision)
	BOOLEAN_PROPERTY(ParticleSettings, use_size_deflect)
	BOOLEAN_PROPERTY(ParticleSettings, use_rotations)
	BOOLEAN_PROPERTY(ParticleSettings, use_dynamic_rotation)
	BOOLEAN_PROPERTY(ParticleSettings, use_multiply_size_mass)
	BOOLEAN_PROPERTY(ParticleSettings, use_advanced_hair)
	BOOLEAN_PROPERTY(ParticleSettings, lock_boids_to_surface)
	BOOLEAN_PROPERTY(ParticleSettings, use_hair_bspline)
	BOOLEAN_PROPERTY(ParticleSettings, invert_grid)
	BOOLEAN_PROPERTY(ParticleSettings, hexagonal_grid)
	BOOLEAN_PROPERTY(ParticleSettings, apply_effector_to_children)
	BOOLEAN_PROPERTY(ParticleSettings, create_long_hair_children)
	BOOLEAN_PROPERTY(ParticleSettings, apply_guide_to_children)
	BOOLEAN_PROPERTY(ParticleSettings, use_self_effect)
	ENUM_PROPERTY(type_enum, ParticleSettings, type)
	ENUM_PROPERTY(emit_from_enum, ParticleSettings, emit_from)
	ENUM_PROPERTY(distribution_enum, ParticleSettings, distribution)
	ENUM_PROPERTY(physics_type_enum, ParticleSettings, physics_type)
	ENUM_PROPERTY(rotation_mode_enum, ParticleSettings, rotation_mode)
	ENUM_PROPERTY(angular_velocity_mode_enum, ParticleSettings, angular_velocity_mode)
	ENUM_PROPERTY(react_event_enum, ParticleSettings, react_event)
	BOOLEAN_PROPERTY(ParticleSettings, show_guide_hairs)
	BOOLEAN_PROPERTY(ParticleSettings, show_hair_grid)
	BOOLEAN_PROPERTY(ParticleSettings, show_velocity)
	BOOLEAN_PROPERTY(ParticleSettings, show_size)
	BOOLEAN_PROPERTY(ParticleSettings, show_health)
	BOOLEAN_PROPERTY(ParticleSettings, use_absolute_path_time)
	BOOLEAN_PROPERTY(ParticleSettings, use_parent_particles)
	BOOLEAN_PROPERTY(ParticleSettings, show_number)
	BOOLEAN_PROPERTY(ParticleSettings, use_collection_pick_random)
	BOOLEAN_PROPERTY(ParticleSettings, use_collection_count)
	BOOLEAN_PROPERTY(ParticleSettings, use_global_instance)
	BOOLEAN_PROPERTY(ParticleSettings, use_rotation_instance)
	BOOLEAN_PROPERTY(ParticleSettings, use_scale_instance)
	BOOLEAN_PROPERTY(ParticleSettings, use_render_adaptive)
	BOOLEAN_PROPERTY(ParticleSettings, use_velocity_length)
	BOOLEAN_PROPERTY(ParticleSettings, use_whole_collection)
	BOOLEAN_PROPERTY(ParticleSettings, use_strand_primitive)
	ENUM_PROPERTY(display_method_enum, ParticleSettings, display_method)
	ENUM_PROPERTY(render_type_enum, ParticleSettings, render_type)
	ENUM_PROPERTY(display_color_enum, ParticleSettings, display_color)
	FLOAT_PROPERTY(ParticleSettings, display_size)
	ENUM_PROPERTY(child_type_enum, ParticleSettings, child_type)
	INT_PROPERTY(ParticleSettings, display_step)
	INT_PROPERTY(ParticleSettings, render_step)
	INT_PROPERTY(ParticleSettings, hair_step)
	FLOAT_PROPERTY(ParticleSettings, bending_random)
	INT_PROPERTY(ParticleSettings, keys_step)
	INT_PROPERTY(ParticleSettings, adaptive_angle)
	INT_PROPERTY(ParticleSettings, adaptive_pixel)
	INT_PROPERTY(ParticleSettings, display_percentage)
	INT_PROPERTY(ParticleSettings, material)
	ENUM_PROPERTY(material_slot_enum, ParticleSettings, material_slot)
	ENUM_PROPERTY(integrator_enum, ParticleSettings, integrator)
	ENUM_PROPERTY(kink_enum, ParticleSettings, kink)
	ENUM_PROPERTY(kink_axis_enum, ParticleSettings, kink_axis)
	FLOAT_PROPERTY(ParticleSettings, color_maximum)
	FLOAT_PROPERTY(ParticleSettings, frame_start)
	FLOAT_PROPERTY(ParticleSettings, frame_end)
	FLOAT_PROPERTY(ParticleSettings, lifetime)
	FLOAT_PROPERTY(ParticleSettings, lifetime_random)
	FLOAT_PROPERTY(ParticleSettings, time_tweak)
	FLOAT_PROPERTY(ParticleSettings, timestep)
	BOOLEAN_PROPERTY(ParticleSettings, use_adaptive_subframes)
	INT_PROPERTY(ParticleSettings, subframes)
	FLOAT_PROPERTY(ParticleSettings, courant_target)
	FLOAT_PROPERTY(ParticleSettings, jitter_factor)
	FLOAT_PROPERTY(ParticleSettings, effect_hair)
	INT_PROPERTY(ParticleSettings, count)
	INT_PROPERTY(ParticleSettings, userjit)
	INT_PROPERTY(ParticleSettings, grid_resolution)
	FLOAT_PROPERTY(ParticleSettings, grid_random)
	INT_PROPERTY(ParticleSettings, effector_amount)
	FLOAT_PROPERTY(ParticleSettings, normal_factor)
	FLOAT_PROPERTY(ParticleSettings, object_factor)
	FLOAT_PROPERTY(ParticleSettings, factor_random)
	FLOAT_PROPERTY(ParticleSettings, particle_factor)
	FLOAT_PROPERTY(ParticleSettings, tangent_factor)
	FLOAT_PROPERTY(ParticleSettings, tangent_phase)
	FLOAT_PROPERTY(ParticleSettings, reactor_factor)
	FLOAT_ARRAY_PROPERTY(ParticleSettings, 3, object_align_factor)
	FLOAT_PROPERTY(ParticleSettings, angular_velocity_factor)
	FLOAT_PROPERTY(ParticleSettings, phase_factor)
	FLOAT_PROPERTY(ParticleSettings, rotation_factor_random)
	FLOAT_PROPERTY(ParticleSettings, phase_factor_random)
	FLOAT_PROPERTY(ParticleSettings, hair_length)
	FLOAT_PROPERTY(ParticleSettings, mass)
	FLOAT_PROPERTY(ParticleSettings, particle_size)
	FLOAT_PROPERTY(ParticleSettings, size_random)
	POINTER_PROPERTY(Collection, ParticleSettings, collision_collection)
	FLOAT_PROPERTY(ParticleSettings, drag_factor)
	FLOAT_PROPERTY(ParticleSettings, brownian_factor)
	FLOAT_PROPERTY(ParticleSettings, damping)
	FLOAT_PROPERTY(ParticleSettings, length_random)
	INT_PROPERTY(ParticleSettings, child_nbr)
	INT_PROPERTY(ParticleSettings, rendered_child_count)
	FLOAT_PROPERTY(ParticleSettings, virtual_parents)
	FLOAT_PROPERTY(ParticleSettings, child_size)
	FLOAT_PROPERTY(ParticleSettings, child_size_random)
	FLOAT_PROPERTY(ParticleSettings, child_radius)
	FLOAT_PROPERTY(ParticleSettings, child_roundness)
	FLOAT_PROPERTY(ParticleSettings, clump_factor)
	FLOAT_PROPERTY(ParticleSettings, clump_shape)
	BOOLEAN_PROPERTY(ParticleSettings, use_clump_curve)
	POINTER_PROPERTY(CurveMapping, ParticleSettings, clump_curve)
	BOOLEAN_PROPERTY(ParticleSettings, use_clump_noise)
	FLOAT_PROPERTY(ParticleSettings, clump_noise_size)
	FLOAT_PROPERTY(ParticleSettings, kink_amplitude)
	FLOAT_PROPERTY(ParticleSettings, kink_amplitude_clump)
	FLOAT_PROPERTY(ParticleSettings, kink_amplitude_random)
	FLOAT_PROPERTY(ParticleSettings, kink_frequency)
	FLOAT_PROPERTY(ParticleSettings, kink_shape)
	FLOAT_PROPERTY(ParticleSettings, kink_flat)
	INT_PROPERTY(ParticleSettings, kink_extra_steps)
	FLOAT_PROPERTY(ParticleSettings, kink_axis_random)
	FLOAT_PROPERTY(ParticleSettings, roughness_1)
	FLOAT_PROPERTY(ParticleSettings, roughness_1_size)
	FLOAT_PROPERTY(ParticleSettings, roughness_2)
	FLOAT_PROPERTY(ParticleSettings, roughness_2_size)
	FLOAT_PROPERTY(ParticleSettings, roughness_2_threshold)
	FLOAT_PROPERTY(ParticleSettings, roughness_endpoint)
	FLOAT_PROPERTY(ParticleSettings, roughness_end_shape)
	BOOLEAN_PROPERTY(ParticleSettings, use_roughness_curve)
	POINTER_PROPERTY(CurveMapping, ParticleSettings, roughness_curve)
	FLOAT_PROPERTY(ParticleSettings, child_length)
	FLOAT_PROPERTY(ParticleSettings, child_length_threshold)
	FLOAT_PROPERTY(ParticleSettings, child_parting_factor)
	FLOAT_PROPERTY(ParticleSettings, child_parting_min)
	FLOAT_PROPERTY(ParticleSettings, child_parting_max)
	FLOAT_PROPERTY(ParticleSettings, branch_threshold)
	FLOAT_PROPERTY(ParticleSettings, line_length_tail)
	FLOAT_PROPERTY(ParticleSettings, line_length_head)
	FLOAT_PROPERTY(ParticleSettings, path_start)
	FLOAT_PROPERTY(ParticleSettings, path_end)
	INT_PROPERTY(ParticleSettings, trail_count)
	INT_PROPERTY(ParticleSettings, keyed_loops)
	BOOLEAN_PROPERTY(ParticleSettings, use_modifier_stack)
	POINTER_PROPERTY(Collection, ParticleSettings, instance_collection)

	POINTER_PROPERTY(ParticleDupliWeight, ParticleSettings, active_instanceweight)
	INT_PROPERTY(ParticleSettings, active_instanceweight_index)
	POINTER_PROPERTY(Object, ParticleSettings, instance_object)
	POINTER_PROPERTY(BoidSettings, ParticleSettings, boids)
	POINTER_PROPERTY(SPHFluidSettings, ParticleSettings, fluid)
	POINTER_PROPERTY(EffectorWeights, ParticleSettings, effector_weights)
	POINTER_PROPERTY(AnimData, ParticleSettings, animation_data)
	POINTER_PROPERTY(FieldSettings, ParticleSettings, force_field_1)
	POINTER_PROPERTY(FieldSettings, ParticleSettings, force_field_2)
	FLOAT_PROPERTY(ParticleSettings, twist)
	BOOLEAN_PROPERTY(ParticleSettings, use_twist_curve)
	POINTER_PROPERTY(CurveMapping, ParticleSettings, twist_curve)
	BOOLEAN_PROPERTY(ParticleSettings, use_close_tip)
	FLOAT_PROPERTY(ParticleSettings, shape)
	FLOAT_PROPERTY(ParticleSettings, root_radius)
	FLOAT_PROPERTY(ParticleSettings, tip_radius)
	FLOAT_PROPERTY(ParticleSettings, radius_scale)


	POINTER_PROPERTY(Struct, ParticleSettingsTextureSlots, rna_type)

	inline ParticleSettingsTextureSlot ParticleSettingsTextureSlots::add(Context C) {
		PointerRNA result;
		::MTex *retdata = ParticleSettingsTextureSlots_add((::ID *) ptr.id.data, (::bContext *) C.ptr.data, NULL);
		RNA_pointer_create((::ID *) ptr.id.data, &RNA_ParticleSettingsTextureSlot, retdata, &result);
		return ParticleSettingsTextureSlot(result);
	}

	inline ParticleSettingsTextureSlot ParticleSettingsTextureSlots::create(Context C, int index) {
		PointerRNA result;
		::MTex *retdata = ParticleSettingsTextureSlots_create((::ID *) ptr.id.data, (::bContext *) C.ptr.data, NULL, index);
		RNA_pointer_create((::ID *) ptr.id.data, &RNA_ParticleSettingsTextureSlot, retdata, &result);
		return ParticleSettingsTextureSlot(result);
	}

	inline void ParticleSettingsTextureSlots::clear(Context C, int index) {
		ParticleSettingsTextureSlots_clear((::ID *) ptr.id.data, (::bContext *) C.ptr.data, NULL, index);
	}


	POINTER_PROPERTY(Struct, Pose, rna_type)


	ENUM_PROPERTY(ik_solver_enum, Pose, ik_solver)
	POINTER_PROPERTY(IKParam, Pose, ik_param)
	POINTER_PROPERTY(AnimViz, Pose, animation_visualization)


	POINTER_PROPERTY(Struct, BoneGroups, rna_type)
	POINTER_PROPERTY(BoneGroup, BoneGroups, active)
	INT_PROPERTY(BoneGroups, active_index)

	inline BoneGroup BoneGroups::create(const char * name) {
		PointerRNA result;
		::bActionGroup *retdata = BoneGroups_new((::ID *) ptr.id.data, (::bPose *) this->ptr.data, name);
		RNA_pointer_create((::ID *) ptr.id.data, &RNA_BoneGroup, retdata, &result);
		return BoneGroup(result);
	}

	inline void BoneGroups::remove(BoneGroup& group) {
		BoneGroups_remove((::ID *) ptr.id.data, (::bPose *) this->ptr.data, NULL, (::PointerRNA *) &group.ptr);
	}


	POINTER_PROPERTY(Struct, PoseBone, rna_type)

	STRING_PROPERTY(PoseBone, name)
	POINTER_PROPERTY(MotionPath, PoseBone, motion_path)
	POINTER_PROPERTY(Bone, PoseBone, bone)
	POINTER_PROPERTY(PoseBone, PoseBone, parent)
	POINTER_PROPERTY(PoseBone, PoseBone, child)
	FLOAT_ARRAY_PROPERTY(PoseBone, 3, location)
	FLOAT_ARRAY_PROPERTY(PoseBone, 3, scale)
	FLOAT_ARRAY_PROPERTY(PoseBone, 4, rotation_quaternion)
	FLOAT_ARRAY_PROPERTY(PoseBone, 4, rotation_axis_angle)
	FLOAT_ARRAY_PROPERTY(PoseBone, 3, rotation_euler)
	ENUM_PROPERTY(rotation_mode_enum, PoseBone, rotation_mode)
	FLOAT_PROPERTY(PoseBone, bbone_rollin)
	FLOAT_PROPERTY(PoseBone, bbone_rollout)
	FLOAT_PROPERTY(PoseBone, bbone_curveinx)
	FLOAT_PROPERTY(PoseBone, bbone_curveiny)
	FLOAT_PROPERTY(PoseBone, bbone_curveoutx)
	FLOAT_PROPERTY(PoseBone, bbone_curveouty)
	FLOAT_PROPERTY(PoseBone, bbone_easein)
	FLOAT_PROPERTY(PoseBone, bbone_easeout)
	FLOAT_PROPERTY(PoseBone, bbone_scalein)
	FLOAT_PROPERTY(PoseBone, bbone_scaleout)
	POINTER_PROPERTY(PoseBone, PoseBone, bbone_custom_handle_start)
	POINTER_PROPERTY(PoseBone, PoseBone, bbone_custom_handle_end)
	FLOAT_ARRAY_PROPERTY(PoseBone, 16, matrix_channel)
	FLOAT_ARRAY_PROPERTY(PoseBone, 16, matrix_basis)
	FLOAT_ARRAY_PROPERTY(PoseBone, 16, matrix)
	FLOAT_ARRAY_PROPERTY(PoseBone, 3, head)
	FLOAT_ARRAY_PROPERTY(PoseBone, 3, tail)
	BOOLEAN_PROPERTY(PoseBone, is_in_ik_chain)
	BOOLEAN_PROPERTY(PoseBone, lock_ik_x)
	BOOLEAN_PROPERTY(PoseBone, lock_ik_y)
	BOOLEAN_PROPERTY(PoseBone, lock_ik_z)
	BOOLEAN_PROPERTY(PoseBone, use_ik_limit_x)
	BOOLEAN_PROPERTY(PoseBone, use_ik_limit_y)
	BOOLEAN_PROPERTY(PoseBone, use_ik_limit_z)
	BOOLEAN_PROPERTY(PoseBone, use_ik_rotation_control)
	BOOLEAN_PROPERTY(PoseBone, use_ik_linear_control)
	FLOAT_PROPERTY(PoseBone, ik_min_x)
	FLOAT_PROPERTY(PoseBone, ik_max_x)
	FLOAT_PROPERTY(PoseBone, ik_min_y)
	FLOAT_PROPERTY(PoseBone, ik_max_y)
	FLOAT_PROPERTY(PoseBone, ik_min_z)
	FLOAT_PROPERTY(PoseBone, ik_max_z)
	FLOAT_PROPERTY(PoseBone, ik_stiffness_x)
	FLOAT_PROPERTY(PoseBone, ik_stiffness_y)
	FLOAT_PROPERTY(PoseBone, ik_stiffness_z)
	FLOAT_PROPERTY(PoseBone, ik_stretch)
	FLOAT_PROPERTY(PoseBone, ik_rotation_weight)
	FLOAT_PROPERTY(PoseBone, ik_linear_weight)
	POINTER_PROPERTY(Object, PoseBone, custom_shape)
	FLOAT_PROPERTY(PoseBone, custom_shape_scale)
	BOOLEAN_PROPERTY(PoseBone, use_custom_shape_bone_size)
	POINTER_PROPERTY(PoseBone, PoseBone, custom_shape_transform)
	INT_PROPERTY(PoseBone, bone_group_index)
	POINTER_PROPERTY(BoneGroup, PoseBone, bone_group)
	BOOLEAN_ARRAY_PROPERTY(PoseBone, 3, lock_location)
	BOOLEAN_ARRAY_PROPERTY(PoseBone, 3, lock_rotation)
	BOOLEAN_PROPERTY(PoseBone, lock_rotation_w)
	BOOLEAN_PROPERTY(PoseBone, lock_rotations_4d)
	BOOLEAN_ARRAY_PROPERTY(PoseBone, 3, lock_scale)

	inline float PoseBone::evaluate_envelope(float point[3]) {
		return PoseBone_evaluate_envelope((::bPoseChannel *) this->ptr.data, point);
	}

	inline void PoseBone::bbone_segment_matrix(float matrix_return[16], int index, bool rest) {
		PoseBone_bbone_segment_matrix((::bPoseChannel *) this->ptr.data, NULL, matrix_return, index, rest);
	}

	inline void PoseBone::compute_bbone_handles(float handle1[3], float *roll1, float handle2[3], float *roll2, bool rest, bool ease, bool offsets) {
		PoseBone_compute_bbone_handles((::bPoseChannel *) this->ptr.data, NULL, handle1, roll1, handle2, roll2, rest, ease, offsets);
	}


	POINTER_PROPERTY(Struct, PoseBoneConstraints, rna_type)
	POINTER_PROPERTY(Constraint, PoseBoneConstraints, active)

	inline Constraint PoseBoneConstraints::create(void *main, int type) {
		PointerRNA result;
		::bConstraint *retdata = PoseBoneConstraints_new((::ID *) ptr.id.data, (::bPoseChannel *) this->ptr.data, (::Main *) main, type);
		RNA_pointer_create((::ID *) ptr.id.data, &RNA_Constraint, retdata, &result);
		return Constraint(result);
	}

	inline void PoseBoneConstraints::remove(void *main, Constraint& constraint) {
		PoseBoneConstraints_remove((::ID *) ptr.id.data, (::bPoseChannel *) this->ptr.data, (::Main *) main, NULL, (::PointerRNA *) &constraint.ptr);
	}


	POINTER_PROPERTY(Struct, IKParam, rna_type)
	ENUM_PROPERTY(ik_solver_enum, IKParam, ik_solver)


	FLOAT_PROPERTY(Itasc, precision)
	INT_PROPERTY(Itasc, iterations)
	INT_PROPERTY(Itasc, step_count)
	ENUM_PROPERTY(mode_enum, Itasc, mode)
	ENUM_PROPERTY(reiteration_method_enum, Itasc, reiteration_method)
	BOOLEAN_PROPERTY(Itasc, use_auto_step)
	FLOAT_PROPERTY(Itasc, step_min)
	FLOAT_PROPERTY(Itasc, step_max)
	FLOAT_PROPERTY(Itasc, feedback)
	FLOAT_PROPERTY(Itasc, velocity_max)
	ENUM_PROPERTY(solver_enum, Itasc, solver)
	FLOAT_PROPERTY(Itasc, damping_max)
	FLOAT_PROPERTY(Itasc, damping_epsilon)


	POINTER_PROPERTY(Struct, BoneGroup, rna_type)
	STRING_PROPERTY(BoneGroup, name)
	ENUM_PROPERTY(color_set_enum, BoneGroup, color_set)
	BOOLEAN_PROPERTY(BoneGroup, is_custom_color_set)
	POINTER_PROPERTY(ThemeBoneColorSet, BoneGroup, colors)


	ENUM_PROPERTY(type_enum, LightProbe, type)
	FLOAT_PROPERTY(LightProbe, clip_start)
	FLOAT_PROPERTY(LightProbe, clip_end)
	BOOLEAN_PROPERTY(LightProbe, show_clip)
	ENUM_PROPERTY(influence_type_enum, LightProbe, influence_type)
	BOOLEAN_PROPERTY(LightProbe, show_influence)
	FLOAT_PROPERTY(LightProbe, influence_distance)
	FLOAT_PROPERTY(LightProbe, falloff)
	BOOLEAN_PROPERTY(LightProbe, use_custom_parallax)
	BOOLEAN_PROPERTY(LightProbe, show_parallax)
	ENUM_PROPERTY(parallax_type_enum, LightProbe, parallax_type)
	FLOAT_PROPERTY(LightProbe, parallax_distance)
	INT_PROPERTY(LightProbe, grid_resolution_x)
	INT_PROPERTY(LightProbe, grid_resolution_y)
	INT_PROPERTY(LightProbe, grid_resolution_z)
	FLOAT_PROPERTY(LightProbe, visibility_buffer_bias)
	FLOAT_PROPERTY(LightProbe, visibility_bleed_bias)
	FLOAT_PROPERTY(LightProbe, visibility_blur)
	FLOAT_PROPERTY(LightProbe, intensity)
	POINTER_PROPERTY(Collection, LightProbe, visibility_collection)
	BOOLEAN_PROPERTY(LightProbe, invert_visibility_collection)
	BOOLEAN_PROPERTY(LightProbe, show_data)
	POINTER_PROPERTY(AnimData, LightProbe, animation_data)


	POINTER_PROPERTY(Struct, RenderEngine, rna_type)
	BOOLEAN_PROPERTY(RenderEngine, is_animation)
	BOOLEAN_PROPERTY(RenderEngine, is_preview)
	POINTER_PROPERTY(Object, RenderEngine, camera_override)
	BOOLEAN_ARRAY_PROPERTY(RenderEngine, 20, layer_override)
	INT_PROPERTY(RenderEngine, tile_x)
	INT_PROPERTY(RenderEngine, tile_y)
	INT_PROPERTY(RenderEngine, resolution_x)
	INT_PROPERTY(RenderEngine, resolution_y)
	POINTER_PROPERTY(RenderSettings, RenderEngine, render)
	BOOLEAN_PROPERTY(RenderEngine, use_highlight_tiles)
	STRING_PROPERTY(RenderEngine, bl_idname)
	STRING_PROPERTY(RenderEngine, bl_label)
	BOOLEAN_PROPERTY(RenderEngine, bl_use_preview)
	BOOLEAN_PROPERTY(RenderEngine, bl_use_texture_preview)
	BOOLEAN_PROPERTY(RenderEngine, bl_use_postprocess)
	BOOLEAN_PROPERTY(RenderEngine, bl_use_shading_nodes)
	BOOLEAN_PROPERTY(RenderEngine, bl_use_shading_nodes_custom)
	BOOLEAN_PROPERTY(RenderEngine, bl_use_exclude_layers)
	BOOLEAN_PROPERTY(RenderEngine, bl_use_save_buffers)
	BOOLEAN_PROPERTY(RenderEngine, bl_use_spherical_stereo)

	inline void RenderEngine::tag_redraw() {
		RenderEngine_tag_redraw((::RenderEngine *) this->ptr.data);
	}

	inline void RenderEngine::tag_update() {
		RenderEngine_tag_update((::RenderEngine *) this->ptr.data);
	}

	inline RenderResult RenderEngine::begin_result(int x, int y, int w, int h, const char * layer, const char * view) {
		PointerRNA result;
		::RenderResult *retdata = RenderEngine_begin_result((::RenderEngine *) this->ptr.data, x, y, w, h, layer, view);
		RNA_pointer_create((::ID *) ptr.id.data, &RNA_RenderResult, retdata, &result);
		return RenderResult(result);
	}

	inline void RenderEngine::update_result(RenderResult& result) {
		RenderEngine_update_result((::RenderEngine *) this->ptr.data, (::RenderResult *) result.ptr.data);
	}

	inline void RenderEngine::end_result(RenderResult& result, bool cancel, bool highlight, bool do_merge_results) {
		RenderEngine_end_result((::RenderEngine *) this->ptr.data, (::RenderResult *) result.ptr.data, cancel, highlight, do_merge_results);
	}

	inline void RenderEngine::add_pass(const char * name, int channels, const char * chan_id, const char * layer) {
		RenderEngine_add_pass((::RenderEngine *) this->ptr.data, name, channels, chan_id, layer);
	}

	inline RenderResult RenderEngine::get_result() {
		PointerRNA result;
		::RenderResult *retdata = RenderEngine_get_result((::RenderEngine *) this->ptr.data);
		RNA_pointer_create((::ID *) ptr.id.data, &RNA_RenderResult, retdata, &result);
		return RenderResult(result);
	}

	inline bool RenderEngine::test_break() {
		return RenderEngine_test_break((::RenderEngine *) this->ptr.data);
	}

	inline const char * RenderEngine::active_view_get() {
		return RenderEngine_active_view_get((::RenderEngine *) this->ptr.data);
	}

	inline void RenderEngine::active_view_set(const char * view) {
		RenderEngine_active_view_set((::RenderEngine *) this->ptr.data, view);
	}

	inline float RenderEngine::camera_shift_x(Object& camera, bool use_spherical_stereo) {
		return RenderEngine_camera_shift_x((::RenderEngine *) this->ptr.data, (::Object *) camera.ptr.data, use_spherical_stereo);
	}

	inline void RenderEngine::camera_model_matrix(Object& camera, bool use_spherical_stereo, float r_model_matrix[16]) {
		RenderEngine_camera_model_matrix((::RenderEngine *) this->ptr.data, (::Object *) camera.ptr.data, use_spherical_stereo, r_model_matrix);
	}

	inline bool RenderEngine::use_spherical_stereo(Object& camera) {
		return RenderEngine_use_spherical_stereo((::RenderEngine *) this->ptr.data, (::Object *) camera.ptr.data);
	}

	inline void RenderEngine::update_stats(const char * stats, const char * info) {
		RenderEngine_update_stats((::RenderEngine *) this->ptr.data, stats, info);
	}

	inline void RenderEngine::frame_set(int frame, float subframe) {
		RenderEngine_frame_set((::RenderEngine *) this->ptr.data, frame, subframe);
	}

	inline void RenderEngine::update_progress(float progress) {
		RenderEngine_update_progress((::RenderEngine *) this->ptr.data, progress);
	}

	inline void RenderEngine::update_memory_stats(float memory_used, float memory_peak) {
		RenderEngine_update_memory_stats((::RenderEngine *) this->ptr.data, memory_used, memory_peak);
	}

	inline void RenderEngine::report(int type, const char * message) {
		RenderEngine_report((::RenderEngine *) this->ptr.data, type, message);
	}

	inline void RenderEngine::error_set(const char * message) {
		RenderEngine_error_set((::RenderEngine *) this->ptr.data, message);
	}

	inline void RenderEngine::bind_display_space_shader(Scene& scene) {
		RenderEngine_bind_display_space_shader((::RenderEngine *) this->ptr.data, (::Scene *) scene.ptr.data);
	}

	inline void RenderEngine::unbind_display_space_shader() {
		RenderEngine_unbind_display_space_shader((::RenderEngine *) this->ptr.data);
	}

	inline bool RenderEngine::support_display_space_shader(Scene& scene) {
		return RenderEngine_support_display_space_shader((::RenderEngine *) this->ptr.data, (::Scene *) scene.ptr.data);
	}

	inline int RenderEngine::get_preview_pixel_size(Scene& scene) {
		return RenderEngine_get_preview_pixel_size((::RenderEngine *) this->ptr.data, (::Scene *) scene.ptr.data);
	}

	inline void RenderEngine::free_blender_memory() {
		RenderEngine_free_blender_memory((::RenderEngine *) this->ptr.data);
	}

	inline void RenderEngine::register_pass(Scene& scene, ViewLayer& view_layer, const char * name, int channels, const char * chanid, int type) {
		RenderEngine_register_pass((::RenderEngine *) this->ptr.data, (::Scene *) scene.ptr.data, (::ViewLayer *) view_layer.ptr.data, name, channels, chanid, type);
	}


	POINTER_PROPERTY(Struct, RenderResult, rna_type)
	INT_PROPERTY(RenderResult, resolution_x)
	INT_PROPERTY(RenderResult, resolution_y)



	inline void RenderResult::load_from_file(const char * filename) {
		RenderResult_load_from_file((::RenderResult *) this->ptr.data, NULL, filename);
	}

	inline void RenderResult::stamp_data_add_field(const char * field, const char * value) {
		RenderResult_stamp_data_add_field((::RenderResult *) this->ptr.data, field, value);
	}


	POINTER_PROPERTY(Struct, RenderView, rna_type)
	STRING_PROPERTY(RenderView, name)


	POINTER_PROPERTY(Struct, RenderLayer, rna_type)
	STRING_PROPERTY(RenderLayer, name)
	BOOLEAN_PROPERTY(RenderLayer, use_zmask)
	BOOLEAN_PROPERTY(RenderLayer, invert_zmask)
	BOOLEAN_PROPERTY(RenderLayer, use_all_z)
	BOOLEAN_PROPERTY(RenderLayer, use_solid)
	BOOLEAN_PROPERTY(RenderLayer, use_halo)
	BOOLEAN_PROPERTY(RenderLayer, use_ztransp)
	BOOLEAN_PROPERTY(RenderLayer, use_sky)
	BOOLEAN_PROPERTY(RenderLayer, use_ao)
	BOOLEAN_PROPERTY(RenderLayer, use_edge_enhance)
	BOOLEAN_PROPERTY(RenderLayer, use_strand)
	BOOLEAN_PROPERTY(RenderLayer, use_pass_combined)
	BOOLEAN_PROPERTY(RenderLayer, use_pass_z)
	BOOLEAN_PROPERTY(RenderLayer, use_pass_vector)
	BOOLEAN_PROPERTY(RenderLayer, use_pass_normal)
	BOOLEAN_PROPERTY(RenderLayer, use_pass_uv)
	BOOLEAN_PROPERTY(RenderLayer, use_pass_mist)
	BOOLEAN_PROPERTY(RenderLayer, use_pass_object_index)
	BOOLEAN_PROPERTY(RenderLayer, use_pass_material_index)
	BOOLEAN_PROPERTY(RenderLayer, use_pass_shadow)
	BOOLEAN_PROPERTY(RenderLayer, use_pass_ambient_occlusion)
	BOOLEAN_PROPERTY(RenderLayer, use_pass_emit)
	BOOLEAN_PROPERTY(RenderLayer, use_pass_environment)
	BOOLEAN_PROPERTY(RenderLayer, use_pass_diffuse_direct)
	BOOLEAN_PROPERTY(RenderLayer, use_pass_diffuse_indirect)
	BOOLEAN_PROPERTY(RenderLayer, use_pass_diffuse_color)
	BOOLEAN_PROPERTY(RenderLayer, use_pass_glossy_direct)
	BOOLEAN_PROPERTY(RenderLayer, use_pass_glossy_indirect)
	BOOLEAN_PROPERTY(RenderLayer, use_pass_glossy_color)
	BOOLEAN_PROPERTY(RenderLayer, use_pass_transmission_direct)
	BOOLEAN_PROPERTY(RenderLayer, use_pass_transmission_indirect)
	BOOLEAN_PROPERTY(RenderLayer, use_pass_transmission_color)
	BOOLEAN_PROPERTY(RenderLayer, use_pass_subsurface_direct)
	BOOLEAN_PROPERTY(RenderLayer, use_pass_subsurface_indirect)
	BOOLEAN_PROPERTY(RenderLayer, use_pass_subsurface_color)


	inline void RenderLayer::load_from_file(const char * filename, int x, int y) {
		RenderLayer_load_from_file((::RenderLayer *) this->ptr.data, NULL, filename, x, y);
	}


	POINTER_PROPERTY(Struct, RenderPasses, rna_type)

	inline RenderPass RenderPasses::find_by_type(int pass_type, const char * view) {
		PointerRNA result;
		::RenderPass *retdata = RenderPasses_find_by_type((::RenderLayer *) this->ptr.data, pass_type, view);
		RNA_pointer_create((::ID *) ptr.id.data, &RNA_RenderPass, retdata, &result);
		return RenderPass(result);
	}

	inline RenderPass RenderPasses::find_by_name(const char * name, const char * view) {
		PointerRNA result;
		::RenderPass *retdata = RenderPasses_find_by_name((::RenderLayer *) this->ptr.data, name, view);
		RNA_pointer_create((::ID *) ptr.id.data, &RNA_RenderPass, retdata, &result);
		return RenderPass(result);
	}


	POINTER_PROPERTY(Struct, RenderPass, rna_type)
	STRING_PROPERTY(RenderPass, fullname)
	STRING_PROPERTY(RenderPass, name)
	STRING_PROPERTY(RenderPass, channel_id)
	INT_PROPERTY(RenderPass, channels)
	FLOAT_DYNAMIC_ARRAY_PROPERTY(RenderPass, rect)
	INT_PROPERTY(RenderPass, view_id)


	POINTER_PROPERTY(Struct, BakePixel, rna_type)
	INT_PROPERTY(BakePixel, primitive_id)
	INT_PROPERTY(BakePixel, object_id)
	FLOAT_ARRAY_PROPERTY(BakePixel, 2, uv)
	FLOAT_PROPERTY(BakePixel, du_dx)
	FLOAT_PROPERTY(BakePixel, du_dy)
	FLOAT_PROPERTY(BakePixel, dv_dx)
	FLOAT_PROPERTY(BakePixel, dv_dy)
	POINTER_PROPERTY(BakePixel, BakePixel, next)


	POINTER_PROPERTY(Struct, RigidBodyWorld, rna_type)
	POINTER_PROPERTY(Collection, RigidBodyWorld, collection)
	POINTER_PROPERTY(Collection, RigidBodyWorld, constraints)
	BOOLEAN_PROPERTY(RigidBodyWorld, enabled)
	FLOAT_PROPERTY(RigidBodyWorld, time_scale)
	INT_PROPERTY(RigidBodyWorld, steps_per_second)
	INT_PROPERTY(RigidBodyWorld, solver_iterations)
	BOOLEAN_PROPERTY(RigidBodyWorld, use_split_impulse)
	POINTER_PROPERTY(PointCache, RigidBodyWorld, point_cache)
	POINTER_PROPERTY(EffectorWeights, RigidBodyWorld, effector_weights)

	inline void RigidBodyWorld::convex_sweep_test(Object& object, float start[3], float end[3], float object_location[3], float hitpoint[3], float normal[3], int *has_hit) {
		RigidBodyWorld_convex_sweep_test((::RigidBodyWorld *) this->ptr.data, NULL, (::Object *) object.ptr.data, start, end, object_location, hitpoint, normal, has_hit);
	}


	POINTER_PROPERTY(Struct, RigidBodyObject, rna_type)
	ENUM_PROPERTY(type_enum, RigidBodyObject, type)
	ENUM_PROPERTY(mesh_source_enum, RigidBodyObject, mesh_source)
	BOOLEAN_PROPERTY(RigidBodyObject, enabled)
	ENUM_PROPERTY(collision_shape_enum, RigidBodyObject, collision_shape)
	BOOLEAN_PROPERTY(RigidBodyObject, kinematic)
	BOOLEAN_PROPERTY(RigidBodyObject, use_deform)
	FLOAT_PROPERTY(RigidBodyObject, mass)
	BOOLEAN_PROPERTY(RigidBodyObject, use_deactivation)
	BOOLEAN_PROPERTY(RigidBodyObject, use_start_deactivated)
	FLOAT_PROPERTY(RigidBodyObject, deactivate_linear_velocity)
	FLOAT_PROPERTY(RigidBodyObject, deactivate_angular_velocity)
	FLOAT_PROPERTY(RigidBodyObject, linear_damping)
	FLOAT_PROPERTY(RigidBodyObject, angular_damping)
	FLOAT_PROPERTY(RigidBodyObject, friction)
	FLOAT_PROPERTY(RigidBodyObject, restitution)
	BOOLEAN_PROPERTY(RigidBodyObject, use_margin)
	FLOAT_PROPERTY(RigidBodyObject, collision_margin)
	BOOLEAN_ARRAY_PROPERTY(RigidBodyObject, 20, collision_collections)


	POINTER_PROPERTY(Struct, RigidBodyConstraint, rna_type)
	ENUM_PROPERTY(type_enum, RigidBodyConstraint, type)
	ENUM_PROPERTY(spring_type_enum, RigidBodyConstraint, spring_type)
	BOOLEAN_PROPERTY(RigidBodyConstraint, enabled)
	BOOLEAN_PROPERTY(RigidBodyConstraint, disable_collisions)
	POINTER_PROPERTY(Object, RigidBodyConstraint, object1)
	POINTER_PROPERTY(Object, RigidBodyConstraint, object2)
	BOOLEAN_PROPERTY(RigidBodyConstraint, use_breaking)
	FLOAT_PROPERTY(RigidBodyConstraint, breaking_threshold)
	BOOLEAN_PROPERTY(RigidBodyConstraint, use_override_solver_iterations)
	INT_PROPERTY(RigidBodyConstraint, solver_iterations)
	BOOLEAN_PROPERTY(RigidBodyConstraint, use_limit_lin_x)
	BOOLEAN_PROPERTY(RigidBodyConstraint, use_limit_lin_y)
	BOOLEAN_PROPERTY(RigidBodyConstraint, use_limit_lin_z)
	BOOLEAN_PROPERTY(RigidBodyConstraint, use_limit_ang_x)
	BOOLEAN_PROPERTY(RigidBodyConstraint, use_limit_ang_y)
	BOOLEAN_PROPERTY(RigidBodyConstraint, use_limit_ang_z)
	BOOLEAN_PROPERTY(RigidBodyConstraint, use_spring_x)
	BOOLEAN_PROPERTY(RigidBodyConstraint, use_spring_y)
	BOOLEAN_PROPERTY(RigidBodyConstraint, use_spring_z)
	BOOLEAN_PROPERTY(RigidBodyConstraint, use_spring_ang_x)
	BOOLEAN_PROPERTY(RigidBodyConstraint, use_spring_ang_y)
	BOOLEAN_PROPERTY(RigidBodyConstraint, use_spring_ang_z)
	BOOLEAN_PROPERTY(RigidBodyConstraint, use_motor_lin)
	BOOLEAN_PROPERTY(RigidBodyConstraint, use_motor_ang)
	FLOAT_PROPERTY(RigidBodyConstraint, limit_lin_x_lower)
	FLOAT_PROPERTY(RigidBodyConstraint, limit_lin_x_upper)
	FLOAT_PROPERTY(RigidBodyConstraint, limit_lin_y_lower)
	FLOAT_PROPERTY(RigidBodyConstraint, limit_lin_y_upper)
	FLOAT_PROPERTY(RigidBodyConstraint, limit_lin_z_lower)
	FLOAT_PROPERTY(RigidBodyConstraint, limit_lin_z_upper)
	FLOAT_PROPERTY(RigidBodyConstraint, limit_ang_x_lower)
	FLOAT_PROPERTY(RigidBodyConstraint, limit_ang_x_upper)
	FLOAT_PROPERTY(RigidBodyConstraint, limit_ang_y_lower)
	FLOAT_PROPERTY(RigidBodyConstraint, limit_ang_y_upper)
	FLOAT_PROPERTY(RigidBodyConstraint, limit_ang_z_lower)
	FLOAT_PROPERTY(RigidBodyConstraint, limit_ang_z_upper)
	FLOAT_PROPERTY(RigidBodyConstraint, spring_stiffness_x)
	FLOAT_PROPERTY(RigidBodyConstraint, spring_stiffness_y)
	FLOAT_PROPERTY(RigidBodyConstraint, spring_stiffness_z)
	FLOAT_PROPERTY(RigidBodyConstraint, spring_stiffness_ang_x)
	FLOAT_PROPERTY(RigidBodyConstraint, spring_stiffness_ang_y)
	FLOAT_PROPERTY(RigidBodyConstraint, spring_stiffness_ang_z)
	FLOAT_PROPERTY(RigidBodyConstraint, spring_damping_x)
	FLOAT_PROPERTY(RigidBodyConstraint, spring_damping_y)
	FLOAT_PROPERTY(RigidBodyConstraint, spring_damping_z)
	FLOAT_PROPERTY(RigidBodyConstraint, spring_damping_ang_x)
	FLOAT_PROPERTY(RigidBodyConstraint, spring_damping_ang_y)
	FLOAT_PROPERTY(RigidBodyConstraint, spring_damping_ang_z)
	FLOAT_PROPERTY(RigidBodyConstraint, motor_lin_target_velocity)
	FLOAT_PROPERTY(RigidBodyConstraint, motor_lin_max_impulse)
	FLOAT_PROPERTY(RigidBodyConstraint, motor_ang_target_velocity)
	FLOAT_PROPERTY(RigidBodyConstraint, motor_ang_max_impulse)


	POINTER_PROPERTY(Object, Scene, camera)
	POINTER_PROPERTY(Scene, Scene, background_set)
	POINTER_PROPERTY(World, Scene, world)

	INT_PROPERTY(Scene, frame_current)
	FLOAT_PROPERTY(Scene, frame_subframe)
	FLOAT_PROPERTY(Scene, frame_float)
	INT_PROPERTY(Scene, frame_start)
	INT_PROPERTY(Scene, frame_end)
	INT_PROPERTY(Scene, frame_step)
	FLOAT_PROPERTY(Scene, frame_current_final)
	BOOLEAN_PROPERTY(Scene, lock_frame_selection_to_range)
	BOOLEAN_PROPERTY(Scene, use_preview_range)
	INT_PROPERTY(Scene, frame_preview_start)
	INT_PROPERTY(Scene, frame_preview_end)
	BOOLEAN_PROPERTY(Scene, show_subframe)
	BOOLEAN_PROPERTY(Scene, show_keys_from_selected_only)
	STRING_PROPERTY(Scene, use_stamp_note)
	POINTER_PROPERTY(AnimData, Scene, animation_data)
	BOOLEAN_PROPERTY(Scene, is_nla_tweakmode)
	ENUM_PROPERTY(sync_mode_enum, Scene, sync_mode)
	POINTER_PROPERTY(NodeTree, Scene, node_tree)
	BOOLEAN_PROPERTY(Scene, use_nodes)
	POINTER_PROPERTY(SequenceEditor, Scene, sequence_editor)


	POINTER_PROPERTY(RigidBodyWorld, Scene, rigidbody_world)
	POINTER_PROPERTY(ToolSettings, Scene, tool_settings)
	POINTER_PROPERTY(UnitSettings, Scene, unit_settings)
	FLOAT_ARRAY_PROPERTY(Scene, 3, gravity)
	BOOLEAN_PROPERTY(Scene, use_gravity)
	POINTER_PROPERTY(RenderSettings, Scene, render)
	POINTER_PROPERTY(DisplaySafeAreas, Scene, safe_areas)


	POINTER_PROPERTY(View3DCursor, Scene, cursor)
	BOOLEAN_PROPERTY(Scene, use_audio)
	BOOLEAN_PROPERTY(Scene, use_audio_scrub)
	FLOAT_PROPERTY(Scene, audio_doppler_speed)
	FLOAT_PROPERTY(Scene, audio_doppler_factor)
	ENUM_PROPERTY(audio_distance_model_enum, Scene, audio_distance_model)
	FLOAT_PROPERTY(Scene, audio_volume)
	POINTER_PROPERTY(GreasePencil, Scene, grease_pencil)
	POINTER_PROPERTY(MovieClip, Scene, active_clip)
	POINTER_PROPERTY(ColorManagedViewSettings, Scene, view_settings)
	POINTER_PROPERTY(ColorManagedDisplaySettings, Scene, display_settings)
	POINTER_PROPERTY(ColorManagedSequencerColorspaceSettings, Scene, sequencer_colorspace_settings)

	POINTER_PROPERTY(Collection, Scene, collection)
	POINTER_PROPERTY(SceneDisplay, Scene, display)
	POINTER_PROPERTY(SceneEEVEE, Scene, eevee)

	inline const char * Scene::statistics(void *main, ViewLayer& view_layer) {
		return Scene_statistics((::Scene *) this->ptr.data, (::Main *) main, (::ViewLayer *) view_layer.ptr.data);
	}

	inline void Scene::frame_set(void *main, int frame, float subframe) {
		Scene_frame_set((::Scene *) this->ptr.data, (::Main *) main, frame, subframe);
	}

	inline void Scene::update(void *main) {
		Scene_update((::Scene *) this->ptr.data, (::Main *) main);
	}

	inline void Scene::uvedit_aspect(Object& object, float result[2]) {
		Scene_uvedit_aspect((::Scene *) this->ptr.data, (::Object *) object.ptr.data, result);
	}

	inline void Scene::ray_cast(void *main, ViewLayer& view_layer, float origin[3], float direction[3], float distance, bool *result, float location[3], float normal[3], int *index, Object *object, float matrix[16]) {
		Scene_ray_cast((::Scene *) this->ptr.data, (::Main *) main, (::ViewLayer *) view_layer.ptr.data, origin, direction, distance, result, location, normal, index, (::Object **) &object->ptr.data, matrix);
	}

	inline SequenceEditor Scene::sequence_editor_create() {
		PointerRNA result;
		::Editing *retdata = Scene_sequence_editor_create((::Scene *) this->ptr.data);
		RNA_pointer_create((::ID *) ptr.id.data, &RNA_SequenceEditor, retdata, &result);
		return SequenceEditor(result);
	}

	inline void Scene::sequence_editor_clear() {
		Scene_sequence_editor_clear((::Scene *) this->ptr.data);
	}


	POINTER_PROPERTY(Struct, SceneObjects, rna_type)


	POINTER_PROPERTY(Struct, KeyingSets, rna_type)
	POINTER_PROPERTY(KeyingSet, KeyingSets, active)
	INT_PROPERTY(KeyingSets, active_index)

	inline KeyingSet KeyingSets::create(const char * idname, const char * name) {
		PointerRNA result;
		::KeyingSet *retdata = KeyingSets_new((::Scene *) this->ptr.data, NULL, idname, name);
		RNA_pointer_create((::ID *) ptr.id.data, &RNA_KeyingSet, retdata, &result);
		return KeyingSet(result);
	}


	POINTER_PROPERTY(Struct, KeyingSetsAll, rna_type)
	POINTER_PROPERTY(KeyingSet, KeyingSetsAll, active)
	INT_PROPERTY(KeyingSetsAll, active_index)


	POINTER_PROPERTY(Struct, TimelineMarkers, rna_type)

	inline TimelineMarker TimelineMarkers::create(const char * name, int frame) {
		PointerRNA result;
		::TimeMarker *retdata = TimelineMarkers_new((::Scene *) this->ptr.data, name, frame);
		RNA_pointer_create((::ID *) ptr.id.data, &RNA_TimelineMarker, retdata, &result);
		return TimelineMarker(result);
	}

	inline void TimelineMarkers::remove(TimelineMarker& marker) {
		TimelineMarkers_remove((::Scene *) this->ptr.data, NULL, (::PointerRNA *) &marker.ptr);
	}

	inline void TimelineMarkers::clear() {
		TimelineMarkers_clear((::Scene *) this->ptr.data);
	}


	POINTER_PROPERTY(Struct, ViewLayers, rna_type)

	inline ViewLayer ViewLayers::create(void *main, const char * name) {
		PointerRNA result;
		::ViewLayer *retdata = ViewLayers_new((::ID *) ptr.id.data, (::Scene *) this->ptr.data, (::Main *) main, name);
		RNA_pointer_create((::ID *) ptr.id.data, &RNA_ViewLayer, retdata, &result);
		return ViewLayer(result);
	}

	inline void ViewLayers::remove(void *main, ViewLayer& layer) {
		ViewLayers_remove((::ID *) ptr.id.data, (::Scene *) this->ptr.data, (::Main *) main, NULL, (::PointerRNA *) &layer.ptr);
	}


	POINTER_PROPERTY(Struct, ToolSettings, rna_type)
	POINTER_PROPERTY(Sculpt, ToolSettings, sculpt)
	BOOLEAN_PROPERTY(ToolSettings, use_auto_normalize)
	BOOLEAN_PROPERTY(ToolSettings, use_multipaint)
	ENUM_PROPERTY(vertex_group_user_enum, ToolSettings, vertex_group_user)
	ENUM_PROPERTY(vertex_group_subset_enum, ToolSettings, vertex_group_subset)
	POINTER_PROPERTY(VertexPaint, ToolSettings, vertex_paint)
	POINTER_PROPERTY(VertexPaint, ToolSettings, weight_paint)
	POINTER_PROPERTY(ImagePaint, ToolSettings, image_paint)
	POINTER_PROPERTY(UvSculpt, ToolSettings, uv_sculpt)
	POINTER_PROPERTY(GpPaint, ToolSettings, gpencil_paint)
	POINTER_PROPERTY(ParticleEdit, ToolSettings, particle_edit)
	BOOLEAN_PROPERTY(ToolSettings, use_uv_sculpt)
	BOOLEAN_PROPERTY(ToolSettings, uv_sculpt_lock_borders)
	BOOLEAN_PROPERTY(ToolSettings, uv_sculpt_all_islands)
	ENUM_PROPERTY(uv_sculpt_tool_enum, ToolSettings, uv_sculpt_tool)
	ENUM_PROPERTY(uv_relax_method_enum, ToolSettings, uv_relax_method)
	BOOLEAN_PROPERTY(ToolSettings, lock_object_mode)
	ENUM_PROPERTY(proportional_edit_enum, ToolSettings, proportional_edit)
	BOOLEAN_PROPERTY(ToolSettings, use_proportional_edit_objects)
	BOOLEAN_PROPERTY(ToolSettings, use_proportional_edit_mask)
	BOOLEAN_PROPERTY(ToolSettings, use_proportional_action)
	BOOLEAN_PROPERTY(ToolSettings, use_proportional_fcurve)
	BOOLEAN_PROPERTY(ToolSettings, lock_markers)
	ENUM_PROPERTY(proportional_edit_falloff_enum, ToolSettings, proportional_edit_falloff)
	FLOAT_PROPERTY(ToolSettings, proportional_size)
	FLOAT_PROPERTY(ToolSettings, double_threshold)
	ENUM_PROPERTY(transform_pivot_point_enum, ToolSettings, transform_pivot_point)
	BOOLEAN_PROPERTY(ToolSettings, use_transform_pivot_point_align)
	BOOLEAN_PROPERTY(ToolSettings, use_mesh_automerge)
	BOOLEAN_PROPERTY(ToolSettings, use_snap)
	BOOLEAN_PROPERTY(ToolSettings, use_snap_align_rotation)
	BOOLEAN_PROPERTY(ToolSettings, use_snap_grid_absolute)
	ENUM_PROPERTY(snap_elements_enum, ToolSettings, snap_elements)
	ENUM_PROPERTY(snap_node_element_enum, ToolSettings, snap_node_element)
	ENUM_PROPERTY(snap_uv_element_enum, ToolSettings, snap_uv_element)
	ENUM_PROPERTY(snap_target_enum, ToolSettings, snap_target)
	BOOLEAN_PROPERTY(ToolSettings, use_snap_peel_object)
	BOOLEAN_PROPERTY(ToolSettings, use_snap_project)
	BOOLEAN_PROPERTY(ToolSettings, use_snap_self)
	BOOLEAN_PROPERTY(ToolSettings, use_snap_translate)
	BOOLEAN_PROPERTY(ToolSettings, use_snap_rotate)
	BOOLEAN_PROPERTY(ToolSettings, use_snap_scale)
	ENUM_PROPERTY(use_gizmo_mode_enum, ToolSettings, use_gizmo_mode)
	BOOLEAN_PROPERTY(ToolSettings, use_gpencil_draw_additive)
	BOOLEAN_PROPERTY(ToolSettings, use_gpencil_draw_onback)
	BOOLEAN_PROPERTY(ToolSettings, use_gpencil_thumbnail_list)
	BOOLEAN_PROPERTY(ToolSettings, use_gpencil_weight_data_add)
	POINTER_PROPERTY(GPencilSculptSettings, ToolSettings, gpencil_sculpt)
	POINTER_PROPERTY(GPencilInterpolateSettings, ToolSettings, gpencil_interpolate)
	ENUM_PROPERTY(gpencil_stroke_placement_view3d_enum, ToolSettings, gpencil_stroke_placement_view3d)
	ENUM_PROPERTY(gpencil_stroke_snap_mode_enum, ToolSettings, gpencil_stroke_snap_mode)
	BOOLEAN_PROPERTY(ToolSettings, use_gpencil_stroke_endpoints)
	ENUM_PROPERTY(gpencil_selectmode_enum, ToolSettings, gpencil_selectmode)
	ENUM_PROPERTY(annotation_stroke_placement_view2d_enum, ToolSettings, annotation_stroke_placement_view2d)
	ENUM_PROPERTY(annotation_stroke_placement_sequencer_preview_enum, ToolSettings, annotation_stroke_placement_sequencer_preview)
	ENUM_PROPERTY(annotation_stroke_placement_image_editor_enum, ToolSettings, annotation_stroke_placement_image_editor)
	ENUM_PROPERTY(annotation_stroke_placement_view3d_enum, ToolSettings, annotation_stroke_placement_view3d)
	INT_PROPERTY(ToolSettings, annotation_thickness)
	BOOLEAN_PROPERTY(ToolSettings, use_keyframe_insert_auto)
	ENUM_PROPERTY(auto_keying_mode_enum, ToolSettings, auto_keying_mode)
	BOOLEAN_PROPERTY(ToolSettings, use_record_with_nla)
	BOOLEAN_PROPERTY(ToolSettings, use_keyframe_insert_keyingset)
	BOOLEAN_PROPERTY(ToolSettings, use_keyframe_cycle_aware)
	ENUM_PROPERTY(keyframe_type_enum, ToolSettings, keyframe_type)
	ENUM_PROPERTY(uv_select_mode_enum, ToolSettings, uv_select_mode)
	BOOLEAN_PROPERTY(ToolSettings, use_uv_select_sync)
	BOOLEAN_PROPERTY(ToolSettings, show_uv_local_view)
	BOOLEAN_ARRAY_PROPERTY(ToolSettings, 3, mesh_select_mode)
	FLOAT_PROPERTY(ToolSettings, vertex_group_weight)
	ENUM_PROPERTY(edge_path_mode_enum, ToolSettings, edge_path_mode)
	BOOLEAN_PROPERTY(ToolSettings, use_edge_path_live_unwrap)
	FLOAT_ARRAY_PROPERTY(ToolSettings, 3, normal_vector)
	ENUM_PROPERTY(face_strength_enum, ToolSettings, face_strength)
	POINTER_PROPERTY(UnifiedPaintSettings, ToolSettings, unified_paint_settings)
	POINTER_PROPERTY(CurvePaintSettings, ToolSettings, curve_paint_settings)
	POINTER_PROPERTY(MeshStatVis, ToolSettings, statvis)


	POINTER_PROPERTY(Struct, GPencilInterpolateSettings, rna_type)
	BOOLEAN_PROPERTY(GPencilInterpolateSettings, interpolate_all_layers)
	BOOLEAN_PROPERTY(GPencilInterpolateSettings, interpolate_selected_only)
	ENUM_PROPERTY(type_enum, GPencilInterpolateSettings, type)
	ENUM_PROPERTY(easing_enum, GPencilInterpolateSettings, easing)
	FLOAT_PROPERTY(GPencilInterpolateSettings, back)
	FLOAT_PROPERTY(GPencilInterpolateSettings, amplitude)
	FLOAT_PROPERTY(GPencilInterpolateSettings, period)
	POINTER_PROPERTY(CurveMapping, GPencilInterpolateSettings, interpolation_curve)


	POINTER_PROPERTY(Struct, UnifiedPaintSettings, rna_type)
	BOOLEAN_PROPERTY(UnifiedPaintSettings, use_unified_size)
	BOOLEAN_PROPERTY(UnifiedPaintSettings, use_unified_strength)
	BOOLEAN_PROPERTY(UnifiedPaintSettings, use_unified_weight)
	BOOLEAN_PROPERTY(UnifiedPaintSettings, use_unified_color)
	INT_PROPERTY(UnifiedPaintSettings, size)
	FLOAT_PROPERTY(UnifiedPaintSettings, unprojected_radius)
	FLOAT_PROPERTY(UnifiedPaintSettings, strength)
	FLOAT_PROPERTY(UnifiedPaintSettings, weight)
	FLOAT_ARRAY_PROPERTY(UnifiedPaintSettings, 3, color)
	FLOAT_ARRAY_PROPERTY(UnifiedPaintSettings, 3, secondary_color)
	BOOLEAN_PROPERTY(UnifiedPaintSettings, use_pressure_size)
	BOOLEAN_PROPERTY(UnifiedPaintSettings, use_pressure_strength)
	ENUM_PROPERTY(use_locked_size_enum, UnifiedPaintSettings, use_locked_size)


	POINTER_PROPERTY(Struct, CurvePaintSettings, rna_type)
	ENUM_PROPERTY(curve_type_enum, CurvePaintSettings, curve_type)
	BOOLEAN_PROPERTY(CurvePaintSettings, use_corners_detect)
	BOOLEAN_PROPERTY(CurvePaintSettings, use_pressure_radius)
	BOOLEAN_PROPERTY(CurvePaintSettings, use_stroke_endpoints)
	BOOLEAN_PROPERTY(CurvePaintSettings, use_offset_absolute)
	INT_PROPERTY(CurvePaintSettings, error_threshold)
	ENUM_PROPERTY(fit_method_enum, CurvePaintSettings, fit_method)
	FLOAT_PROPERTY(CurvePaintSettings, corner_angle)
	FLOAT_PROPERTY(CurvePaintSettings, radius_min)
	FLOAT_PROPERTY(CurvePaintSettings, radius_max)
	FLOAT_PROPERTY(CurvePaintSettings, radius_taper_start)
	FLOAT_PROPERTY(CurvePaintSettings, radius_taper_end)
	FLOAT_PROPERTY(CurvePaintSettings, surface_offset)
	ENUM_PROPERTY(depth_mode_enum, CurvePaintSettings, depth_mode)
	ENUM_PROPERTY(surface_plane_enum, CurvePaintSettings, surface_plane)


	POINTER_PROPERTY(Struct, MeshStatVis, rna_type)
	ENUM_PROPERTY(type_enum, MeshStatVis, type)
	FLOAT_PROPERTY(MeshStatVis, overhang_min)
	FLOAT_PROPERTY(MeshStatVis, overhang_max)
	ENUM_PROPERTY(overhang_axis_enum, MeshStatVis, overhang_axis)
	FLOAT_PROPERTY(MeshStatVis, thickness_min)
	FLOAT_PROPERTY(MeshStatVis, thickness_max)
	INT_PROPERTY(MeshStatVis, thickness_samples)
	FLOAT_PROPERTY(MeshStatVis, distort_min)
	FLOAT_PROPERTY(MeshStatVis, distort_max)
	FLOAT_PROPERTY(MeshStatVis, sharp_min)
	FLOAT_PROPERTY(MeshStatVis, sharp_max)


	POINTER_PROPERTY(Struct, UnitSettings, rna_type)
	ENUM_PROPERTY(system_enum, UnitSettings, system)
	ENUM_PROPERTY(system_rotation_enum, UnitSettings, system_rotation)
	FLOAT_PROPERTY(UnitSettings, scale_length)
	BOOLEAN_PROPERTY(UnitSettings, use_separate)
	ENUM_PROPERTY(length_unit_enum, UnitSettings, length_unit)
	ENUM_PROPERTY(mass_unit_enum, UnitSettings, mass_unit)
	ENUM_PROPERTY(time_unit_enum, UnitSettings, time_unit)


	POINTER_PROPERTY(Struct, Stereo3dFormat, rna_type)
	ENUM_PROPERTY(display_mode_enum, Stereo3dFormat, display_mode)
	ENUM_PROPERTY(anaglyph_type_enum, Stereo3dFormat, anaglyph_type)
	ENUM_PROPERTY(interlace_type_enum, Stereo3dFormat, interlace_type)
	BOOLEAN_PROPERTY(Stereo3dFormat, use_interlace_swap)
	BOOLEAN_PROPERTY(Stereo3dFormat, use_sidebyside_crosseyed)
	BOOLEAN_PROPERTY(Stereo3dFormat, use_squeezed_frame)


	POINTER_PROPERTY(Struct, ImageFormatSettings, rna_type)
	ENUM_PROPERTY(file_format_enum, ImageFormatSettings, file_format)
	ENUM_PROPERTY(color_mode_enum, ImageFormatSettings, color_mode)
	ENUM_PROPERTY(color_depth_enum, ImageFormatSettings, color_depth)
	INT_PROPERTY(ImageFormatSettings, quality)
	INT_PROPERTY(ImageFormatSettings, compression)
	BOOLEAN_PROPERTY(ImageFormatSettings, use_zbuffer)
	BOOLEAN_PROPERTY(ImageFormatSettings, use_preview)
	ENUM_PROPERTY(exr_codec_enum, ImageFormatSettings, exr_codec)
	BOOLEAN_PROPERTY(ImageFormatSettings, use_jpeg2k_ycc)
	BOOLEAN_PROPERTY(ImageFormatSettings, use_jpeg2k_cinema_preset)
	BOOLEAN_PROPERTY(ImageFormatSettings, use_jpeg2k_cinema_48)
	ENUM_PROPERTY(jpeg2k_codec_enum, ImageFormatSettings, jpeg2k_codec)
	ENUM_PROPERTY(tiff_codec_enum, ImageFormatSettings, tiff_codec)
	BOOLEAN_PROPERTY(ImageFormatSettings, use_cineon_log)
	INT_PROPERTY(ImageFormatSettings, cineon_black)
	INT_PROPERTY(ImageFormatSettings, cineon_white)
	FLOAT_PROPERTY(ImageFormatSettings, cineon_gamma)
	ENUM_PROPERTY(views_format_enum, ImageFormatSettings, views_format)
	POINTER_PROPERTY(Stereo3dFormat, ImageFormatSettings, stereo_3d_format)
	POINTER_PROPERTY(ColorManagedViewSettings, ImageFormatSettings, view_settings)
	POINTER_PROPERTY(ColorManagedDisplaySettings, ImageFormatSettings, display_settings)


	POINTER_PROPERTY(Struct, TransformOrientation, rna_type)
	FLOAT_ARRAY_PROPERTY(TransformOrientation, 9, matrix)
	STRING_PROPERTY(TransformOrientation, name)


	POINTER_PROPERTY(Struct, TransformOrientationSlot, rna_type)
	ENUM_PROPERTY(type_enum, TransformOrientationSlot, type)
	POINTER_PROPERTY(TransformOrientation, TransformOrientationSlot, custom_orientation)
	BOOLEAN_PROPERTY(TransformOrientationSlot, use)


	POINTER_PROPERTY(Struct, View3DCursor, rna_type)
	FLOAT_ARRAY_PROPERTY(View3DCursor, 3, location)
	FLOAT_ARRAY_PROPERTY(View3DCursor, 4, rotation_quaternion)
	FLOAT_ARRAY_PROPERTY(View3DCursor, 4, rotation_axis_angle)
	FLOAT_ARRAY_PROPERTY(View3DCursor, 3, rotation_euler)
	ENUM_PROPERTY(rotation_mode_enum, View3DCursor, rotation_mode)




	POINTER_PROPERTY(Struct, DisplaySafeAreas, rna_type)
	FLOAT_ARRAY_PROPERTY(DisplaySafeAreas, 2, title)
	FLOAT_ARRAY_PROPERTY(DisplaySafeAreas, 2, action)
	FLOAT_ARRAY_PROPERTY(DisplaySafeAreas, 2, title_center)
	FLOAT_ARRAY_PROPERTY(DisplaySafeAreas, 2, action_center)


	POINTER_PROPERTY(Struct, SceneDisplay, rna_type)
	FLOAT_ARRAY_PROPERTY(SceneDisplay, 3, light_direction)
	FLOAT_PROPERTY(SceneDisplay, shadow_shift)
	FLOAT_PROPERTY(SceneDisplay, shadow_focus)
	FLOAT_PROPERTY(SceneDisplay, matcap_ssao_distance)
	FLOAT_PROPERTY(SceneDisplay, matcap_ssao_attenuation)
	INT_PROPERTY(SceneDisplay, matcap_ssao_samples)
	POINTER_PROPERTY(View3DShading, SceneDisplay, shading)


	POINTER_PROPERTY(Struct, SceneEEVEE, rna_type)
	INT_PROPERTY(SceneEEVEE, gi_diffuse_bounces)
	ENUM_PROPERTY(gi_cubemap_resolution_enum, SceneEEVEE, gi_cubemap_resolution)
	ENUM_PROPERTY(gi_visibility_resolution_enum, SceneEEVEE, gi_visibility_resolution)
	FLOAT_PROPERTY(SceneEEVEE, gi_irradiance_smoothing)
	FLOAT_PROPERTY(SceneEEVEE, gi_glossy_clamp)
	FLOAT_PROPERTY(SceneEEVEE, gi_filter_quality)
	BOOLEAN_PROPERTY(SceneEEVEE, gi_show_irradiance)
	BOOLEAN_PROPERTY(SceneEEVEE, gi_show_cubemaps)
	FLOAT_PROPERTY(SceneEEVEE, gi_irradiance_display_size)
	FLOAT_PROPERTY(SceneEEVEE, gi_cubemap_display_size)
	BOOLEAN_PROPERTY(SceneEEVEE, gi_auto_bake)
	STRING_PROPERTY(SceneEEVEE, gi_cache_info)
	INT_PROPERTY(SceneEEVEE, taa_samples)
	INT_PROPERTY(SceneEEVEE, taa_render_samples)
	BOOLEAN_PROPERTY(SceneEEVEE, use_taa_reprojection)
	BOOLEAN_PROPERTY(SceneEEVEE, use_sss)
	INT_PROPERTY(SceneEEVEE, sss_samples)
	FLOAT_PROPERTY(SceneEEVEE, sss_jitter_threshold)
	BOOLEAN_PROPERTY(SceneEEVEE, use_sss_separate_albedo)
	BOOLEAN_PROPERTY(SceneEEVEE, use_ssr)
	BOOLEAN_PROPERTY(SceneEEVEE, use_ssr_refraction)
	BOOLEAN_PROPERTY(SceneEEVEE, use_ssr_halfres)
	FLOAT_PROPERTY(SceneEEVEE, ssr_quality)
	FLOAT_PROPERTY(SceneEEVEE, ssr_max_roughness)
	FLOAT_PROPERTY(SceneEEVEE, ssr_thickness)
	FLOAT_PROPERTY(SceneEEVEE, ssr_border_fade)
	FLOAT_PROPERTY(SceneEEVEE, ssr_firefly_fac)
	BOOLEAN_PROPERTY(SceneEEVEE, use_volumetric)
	FLOAT_PROPERTY(SceneEEVEE, volumetric_start)
	FLOAT_PROPERTY(SceneEEVEE, volumetric_end)
	ENUM_PROPERTY(volumetric_tile_size_enum, SceneEEVEE, volumetric_tile_size)
	INT_PROPERTY(SceneEEVEE, volumetric_samples)
	FLOAT_PROPERTY(SceneEEVEE, volumetric_sample_distribution)
	BOOLEAN_PROPERTY(SceneEEVEE, use_volumetric_lights)
	FLOAT_PROPERTY(SceneEEVEE, volumetric_light_clamp)
	BOOLEAN_PROPERTY(SceneEEVEE, use_volumetric_shadows)
	INT_PROPERTY(SceneEEVEE, volumetric_shadow_samples)
	BOOLEAN_PROPERTY(SceneEEVEE, use_gtao)
	BOOLEAN_PROPERTY(SceneEEVEE, use_gtao_bent_normals)
	BOOLEAN_PROPERTY(SceneEEVEE, use_gtao_bounce)
	FLOAT_PROPERTY(SceneEEVEE, gtao_factor)
	FLOAT_PROPERTY(SceneEEVEE, gtao_quality)
	FLOAT_PROPERTY(SceneEEVEE, gtao_distance)
	BOOLEAN_PROPERTY(SceneEEVEE, use_dof)
	FLOAT_PROPERTY(SceneEEVEE, bokeh_max_size)
	FLOAT_PROPERTY(SceneEEVEE, bokeh_threshold)
	BOOLEAN_PROPERTY(SceneEEVEE, use_bloom)
	FLOAT_PROPERTY(SceneEEVEE, bloom_threshold)
	FLOAT_ARRAY_PROPERTY(SceneEEVEE, 3, bloom_color)
	FLOAT_PROPERTY(SceneEEVEE, bloom_knee)
	FLOAT_PROPERTY(SceneEEVEE, bloom_radius)
	FLOAT_PROPERTY(SceneEEVEE, bloom_clamp)
	FLOAT_PROPERTY(SceneEEVEE, bloom_intensity)
	BOOLEAN_PROPERTY(SceneEEVEE, use_motion_blur)
	INT_PROPERTY(SceneEEVEE, motion_blur_samples)
	FLOAT_PROPERTY(SceneEEVEE, motion_blur_shutter)
	ENUM_PROPERTY(shadow_method_enum, SceneEEVEE, shadow_method)
	ENUM_PROPERTY(shadow_cube_size_enum, SceneEEVEE, shadow_cube_size)
	ENUM_PROPERTY(shadow_cascade_size_enum, SceneEEVEE, shadow_cascade_size)
	BOOLEAN_PROPERTY(SceneEEVEE, use_shadow_high_bitdepth)
	BOOLEAN_PROPERTY(SceneEEVEE, use_soft_shadows)
	FLOAT_PROPERTY(SceneEEVEE, light_threshold)
	BOOLEAN_PROPERTY(SceneEEVEE, use_overscan)
	FLOAT_PROPERTY(SceneEEVEE, overscan_size)


	POINTER_PROPERTY(Struct, FFmpegSettings, rna_type)
	ENUM_PROPERTY(format_enum, FFmpegSettings, format)
	ENUM_PROPERTY(codec_enum, FFmpegSettings, codec)
	INT_PROPERTY(FFmpegSettings, video_bitrate)
	INT_PROPERTY(FFmpegSettings, minrate)
	INT_PROPERTY(FFmpegSettings, maxrate)
	INT_PROPERTY(FFmpegSettings, muxrate)
	INT_PROPERTY(FFmpegSettings, gopsize)
	INT_PROPERTY(FFmpegSettings, max_b_frames)
	BOOLEAN_PROPERTY(FFmpegSettings, use_max_b_frames)
	INT_PROPERTY(FFmpegSettings, buffersize)
	INT_PROPERTY(FFmpegSettings, packetsize)
	ENUM_PROPERTY(constant_rate_factor_enum, FFmpegSettings, constant_rate_factor)
	ENUM_PROPERTY(ffmpeg_preset_enum, FFmpegSettings, ffmpeg_preset)
	BOOLEAN_PROPERTY(FFmpegSettings, use_autosplit)
	BOOLEAN_PROPERTY(FFmpegSettings, use_lossless_output)
	ENUM_PROPERTY(audio_codec_enum, FFmpegSettings, audio_codec)
	INT_PROPERTY(FFmpegSettings, audio_bitrate)
	FLOAT_PROPERTY(FFmpegSettings, audio_volume)
	INT_PROPERTY(FFmpegSettings, audio_mixrate)
	ENUM_PROPERTY(audio_channels_enum, FFmpegSettings, audio_channels)


	POINTER_PROPERTY(Struct, RenderSettings, rna_type)
	POINTER_PROPERTY(ImageFormatSettings, RenderSettings, image_settings)
	INT_PROPERTY(RenderSettings, resolution_x)
	INT_PROPERTY(RenderSettings, resolution_y)
	INT_PROPERTY(RenderSettings, resolution_percentage)
	INT_PROPERTY(RenderSettings, tile_x)
	INT_PROPERTY(RenderSettings, tile_y)
	INT_PROPERTY(RenderSettings, preview_start_resolution)
	ENUM_PROPERTY(preview_pixel_size_enum, RenderSettings, preview_pixel_size)
	FLOAT_PROPERTY(RenderSettings, pixel_aspect_x)
	FLOAT_PROPERTY(RenderSettings, pixel_aspect_y)
	POINTER_PROPERTY(FFmpegSettings, RenderSettings, ffmpeg)
	INT_PROPERTY(RenderSettings, fps)
	FLOAT_PROPERTY(RenderSettings, fps_base)
	INT_PROPERTY(RenderSettings, frame_map_old)
	INT_PROPERTY(RenderSettings, frame_map_new)
	FLOAT_PROPERTY(RenderSettings, dither_intensity)
	FLOAT_PROPERTY(RenderSettings, filter_size)
	ENUM_PROPERTY(alpha_mode_enum, RenderSettings, alpha_mode)
	BOOLEAN_PROPERTY(RenderSettings, use_antialiasing)
	ENUM_PROPERTY(antialiasing_samples_enum, RenderSettings, antialiasing_samples)
	BOOLEAN_PROPERTY(RenderSettings, use_freestyle)
	INT_PROPERTY(RenderSettings, threads)
	ENUM_PROPERTY(threads_mode_enum, RenderSettings, threads_mode)
	BOOLEAN_PROPERTY(RenderSettings, use_motion_blur)
	FLOAT_PROPERTY(RenderSettings, motion_blur_shutter)
	POINTER_PROPERTY(CurveMapping, RenderSettings, motion_blur_shutter_curve)
	ENUM_PROPERTY(hair_type_enum, RenderSettings, hair_type)
	INT_PROPERTY(RenderSettings, hair_subdiv)
	BOOLEAN_PROPERTY(RenderSettings, use_border)
	FLOAT_PROPERTY(RenderSettings, border_min_x)
	FLOAT_PROPERTY(RenderSettings, border_min_y)
	FLOAT_PROPERTY(RenderSettings, border_max_x)
	FLOAT_PROPERTY(RenderSettings, border_max_y)
	BOOLEAN_PROPERTY(RenderSettings, use_crop_to_border)
	BOOLEAN_PROPERTY(RenderSettings, use_placeholder)
	BOOLEAN_PROPERTY(RenderSettings, use_overwrite)
	BOOLEAN_PROPERTY(RenderSettings, use_compositing)
	BOOLEAN_PROPERTY(RenderSettings, use_sequencer)
	BOOLEAN_PROPERTY(RenderSettings, use_file_extension)
	STRING_PROPERTY(RenderSettings, file_extension)
	BOOLEAN_PROPERTY(RenderSettings, is_movie_format)
	BOOLEAN_PROPERTY(RenderSettings, use_save_buffers)
	BOOLEAN_PROPERTY(RenderSettings, use_full_sample)
	ENUM_PROPERTY(display_mode_enum, RenderSettings, display_mode)
	BOOLEAN_PROPERTY(RenderSettings, use_lock_interface)
	STRING_PROPERTY(RenderSettings, filepath)
	BOOLEAN_PROPERTY(RenderSettings, use_render_cache)
	ENUM_PROPERTY(bake_type_enum, RenderSettings, bake_type)
	BOOLEAN_PROPERTY(RenderSettings, use_bake_selected_to_active)
	BOOLEAN_PROPERTY(RenderSettings, use_bake_clear)
	INT_PROPERTY(RenderSettings, bake_margin)
	FLOAT_PROPERTY(RenderSettings, bake_bias)
	BOOLEAN_PROPERTY(RenderSettings, use_bake_multires)
	BOOLEAN_PROPERTY(RenderSettings, use_bake_lores_mesh)
	INT_PROPERTY(RenderSettings, bake_samples)
	BOOLEAN_PROPERTY(RenderSettings, use_bake_user_scale)
	FLOAT_PROPERTY(RenderSettings, bake_user_scale)
	BOOLEAN_PROPERTY(RenderSettings, use_stamp_time)
	BOOLEAN_PROPERTY(RenderSettings, use_stamp_date)
	BOOLEAN_PROPERTY(RenderSettings, use_stamp_frame)
	BOOLEAN_PROPERTY(RenderSettings, use_stamp_frame_range)
	BOOLEAN_PROPERTY(RenderSettings, use_stamp_camera)
	BOOLEAN_PROPERTY(RenderSettings, use_stamp_lens)
	BOOLEAN_PROPERTY(RenderSettings, use_stamp_scene)
	BOOLEAN_PROPERTY(RenderSettings, use_stamp_note)
	BOOLEAN_PROPERTY(RenderSettings, use_stamp_marker)
	BOOLEAN_PROPERTY(RenderSettings, use_stamp_filename)
	BOOLEAN_PROPERTY(RenderSettings, use_stamp_sequencer_strip)
	BOOLEAN_PROPERTY(RenderSettings, use_stamp_render_time)
	STRING_PROPERTY(RenderSettings, stamp_note_text)
	BOOLEAN_PROPERTY(RenderSettings, use_stamp)
	BOOLEAN_PROPERTY(RenderSettings, use_stamp_labels)
	BOOLEAN_PROPERTY(RenderSettings, use_stamp_strip_meta)
	BOOLEAN_PROPERTY(RenderSettings, use_stamp_memory)
	BOOLEAN_PROPERTY(RenderSettings, use_stamp_hostname)
	INT_PROPERTY(RenderSettings, stamp_font_size)
	FLOAT_ARRAY_PROPERTY(RenderSettings, 4, stamp_foreground)
	FLOAT_ARRAY_PROPERTY(RenderSettings, 4, stamp_background)
	ENUM_PROPERTY(sequencer_gl_preview_enum, RenderSettings, sequencer_gl_preview)
	BOOLEAN_PROPERTY(RenderSettings, use_sequencer_gl_textured_solid)
	BOOLEAN_PROPERTY(RenderSettings, use_sequencer_gl_dof)
	BOOLEAN_PROPERTY(RenderSettings, use_single_layer)


	BOOLEAN_PROPERTY(RenderSettings, use_multiview)
	ENUM_PROPERTY(views_format_enum, RenderSettings, views_format)
	ENUM_PROPERTY(engine_enum, RenderSettings, engine)
	BOOLEAN_PROPERTY(RenderSettings, has_multiple_engines)
	BOOLEAN_PROPERTY(RenderSettings, use_spherical_stereo)
	BOOLEAN_PROPERTY(RenderSettings, use_simplify)
	INT_PROPERTY(RenderSettings, simplify_subdivision)
	FLOAT_PROPERTY(RenderSettings, simplify_child_particles)
	INT_PROPERTY(RenderSettings, simplify_subdivision_render)
	FLOAT_PROPERTY(RenderSettings, simplify_child_particles_render)
	BOOLEAN_PROPERTY(RenderSettings, use_simplify_smoke_highres)
	BOOLEAN_PROPERTY(RenderSettings, simplify_gpencil)
	BOOLEAN_PROPERTY(RenderSettings, simplify_gpencil_onplay)
	BOOLEAN_PROPERTY(RenderSettings, simplify_gpencil_view_fill)
	BOOLEAN_PROPERTY(RenderSettings, simplify_gpencil_remove_lines)
	BOOLEAN_PROPERTY(RenderSettings, simplify_gpencil_view_modifier)
	BOOLEAN_PROPERTY(RenderSettings, simplify_gpencil_shader_fx)
	BOOLEAN_PROPERTY(RenderSettings, simplify_gpencil_blend)
	BOOLEAN_PROPERTY(RenderSettings, use_persistent_data)
	ENUM_PROPERTY(line_thickness_mode_enum, RenderSettings, line_thickness_mode)
	FLOAT_PROPERTY(RenderSettings, line_thickness)
	POINTER_PROPERTY(BakeSettings, RenderSettings, bake)

	inline void RenderSettings::frame_path(void *main, int frame, bool preview, const char * view, char * filepath) {
		RenderSettings_frame_path((::RenderData *) this->ptr.data, (::Main *) main, frame, preview, view, filepath);
	}


	POINTER_PROPERTY(Struct, RenderViews, rna_type)
	INT_PROPERTY(RenderViews, active_index)
	POINTER_PROPERTY(SceneRenderView, RenderViews, active)

	inline SceneRenderView RenderViews::create(const char * name) {
		PointerRNA result;
		::SceneRenderView *retdata = RenderViews_new((::ID *) ptr.id.data, (::RenderData *) this->ptr.data, name);
		RNA_pointer_create((::ID *) ptr.id.data, &RNA_SceneRenderView, retdata, &result);
		return SceneRenderView(result);
	}

	inline void RenderViews::remove(void *main, SceneRenderView& view) {
		RenderViews_remove((::ID *) ptr.id.data, (::RenderData *) this->ptr.data, (::Main *) main, NULL, (::PointerRNA *) &view.ptr);
	}


	POINTER_PROPERTY(Struct, BakeSettings, rna_type)
	POINTER_PROPERTY(Object, BakeSettings, cage_object)
	STRING_PROPERTY(BakeSettings, filepath)
	INT_PROPERTY(BakeSettings, width)
	INT_PROPERTY(BakeSettings, height)
	INT_PROPERTY(BakeSettings, margin)
	FLOAT_PROPERTY(BakeSettings, cage_extrusion)
	ENUM_PROPERTY(normal_space_enum, BakeSettings, normal_space)
	ENUM_PROPERTY(normal_r_enum, BakeSettings, normal_r)
	ENUM_PROPERTY(normal_g_enum, BakeSettings, normal_g)
	ENUM_PROPERTY(normal_b_enum, BakeSettings, normal_b)
	POINTER_PROPERTY(ImageFormatSettings, BakeSettings, image_settings)
	ENUM_PROPERTY(save_mode_enum, BakeSettings, save_mode)
	BOOLEAN_PROPERTY(BakeSettings, use_selected_to_active)
	BOOLEAN_PROPERTY(BakeSettings, use_clear)
	BOOLEAN_PROPERTY(BakeSettings, use_split_materials)
	BOOLEAN_PROPERTY(BakeSettings, use_automatic_name)
	BOOLEAN_PROPERTY(BakeSettings, use_cage)
	BOOLEAN_PROPERTY(BakeSettings, use_pass_ambient_occlusion)
	BOOLEAN_PROPERTY(BakeSettings, use_pass_emit)
	BOOLEAN_PROPERTY(BakeSettings, use_pass_direct)
	BOOLEAN_PROPERTY(BakeSettings, use_pass_indirect)
	BOOLEAN_PROPERTY(BakeSettings, use_pass_color)
	BOOLEAN_PROPERTY(BakeSettings, use_pass_diffuse)
	BOOLEAN_PROPERTY(BakeSettings, use_pass_glossy)
	BOOLEAN_PROPERTY(BakeSettings, use_pass_transmission)
	BOOLEAN_PROPERTY(BakeSettings, use_pass_subsurface)
	ENUM_PROPERTY(pass_filter_enum, BakeSettings, pass_filter)


	POINTER_PROPERTY(Struct, GPUSSAOSettings, rna_type)
	FLOAT_PROPERTY(GPUSSAOSettings, factor)
	FLOAT_PROPERTY(GPUSSAOSettings, distance_max)
	FLOAT_PROPERTY(GPUSSAOSettings, attenuation)
	INT_PROPERTY(GPUSSAOSettings, samples)
	FLOAT_ARRAY_PROPERTY(GPUSSAOSettings, 3, color)


	POINTER_PROPERTY(Struct, GPUDOFSettings, rna_type)
	FLOAT_PROPERTY(GPUDOFSettings, focus_distance)
	FLOAT_PROPERTY(GPUDOFSettings, focal_length)
	FLOAT_PROPERTY(GPUDOFSettings, sensor)
	FLOAT_PROPERTY(GPUDOFSettings, fstop)
	INT_PROPERTY(GPUDOFSettings, blades)
	FLOAT_PROPERTY(GPUDOFSettings, rotation)
	FLOAT_PROPERTY(GPUDOFSettings, ratio)


	POINTER_PROPERTY(Struct, GPUFXSettings, rna_type)
	POINTER_PROPERTY(GPUDOFSettings, GPUFXSettings, dof)
	BOOLEAN_PROPERTY(GPUFXSettings, use_dof)
	POINTER_PROPERTY(GPUSSAOSettings, GPUFXSettings, ssao)
	BOOLEAN_PROPERTY(GPUFXSettings, use_ssao)


	POINTER_PROPERTY(Struct, SceneRenderView, rna_type)
	STRING_PROPERTY(SceneRenderView, name)
	STRING_PROPERTY(SceneRenderView, file_suffix)
	STRING_PROPERTY(SceneRenderView, camera_suffix)
	BOOLEAN_PROPERTY(SceneRenderView, use)



	BOOLEAN_PROPERTY(Screen, is_animation_playing)
	BOOLEAN_PROPERTY(Screen, show_fullscreen)
	BOOLEAN_PROPERTY(Screen, show_topbar)
	BOOLEAN_PROPERTY(Screen, show_statusbar)
	BOOLEAN_PROPERTY(Screen, use_play_top_left_3d_editor)
	BOOLEAN_PROPERTY(Screen, use_play_3d_editors)
	BOOLEAN_PROPERTY(Screen, use_follow)
	BOOLEAN_PROPERTY(Screen, use_play_animation_editors)
	BOOLEAN_PROPERTY(Screen, use_play_properties_editors)
	BOOLEAN_PROPERTY(Screen, use_play_image_editors)
	BOOLEAN_PROPERTY(Screen, use_play_sequence_editors)
	BOOLEAN_PROPERTY(Screen, use_play_node_editors)
	BOOLEAN_PROPERTY(Screen, use_play_clip_editors)


	POINTER_PROPERTY(Struct, Area, rna_type)


	BOOLEAN_PROPERTY(Area, show_menus)
	ENUM_PROPERTY(type_enum, Area, type)
	ENUM_PROPERTY(ui_type_enum, Area, ui_type)
	INT_PROPERTY(Area, x)
	INT_PROPERTY(Area, y)
	INT_PROPERTY(Area, width)
	INT_PROPERTY(Area, height)

	inline void Area::tag_redraw() {
		Area_tag_redraw((::ScrArea *) this->ptr.data);
	}

	inline void Area::header_text_set(const char * text) {
		Area_header_text_set((::ScrArea *) this->ptr.data, text);
	}


	POINTER_PROPERTY(Struct, AreaSpaces, rna_type)
	POINTER_PROPERTY(Space, AreaSpaces, active)


	POINTER_PROPERTY(Struct, Region, rna_type)
	ENUM_PROPERTY(type_enum, Region, type)
	INT_PROPERTY(Region, x)
	INT_PROPERTY(Region, y)
	INT_PROPERTY(Region, width)
	INT_PROPERTY(Region, height)
	POINTER_PROPERTY(View2D, Region, view2d)
	ENUM_PROPERTY(alignment_enum, Region, alignment)

	inline void Region::tag_redraw() {
		Region_tag_redraw((::ARegion *) this->ptr.data);
	}


	POINTER_PROPERTY(Struct, View2D, rna_type)

	inline void View2D::region_to_view(int x, int y, float result[2]) {
		View2D_region_to_view((::View2D *) this->ptr.data, x, y, result);
	}

	inline void View2D::view_to_region(float x, float y, bool clip, int result[2]) {
		View2D_view_to_region((::View2D *) this->ptr.data, x, y, clip, result);
	}




	POINTER_PROPERTY(Struct, PaintToolSlot, rna_type)
	POINTER_PROPERTY(Brush, PaintToolSlot, brush)


	POINTER_PROPERTY(Struct, Paint, rna_type)
	POINTER_PROPERTY(Brush, Paint, brush)

	POINTER_PROPERTY(Palette, Paint, palette)
	BOOLEAN_PROPERTY(Paint, show_brush)
	BOOLEAN_PROPERTY(Paint, show_brush_on_surface)
	BOOLEAN_PROPERTY(Paint, show_low_resolution)
	INT_PROPERTY(Paint, input_samples)
	BOOLEAN_PROPERTY(Paint, use_symmetry_x)
	BOOLEAN_PROPERTY(Paint, use_symmetry_y)
	BOOLEAN_PROPERTY(Paint, use_symmetry_z)
	BOOLEAN_PROPERTY(Paint, use_symmetry_feather)
	POINTER_PROPERTY(CurveMapping, Paint, cavity_curve)
	BOOLEAN_PROPERTY(Paint, use_cavity)
	FLOAT_ARRAY_PROPERTY(Paint, 3, tile_offset)
	BOOLEAN_PROPERTY(Paint, tile_x)
	BOOLEAN_PROPERTY(Paint, tile_y)
	BOOLEAN_PROPERTY(Paint, tile_z)


	INT_ARRAY_PROPERTY(Sculpt, 3, radial_symmetry)
	BOOLEAN_PROPERTY(Sculpt, lock_x)
	BOOLEAN_PROPERTY(Sculpt, lock_y)
	BOOLEAN_PROPERTY(Sculpt, lock_z)
	BOOLEAN_PROPERTY(Sculpt, use_threaded)
	BOOLEAN_PROPERTY(Sculpt, use_deform_only)
	BOOLEAN_PROPERTY(Sculpt, show_diffuse_color)
	BOOLEAN_PROPERTY(Sculpt, show_mask)
	FLOAT_PROPERTY(Sculpt, detail_size)
	FLOAT_PROPERTY(Sculpt, detail_percent)
	FLOAT_PROPERTY(Sculpt, constant_detail_resolution)
	BOOLEAN_PROPERTY(Sculpt, use_smooth_shading)
	ENUM_PROPERTY(symmetrize_direction_enum, Sculpt, symmetrize_direction)
	ENUM_PROPERTY(detail_refine_method_enum, Sculpt, detail_refine_method)
	ENUM_PROPERTY(detail_type_method_enum, Sculpt, detail_type_method)
	FLOAT_PROPERTY(Sculpt, gravity)
	POINTER_PROPERTY(Object, Sculpt, gravity_object)






	BOOLEAN_PROPERTY(VertexPaint, use_group_restrict)
	INT_ARRAY_PROPERTY(VertexPaint, 3, radial_symmetry)


	BOOLEAN_PROPERTY(ImagePaint, use_occlude)
	BOOLEAN_PROPERTY(ImagePaint, use_backface_culling)
	BOOLEAN_PROPERTY(ImagePaint, use_normal_falloff)
	BOOLEAN_PROPERTY(ImagePaint, use_stencil_layer)
	BOOLEAN_PROPERTY(ImagePaint, invert_stencil)
	POINTER_PROPERTY(Image, ImagePaint, stencil_image)
	POINTER_PROPERTY(Image, ImagePaint, canvas)
	POINTER_PROPERTY(Image, ImagePaint, clone_image)
	FLOAT_ARRAY_PROPERTY(ImagePaint, 3, stencil_color)
	FLOAT_PROPERTY(ImagePaint, dither)
	BOOLEAN_PROPERTY(ImagePaint, use_clone_layer)
	INT_PROPERTY(ImagePaint, seam_bleed)
	INT_PROPERTY(ImagePaint, normal_angle)
	INT_ARRAY_PROPERTY(ImagePaint, 2, screen_grab_size)
	ENUM_PROPERTY(mode_enum, ImagePaint, mode)
	ENUM_PROPERTY(interpolation_enum, ImagePaint, interpolation)
	BOOLEAN_PROPERTY(ImagePaint, missing_uvs)
	BOOLEAN_PROPERTY(ImagePaint, missing_materials)
	BOOLEAN_PROPERTY(ImagePaint, missing_stencil)
	BOOLEAN_PROPERTY(ImagePaint, missing_texture)

	inline bool ImagePaint::detect_data() {
		return ImagePaint_detect_data((::ImagePaintSettings *) this->ptr.data);
	}


	POINTER_PROPERTY(Struct, ParticleEdit, rna_type)
	ENUM_PROPERTY(tool_enum, ParticleEdit, tool)
	ENUM_PROPERTY(select_mode_enum, ParticleEdit, select_mode)
	BOOLEAN_PROPERTY(ParticleEdit, use_preserve_length)
	BOOLEAN_PROPERTY(ParticleEdit, use_preserve_root)
	BOOLEAN_PROPERTY(ParticleEdit, use_emitter_deflect)
	FLOAT_PROPERTY(ParticleEdit, emitter_distance)
	BOOLEAN_PROPERTY(ParticleEdit, use_fade_time)
	BOOLEAN_PROPERTY(ParticleEdit, use_auto_velocity)
	BOOLEAN_PROPERTY(ParticleEdit, show_particles)
	BOOLEAN_PROPERTY(ParticleEdit, use_default_interpolate)
	INT_PROPERTY(ParticleEdit, default_key_count)
	POINTER_PROPERTY(ParticleBrush, ParticleEdit, brush)
	INT_PROPERTY(ParticleEdit, display_step)
	INT_PROPERTY(ParticleEdit, fade_frames)
	ENUM_PROPERTY(type_enum, ParticleEdit, type)
	BOOLEAN_PROPERTY(ParticleEdit, is_editable)
	BOOLEAN_PROPERTY(ParticleEdit, is_hair)
	POINTER_PROPERTY(Object, ParticleEdit, object)
	POINTER_PROPERTY(Object, ParticleEdit, shape_object)


	POINTER_PROPERTY(Struct, ParticleBrush, rna_type)
	INT_PROPERTY(ParticleBrush, size)
	FLOAT_PROPERTY(ParticleBrush, strength)
	INT_PROPERTY(ParticleBrush, count)
	INT_PROPERTY(ParticleBrush, steps)
	ENUM_PROPERTY(puff_mode_enum, ParticleBrush, puff_mode)
	BOOLEAN_PROPERTY(ParticleBrush, use_puff_volume)
	ENUM_PROPERTY(length_mode_enum, ParticleBrush, length_mode)
	POINTER_PROPERTY(CurveMapping, ParticleBrush, curve)


	POINTER_PROPERTY(Struct, GPencilSculptGuide, rna_type)
	BOOLEAN_PROPERTY(GPencilSculptGuide, use_guide)
	BOOLEAN_PROPERTY(GPencilSculptGuide, use_snapping)
	POINTER_PROPERTY(Object, GPencilSculptGuide, reference_object)
	ENUM_PROPERTY(reference_point_enum, GPencilSculptGuide, reference_point)
	ENUM_PROPERTY(type_enum, GPencilSculptGuide, type)
	FLOAT_PROPERTY(GPencilSculptGuide, angle)
	FLOAT_PROPERTY(GPencilSculptGuide, angle_snap)
	FLOAT_PROPERTY(GPencilSculptGuide, spacing)
	FLOAT_ARRAY_PROPERTY(GPencilSculptGuide, 3, location)


	POINTER_PROPERTY(Struct, GPencilSculptSettings, rna_type)
	ENUM_PROPERTY(sculpt_tool_enum, GPencilSculptSettings, sculpt_tool)
	ENUM_PROPERTY(weight_tool_enum, GPencilSculptSettings, weight_tool)
	POINTER_PROPERTY(GPencilSculptBrush, GPencilSculptSettings, brush)
	POINTER_PROPERTY(GPencilSculptGuide, GPencilSculptSettings, guide)
	BOOLEAN_PROPERTY(GPencilSculptSettings, use_select_mask)
	BOOLEAN_PROPERTY(GPencilSculptSettings, use_edit_position)
	BOOLEAN_PROPERTY(GPencilSculptSettings, use_edit_strength)
	BOOLEAN_PROPERTY(GPencilSculptSettings, use_edit_thickness)
	BOOLEAN_PROPERTY(GPencilSculptSettings, use_edit_uv)
	BOOLEAN_PROPERTY(GPencilSculptSettings, use_multiframe_falloff)
	BOOLEAN_PROPERTY(GPencilSculptSettings, use_thickness_curve)
	POINTER_PROPERTY(CurveMapping, GPencilSculptSettings, multiframe_falloff_curve)
	POINTER_PROPERTY(CurveMapping, GPencilSculptSettings, thickness_primitive_curve)
	ENUM_PROPERTY(lock_axis_enum, GPencilSculptSettings, lock_axis)
	FLOAT_PROPERTY(GPencilSculptSettings, intersection_threshold)


	POINTER_PROPERTY(Struct, GPencilSculptBrush, rna_type)
	INT_PROPERTY(GPencilSculptBrush, size)
	FLOAT_PROPERTY(GPencilSculptBrush, strength)
	FLOAT_PROPERTY(GPencilSculptBrush, weight)
	BOOLEAN_PROPERTY(GPencilSculptBrush, use_pressure_strength)
	BOOLEAN_PROPERTY(GPencilSculptBrush, use_pressure_radius)
	BOOLEAN_PROPERTY(GPencilSculptBrush, use_falloff)
	BOOLEAN_PROPERTY(GPencilSculptBrush, use_edit_pressure)
	ENUM_PROPERTY(direction_enum, GPencilSculptBrush, direction)
	FLOAT_ARRAY_PROPERTY(GPencilSculptBrush, 3, cursor_color_add)
	FLOAT_ARRAY_PROPERTY(GPencilSculptBrush, 3, cursor_color_sub)
	BOOLEAN_PROPERTY(GPencilSculptBrush, use_cursor)


	POINTER_PROPERTY(Struct, SequenceColorBalanceData, rna_type)
	FLOAT_ARRAY_PROPERTY(SequenceColorBalanceData, 3, lift)
	FLOAT_ARRAY_PROPERTY(SequenceColorBalanceData, 3, gamma)
	FLOAT_ARRAY_PROPERTY(SequenceColorBalanceData, 3, gain)
	BOOLEAN_PROPERTY(SequenceColorBalanceData, invert_gain)
	BOOLEAN_PROPERTY(SequenceColorBalanceData, invert_gamma)
	BOOLEAN_PROPERTY(SequenceColorBalanceData, invert_lift)


	POINTER_PROPERTY(Struct, SequenceElement, rna_type)
	STRING_PROPERTY(SequenceElement, filename)
	INT_PROPERTY(SequenceElement, orig_width)
	INT_PROPERTY(SequenceElement, orig_height)


	POINTER_PROPERTY(Struct, SequenceProxy, rna_type)
	STRING_PROPERTY(SequenceProxy, directory)
	STRING_PROPERTY(SequenceProxy, filepath)
	BOOLEAN_PROPERTY(SequenceProxy, use_overwrite)
	BOOLEAN_PROPERTY(SequenceProxy, build_25)
	BOOLEAN_PROPERTY(SequenceProxy, build_50)
	BOOLEAN_PROPERTY(SequenceProxy, build_75)
	BOOLEAN_PROPERTY(SequenceProxy, build_100)
	BOOLEAN_PROPERTY(SequenceProxy, build_record_run)
	BOOLEAN_PROPERTY(SequenceProxy, build_free_run)
	BOOLEAN_PROPERTY(SequenceProxy, build_free_run_rec_date)
	INT_PROPERTY(SequenceProxy, quality)
	ENUM_PROPERTY(timecode_enum, SequenceProxy, timecode)
	BOOLEAN_PROPERTY(SequenceProxy, use_proxy_custom_directory)
	BOOLEAN_PROPERTY(SequenceProxy, use_proxy_custom_file)




	POINTER_PROPERTY(Struct, SequenceCrop, rna_type)
	INT_PROPERTY(SequenceCrop, max_y)
	INT_PROPERTY(SequenceCrop, min_y)
	INT_PROPERTY(SequenceCrop, min_x)
	INT_PROPERTY(SequenceCrop, max_x)


	POINTER_PROPERTY(Struct, SequenceTransform, rna_type)
	INT_PROPERTY(SequenceTransform, offset_x)
	INT_PROPERTY(SequenceTransform, offset_y)


	POINTER_PROPERTY(Struct, Sequence, rna_type)
	STRING_PROPERTY(Sequence, name)
	ENUM_PROPERTY(type_enum, Sequence, type)
	BOOLEAN_PROPERTY(Sequence, select)
	BOOLEAN_PROPERTY(Sequence, select_left_handle)
	BOOLEAN_PROPERTY(Sequence, select_right_handle)
	BOOLEAN_PROPERTY(Sequence, mute)
	BOOLEAN_PROPERTY(Sequence, lock)
	INT_PROPERTY(Sequence, frame_final_duration)
	INT_PROPERTY(Sequence, frame_duration)
	INT_PROPERTY(Sequence, frame_start)
	INT_PROPERTY(Sequence, frame_final_start)
	INT_PROPERTY(Sequence, frame_final_end)
	INT_PROPERTY(Sequence, frame_offset_start)
	INT_PROPERTY(Sequence, frame_offset_end)
	INT_PROPERTY(Sequence, frame_still_start)
	INT_PROPERTY(Sequence, frame_still_end)
	INT_PROPERTY(Sequence, channel)
	BOOLEAN_PROPERTY(Sequence, use_linear_modifiers)
	ENUM_PROPERTY(blend_type_enum, Sequence, blend_type)
	FLOAT_PROPERTY(Sequence, blend_alpha)
	FLOAT_PROPERTY(Sequence, effect_fader)
	BOOLEAN_PROPERTY(Sequence, use_default_fade)
	FLOAT_PROPERTY(Sequence, speed_factor)


	inline void Sequence::update(bool data) {
		Sequence_update((::ID *) ptr.id.data, (::Sequence *) this->ptr.data, data);
	}

	inline SequenceElement Sequence::strip_elem_from_frame(int frame) {
		PointerRNA result;
		::StripElem *retdata = Sequence_strip_elem_from_frame((::Sequence *) this->ptr.data, frame);
		RNA_pointer_create((::ID *) ptr.id.data, &RNA_SequenceElement, retdata, &result);
		return SequenceElement(result);
	}

	inline void Sequence::swap(Sequence& other) {
		Sequence_swap((::Sequence *) this->ptr.data, NULL, (::Sequence *) other.ptr.data);
	}


	POINTER_PROPERTY(Struct, SequenceModifiers, rna_type)

	inline SequenceModifier SequenceModifiers::create(Context C, const char * name, int type) {
		PointerRNA result;
		::SequenceModifierData *retdata = SequenceModifiers_new((::Sequence *) this->ptr.data, (::bContext *) C.ptr.data, NULL, name, type);
		RNA_pointer_create((::ID *) ptr.id.data, &RNA_SequenceModifier, retdata, &result);
		return SequenceModifier(result);
	}

	inline void SequenceModifiers::remove(Context C, SequenceModifier& modifier) {
		SequenceModifiers_remove((::Sequence *) this->ptr.data, (::bContext *) C.ptr.data, NULL, (::PointerRNA *) &modifier.ptr);
	}

	inline void SequenceModifiers::clear(Context C) {
		SequenceModifiers_clear((::Sequence *) this->ptr.data, (::bContext *) C.ptr.data);
	}


	POINTER_PROPERTY(Struct, SequenceEditor, rna_type)



	POINTER_PROPERTY(Sequence, SequenceEditor, active_strip)
	BOOLEAN_PROPERTY(SequenceEditor, show_overlay)
	BOOLEAN_PROPERTY(SequenceEditor, use_overlay_lock)
	INT_PROPERTY(SequenceEditor, overlay_frame)
	ENUM_PROPERTY(proxy_storage_enum, SequenceEditor, proxy_storage)
	STRING_PROPERTY(SequenceEditor, proxy_dir)


	POINTER_PROPERTY(Struct, Sequences, rna_type)

	inline Sequence Sequences::new_clip(const char * name, MovieClip& clip, int channel, int frame_start) {
		PointerRNA result;
		::Sequence *retdata = Sequences_new_clip((::ID *) ptr.id.data, (::Editing *) this->ptr.data, name, (::MovieClip *) clip.ptr.data, channel, frame_start);
		RNA_pointer_create((::ID *) ptr.id.data, &RNA_Sequence, retdata, &result);
		return Sequence(result);
	}

	inline Sequence Sequences::new_mask(const char * name, Mask& mask, int channel, int frame_start) {
		PointerRNA result;
		::Sequence *retdata = Sequences_new_mask((::ID *) ptr.id.data, (::Editing *) this->ptr.data, name, (::Mask *) mask.ptr.data, channel, frame_start);
		RNA_pointer_create((::ID *) ptr.id.data, &RNA_Sequence, retdata, &result);
		return Sequence(result);
	}

	inline Sequence Sequences::new_scene(const char * name, Scene& scene, int channel, int frame_start) {
		PointerRNA result;
		::Sequence *retdata = Sequences_new_scene((::ID *) ptr.id.data, (::Editing *) this->ptr.data, name, (::Scene *) scene.ptr.data, channel, frame_start);
		RNA_pointer_create((::ID *) ptr.id.data, &RNA_Sequence, retdata, &result);
		return Sequence(result);
	}

	inline Sequence Sequences::new_image(const char * name, const char * filepath, int channel, int frame_start) {
		PointerRNA result;
		::Sequence *retdata = Sequences_new_image((::ID *) ptr.id.data, (::Editing *) this->ptr.data, NULL, name, filepath, channel, frame_start);
		RNA_pointer_create((::ID *) ptr.id.data, &RNA_Sequence, retdata, &result);
		return Sequence(result);
	}

	inline Sequence Sequences::new_movie(const char * name, const char * filepath, int channel, int frame_start) {
		PointerRNA result;
		::Sequence *retdata = Sequences_new_movie((::ID *) ptr.id.data, (::Editing *) this->ptr.data, NULL, name, filepath, channel, frame_start);
		RNA_pointer_create((::ID *) ptr.id.data, &RNA_Sequence, retdata, &result);
		return Sequence(result);
	}

	inline Sequence Sequences::new_sound(void *main, const char * name, const char * filepath, int channel, int frame_start) {
		PointerRNA result;
		::Sequence *retdata = Sequences_new_sound((::ID *) ptr.id.data, (::Editing *) this->ptr.data, (::Main *) main, NULL, name, filepath, channel, frame_start);
		RNA_pointer_create((::ID *) ptr.id.data, &RNA_Sequence, retdata, &result);
		return Sequence(result);
	}

	inline Sequence Sequences::new_effect(const char * name, int type, int channel, int frame_start, int frame_end, Sequence& seq1, Sequence& seq2, Sequence& seq3) {
		PointerRNA result;
		::Sequence *retdata = Sequences_new_effect((::ID *) ptr.id.data, (::Editing *) this->ptr.data, NULL, name, type, channel, frame_start, frame_end, (::Sequence *) seq1.ptr.data, (::Sequence *) seq2.ptr.data, (::Sequence *) seq3.ptr.data);
		RNA_pointer_create((::ID *) ptr.id.data, &RNA_Sequence, retdata, &result);
		return Sequence(result);
	}

	inline void Sequences::remove(Sequence& sequence) {
		Sequences_remove((::ID *) ptr.id.data, (::Editing *) this->ptr.data, NULL, (::PointerRNA *) &sequence.ptr);
	}


	STRING_PROPERTY(ImageSequence, directory)

	BOOLEAN_PROPERTY(ImageSequence, use_multiview)
	ENUM_PROPERTY(views_format_enum, ImageSequence, views_format)
	POINTER_PROPERTY(Stereo3dFormat, ImageSequence, stereo_3d_format)
	BOOLEAN_PROPERTY(ImageSequence, use_deinterlace)
	ENUM_PROPERTY(alpha_mode_enum, ImageSequence, alpha_mode)
	BOOLEAN_PROPERTY(ImageSequence, use_flip_x)
	BOOLEAN_PROPERTY(ImageSequence, use_flip_y)
	BOOLEAN_PROPERTY(ImageSequence, use_float)
	BOOLEAN_PROPERTY(ImageSequence, use_reverse_frames)
	FLOAT_PROPERTY(ImageSequence, color_multiply)
	FLOAT_PROPERTY(ImageSequence, color_saturation)
	FLOAT_PROPERTY(ImageSequence, strobe)
	BOOLEAN_PROPERTY(ImageSequence, use_translation)
	POINTER_PROPERTY(SequenceTransform, ImageSequence, transform)
	BOOLEAN_PROPERTY(ImageSequence, use_crop)
	POINTER_PROPERTY(SequenceCrop, ImageSequence, crop)
	BOOLEAN_PROPERTY(ImageSequence, use_proxy)
	POINTER_PROPERTY(SequenceProxy, ImageSequence, proxy)
	INT_PROPERTY(ImageSequence, animation_offset_start)
	INT_PROPERTY(ImageSequence, animation_offset_end)
	POINTER_PROPERTY(ColorManagedInputColorspaceSettings, ImageSequence, colorspace_settings)


	POINTER_PROPERTY(Struct, SequenceElements, rna_type)

	inline SequenceElement SequenceElements::append(const char * filename) {
		PointerRNA result;
		::StripElem *retdata = SequenceElements_append((::ID *) ptr.id.data, (::Sequence *) this->ptr.data, filename);
		RNA_pointer_create((::ID *) ptr.id.data, &RNA_SequenceElement, retdata, &result);
		return SequenceElement(result);
	}

	inline void SequenceElements::pop(int index) {
		SequenceElements_pop((::ID *) ptr.id.data, (::Sequence *) this->ptr.data, NULL, index);
	}



	BOOLEAN_PROPERTY(MetaSequence, use_deinterlace)
	ENUM_PROPERTY(alpha_mode_enum, MetaSequence, alpha_mode)
	BOOLEAN_PROPERTY(MetaSequence, use_flip_x)
	BOOLEAN_PROPERTY(MetaSequence, use_flip_y)
	BOOLEAN_PROPERTY(MetaSequence, use_float)
	BOOLEAN_PROPERTY(MetaSequence, use_reverse_frames)
	FLOAT_PROPERTY(MetaSequence, color_multiply)
	FLOAT_PROPERTY(MetaSequence, color_saturation)
	FLOAT_PROPERTY(MetaSequence, strobe)
	BOOLEAN_PROPERTY(MetaSequence, use_translation)
	POINTER_PROPERTY(SequenceTransform, MetaSequence, transform)
	BOOLEAN_PROPERTY(MetaSequence, use_crop)
	POINTER_PROPERTY(SequenceCrop, MetaSequence, crop)
	BOOLEAN_PROPERTY(MetaSequence, use_proxy)
	POINTER_PROPERTY(SequenceProxy, MetaSequence, proxy)
	INT_PROPERTY(MetaSequence, animation_offset_start)
	INT_PROPERTY(MetaSequence, animation_offset_end)


	POINTER_PROPERTY(Scene, SceneSequence, scene)
	POINTER_PROPERTY(Object, SceneSequence, scene_camera)
	BOOLEAN_PROPERTY(SceneSequence, use_sequence)
	BOOLEAN_PROPERTY(SceneSequence, use_grease_pencil)
	BOOLEAN_PROPERTY(SceneSequence, use_deinterlace)
	ENUM_PROPERTY(alpha_mode_enum, SceneSequence, alpha_mode)
	BOOLEAN_PROPERTY(SceneSequence, use_flip_x)
	BOOLEAN_PROPERTY(SceneSequence, use_flip_y)
	BOOLEAN_PROPERTY(SceneSequence, use_float)
	BOOLEAN_PROPERTY(SceneSequence, use_reverse_frames)
	FLOAT_PROPERTY(SceneSequence, color_multiply)
	FLOAT_PROPERTY(SceneSequence, color_saturation)
	FLOAT_PROPERTY(SceneSequence, strobe)
	BOOLEAN_PROPERTY(SceneSequence, use_translation)
	POINTER_PROPERTY(SequenceTransform, SceneSequence, transform)
	BOOLEAN_PROPERTY(SceneSequence, use_crop)
	POINTER_PROPERTY(SequenceCrop, SceneSequence, crop)
	BOOLEAN_PROPERTY(SceneSequence, use_proxy)
	POINTER_PROPERTY(SequenceProxy, SceneSequence, proxy)
	INT_PROPERTY(SceneSequence, animation_offset_start)
	INT_PROPERTY(SceneSequence, animation_offset_end)
	FLOAT_PROPERTY(SceneSequence, fps)


	INT_PROPERTY(MovieSequence, mpeg_preseek)
	INT_PROPERTY(MovieSequence, stream_index)

	STRING_PROPERTY(MovieSequence, filepath)
	BOOLEAN_PROPERTY(MovieSequence, use_multiview)
	ENUM_PROPERTY(views_format_enum, MovieSequence, views_format)
	POINTER_PROPERTY(Stereo3dFormat, MovieSequence, stereo_3d_format)
	BOOLEAN_PROPERTY(MovieSequence, use_deinterlace)
	ENUM_PROPERTY(alpha_mode_enum, MovieSequence, alpha_mode)
	BOOLEAN_PROPERTY(MovieSequence, use_flip_x)
	BOOLEAN_PROPERTY(MovieSequence, use_flip_y)
	BOOLEAN_PROPERTY(MovieSequence, use_float)
	BOOLEAN_PROPERTY(MovieSequence, use_reverse_frames)
	FLOAT_PROPERTY(MovieSequence, color_multiply)
	FLOAT_PROPERTY(MovieSequence, color_saturation)
	FLOAT_PROPERTY(MovieSequence, strobe)
	BOOLEAN_PROPERTY(MovieSequence, use_translation)
	POINTER_PROPERTY(SequenceTransform, MovieSequence, transform)
	BOOLEAN_PROPERTY(MovieSequence, use_crop)
	POINTER_PROPERTY(SequenceCrop, MovieSequence, crop)
	BOOLEAN_PROPERTY(MovieSequence, use_proxy)
	POINTER_PROPERTY(SequenceProxy, MovieSequence, proxy)
	INT_PROPERTY(MovieSequence, animation_offset_start)
	INT_PROPERTY(MovieSequence, animation_offset_end)
	POINTER_PROPERTY(ColorManagedInputColorspaceSettings, MovieSequence, colorspace_settings)
	FLOAT_PROPERTY(MovieSequence, fps)

	inline IDPropertyWrapPtr MovieSequence::metadata() {
		PointerRNA result;
		result = MovieSequence_metadata((::Sequence *) this->ptr.data);
		return IDPropertyWrapPtr(result);
	}


	BOOLEAN_PROPERTY(MovieClipSequence, undistort)
	BOOLEAN_PROPERTY(MovieClipSequence, stabilize2d)
	BOOLEAN_PROPERTY(MovieClipSequence, use_deinterlace)
	ENUM_PROPERTY(alpha_mode_enum, MovieClipSequence, alpha_mode)
	BOOLEAN_PROPERTY(MovieClipSequence, use_flip_x)
	BOOLEAN_PROPERTY(MovieClipSequence, use_flip_y)
	BOOLEAN_PROPERTY(MovieClipSequence, use_float)
	BOOLEAN_PROPERTY(MovieClipSequence, use_reverse_frames)
	FLOAT_PROPERTY(MovieClipSequence, color_multiply)
	FLOAT_PROPERTY(MovieClipSequence, color_saturation)
	FLOAT_PROPERTY(MovieClipSequence, strobe)
	BOOLEAN_PROPERTY(MovieClipSequence, use_translation)
	POINTER_PROPERTY(SequenceTransform, MovieClipSequence, transform)
	BOOLEAN_PROPERTY(MovieClipSequence, use_crop)
	POINTER_PROPERTY(SequenceCrop, MovieClipSequence, crop)
	INT_PROPERTY(MovieClipSequence, animation_offset_start)
	INT_PROPERTY(MovieClipSequence, animation_offset_end)
	FLOAT_PROPERTY(MovieClipSequence, fps)


	POINTER_PROPERTY(Mask, MaskSequence, mask)
	BOOLEAN_PROPERTY(MaskSequence, use_deinterlace)
	ENUM_PROPERTY(alpha_mode_enum, MaskSequence, alpha_mode)
	BOOLEAN_PROPERTY(MaskSequence, use_flip_x)
	BOOLEAN_PROPERTY(MaskSequence, use_flip_y)
	BOOLEAN_PROPERTY(MaskSequence, use_float)
	BOOLEAN_PROPERTY(MaskSequence, use_reverse_frames)
	FLOAT_PROPERTY(MaskSequence, color_multiply)
	FLOAT_PROPERTY(MaskSequence, color_saturation)
	FLOAT_PROPERTY(MaskSequence, strobe)
	BOOLEAN_PROPERTY(MaskSequence, use_translation)
	POINTER_PROPERTY(SequenceTransform, MaskSequence, transform)
	BOOLEAN_PROPERTY(MaskSequence, use_crop)
	POINTER_PROPERTY(SequenceCrop, MaskSequence, crop)
	INT_PROPERTY(MaskSequence, animation_offset_start)
	INT_PROPERTY(MaskSequence, animation_offset_end)


	POINTER_PROPERTY(Sound, SoundSequence, sound)
	FLOAT_PROPERTY(SoundSequence, volume)
	FLOAT_PROPERTY(SoundSequence, pitch)
	FLOAT_PROPERTY(SoundSequence, pan)
	BOOLEAN_PROPERTY(SoundSequence, show_waveform)
	INT_PROPERTY(SoundSequence, animation_offset_start)
	INT_PROPERTY(SoundSequence, animation_offset_end)


	BOOLEAN_PROPERTY(EffectSequence, use_deinterlace)
	ENUM_PROPERTY(alpha_mode_enum, EffectSequence, alpha_mode)
	BOOLEAN_PROPERTY(EffectSequence, use_flip_x)
	BOOLEAN_PROPERTY(EffectSequence, use_flip_y)
	BOOLEAN_PROPERTY(EffectSequence, use_float)
	BOOLEAN_PROPERTY(EffectSequence, use_reverse_frames)
	FLOAT_PROPERTY(EffectSequence, color_multiply)
	FLOAT_PROPERTY(EffectSequence, color_saturation)
	FLOAT_PROPERTY(EffectSequence, strobe)
	BOOLEAN_PROPERTY(EffectSequence, use_translation)
	POINTER_PROPERTY(SequenceTransform, EffectSequence, transform)
	BOOLEAN_PROPERTY(EffectSequence, use_crop)
	POINTER_PROPERTY(SequenceCrop, EffectSequence, crop)
	BOOLEAN_PROPERTY(EffectSequence, use_proxy)
	POINTER_PROPERTY(SequenceProxy, EffectSequence, proxy)


	INT_PROPERTY(AddSequence, input_count)
	POINTER_PROPERTY(Sequence, AddSequence, input_1)
	POINTER_PROPERTY(Sequence, AddSequence, input_2)


	INT_PROPERTY(AdjustmentSequence, input_count)
	INT_PROPERTY(AdjustmentSequence, animation_offset_start)
	INT_PROPERTY(AdjustmentSequence, animation_offset_end)


	INT_PROPERTY(AlphaOverSequence, input_count)
	POINTER_PROPERTY(Sequence, AlphaOverSequence, input_1)
	POINTER_PROPERTY(Sequence, AlphaOverSequence, input_2)


	INT_PROPERTY(AlphaUnderSequence, input_count)
	POINTER_PROPERTY(Sequence, AlphaUnderSequence, input_1)
	POINTER_PROPERTY(Sequence, AlphaUnderSequence, input_2)


	INT_PROPERTY(ColorSequence, input_count)
	FLOAT_ARRAY_PROPERTY(ColorSequence, 3, color)


	INT_PROPERTY(CrossSequence, input_count)
	POINTER_PROPERTY(Sequence, CrossSequence, input_1)
	POINTER_PROPERTY(Sequence, CrossSequence, input_2)


	INT_PROPERTY(GammaCrossSequence, input_count)
	POINTER_PROPERTY(Sequence, GammaCrossSequence, input_1)
	POINTER_PROPERTY(Sequence, GammaCrossSequence, input_2)


	INT_PROPERTY(GlowSequence, input_count)
	POINTER_PROPERTY(Sequence, GlowSequence, input_1)
	FLOAT_PROPERTY(GlowSequence, threshold)
	FLOAT_PROPERTY(GlowSequence, clamp)
	FLOAT_PROPERTY(GlowSequence, boost_factor)
	FLOAT_PROPERTY(GlowSequence, blur_radius)
	INT_PROPERTY(GlowSequence, quality)
	BOOLEAN_PROPERTY(GlowSequence, use_only_boost)


	INT_PROPERTY(MulticamSequence, input_count)
	INT_PROPERTY(MulticamSequence, multicam_source)
	INT_PROPERTY(MulticamSequence, animation_offset_start)
	INT_PROPERTY(MulticamSequence, animation_offset_end)


	INT_PROPERTY(MultiplySequence, input_count)
	POINTER_PROPERTY(Sequence, MultiplySequence, input_1)
	POINTER_PROPERTY(Sequence, MultiplySequence, input_2)


	INT_PROPERTY(OverDropSequence, input_count)
	POINTER_PROPERTY(Sequence, OverDropSequence, input_1)
	POINTER_PROPERTY(Sequence, OverDropSequence, input_2)


	INT_PROPERTY(SpeedControlSequence, input_count)
	POINTER_PROPERTY(Sequence, SpeedControlSequence, input_1)
	FLOAT_PROPERTY(SpeedControlSequence, multiply_speed)
	BOOLEAN_PROPERTY(SpeedControlSequence, use_as_speed)
	BOOLEAN_PROPERTY(SpeedControlSequence, use_scale_to_length)


	INT_PROPERTY(SubtractSequence, input_count)
	POINTER_PROPERTY(Sequence, SubtractSequence, input_1)
	POINTER_PROPERTY(Sequence, SubtractSequence, input_2)


	INT_PROPERTY(TransformSequence, input_count)
	POINTER_PROPERTY(Sequence, TransformSequence, input_1)
	FLOAT_PROPERTY(TransformSequence, scale_start_x)
	FLOAT_PROPERTY(TransformSequence, scale_start_y)
	BOOLEAN_PROPERTY(TransformSequence, use_uniform_scale)
	FLOAT_PROPERTY(TransformSequence, translate_start_x)
	FLOAT_PROPERTY(TransformSequence, translate_start_y)
	FLOAT_PROPERTY(TransformSequence, rotation_start)
	ENUM_PROPERTY(translation_unit_enum, TransformSequence, translation_unit)
	ENUM_PROPERTY(interpolation_enum, TransformSequence, interpolation)


	INT_PROPERTY(WipeSequence, input_count)
	POINTER_PROPERTY(Sequence, WipeSequence, input_1)
	POINTER_PROPERTY(Sequence, WipeSequence, input_2)
	FLOAT_PROPERTY(WipeSequence, blur_width)
	FLOAT_PROPERTY(WipeSequence, angle)
	ENUM_PROPERTY(direction_enum, WipeSequence, direction)
	ENUM_PROPERTY(transition_type_enum, WipeSequence, transition_type)


	INT_PROPERTY(GaussianBlurSequence, input_count)
	POINTER_PROPERTY(Sequence, GaussianBlurSequence, input_1)
	FLOAT_PROPERTY(GaussianBlurSequence, size_x)
	FLOAT_PROPERTY(GaussianBlurSequence, size_y)


	INT_PROPERTY(TextSequence, input_count)
	POINTER_PROPERTY(VectorFont, TextSequence, font)
	INT_PROPERTY(TextSequence, font_size)
	FLOAT_ARRAY_PROPERTY(TextSequence, 4, color)
	FLOAT_ARRAY_PROPERTY(TextSequence, 4, shadow_color)
	FLOAT_ARRAY_PROPERTY(TextSequence, 2, location)
	FLOAT_PROPERTY(TextSequence, wrap_width)
	ENUM_PROPERTY(align_x_enum, TextSequence, align_x)
	ENUM_PROPERTY(align_y_enum, TextSequence, align_y)
	STRING_PROPERTY(TextSequence, text)
	BOOLEAN_PROPERTY(TextSequence, use_shadow)


	INT_PROPERTY(ColorMixSequence, input_count)
	POINTER_PROPERTY(Sequence, ColorMixSequence, input_1)
	POINTER_PROPERTY(Sequence, ColorMixSequence, input_2)
	ENUM_PROPERTY(blend_effect_enum, ColorMixSequence, blend_effect)
	FLOAT_PROPERTY(ColorMixSequence, factor)


	POINTER_PROPERTY(Struct, SequenceModifier, rna_type)
	STRING_PROPERTY(SequenceModifier, name)
	ENUM_PROPERTY(type_enum, SequenceModifier, type)
	BOOLEAN_PROPERTY(SequenceModifier, mute)
	BOOLEAN_PROPERTY(SequenceModifier, show_expanded)
	ENUM_PROPERTY(input_mask_type_enum, SequenceModifier, input_mask_type)
	ENUM_PROPERTY(mask_time_enum, SequenceModifier, mask_time)
	POINTER_PROPERTY(Sequence, SequenceModifier, input_mask_strip)
	POINTER_PROPERTY(Mask, SequenceModifier, input_mask_id)


	POINTER_PROPERTY(SequenceColorBalanceData, ColorBalanceModifier, color_balance)
	FLOAT_PROPERTY(ColorBalanceModifier, color_multiply)


	POINTER_PROPERTY(CurveMapping, CurvesModifier, curve_mapping)


	POINTER_PROPERTY(CurveMapping, HueCorrectModifier, curve_mapping)


	FLOAT_PROPERTY(BrightContrastModifier, bright)
	FLOAT_PROPERTY(BrightContrastModifier, contrast)


	FLOAT_ARRAY_PROPERTY(WhiteBalanceModifier, 3, white_value)


	ENUM_PROPERTY(tonemap_type_enum, SequencerTonemapModifierData, tonemap_type)
	FLOAT_PROPERTY(SequencerTonemapModifierData, key)
	FLOAT_PROPERTY(SequencerTonemapModifierData, offset)
	FLOAT_PROPERTY(SequencerTonemapModifierData, gamma)
	FLOAT_PROPERTY(SequencerTonemapModifierData, intensity)
	FLOAT_PROPERTY(SequencerTonemapModifierData, contrast)
	FLOAT_PROPERTY(SequencerTonemapModifierData, adaptation)
	FLOAT_PROPERTY(SequencerTonemapModifierData, correction)


	POINTER_PROPERTY(Struct, SmokeDomainSettings, rna_type)
	INT_PROPERTY(SmokeDomainSettings, resolution_max)
	INT_PROPERTY(SmokeDomainSettings, amplify)
	BOOLEAN_PROPERTY(SmokeDomainSettings, use_high_resolution)
	BOOLEAN_PROPERTY(SmokeDomainSettings, show_high_resolution)
	ENUM_PROPERTY(noise_type_enum, SmokeDomainSettings, noise_type)
	FLOAT_PROPERTY(SmokeDomainSettings, alpha)
	FLOAT_PROPERTY(SmokeDomainSettings, beta)
	POINTER_PROPERTY(Collection, SmokeDomainSettings, collision_collection)
	POINTER_PROPERTY(Collection, SmokeDomainSettings, fluid_collection)
	POINTER_PROPERTY(Collection, SmokeDomainSettings, effector_collection)
	FLOAT_PROPERTY(SmokeDomainSettings, strength)
	INT_PROPERTY(SmokeDomainSettings, dissolve_speed)
	BOOLEAN_PROPERTY(SmokeDomainSettings, use_dissolve_smoke)
	BOOLEAN_PROPERTY(SmokeDomainSettings, use_dissolve_smoke_log)
	POINTER_PROPERTY(PointCache, SmokeDomainSettings, point_cache)
	ENUM_PROPERTY(point_cache_compress_type_enum, SmokeDomainSettings, point_cache_compress_type)
	ENUM_PROPERTY(openvdb_cache_compress_type_enum, SmokeDomainSettings, openvdb_cache_compress_type)
	ENUM_PROPERTY(data_depth_enum, SmokeDomainSettings, data_depth)
	ENUM_PROPERTY(collision_extents_enum, SmokeDomainSettings, collision_extents)
	POINTER_PROPERTY(EffectorWeights, SmokeDomainSettings, effector_weights)
	ENUM_PROPERTY(highres_sampling_enum, SmokeDomainSettings, highres_sampling)
	FLOAT_PROPERTY(SmokeDomainSettings, time_scale)
	FLOAT_PROPERTY(SmokeDomainSettings, vorticity)
	FLOAT_ARRAY_PROPERTY(SmokeDomainSettings, 32, density_grid)
	FLOAT_ARRAY_PROPERTY(SmokeDomainSettings, 32, velocity_grid)
	FLOAT_ARRAY_PROPERTY(SmokeDomainSettings, 32, flame_grid)
	FLOAT_ARRAY_PROPERTY(SmokeDomainSettings, 32, color_grid)
	FLOAT_ARRAY_PROPERTY(SmokeDomainSettings, 32, heat_grid)
	FLOAT_ARRAY_PROPERTY(SmokeDomainSettings, 32, temperature_grid)
	FLOAT_ARRAY_PROPERTY(SmokeDomainSettings, 3, cell_size)
	FLOAT_ARRAY_PROPERTY(SmokeDomainSettings, 3, start_point)
	INT_ARRAY_PROPERTY(SmokeDomainSettings, 3, domain_resolution)
	FLOAT_PROPERTY(SmokeDomainSettings, burning_rate)
	FLOAT_PROPERTY(SmokeDomainSettings, flame_smoke)
	FLOAT_PROPERTY(SmokeDomainSettings, flame_vorticity)
	FLOAT_PROPERTY(SmokeDomainSettings, flame_ignition)
	FLOAT_PROPERTY(SmokeDomainSettings, flame_max_temp)
	FLOAT_ARRAY_PROPERTY(SmokeDomainSettings, 3, flame_smoke_color)
	BOOLEAN_PROPERTY(SmokeDomainSettings, use_adaptive_domain)
	INT_PROPERTY(SmokeDomainSettings, additional_res)
	INT_PROPERTY(SmokeDomainSettings, adapt_margin)
	FLOAT_PROPERTY(SmokeDomainSettings, adapt_threshold)
	ENUM_PROPERTY(cache_file_format_enum, SmokeDomainSettings, cache_file_format)
	ENUM_PROPERTY(slice_method_enum, SmokeDomainSettings, slice_method)
	ENUM_PROPERTY(axis_slice_method_enum, SmokeDomainSettings, axis_slice_method)
	ENUM_PROPERTY(slice_axis_enum, SmokeDomainSettings, slice_axis)
	FLOAT_PROPERTY(SmokeDomainSettings, slice_per_voxel)
	FLOAT_PROPERTY(SmokeDomainSettings, slice_depth)
	FLOAT_PROPERTY(SmokeDomainSettings, display_thickness)
	ENUM_PROPERTY(display_interpolation_enum, SmokeDomainSettings, display_interpolation)
	BOOLEAN_PROPERTY(SmokeDomainSettings, show_velocity)
	ENUM_PROPERTY(vector_display_type_enum, SmokeDomainSettings, vector_display_type)
	FLOAT_PROPERTY(SmokeDomainSettings, vector_scale)
	BOOLEAN_PROPERTY(SmokeDomainSettings, use_color_ramp)
	ENUM_PROPERTY(coba_field_enum, SmokeDomainSettings, coba_field)
	POINTER_PROPERTY(ColorRamp, SmokeDomainSettings, color_ramp)
	FLOAT_PROPERTY(SmokeDomainSettings, clipping)


	POINTER_PROPERTY(Struct, SmokeFlowSettings, rna_type)
	FLOAT_PROPERTY(SmokeFlowSettings, density)
	FLOAT_ARRAY_PROPERTY(SmokeFlowSettings, 3, smoke_color)
	FLOAT_PROPERTY(SmokeFlowSettings, fuel_amount)
	FLOAT_PROPERTY(SmokeFlowSettings, temperature)
	POINTER_PROPERTY(ParticleSystem, SmokeFlowSettings, particle_system)
	ENUM_PROPERTY(smoke_flow_type_enum, SmokeFlowSettings, smoke_flow_type)
	ENUM_PROPERTY(smoke_flow_source_enum, SmokeFlowSettings, smoke_flow_source)
	BOOLEAN_PROPERTY(SmokeFlowSettings, use_absolute)
	BOOLEAN_PROPERTY(SmokeFlowSettings, use_initial_velocity)
	FLOAT_PROPERTY(SmokeFlowSettings, velocity_factor)
	FLOAT_PROPERTY(SmokeFlowSettings, velocity_normal)
	FLOAT_PROPERTY(SmokeFlowSettings, velocity_random)
	FLOAT_PROPERTY(SmokeFlowSettings, volume_density)
	FLOAT_PROPERTY(SmokeFlowSettings, surface_distance)
	FLOAT_PROPERTY(SmokeFlowSettings, particle_size)
	BOOLEAN_PROPERTY(SmokeFlowSettings, use_particle_size)
	INT_PROPERTY(SmokeFlowSettings, subframes)
	STRING_PROPERTY(SmokeFlowSettings, density_vertex_group)
	BOOLEAN_PROPERTY(SmokeFlowSettings, use_texture)
	ENUM_PROPERTY(texture_map_type_enum, SmokeFlowSettings, texture_map_type)
	STRING_PROPERTY(SmokeFlowSettings, uv_layer)
	POINTER_PROPERTY(Texture, SmokeFlowSettings, noise_texture)
	FLOAT_PROPERTY(SmokeFlowSettings, texture_size)
	FLOAT_PROPERTY(SmokeFlowSettings, texture_offset)


	POINTER_PROPERTY(Struct, SmokeCollSettings, rna_type)
	ENUM_PROPERTY(collision_type_enum, SmokeCollSettings, collision_type)


	POINTER_PROPERTY(Struct, Space, rna_type)
	ENUM_PROPERTY(type_enum, Space, type)
	BOOLEAN_PROPERTY(Space, show_locked_time)


	POINTER_PROPERTY(Image, SpaceImageEditor, image)
	POINTER_PROPERTY(ImageUser, SpaceImageEditor, image_user)
	POINTER_PROPERTY(Scopes, SpaceImageEditor, scopes)
	BOOLEAN_PROPERTY(SpaceImageEditor, use_image_pin)
	POINTER_PROPERTY(Histogram, SpaceImageEditor, sample_histogram)
	FLOAT_ARRAY_PROPERTY(SpaceImageEditor, 2, zoom)
	BOOLEAN_PROPERTY(SpaceImageEditor, show_repeat)
	BOOLEAN_PROPERTY(SpaceImageEditor, show_annotation)
	ENUM_PROPERTY(display_channels_enum, SpaceImageEditor, display_channels)
	BOOLEAN_PROPERTY(SpaceImageEditor, show_stereo_3d)
	POINTER_PROPERTY(SpaceUVEditor, SpaceImageEditor, uv_editor)
	ENUM_PROPERTY(mode_enum, SpaceImageEditor, mode)
	ENUM_PROPERTY(ui_mode_enum, SpaceImageEditor, ui_mode)
	FLOAT_ARRAY_PROPERTY(SpaceImageEditor, 2, cursor_location)
	ENUM_PROPERTY(pivot_point_enum, SpaceImageEditor, pivot_point)
	POINTER_PROPERTY(GreasePencil, SpaceImageEditor, grease_pencil)
	BOOLEAN_PROPERTY(SpaceImageEditor, use_realtime_update)
	BOOLEAN_PROPERTY(SpaceImageEditor, show_render)
	BOOLEAN_PROPERTY(SpaceImageEditor, show_paint)
	BOOLEAN_PROPERTY(SpaceImageEditor, show_uvedit)
	BOOLEAN_PROPERTY(SpaceImageEditor, show_maskedit)
	POINTER_PROPERTY(Mask, SpaceImageEditor, mask)
	ENUM_PROPERTY(mask_display_type_enum, SpaceImageEditor, mask_display_type)
	BOOLEAN_PROPERTY(SpaceImageEditor, show_mask_smooth)
	BOOLEAN_PROPERTY(SpaceImageEditor, show_mask_overlay)
	ENUM_PROPERTY(mask_overlay_mode_enum, SpaceImageEditor, mask_overlay_mode)


	POINTER_PROPERTY(Struct, SpaceUVEditor, rna_type)
	ENUM_PROPERTY(sticky_select_mode_enum, SpaceUVEditor, sticky_select_mode)
	ENUM_PROPERTY(edge_display_type_enum, SpaceUVEditor, edge_display_type)
	BOOLEAN_PROPERTY(SpaceUVEditor, show_smooth_edges)
	BOOLEAN_PROPERTY(SpaceUVEditor, show_stretch)
	ENUM_PROPERTY(display_stretch_type_enum, SpaceUVEditor, display_stretch_type)
	BOOLEAN_PROPERTY(SpaceUVEditor, show_modified_edges)
	BOOLEAN_PROPERTY(SpaceUVEditor, show_metadata)
	BOOLEAN_PROPERTY(SpaceUVEditor, show_texpaint)
	BOOLEAN_PROPERTY(SpaceUVEditor, show_pixel_coords)
	BOOLEAN_PROPERTY(SpaceUVEditor, show_faces)
	BOOLEAN_PROPERTY(SpaceUVEditor, show_edges)
	ENUM_PROPERTY(pixel_snap_mode_enum, SpaceUVEditor, pixel_snap_mode)
	BOOLEAN_PROPERTY(SpaceUVEditor, lock_bounds)
	BOOLEAN_PROPERTY(SpaceUVEditor, use_live_unwrap)


	ENUM_PROPERTY(view_type_enum, SpaceSequenceEditor, view_type)
	ENUM_PROPERTY(display_mode_enum, SpaceSequenceEditor, display_mode)
	BOOLEAN_PROPERTY(SpaceSequenceEditor, show_frame_indicator)
	BOOLEAN_PROPERTY(SpaceSequenceEditor, show_frames)
	BOOLEAN_PROPERTY(SpaceSequenceEditor, use_marker_sync)
	BOOLEAN_PROPERTY(SpaceSequenceEditor, show_separate_color)
	BOOLEAN_PROPERTY(SpaceSequenceEditor, show_safe_areas)
	BOOLEAN_PROPERTY(SpaceSequenceEditor, show_safe_center)
	BOOLEAN_PROPERTY(SpaceSequenceEditor, show_metadata)
	BOOLEAN_PROPERTY(SpaceSequenceEditor, show_seconds)
	BOOLEAN_PROPERTY(SpaceSequenceEditor, show_marker_lines)
	BOOLEAN_PROPERTY(SpaceSequenceEditor, show_annotation)
	INT_PROPERTY(SpaceSequenceEditor, display_channel)
	ENUM_PROPERTY(preview_channels_enum, SpaceSequenceEditor, preview_channels)
	ENUM_PROPERTY(waveform_display_type_enum, SpaceSequenceEditor, waveform_display_type)
	INT_PROPERTY(SpaceSequenceEditor, show_overexposed)
	ENUM_PROPERTY(proxy_render_size_enum, SpaceSequenceEditor, proxy_render_size)
	POINTER_PROPERTY(GreasePencil, SpaceSequenceEditor, grease_pencil)
	ENUM_PROPERTY(overlay_type_enum, SpaceSequenceEditor, overlay_type)
	BOOLEAN_PROPERTY(SpaceSequenceEditor, show_backdrop)
	BOOLEAN_PROPERTY(SpaceSequenceEditor, show_strip_offset)


	POINTER_PROPERTY(Text, SpaceTextEditor, text)
	BOOLEAN_PROPERTY(SpaceTextEditor, show_word_wrap)
	BOOLEAN_PROPERTY(SpaceTextEditor, show_line_numbers)
	BOOLEAN_PROPERTY(SpaceTextEditor, show_syntax_highlight)
	BOOLEAN_PROPERTY(SpaceTextEditor, show_line_highlight)
	INT_PROPERTY(SpaceTextEditor, tab_width)
	INT_PROPERTY(SpaceTextEditor, font_size)
	BOOLEAN_PROPERTY(SpaceTextEditor, show_margin)
	INT_PROPERTY(SpaceTextEditor, margin_column)
	INT_PROPERTY(SpaceTextEditor, top)
	INT_PROPERTY(SpaceTextEditor, visible_lines)
	BOOLEAN_PROPERTY(SpaceTextEditor, use_overwrite)
	BOOLEAN_PROPERTY(SpaceTextEditor, use_live_edit)
	BOOLEAN_PROPERTY(SpaceTextEditor, use_find_all)
	BOOLEAN_PROPERTY(SpaceTextEditor, use_find_wrap)
	BOOLEAN_PROPERTY(SpaceTextEditor, use_match_case)
	STRING_PROPERTY(SpaceTextEditor, find_text)
	STRING_PROPERTY(SpaceTextEditor, replace_text)

	inline void SpaceTextEditor::region_location_from_cursor(int line, int column, int result[2]) {
		SpaceTextEditor_region_location_from_cursor((::ID *) ptr.id.data, (::SpaceText *) this->ptr.data, line, column, result);
	}


	POINTER_PROPERTY(Struct, FileSelectParams, rna_type)
	STRING_PROPERTY(FileSelectParams, title)
	STRING_PROPERTY(FileSelectParams, directory)
	STRING_PROPERTY(FileSelectParams, filename)
	BOOLEAN_PROPERTY(FileSelectParams, use_library_browsing)
	ENUM_PROPERTY(display_type_enum, FileSelectParams, display_type)
	ENUM_PROPERTY(recursion_level_enum, FileSelectParams, recursion_level)
	BOOLEAN_PROPERTY(FileSelectParams, use_filter)
	BOOLEAN_PROPERTY(FileSelectParams, show_hidden)
	ENUM_PROPERTY(sort_method_enum, FileSelectParams, sort_method)
	BOOLEAN_PROPERTY(FileSelectParams, use_filter_image)
	BOOLEAN_PROPERTY(FileSelectParams, use_filter_blender)
	BOOLEAN_PROPERTY(FileSelectParams, use_filter_backup)
	BOOLEAN_PROPERTY(FileSelectParams, use_filter_movie)
	BOOLEAN_PROPERTY(FileSelectParams, use_filter_script)
	BOOLEAN_PROPERTY(FileSelectParams, use_filter_font)
	BOOLEAN_PROPERTY(FileSelectParams, use_filter_sound)
	BOOLEAN_PROPERTY(FileSelectParams, use_filter_text)
	BOOLEAN_PROPERTY(FileSelectParams, use_filter_folder)
	BOOLEAN_PROPERTY(FileSelectParams, use_filter_blendid)
	ENUM_PROPERTY(filter_id_enum, FileSelectParams, filter_id)
	ENUM_PROPERTY(filter_id_category_enum, FileSelectParams, filter_id_category)
	STRING_PROPERTY(FileSelectParams, filter_glob)
	STRING_PROPERTY(FileSelectParams, filter_search)
	ENUM_PROPERTY(display_size_enum, FileSelectParams, display_size)


	POINTER_PROPERTY(Struct, FileBrowserFSMenuEntry, rna_type)
	STRING_PROPERTY(FileBrowserFSMenuEntry, path)
	STRING_PROPERTY(FileBrowserFSMenuEntry, name)
	BOOLEAN_PROPERTY(FileBrowserFSMenuEntry, use_save)
	BOOLEAN_PROPERTY(FileBrowserFSMenuEntry, is_valid)


	POINTER_PROPERTY(FileSelectParams, SpaceFileBrowser, params)
	POINTER_PROPERTY(Operator, SpaceFileBrowser, active_operator)
	POINTER_PROPERTY(Operator, SpaceFileBrowser, operator_value)

	INT_PROPERTY(SpaceFileBrowser, system_folders_active)

	INT_PROPERTY(SpaceFileBrowser, system_bookmarks_active)

	INT_PROPERTY(SpaceFileBrowser, bookmarks_active)

	INT_PROPERTY(SpaceFileBrowser, recent_folders_active)


	ENUM_PROPERTY(display_mode_enum, SpaceOutliner, display_mode)
	STRING_PROPERTY(SpaceOutliner, filter_text)
	BOOLEAN_PROPERTY(SpaceOutliner, use_filter_case_sensitive)
	BOOLEAN_PROPERTY(SpaceOutliner, use_filter_complete)
	BOOLEAN_PROPERTY(SpaceOutliner, use_sort_alpha)
	BOOLEAN_PROPERTY(SpaceOutliner, show_restrict_columns)
	BOOLEAN_PROPERTY(SpaceOutliner, use_filter_object)
	BOOLEAN_PROPERTY(SpaceOutliner, use_filter_object_content)
	BOOLEAN_PROPERTY(SpaceOutliner, use_filter_children)
	BOOLEAN_PROPERTY(SpaceOutliner, use_filter_collection)
	ENUM_PROPERTY(filter_state_enum, SpaceOutliner, filter_state)
	BOOLEAN_PROPERTY(SpaceOutliner, use_filter_object_mesh)
	BOOLEAN_PROPERTY(SpaceOutliner, use_filter_object_armature)
	BOOLEAN_PROPERTY(SpaceOutliner, use_filter_object_empty)
	BOOLEAN_PROPERTY(SpaceOutliner, use_filter_object_light)
	BOOLEAN_PROPERTY(SpaceOutliner, use_filter_object_camera)
	BOOLEAN_PROPERTY(SpaceOutliner, use_filter_object_others)
	BOOLEAN_PROPERTY(SpaceOutliner, use_filter_id_type)
	ENUM_PROPERTY(filter_id_type_enum, SpaceOutliner, filter_id_type)


	POINTER_PROPERTY(Object, SpaceView3D, camera)
	BOOLEAN_PROPERTY(SpaceView3D, use_render_border)
	FLOAT_PROPERTY(SpaceView3D, render_border_min_x)
	FLOAT_PROPERTY(SpaceView3D, render_border_min_y)
	FLOAT_PROPERTY(SpaceView3D, render_border_max_x)
	FLOAT_PROPERTY(SpaceView3D, render_border_max_y)
	POINTER_PROPERTY(Object, SpaceView3D, lock_object)
	STRING_PROPERTY(SpaceView3D, lock_bone)
	BOOLEAN_PROPERTY(SpaceView3D, lock_cursor)
	POINTER_PROPERTY(SpaceView3D, SpaceView3D, local_view)
	FLOAT_PROPERTY(SpaceView3D, lens)
	FLOAT_PROPERTY(SpaceView3D, clip_start)
	FLOAT_PROPERTY(SpaceView3D, clip_end)
	BOOLEAN_PROPERTY(SpaceView3D, lock_camera)
	BOOLEAN_PROPERTY(SpaceView3D, show_gizmo)
	BOOLEAN_PROPERTY(SpaceView3D, show_gizmo_navigate)
	BOOLEAN_PROPERTY(SpaceView3D, show_gizmo_context)
	BOOLEAN_PROPERTY(SpaceView3D, show_gizmo_tool)
	BOOLEAN_PROPERTY(SpaceView3D, use_local_camera)
	POINTER_PROPERTY(RegionView3D, SpaceView3D, region_3d)

	BOOLEAN_PROPERTY(SpaceView3D, show_reconstruction)
	FLOAT_PROPERTY(SpaceView3D, tracks_display_size)
	ENUM_PROPERTY(tracks_display_type_enum, SpaceView3D, tracks_display_type)
	BOOLEAN_PROPERTY(SpaceView3D, show_camera_path)
	BOOLEAN_PROPERTY(SpaceView3D, show_bundle_names)
	POINTER_PROPERTY(GPUFXSettings, SpaceView3D, fx_settings)
	ENUM_PROPERTY(stereo_3d_eye_enum, SpaceView3D, stereo_3d_eye)
	ENUM_PROPERTY(stereo_3d_camera_enum, SpaceView3D, stereo_3d_camera)
	BOOLEAN_PROPERTY(SpaceView3D, show_stereo_3d_cameras)
	BOOLEAN_PROPERTY(SpaceView3D, show_stereo_3d_convergence_plane)
	FLOAT_PROPERTY(SpaceView3D, stereo_3d_convergence_plane_alpha)
	BOOLEAN_PROPERTY(SpaceView3D, show_stereo_3d_volume)
	FLOAT_PROPERTY(SpaceView3D, stereo_3d_volume_alpha)
	BOOLEAN_PROPERTY(SpaceView3D, show_object_viewport_mesh)
	BOOLEAN_PROPERTY(SpaceView3D, show_object_viewport_curve)
	BOOLEAN_PROPERTY(SpaceView3D, show_object_viewport_surf)
	BOOLEAN_PROPERTY(SpaceView3D, show_object_viewport_meta)
	BOOLEAN_PROPERTY(SpaceView3D, show_object_viewport_font)
	BOOLEAN_PROPERTY(SpaceView3D, show_object_viewport_armature)
	BOOLEAN_PROPERTY(SpaceView3D, show_object_viewport_lattice)
	BOOLEAN_PROPERTY(SpaceView3D, show_object_viewport_empty)
	BOOLEAN_PROPERTY(SpaceView3D, show_object_viewport_grease_pencil)
	BOOLEAN_PROPERTY(SpaceView3D, show_object_viewport_camera)
	BOOLEAN_PROPERTY(SpaceView3D, show_object_viewport_light)
	BOOLEAN_PROPERTY(SpaceView3D, show_object_viewport_speaker)
	BOOLEAN_PROPERTY(SpaceView3D, show_object_viewport_light_probe)
	BOOLEAN_PROPERTY(SpaceView3D, show_object_select_mesh)
	BOOLEAN_PROPERTY(SpaceView3D, show_object_select_curve)
	BOOLEAN_PROPERTY(SpaceView3D, show_object_select_surf)
	BOOLEAN_PROPERTY(SpaceView3D, show_object_select_meta)
	BOOLEAN_PROPERTY(SpaceView3D, show_object_select_font)
	BOOLEAN_PROPERTY(SpaceView3D, show_object_select_armature)
	BOOLEAN_PROPERTY(SpaceView3D, show_object_select_lattice)
	BOOLEAN_PROPERTY(SpaceView3D, show_object_select_empty)
	BOOLEAN_PROPERTY(SpaceView3D, show_object_select_grease_pencil)
	BOOLEAN_PROPERTY(SpaceView3D, show_object_select_camera)
	BOOLEAN_PROPERTY(SpaceView3D, show_object_select_light)
	BOOLEAN_PROPERTY(SpaceView3D, show_object_select_speaker)
	BOOLEAN_PROPERTY(SpaceView3D, show_object_select_light_probe)
	INT_PROPERTY(SpaceView3D, icon_from_show_object_viewport)
	POINTER_PROPERTY(View3DShading, SpaceView3D, shading)
	POINTER_PROPERTY(View3DOverlay, SpaceView3D, overlay)


	POINTER_PROPERTY(Struct, View3DShading, rna_type)
	ENUM_PROPERTY(type_enum, View3DShading, type)
	ENUM_PROPERTY(light_enum, View3DShading, light)
	BOOLEAN_PROPERTY(View3DShading, show_object_outline)
	ENUM_PROPERTY(studio_light_enum, View3DShading, studio_light)
	BOOLEAN_PROPERTY(View3DShading, use_world_space_lighting)
	BOOLEAN_PROPERTY(View3DShading, show_backface_culling)
	BOOLEAN_PROPERTY(View3DShading, show_cavity)
	ENUM_PROPERTY(cavity_type_enum, View3DShading, cavity_type)
	FLOAT_PROPERTY(View3DShading, curvature_ridge_factor)
	FLOAT_PROPERTY(View3DShading, curvature_valley_factor)
	FLOAT_PROPERTY(View3DShading, cavity_ridge_factor)
	FLOAT_PROPERTY(View3DShading, cavity_valley_factor)
	POINTER_PROPERTY(StudioLight, View3DShading, selected_studio_light)
	FLOAT_PROPERTY(View3DShading, studiolight_rotate_z)
	ENUM_PROPERTY(color_type_enum, View3DShading, color_type)
	ENUM_PROPERTY(wireframe_color_type_enum, View3DShading, wireframe_color_type)
	FLOAT_ARRAY_PROPERTY(View3DShading, 3, single_color)
	ENUM_PROPERTY(background_type_enum, View3DShading, background_type)
	FLOAT_ARRAY_PROPERTY(View3DShading, 3, background_color)
	BOOLEAN_PROPERTY(View3DShading, show_shadows)
	BOOLEAN_PROPERTY(View3DShading, show_xray)
	BOOLEAN_PROPERTY(View3DShading, show_xray_wireframe)
	FLOAT_PROPERTY(View3DShading, xray_alpha)
	FLOAT_PROPERTY(View3DShading, xray_alpha_wireframe)
	BOOLEAN_PROPERTY(View3DShading, use_dof)
	BOOLEAN_PROPERTY(View3DShading, use_scene_lights)
	BOOLEAN_PROPERTY(View3DShading, use_scene_world)
	BOOLEAN_PROPERTY(View3DShading, show_specular_highlight)
	FLOAT_ARRAY_PROPERTY(View3DShading, 3, object_outline_color)
	FLOAT_PROPERTY(View3DShading, shadow_intensity)
	FLOAT_PROPERTY(View3DShading, studiolight_background_alpha)


	POINTER_PROPERTY(Struct, View3DOverlay, rna_type)
	BOOLEAN_PROPERTY(View3DOverlay, show_overlays)
	BOOLEAN_PROPERTY(View3DOverlay, show_floor)
	BOOLEAN_PROPERTY(View3DOverlay, show_axis_x)
	BOOLEAN_PROPERTY(View3DOverlay, show_axis_y)
	BOOLEAN_PROPERTY(View3DOverlay, show_axis_z)
	FLOAT_PROPERTY(View3DOverlay, grid_scale)
	INT_PROPERTY(View3DOverlay, grid_lines)
	INT_PROPERTY(View3DOverlay, grid_subdivisions)
	FLOAT_PROPERTY(View3DOverlay, grid_scale_unit)
	BOOLEAN_PROPERTY(View3DOverlay, show_outline_selected)
	BOOLEAN_PROPERTY(View3DOverlay, show_object_origins)
	BOOLEAN_PROPERTY(View3DOverlay, show_object_origins_all)
	BOOLEAN_PROPERTY(View3DOverlay, show_relationship_lines)
	BOOLEAN_PROPERTY(View3DOverlay, show_cursor)
	BOOLEAN_PROPERTY(View3DOverlay, show_text)
	BOOLEAN_PROPERTY(View3DOverlay, show_extras)
	BOOLEAN_PROPERTY(View3DOverlay, show_bones)
	BOOLEAN_PROPERTY(View3DOverlay, show_face_orientation)
	BOOLEAN_PROPERTY(View3DOverlay, show_xray_bone)
	FLOAT_PROPERTY(View3DOverlay, xray_alpha_bone)
	BOOLEAN_PROPERTY(View3DOverlay, show_motion_paths)
	BOOLEAN_PROPERTY(View3DOverlay, show_onion_skins)
	BOOLEAN_PROPERTY(View3DOverlay, show_look_dev)
	BOOLEAN_PROPERTY(View3DOverlay, show_wireframes)
	FLOAT_PROPERTY(View3DOverlay, wireframe_threshold)
	BOOLEAN_PROPERTY(View3DOverlay, show_paint_wire)
	BOOLEAN_PROPERTY(View3DOverlay, show_wpaint_contours)
	BOOLEAN_PROPERTY(View3DOverlay, show_weight)
	BOOLEAN_PROPERTY(View3DOverlay, show_occlude_wire)
	BOOLEAN_PROPERTY(View3DOverlay, show_face_normals)
	BOOLEAN_PROPERTY(View3DOverlay, show_vertex_normals)
	BOOLEAN_PROPERTY(View3DOverlay, show_split_normals)
	BOOLEAN_PROPERTY(View3DOverlay, show_edges)
	BOOLEAN_PROPERTY(View3DOverlay, show_faces)
	BOOLEAN_PROPERTY(View3DOverlay, show_face_center)
	BOOLEAN_PROPERTY(View3DOverlay, show_edge_crease)
	BOOLEAN_PROPERTY(View3DOverlay, show_edge_bevel_weight)
	BOOLEAN_PROPERTY(View3DOverlay, show_edge_seams)
	BOOLEAN_PROPERTY(View3DOverlay, show_edge_sharp)
	BOOLEAN_PROPERTY(View3DOverlay, show_freestyle_edge_marks)
	BOOLEAN_PROPERTY(View3DOverlay, show_freestyle_face_marks)
	BOOLEAN_PROPERTY(View3DOverlay, show_statvis)
	BOOLEAN_PROPERTY(View3DOverlay, show_extra_edge_length)
	BOOLEAN_PROPERTY(View3DOverlay, show_extra_edge_angle)
	BOOLEAN_PROPERTY(View3DOverlay, show_extra_face_angle)
	BOOLEAN_PROPERTY(View3DOverlay, show_extra_face_area)
	BOOLEAN_PROPERTY(View3DOverlay, show_extra_indices)
	BOOLEAN_PROPERTY(View3DOverlay, show_curve_handles)
	BOOLEAN_PROPERTY(View3DOverlay, show_curve_normals)
	FLOAT_PROPERTY(View3DOverlay, normals_length)
	FLOAT_PROPERTY(View3DOverlay, backwire_opacity)
	FLOAT_PROPERTY(View3DOverlay, texture_paint_mode_opacity)
	FLOAT_PROPERTY(View3DOverlay, vertex_paint_mode_opacity)
	FLOAT_PROPERTY(View3DOverlay, weight_paint_mode_opacity)
	BOOLEAN_PROPERTY(View3DOverlay, show_annotation)
	BOOLEAN_PROPERTY(View3DOverlay, use_gpencil_paper)
	BOOLEAN_PROPERTY(View3DOverlay, use_gpencil_grid)
	BOOLEAN_PROPERTY(View3DOverlay, use_gpencil_fade_layers)
	FLOAT_PROPERTY(View3DOverlay, gpencil_grid_opacity)
	FLOAT_PROPERTY(View3DOverlay, gpencil_paper_opacity)
	FLOAT_PROPERTY(View3DOverlay, gpencil_fade_layer)
	BOOLEAN_PROPERTY(View3DOverlay, use_gpencil_edit_lines)
	BOOLEAN_PROPERTY(View3DOverlay, use_gpencil_multiedit_line_only)
	BOOLEAN_PROPERTY(View3DOverlay, use_gpencil_onion_skin)
	FLOAT_PROPERTY(View3DOverlay, vertex_opacity)


	POINTER_PROPERTY(Struct, RegionView3D, rna_type)
	BOOLEAN_PROPERTY(RegionView3D, lock_rotation)
	BOOLEAN_PROPERTY(RegionView3D, show_sync_view)
	BOOLEAN_PROPERTY(RegionView3D, use_box_clip)
	FLOAT_ARRAY_PROPERTY(RegionView3D, 16, perspective_matrix)
	FLOAT_ARRAY_PROPERTY(RegionView3D, 16, window_matrix)
	FLOAT_ARRAY_PROPERTY(RegionView3D, 16, view_matrix)
	ENUM_PROPERTY(view_perspective_enum, RegionView3D, view_perspective)
	BOOLEAN_PROPERTY(RegionView3D, is_perspective)
	BOOLEAN_PROPERTY(RegionView3D, use_clip_planes)
	FLOAT_ARRAY_PROPERTY(RegionView3D, 24, clip_planes)
	FLOAT_ARRAY_PROPERTY(RegionView3D, 3, view_location)
	FLOAT_ARRAY_PROPERTY(RegionView3D, 4, view_rotation)
	FLOAT_PROPERTY(RegionView3D, view_distance)
	FLOAT_PROPERTY(RegionView3D, view_camera_zoom)
	FLOAT_ARRAY_PROPERTY(RegionView3D, 2, view_camera_offset)

	inline void RegionView3D::update(Context C) {
		RegionView3D_update((::ID *) ptr.id.data, (::RegionView3D *) this->ptr.data, (::bContext *) C.ptr.data);
	}


	ENUM_PROPERTY(context_enum, SpaceProperties, context)
	POINTER_PROPERTY(ID, SpaceProperties, pin_id)
	BOOLEAN_PROPERTY(SpaceProperties, use_pin_id)


	POINTER_PROPERTY(Action, SpaceDopeSheetEditor, action)
	ENUM_PROPERTY(mode_enum, SpaceDopeSheetEditor, mode)
	ENUM_PROPERTY(ui_mode_enum, SpaceDopeSheetEditor, ui_mode)
	BOOLEAN_PROPERTY(SpaceDopeSheetEditor, show_seconds)
	BOOLEAN_PROPERTY(SpaceDopeSheetEditor, show_frame_indicator)
	BOOLEAN_PROPERTY(SpaceDopeSheetEditor, show_sliders)
	BOOLEAN_PROPERTY(SpaceDopeSheetEditor, show_pose_markers)
	BOOLEAN_PROPERTY(SpaceDopeSheetEditor, show_group_colors)
	BOOLEAN_PROPERTY(SpaceDopeSheetEditor, show_interpolation)
	BOOLEAN_PROPERTY(SpaceDopeSheetEditor, show_extremes)
	BOOLEAN_PROPERTY(SpaceDopeSheetEditor, show_marker_lines)
	BOOLEAN_PROPERTY(SpaceDopeSheetEditor, use_auto_merge_keyframes)
	BOOLEAN_PROPERTY(SpaceDopeSheetEditor, use_realtime_update)
	BOOLEAN_PROPERTY(SpaceDopeSheetEditor, use_marker_sync)
	POINTER_PROPERTY(DopeSheet, SpaceDopeSheetEditor, dopesheet)
	ENUM_PROPERTY(auto_snap_enum, SpaceDopeSheetEditor, auto_snap)
	BOOLEAN_PROPERTY(SpaceDopeSheetEditor, show_cache)
	BOOLEAN_PROPERTY(SpaceDopeSheetEditor, cache_softbody)
	BOOLEAN_PROPERTY(SpaceDopeSheetEditor, cache_particles)
	BOOLEAN_PROPERTY(SpaceDopeSheetEditor, cache_cloth)
	BOOLEAN_PROPERTY(SpaceDopeSheetEditor, cache_smoke)
	BOOLEAN_PROPERTY(SpaceDopeSheetEditor, cache_dynamicpaint)
	BOOLEAN_PROPERTY(SpaceDopeSheetEditor, cache_rigidbody)


	ENUM_PROPERTY(mode_enum, SpaceGraphEditor, mode)
	BOOLEAN_PROPERTY(SpaceGraphEditor, show_seconds)
	BOOLEAN_PROPERTY(SpaceGraphEditor, show_frame_indicator)
	BOOLEAN_PROPERTY(SpaceGraphEditor, show_sliders)
	BOOLEAN_PROPERTY(SpaceGraphEditor, show_handles)
	BOOLEAN_PROPERTY(SpaceGraphEditor, use_only_selected_curves_handles)
	BOOLEAN_PROPERTY(SpaceGraphEditor, use_only_selected_keyframe_handles)
	BOOLEAN_PROPERTY(SpaceGraphEditor, use_beauty_drawing)
	BOOLEAN_PROPERTY(SpaceGraphEditor, show_group_colors)
	BOOLEAN_PROPERTY(SpaceGraphEditor, show_marker_lines)
	BOOLEAN_PROPERTY(SpaceGraphEditor, use_auto_merge_keyframes)
	BOOLEAN_PROPERTY(SpaceGraphEditor, use_realtime_update)
	BOOLEAN_PROPERTY(SpaceGraphEditor, show_cursor)
	FLOAT_PROPERTY(SpaceGraphEditor, cursor_position_x)
	FLOAT_PROPERTY(SpaceGraphEditor, cursor_position_y)
	ENUM_PROPERTY(pivot_point_enum, SpaceGraphEditor, pivot_point)
	POINTER_PROPERTY(DopeSheet, SpaceGraphEditor, dopesheet)
	ENUM_PROPERTY(auto_snap_enum, SpaceGraphEditor, auto_snap)
	BOOLEAN_PROPERTY(SpaceGraphEditor, has_ghost_curves)
	BOOLEAN_PROPERTY(SpaceGraphEditor, use_normalization)
	BOOLEAN_PROPERTY(SpaceGraphEditor, use_auto_normalization)


	BOOLEAN_PROPERTY(SpaceNLA, show_seconds)
	BOOLEAN_PROPERTY(SpaceNLA, show_frame_indicator)
	BOOLEAN_PROPERTY(SpaceNLA, show_strip_curves)
	BOOLEAN_PROPERTY(SpaceNLA, show_local_markers)
	BOOLEAN_PROPERTY(SpaceNLA, show_marker_lines)
	BOOLEAN_PROPERTY(SpaceNLA, use_realtime_update)
	POINTER_PROPERTY(DopeSheet, SpaceNLA, dopesheet)
	ENUM_PROPERTY(auto_snap_enum, SpaceNLA, auto_snap)


	INT_PROPERTY(SpaceConsole, font_size)
	INT_PROPERTY(SpaceConsole, select_start)
	INT_PROPERTY(SpaceConsole, select_end)
	STRING_PROPERTY(SpaceConsole, prompt)
	STRING_PROPERTY(SpaceConsole, language)




	POINTER_PROPERTY(Struct, ConsoleLine, rna_type)
	STRING_PROPERTY(ConsoleLine, body)
	INT_PROPERTY(ConsoleLine, current_character)
	ENUM_PROPERTY(type_enum, ConsoleLine, type)


	BOOLEAN_PROPERTY(SpaceInfo, show_report_debug)
	BOOLEAN_PROPERTY(SpaceInfo, show_report_info)
	BOOLEAN_PROPERTY(SpaceInfo, show_report_operator)
	BOOLEAN_PROPERTY(SpaceInfo, show_report_warning)
	BOOLEAN_PROPERTY(SpaceInfo, show_report_error)


	ENUM_PROPERTY(filter_type_enum, SpacePreferences, filter_type)
	STRING_PROPERTY(SpacePreferences, filter_text)


	POINTER_PROPERTY(Struct, NodeTreePath, rna_type)
	POINTER_PROPERTY(NodeTree, NodeTreePath, node_tree)


	ENUM_PROPERTY(tree_type_enum, SpaceNodeEditor, tree_type)
	ENUM_PROPERTY(texture_type_enum, SpaceNodeEditor, texture_type)
	ENUM_PROPERTY(shader_type_enum, SpaceNodeEditor, shader_type)
	POINTER_PROPERTY(ID, SpaceNodeEditor, id)
	POINTER_PROPERTY(ID, SpaceNodeEditor, id_from)

	POINTER_PROPERTY(NodeTree, SpaceNodeEditor, node_tree)
	POINTER_PROPERTY(NodeTree, SpaceNodeEditor, edit_tree)
	BOOLEAN_PROPERTY(SpaceNodeEditor, pin)
	BOOLEAN_PROPERTY(SpaceNodeEditor, show_backdrop)
	BOOLEAN_PROPERTY(SpaceNodeEditor, show_annotation)
	BOOLEAN_PROPERTY(SpaceNodeEditor, use_auto_render)
	FLOAT_PROPERTY(SpaceNodeEditor, backdrop_zoom)
	FLOAT_ARRAY_PROPERTY(SpaceNodeEditor, 2, backdrop_offset)
	ENUM_PROPERTY(backdrop_channels_enum, SpaceNodeEditor, backdrop_channels)
	FLOAT_ARRAY_PROPERTY(SpaceNodeEditor, 2, cursor_location)
	BOOLEAN_PROPERTY(SpaceNodeEditor, use_insert_offset)
	ENUM_PROPERTY(insert_offset_direction_enum, SpaceNodeEditor, insert_offset_direction)

	inline void SpaceNodeEditor::cursor_location_from_region(Context C, int x, int y) {
		SpaceNodeEditor_cursor_location_from_region((::SpaceNode *) this->ptr.data, (::bContext *) C.ptr.data, x, y);
	}


	POINTER_PROPERTY(Struct, SpaceNodeEditorPath, rna_type)
	STRING_PROPERTY(SpaceNodeEditorPath, to_string)

	inline void SpaceNodeEditorPath::clear(Context C) {
		SpaceNodeEditorPath_clear((::SpaceNode *) this->ptr.data, (::bContext *) C.ptr.data);
	}

	inline void SpaceNodeEditorPath::start(Context C, NodeTree& node_tree) {
		SpaceNodeEditorPath_start((::SpaceNode *) this->ptr.data, (::bContext *) C.ptr.data, (::PointerRNA *) node_tree.ptr.data);
	}

	inline void SpaceNodeEditorPath::append(Context C, NodeTree& node_tree, Node& node) {
		SpaceNodeEditorPath_append((::SpaceNode *) this->ptr.data, (::bContext *) C.ptr.data, (::PointerRNA *) node_tree.ptr.data, (::PointerRNA *) node.ptr.data);
	}

	inline void SpaceNodeEditorPath::pop(Context C) {
		SpaceNodeEditorPath_pop((::SpaceNode *) this->ptr.data, (::bContext *) C.ptr.data);
	}


	POINTER_PROPERTY(MovieClip, SpaceClipEditor, clip)
	POINTER_PROPERTY(MovieClipUser, SpaceClipEditor, clip_user)
	POINTER_PROPERTY(Mask, SpaceClipEditor, mask)
	ENUM_PROPERTY(mask_display_type_enum, SpaceClipEditor, mask_display_type)
	BOOLEAN_PROPERTY(SpaceClipEditor, show_mask_smooth)
	BOOLEAN_PROPERTY(SpaceClipEditor, show_mask_overlay)
	ENUM_PROPERTY(mask_overlay_mode_enum, SpaceClipEditor, mask_overlay_mode)
	ENUM_PROPERTY(mode_enum, SpaceClipEditor, mode)
	ENUM_PROPERTY(view_enum, SpaceClipEditor, view)
	BOOLEAN_PROPERTY(SpaceClipEditor, show_marker_pattern)
	BOOLEAN_PROPERTY(SpaceClipEditor, show_marker_search)
	BOOLEAN_PROPERTY(SpaceClipEditor, lock_selection)
	BOOLEAN_PROPERTY(SpaceClipEditor, lock_time_cursor)
	BOOLEAN_PROPERTY(SpaceClipEditor, show_track_path)
	INT_PROPERTY(SpaceClipEditor, path_length)
	BOOLEAN_PROPERTY(SpaceClipEditor, show_tiny_markers)
	BOOLEAN_PROPERTY(SpaceClipEditor, show_bundles)
	BOOLEAN_PROPERTY(SpaceClipEditor, use_mute_footage)
	BOOLEAN_PROPERTY(SpaceClipEditor, show_disabled)
	BOOLEAN_PROPERTY(SpaceClipEditor, show_metadata)
	POINTER_PROPERTY(MovieClipScopes, SpaceClipEditor, scopes)
	BOOLEAN_PROPERTY(SpaceClipEditor, show_names)
	BOOLEAN_PROPERTY(SpaceClipEditor, show_grid)
	BOOLEAN_PROPERTY(SpaceClipEditor, show_stable)
	BOOLEAN_PROPERTY(SpaceClipEditor, use_manual_calibration)
	BOOLEAN_PROPERTY(SpaceClipEditor, show_annotation)
	BOOLEAN_PROPERTY(SpaceClipEditor, show_filters)
	BOOLEAN_PROPERTY(SpaceClipEditor, show_graph_frames)
	BOOLEAN_PROPERTY(SpaceClipEditor, show_graph_tracks_motion)
	BOOLEAN_PROPERTY(SpaceClipEditor, show_graph_tracks_error)
	BOOLEAN_PROPERTY(SpaceClipEditor, show_graph_only_selected)
	BOOLEAN_PROPERTY(SpaceClipEditor, show_graph_hidden)
	BOOLEAN_PROPERTY(SpaceClipEditor, show_red_channel)
	BOOLEAN_PROPERTY(SpaceClipEditor, show_green_channel)
	BOOLEAN_PROPERTY(SpaceClipEditor, show_blue_channel)
	BOOLEAN_PROPERTY(SpaceClipEditor, use_grayscale_preview)
	BOOLEAN_PROPERTY(SpaceClipEditor, show_seconds)
	ENUM_PROPERTY(grease_pencil_source_enum, SpaceClipEditor, grease_pencil_source)
	ENUM_PROPERTY(pivot_point_enum, SpaceClipEditor, pivot_point)


	BOOLEAN_PROPERTY(Speaker, muted)
	POINTER_PROPERTY(Sound, Speaker, sound)
	FLOAT_PROPERTY(Speaker, volume_max)
	FLOAT_PROPERTY(Speaker, volume_min)
	FLOAT_PROPERTY(Speaker, distance_max)
	FLOAT_PROPERTY(Speaker, distance_reference)
	FLOAT_PROPERTY(Speaker, attenuation)
	FLOAT_PROPERTY(Speaker, cone_angle_outer)
	FLOAT_PROPERTY(Speaker, cone_angle_inner)
	FLOAT_PROPERTY(Speaker, cone_volume_outer)
	FLOAT_PROPERTY(Speaker, volume)
	FLOAT_PROPERTY(Speaker, pitch)
	POINTER_PROPERTY(AnimData, Speaker, animation_data)


	POINTER_PROPERTY(Struct, TextLine, rna_type)
	STRING_PROPERTY(TextLine, body)


	STRING_PROPERTY(Text, filepath)
	BOOLEAN_PROPERTY(Text, is_dirty)
	BOOLEAN_PROPERTY(Text, is_modified)
	BOOLEAN_PROPERTY(Text, is_in_memory)
	BOOLEAN_PROPERTY(Text, use_module)
	BOOLEAN_PROPERTY(Text, use_tabs_as_spaces)

	POINTER_PROPERTY(TextLine, Text, current_line)
	INT_PROPERTY(Text, current_character)
	INT_PROPERTY(Text, current_line_index)
	POINTER_PROPERTY(TextLine, Text, select_end_line)
	INT_PROPERTY(Text, select_end_character)

	inline void Text::clear() {
		Text_clear((::Text *) this->ptr.data);
	}

	inline void Text::write(const char * text) {
		Text_write((::Text *) this->ptr.data, text);
	}


	POINTER_PROPERTY(Struct, TimelineMarker, rna_type)
	STRING_PROPERTY(TimelineMarker, name)
	INT_PROPERTY(TimelineMarker, frame)
	BOOLEAN_PROPERTY(TimelineMarker, select)
	POINTER_PROPERTY(Object, TimelineMarker, camera)


	STRING_PROPERTY(Sound, filepath)
	POINTER_PROPERTY(PackedFile, Sound, packed_file)
	BOOLEAN_PROPERTY(Sound, use_memory_cache)
	BOOLEAN_PROPERTY(Sound, use_mono)

	inline void Sound::pack(void *main) {
		Sound_pack((::bSound *) this->ptr.data, (::Main *) main, NULL);
	}

	inline void Sound::unpack(void *main, int method) {
		Sound_unpack((::bSound *) this->ptr.data, (::Main *) main, NULL, method);
	}


	POINTER_PROPERTY(Struct, UILayout, rna_type)
	BOOLEAN_PROPERTY(UILayout, active)
	BOOLEAN_PROPERTY(UILayout, active_default)
	BOOLEAN_PROPERTY(UILayout, activate_init)
	ENUM_PROPERTY(operator_context_enum, UILayout, operator_context)
	BOOLEAN_PROPERTY(UILayout, enabled)
	BOOLEAN_PROPERTY(UILayout, alert)
	ENUM_PROPERTY(alignment_enum, UILayout, alignment)
	ENUM_PROPERTY(direction_enum, UILayout, direction)
	FLOAT_PROPERTY(UILayout, scale_x)
	FLOAT_PROPERTY(UILayout, scale_y)
	FLOAT_PROPERTY(UILayout, ui_units_x)
	FLOAT_PROPERTY(UILayout, ui_units_y)
	ENUM_PROPERTY(emboss_enum, UILayout, emboss)
	BOOLEAN_PROPERTY(UILayout, use_property_split)
	BOOLEAN_PROPERTY(UILayout, use_property_decorate)

	inline UILayout UILayout::row(bool align) {
		PointerRNA result;
		::uiLayout *retdata = UILayout_row((::uiLayout *) this->ptr.data, align);
		RNA_pointer_create((::ID *) ptr.id.data, &RNA_UILayout, retdata, &result);
		return UILayout(result);
	}

	inline UILayout UILayout::column(bool align) {
		PointerRNA result;
		::uiLayout *retdata = UILayout_column((::uiLayout *) this->ptr.data, align);
		RNA_pointer_create((::ID *) ptr.id.data, &RNA_UILayout, retdata, &result);
		return UILayout(result);
	}

	inline UILayout UILayout::column_flow(int columns, bool align) {
		PointerRNA result;
		::uiLayout *retdata = UILayout_column_flow((::uiLayout *) this->ptr.data, columns, align);
		RNA_pointer_create((::ID *) ptr.id.data, &RNA_UILayout, retdata, &result);
		return UILayout(result);
	}

	inline UILayout UILayout::grid_flow(bool row_major, int columns, bool even_columns, bool even_rows, bool align) {
		PointerRNA result;
		::uiLayout *retdata = UILayout_grid_flow((::uiLayout *) this->ptr.data, row_major, columns, even_columns, even_rows, align);
		RNA_pointer_create((::ID *) ptr.id.data, &RNA_UILayout, retdata, &result);
		return UILayout(result);
	}

	inline UILayout UILayout::box() {
		PointerRNA result;
		::uiLayout *retdata = UILayout_box((::uiLayout *) this->ptr.data);
		RNA_pointer_create((::ID *) ptr.id.data, &RNA_UILayout, retdata, &result);
		return UILayout(result);
	}

	inline UILayout UILayout::split(float factor, bool align) {
		PointerRNA result;
		::uiLayout *retdata = UILayout_split((::uiLayout *) this->ptr.data, factor, align);
		RNA_pointer_create((::ID *) ptr.id.data, &RNA_UILayout, retdata, &result);
		return UILayout(result);
	}

	inline UILayout UILayout::menu_pie() {
		PointerRNA result;
		::uiLayout *retdata = UILayout_menu_pie((::uiLayout *) this->ptr.data);
		RNA_pointer_create((::ID *) ptr.id.data, &RNA_UILayout, retdata, &result);
		return UILayout(result);
	}

	inline int UILayout::icon(Context C, AnyType& data) {
		return UILayout_icon((::bContext *) C.ptr.data, (::PointerRNA *) data.ptr.data);
	}

	inline const char * UILayout::enum_item_name(Context C, AnyType& data, const char * property, const char * identifier) {
		return UILayout_enum_item_name((::bContext *) C.ptr.data, (::PointerRNA *) data.ptr.data, property, identifier);
	}

	inline const char * UILayout::enum_item_description(Context C, AnyType& data, const char * property, const char * identifier) {
		return UILayout_enum_item_description((::bContext *) C.ptr.data, (::PointerRNA *) data.ptr.data, property, identifier);
	}

	inline int UILayout::enum_item_icon(Context C, AnyType& data, const char * property, const char * identifier) {
		return UILayout_enum_item_icon((::bContext *) C.ptr.data, (::PointerRNA *) data.ptr.data, property, identifier);
	}

	inline void UILayout::prop(AnyType& data, const char * property, const char * text, const char * text_ctxt, bool translate, int icon, bool expand, bool slider, bool toggle, bool icon_only, bool event, bool full_event, bool emboss, int index, int icon_value) {
		UILayout_prop((::uiLayout *) this->ptr.data, (::PointerRNA *) data.ptr.data, property, text, text_ctxt, translate, icon, expand, slider, toggle, icon_only, event, full_event, emboss, index, icon_value);
	}

	inline void UILayout::props_enum(AnyType& data, const char * property) {
		UILayout_props_enum((::uiLayout *) this->ptr.data, (::PointerRNA *) data.ptr.data, property);
	}

	inline void UILayout::prop_menu_enum(AnyType& data, const char * property, const char * text, const char * text_ctxt, bool translate, int icon) {
		UILayout_prop_menu_enum((::uiLayout *) this->ptr.data, (::PointerRNA *) data.ptr.data, property, text, text_ctxt, translate, icon);
	}

	inline void UILayout::prop_with_popover(AnyType& data, const char * property, const char * text, const char * text_ctxt, bool translate, int icon, bool icon_only, const char * panel) {
		UILayout_prop_with_popover((::uiLayout *) this->ptr.data, (::PointerRNA *) data.ptr.data, property, text, text_ctxt, translate, icon, icon_only, panel);
	}

	inline void UILayout::prop_with_menu(AnyType& data, const char * property, const char * text, const char * text_ctxt, bool translate, int icon, bool icon_only, const char * menu) {
		UILayout_prop_with_menu((::uiLayout *) this->ptr.data, (::PointerRNA *) data.ptr.data, property, text, text_ctxt, translate, icon, icon_only, menu);
	}

	inline void UILayout::prop_tabs_enum(Context C, AnyType& data, const char * property, bool icon_only) {
		UILayout_prop_tabs_enum((::uiLayout *) this->ptr.data, (::bContext *) C.ptr.data, (::PointerRNA *) data.ptr.data, property, icon_only);
	}

	inline void UILayout::prop_enum(AnyType& data, const char * property, const char * value, const char * text, const char * text_ctxt, bool translate, int icon) {
		UILayout_prop_enum((::uiLayout *) this->ptr.data, (::PointerRNA *) data.ptr.data, property, value, text, text_ctxt, translate, icon);
	}

	inline void UILayout::prop_search(AnyType& data, const char * property, AnyType& search_data, const char * search_property, const char * text, const char * text_ctxt, bool translate, int icon) {
		UILayout_prop_search((::uiLayout *) this->ptr.data, (::PointerRNA *) data.ptr.data, property, (::PointerRNA *) search_data.ptr.data, search_property, text, text_ctxt, translate, icon);
	}

	inline OperatorProperties UILayout::operator_value(const char * operator_value, const char * text, const char * text_ctxt, bool translate, int icon, bool emboss, bool depress, int icon_value) {
		PointerRNA result;
		result = UILayout_operator((::uiLayout *) this->ptr.data, operator_value, text, text_ctxt, translate, icon, emboss, depress, icon_value);
		return OperatorProperties(result);
	}

	inline OperatorProperties UILayout::operator_menu_hold(const char * operator_value, const char * text, const char * text_ctxt, bool translate, int icon, bool emboss, bool depress, int icon_value, const char * menu) {
		PointerRNA result;
		result = UILayout_operator_menu_hold((::uiLayout *) this->ptr.data, operator_value, text, text_ctxt, translate, icon, emboss, depress, icon_value, menu);
		return OperatorProperties(result);
	}

	inline void UILayout::operator_enum(const char * operator_value, const char * property) {
		UILayout_operator_enum((::uiLayout *) this->ptr.data, operator_value, property);
	}

	inline void UILayout::operator_menu_enum(Context C, const char * operator_value, const char * property, const char * text, const char * text_ctxt, bool translate, int icon) {
		UILayout_operator_menu_enum((::uiLayout *) this->ptr.data, (::bContext *) C.ptr.data, operator_value, property, text, text_ctxt, translate, icon);
	}

	inline void UILayout::label(const char * text, const char * text_ctxt, bool translate, int icon, int icon_value) {
		UILayout_label((::uiLayout *) this->ptr.data, text, text_ctxt, translate, icon, icon_value);
	}

	inline void UILayout::menu(const char * menu, const char * text, const char * text_ctxt, bool translate, int icon, int icon_value) {
		UILayout_menu((::uiLayout *) this->ptr.data, menu, text, text_ctxt, translate, icon, icon_value);
	}

	inline void UILayout::menu_contents(const char * menu) {
		UILayout_menu_contents((::uiLayout *) this->ptr.data, menu);
	}

	inline void UILayout::popover(Context C, const char * panel, const char * text, const char * text_ctxt, bool translate, int icon, int icon_value) {
		UILayout_popover((::uiLayout *) this->ptr.data, (::bContext *) C.ptr.data, panel, text, text_ctxt, translate, icon, icon_value);
	}

	inline void UILayout::popover_group(Context C, int space_type, int region_type, const char * context, const char * category) {
		UILayout_popover_group((::uiLayout *) this->ptr.data, (::bContext *) C.ptr.data, space_type, region_type, context, category);
	}

	inline void UILayout::separator(float factor) {
		UILayout_separator((::uiLayout *) this->ptr.data, factor);
	}

	inline void UILayout::separator_spacer() {
		UILayout_separator_spacer((::uiLayout *) this->ptr.data);
	}

	inline void UILayout::context_pointer_set(const char * name, AnyType& data) {
		UILayout_context_pointer_set((::uiLayout *) this->ptr.data, name, (::PointerRNA *) data.ptr.data);
	}

	inline void UILayout::template_header(Context C) {
		UILayout_template_header((::uiLayout *) this->ptr.data, (::bContext *) C.ptr.data);
	}

	inline void UILayout::template_ID(Context C, AnyType& data, const char * property, const char * create, const char * open, const char * unlink, int filter, bool live_icon) {
		UILayout_template_ID((::uiLayout *) this->ptr.data, (::bContext *) C.ptr.data, (::PointerRNA *) data.ptr.data, property, create, open, unlink, filter, live_icon);
	}

	inline void UILayout::template_ID_preview(Context C, AnyType& data, const char * property, const char * create, const char * open, const char * unlink, int rows, int cols, int filter, bool hide_buttons) {
		UILayout_template_ID_preview((::uiLayout *) this->ptr.data, (::bContext *) C.ptr.data, (::PointerRNA *) data.ptr.data, property, create, open, unlink, rows, cols, filter, hide_buttons);
	}

	inline void UILayout::template_any_ID(AnyType& data, const char * property, const char * type_property, const char * text, const char * text_ctxt, bool translate) {
		UILayout_template_any_ID((::uiLayout *) this->ptr.data, (::PointerRNA *) data.ptr.data, property, type_property, text, text_ctxt, translate);
	}

	inline void UILayout::template_ID_tabs(Context C, AnyType& data, const char * property, const char * create, const char * menu, int filter) {
		UILayout_template_ID_tabs((::uiLayout *) this->ptr.data, (::bContext *) C.ptr.data, (::PointerRNA *) data.ptr.data, property, create, menu, filter);
	}

	inline void UILayout::template_search(Context C, AnyType& data, const char * property, AnyType& search_data, const char * search_property, const char * create, const char * unlink) {
		UILayout_template_search((::uiLayout *) this->ptr.data, (::bContext *) C.ptr.data, (::PointerRNA *) data.ptr.data, property, (::PointerRNA *) search_data.ptr.data, search_property, create, unlink);
	}

	inline void UILayout::template_search_preview(Context C, AnyType& data, const char * property, AnyType& search_data, const char * search_property, const char * create, const char * unlink, int rows, int cols) {
		UILayout_template_search_preview((::uiLayout *) this->ptr.data, (::bContext *) C.ptr.data, (::PointerRNA *) data.ptr.data, property, (::PointerRNA *) search_data.ptr.data, search_property, create, unlink, rows, cols);
	}

	inline void UILayout::template_path_builder(AnyType& data, const char * property, ID& root, const char * text, const char * text_ctxt, bool translate) {
		UILayout_template_path_builder((::uiLayout *) this->ptr.data, (::PointerRNA *) data.ptr.data, property, (::PointerRNA *) root.ptr.data, text, text_ctxt, translate);
	}

	inline UILayout UILayout::template_modifier(Context C, Modifier& data) {
		PointerRNA result;
		::uiLayout *retdata = UILayout_template_modifier((::uiLayout *) this->ptr.data, (::bContext *) C.ptr.data, (::PointerRNA *) data.ptr.data);
		RNA_pointer_create((::ID *) ptr.id.data, &RNA_UILayout, retdata, &result);
		return UILayout(result);
	}

	inline UILayout UILayout::template_greasepencil_modifier(Context C, GpencilModifier& data) {
		PointerRNA result;
		::uiLayout *retdata = UILayout_template_greasepencil_modifier((::uiLayout *) this->ptr.data, (::bContext *) C.ptr.data, (::PointerRNA *) data.ptr.data);
		RNA_pointer_create((::ID *) ptr.id.data, &RNA_UILayout, retdata, &result);
		return UILayout(result);
	}

	inline UILayout UILayout::template_shaderfx(Context C, ShaderFx& data) {
		PointerRNA result;
		::uiLayout *retdata = UILayout_template_shaderfx((::uiLayout *) this->ptr.data, (::bContext *) C.ptr.data, (::PointerRNA *) data.ptr.data);
		RNA_pointer_create((::ID *) ptr.id.data, &RNA_UILayout, retdata, &result);
		return UILayout(result);
	}

	inline void UILayout::template_greasepencil_color(Context C, AnyType& data, const char * property, int rows, int cols, float scale, int filter) {
		UILayout_template_greasepencil_color((::uiLayout *) this->ptr.data, (::bContext *) C.ptr.data, (::PointerRNA *) data.ptr.data, property, rows, cols, scale, filter);
	}

	inline UILayout UILayout::template_constraint(Constraint& data) {
		PointerRNA result;
		::uiLayout *retdata = UILayout_template_constraint((::uiLayout *) this->ptr.data, (::PointerRNA *) data.ptr.data);
		RNA_pointer_create((::ID *) ptr.id.data, &RNA_UILayout, retdata, &result);
		return UILayout(result);
	}

	inline void UILayout::template_preview(Context C, ID& id, bool show_buttons, ID& parent, TextureSlot& slot, const char * preview_id) {
		UILayout_template_preview((::uiLayout *) this->ptr.data, (::bContext *) C.ptr.data, (::ID *) id.ptr.data, show_buttons, (::ID *) parent.ptr.data, (::MTex *) slot.ptr.data, preview_id);
	}

	inline void UILayout::template_curve_mapping(AnyType& data, const char * property, int type, bool levels, bool brush, bool use_negative_slope, bool show_tone) {
		UILayout_template_curve_mapping((::uiLayout *) this->ptr.data, (::PointerRNA *) data.ptr.data, property, type, levels, brush, use_negative_slope, show_tone);
	}

	inline void UILayout::template_color_ramp(AnyType& data, const char * property, bool expand) {
		UILayout_template_color_ramp((::uiLayout *) this->ptr.data, (::PointerRNA *) data.ptr.data, property, expand);
	}

	inline void UILayout::template_icon(int icon_value, float scale) {
		UILayout_template_icon((::uiLayout *) this->ptr.data, icon_value, scale);
	}

	inline void UILayout::template_icon_view(AnyType& data, const char * property, bool show_labels, float scale, float scale_popup) {
		UILayout_template_icon_view((::uiLayout *) this->ptr.data, (::PointerRNA *) data.ptr.data, property, show_labels, scale, scale_popup);
	}

	inline void UILayout::template_histogram(AnyType& data, const char * property) {
		UILayout_template_histogram((::uiLayout *) this->ptr.data, (::PointerRNA *) data.ptr.data, property);
	}

	inline void UILayout::template_waveform(AnyType& data, const char * property) {
		UILayout_template_waveform((::uiLayout *) this->ptr.data, (::PointerRNA *) data.ptr.data, property);
	}

	inline void UILayout::template_vectorscope(AnyType& data, const char * property) {
		UILayout_template_vectorscope((::uiLayout *) this->ptr.data, (::PointerRNA *) data.ptr.data, property);
	}

	inline void UILayout::template_layers(AnyType& data, const char * property, AnyType& used_layers_data, const char * used_layers_property, int active_layer) {
		UILayout_template_layers((::uiLayout *) this->ptr.data, (::PointerRNA *) data.ptr.data, property, (::PointerRNA *) used_layers_data.ptr.data, used_layers_property, active_layer);
	}

	inline void UILayout::template_color_picker(AnyType& data, const char * property, bool value_slider, bool lock, bool lock_luminosity, bool cubic) {
		UILayout_template_color_picker((::uiLayout *) this->ptr.data, (::PointerRNA *) data.ptr.data, property, value_slider, lock, lock_luminosity, cubic);
	}

	inline void UILayout::template_palette(AnyType& data, const char * property, bool color) {
		UILayout_template_palette((::uiLayout *) this->ptr.data, (::PointerRNA *) data.ptr.data, property, color);
	}

	inline void UILayout::template_image_layers(Context C, Image& image, ImageUser& image_user) {
		UILayout_template_image_layers((::uiLayout *) this->ptr.data, (::bContext *) C.ptr.data, (::Image *) image.ptr.data, (::ImageUser *) image_user.ptr.data);
	}

	inline void UILayout::template_image(Context C, AnyType& data, const char * property, ImageUser& image_user, bool compact, bool multiview) {
		UILayout_template_image((::uiLayout *) this->ptr.data, (::bContext *) C.ptr.data, (::PointerRNA *) data.ptr.data, property, (::PointerRNA *) image_user.ptr.data, compact, multiview);
	}

	inline void UILayout::template_image_settings(ImageFormatSettings& image_settings, bool color_management) {
		UILayout_template_image_settings((::uiLayout *) this->ptr.data, (::PointerRNA *) image_settings.ptr.data, color_management);
	}

	inline void UILayout::template_image_stereo_3d(Stereo3dFormat& stereo_3d_format) {
		UILayout_template_image_stereo_3d((::uiLayout *) this->ptr.data, (::PointerRNA *) stereo_3d_format.ptr.data);
	}

	inline void UILayout::template_image_views(ImageFormatSettings& image_settings) {
		UILayout_template_image_views((::uiLayout *) this->ptr.data, (::PointerRNA *) image_settings.ptr.data);
	}

	inline void UILayout::template_movieclip(Context C, AnyType& data, const char * property, bool compact) {
		UILayout_template_movieclip((::uiLayout *) this->ptr.data, (::bContext *) C.ptr.data, (::PointerRNA *) data.ptr.data, property, compact);
	}

	inline void UILayout::template_track(AnyType& data, const char * property) {
		UILayout_template_track((::uiLayout *) this->ptr.data, (::PointerRNA *) data.ptr.data, property);
	}

	inline void UILayout::template_marker(AnyType& data, const char * property, MovieClipUser& clip_user, MovieTrackingTrack& track, bool compact) {
		UILayout_template_marker((::uiLayout *) this->ptr.data, (::PointerRNA *) data.ptr.data, property, (::PointerRNA *) clip_user.ptr.data, (::PointerRNA *) track.ptr.data, compact);
	}

	inline void UILayout::template_movieclip_information(AnyType& data, const char * property, MovieClipUser& clip_user) {
		UILayout_template_movieclip_information((::uiLayout *) this->ptr.data, (::PointerRNA *) data.ptr.data, property, (::PointerRNA *) clip_user.ptr.data);
	}

	inline void UILayout::template_list(Context C, const char * listtype_name, const char * list_id, AnyType& dataptr, const char * propname, AnyType& active_dataptr, const char * active_propname, const char * item_dyntip_propname, int rows, int maxrows, int type, int columns, bool sort_reverse, bool sort_lock) {
		UILayout_template_list((::uiLayout *) this->ptr.data, (::bContext *) C.ptr.data, listtype_name, list_id, (::PointerRNA *) dataptr.ptr.data, propname, (::PointerRNA *) active_dataptr.ptr.data, active_propname, item_dyntip_propname, rows, maxrows, type, columns, sort_reverse, sort_lock);
	}

	inline void UILayout::template_running_jobs(Context C) {
		UILayout_template_running_jobs((::uiLayout *) this->ptr.data, (::bContext *) C.ptr.data);
	}

	inline void UILayout::template_operator_search() {
		UILayout_template_operator_search((::uiLayout *) this->ptr.data);
	}

	inline void UILayout::template_header_3D_mode(Context C) {
		UILayout_template_header_3D_mode((::uiLayout *) this->ptr.data, (::bContext *) C.ptr.data);
	}

	inline void UILayout::template_edit_mode_selection(Context C) {
		UILayout_template_edit_mode_selection((::uiLayout *) this->ptr.data, (::bContext *) C.ptr.data);
	}

	inline void UILayout::template_reports_banner(Context C) {
		UILayout_template_reports_banner((::uiLayout *) this->ptr.data, (::bContext *) C.ptr.data);
	}

	inline void UILayout::template_input_status(Context C) {
		UILayout_template_input_status((::uiLayout *) this->ptr.data, (::bContext *) C.ptr.data);
	}

	inline void UILayout::template_node_link(NodeTree& ntree, Node& node, NodeSocket& socket) {
		UILayout_template_node_link((::uiLayout *) this->ptr.data, (::bNodeTree *) ntree.ptr.data, (::bNode *) node.ptr.data, (::bNodeSocket *) socket.ptr.data);
	}

	inline void UILayout::template_node_view(Context C, NodeTree& ntree, Node& node, NodeSocket& socket) {
		UILayout_template_node_view((::uiLayout *) this->ptr.data, (::bContext *) C.ptr.data, (::bNodeTree *) ntree.ptr.data, (::bNode *) node.ptr.data, (::bNodeSocket *) socket.ptr.data);
	}

	inline void UILayout::template_texture_user(Context C) {
		UILayout_template_texture_user((::uiLayout *) this->ptr.data, (::bContext *) C.ptr.data);
	}

	inline void UILayout::template_keymap_item_properties(KeyMapItem& item) {
		UILayout_template_keymap_item_properties((::uiLayout *) this->ptr.data, (::PointerRNA *) item.ptr.data);
	}

	inline void UILayout::template_component_menu(AnyType& data, const char * property, const char * name) {
		UILayout_template_component_menu((::uiLayout *) this->ptr.data, (::PointerRNA *) data.ptr.data, property, name);
	}

	inline void UILayout::template_colorspace_settings(AnyType& data, const char * property) {
		UILayout_template_colorspace_settings((::uiLayout *) this->ptr.data, (::PointerRNA *) data.ptr.data, property);
	}

	inline void UILayout::template_colormanaged_view_settings(Context C, AnyType& data, const char * property) {
		UILayout_template_colormanaged_view_settings((::uiLayout *) this->ptr.data, (::bContext *) C.ptr.data, (::PointerRNA *) data.ptr.data, property);
	}

	inline void UILayout::template_node_socket(Context C, float color[4]) {
		UILayout_template_node_socket((::uiLayout *) this->ptr.data, (::bContext *) C.ptr.data, color);
	}

	inline void UILayout::template_cache_file(Context C, AnyType& data, const char * property) {
		UILayout_template_cache_file((::uiLayout *) this->ptr.data, (::bContext *) C.ptr.data, (::PointerRNA *) data.ptr.data, property);
	}

	inline int UILayout::template_recent_files(int rows) {
		return UILayout_template_recent_files((::uiLayout *) this->ptr.data, rows);
	}


	POINTER_PROPERTY(Struct, Panel, rna_type)
	POINTER_PROPERTY(UILayout, Panel, layout)
	STRING_PROPERTY(Panel, text)
	STRING_PROPERTY(Panel, bl_idname)
	STRING_PROPERTY(Panel, bl_label)
	STRING_PROPERTY(Panel, bl_translation_context)
	STRING_PROPERTY(Panel, bl_category)
	STRING_PROPERTY(Panel, bl_owner_id)
	ENUM_PROPERTY(bl_space_type_enum, Panel, bl_space_type)
	ENUM_PROPERTY(bl_region_type_enum, Panel, bl_region_type)
	STRING_PROPERTY(Panel, bl_context)
	ENUM_PROPERTY(bl_options_enum, Panel, bl_options)
	STRING_PROPERTY(Panel, bl_parent_id)
	INT_PROPERTY(Panel, bl_ui_units_x)
	BOOLEAN_PROPERTY(Panel, use_pin)
	BOOLEAN_PROPERTY(Panel, is_popover)


	POINTER_PROPERTY(Struct, UIList, rna_type)
	STRING_PROPERTY(UIList, bl_idname)
	ENUM_PROPERTY(layout_type_enum, UIList, layout_type)
	BOOLEAN_PROPERTY(UIList, use_filter_show)
	STRING_PROPERTY(UIList, filter_name)
	BOOLEAN_PROPERTY(UIList, use_filter_invert)
	BOOLEAN_PROPERTY(UIList, use_filter_sort_alpha)
	BOOLEAN_PROPERTY(UIList, use_filter_sort_reverse)
	BOOLEAN_PROPERTY(UIList, use_filter_sort_lock)
	INT_PROPERTY(UIList, bitflag_filter_item)


	POINTER_PROPERTY(Struct, Header, rna_type)
	POINTER_PROPERTY(UILayout, Header, layout)
	STRING_PROPERTY(Header, bl_idname)
	ENUM_PROPERTY(bl_space_type_enum, Header, bl_space_type)
	ENUM_PROPERTY(bl_region_type_enum, Header, bl_region_type)


	POINTER_PROPERTY(Struct, Menu, rna_type)
	POINTER_PROPERTY(UILayout, Menu, layout)
	STRING_PROPERTY(Menu, bl_idname)
	STRING_PROPERTY(Menu, bl_label)
	STRING_PROPERTY(Menu, bl_translation_context)
	STRING_PROPERTY(Menu, bl_description)
	STRING_PROPERTY(Menu, bl_owner_id)


	POINTER_PROPERTY(Struct, ThemeFontStyle, rna_type)
	INT_PROPERTY(ThemeFontStyle, points)
	ENUM_PROPERTY(font_kerning_style_enum, ThemeFontStyle, font_kerning_style)
	INT_PROPERTY(ThemeFontStyle, shadow)
	INT_PROPERTY(ThemeFontStyle, shadow_offset_x)
	INT_PROPERTY(ThemeFontStyle, shadow_offset_y)
	FLOAT_PROPERTY(ThemeFontStyle, shadow_alpha)
	FLOAT_PROPERTY(ThemeFontStyle, shadow_value)


	POINTER_PROPERTY(Struct, ThemeStyle, rna_type)
	POINTER_PROPERTY(ThemeFontStyle, ThemeStyle, panel_title)
	POINTER_PROPERTY(ThemeFontStyle, ThemeStyle, widget_label)
	POINTER_PROPERTY(ThemeFontStyle, ThemeStyle, widget)


	POINTER_PROPERTY(Struct, ThemeWidgetColors, rna_type)
	FLOAT_ARRAY_PROPERTY(ThemeWidgetColors, 3, outline)
	FLOAT_ARRAY_PROPERTY(ThemeWidgetColors, 4, inner)
	FLOAT_ARRAY_PROPERTY(ThemeWidgetColors, 4, inner_sel)
	FLOAT_ARRAY_PROPERTY(ThemeWidgetColors, 4, item)
	FLOAT_ARRAY_PROPERTY(ThemeWidgetColors, 3, text)
	FLOAT_ARRAY_PROPERTY(ThemeWidgetColors, 3, text_sel)
	BOOLEAN_PROPERTY(ThemeWidgetColors, show_shaded)
	INT_PROPERTY(ThemeWidgetColors, shadetop)
	INT_PROPERTY(ThemeWidgetColors, shadedown)
	FLOAT_PROPERTY(ThemeWidgetColors, roundness)


	POINTER_PROPERTY(Struct, ThemeWidgetStateColors, rna_type)
	FLOAT_ARRAY_PROPERTY(ThemeWidgetStateColors, 3, inner_anim)
	FLOAT_ARRAY_PROPERTY(ThemeWidgetStateColors, 3, inner_anim_sel)
	FLOAT_ARRAY_PROPERTY(ThemeWidgetStateColors, 3, inner_key)
	FLOAT_ARRAY_PROPERTY(ThemeWidgetStateColors, 3, inner_key_sel)
	FLOAT_ARRAY_PROPERTY(ThemeWidgetStateColors, 3, inner_driven)
	FLOAT_ARRAY_PROPERTY(ThemeWidgetStateColors, 3, inner_driven_sel)
	FLOAT_ARRAY_PROPERTY(ThemeWidgetStateColors, 3, inner_overridden)
	FLOAT_ARRAY_PROPERTY(ThemeWidgetStateColors, 3, inner_overridden_sel)
	FLOAT_ARRAY_PROPERTY(ThemeWidgetStateColors, 3, inner_changed)
	FLOAT_ARRAY_PROPERTY(ThemeWidgetStateColors, 3, inner_changed_sel)
	FLOAT_PROPERTY(ThemeWidgetStateColors, blend)


	POINTER_PROPERTY(Struct, ThemePanelColors, rna_type)
	FLOAT_ARRAY_PROPERTY(ThemePanelColors, 4, header)
	FLOAT_ARRAY_PROPERTY(ThemePanelColors, 4, back)
	FLOAT_ARRAY_PROPERTY(ThemePanelColors, 4, sub_back)


	POINTER_PROPERTY(Struct, ThemeGradientColors, rna_type)
	BOOLEAN_PROPERTY(ThemeGradientColors, show_grad)
	FLOAT_ARRAY_PROPERTY(ThemeGradientColors, 3, high_gradient)
	FLOAT_ARRAY_PROPERTY(ThemeGradientColors, 3, gradient)


	POINTER_PROPERTY(Struct, ThemeUserInterface, rna_type)
	POINTER_PROPERTY(ThemeWidgetColors, ThemeUserInterface, wcol_regular)
	POINTER_PROPERTY(ThemeWidgetColors, ThemeUserInterface, wcol_tool)
	POINTER_PROPERTY(ThemeWidgetColors, ThemeUserInterface, wcol_toolbar_item)
	POINTER_PROPERTY(ThemeWidgetColors, ThemeUserInterface, wcol_radio)
	POINTER_PROPERTY(ThemeWidgetColors, ThemeUserInterface, wcol_text)
	POINTER_PROPERTY(ThemeWidgetColors, ThemeUserInterface, wcol_option)
	POINTER_PROPERTY(ThemeWidgetColors, ThemeUserInterface, wcol_toggle)
	POINTER_PROPERTY(ThemeWidgetColors, ThemeUserInterface, wcol_num)
	POINTER_PROPERTY(ThemeWidgetColors, ThemeUserInterface, wcol_numslider)
	POINTER_PROPERTY(ThemeWidgetColors, ThemeUserInterface, wcol_box)
	POINTER_PROPERTY(ThemeWidgetColors, ThemeUserInterface, wcol_menu)
	POINTER_PROPERTY(ThemeWidgetColors, ThemeUserInterface, wcol_pulldown)
	POINTER_PROPERTY(ThemeWidgetColors, ThemeUserInterface, wcol_menu_back)
	POINTER_PROPERTY(ThemeWidgetColors, ThemeUserInterface, wcol_pie_menu)
	POINTER_PROPERTY(ThemeWidgetColors, ThemeUserInterface, wcol_tooltip)
	POINTER_PROPERTY(ThemeWidgetColors, ThemeUserInterface, wcol_menu_item)
	POINTER_PROPERTY(ThemeWidgetColors, ThemeUserInterface, wcol_scroll)
	POINTER_PROPERTY(ThemeWidgetColors, ThemeUserInterface, wcol_progress)
	POINTER_PROPERTY(ThemeWidgetColors, ThemeUserInterface, wcol_list_item)
	POINTER_PROPERTY(ThemeWidgetStateColors, ThemeUserInterface, wcol_state)
	POINTER_PROPERTY(ThemeWidgetColors, ThemeUserInterface, wcol_tab)
	FLOAT_PROPERTY(ThemeUserInterface, menu_shadow_fac)
	INT_PROPERTY(ThemeUserInterface, menu_shadow_width)
	FLOAT_PROPERTY(ThemeUserInterface, icon_alpha)
	FLOAT_PROPERTY(ThemeUserInterface, icon_saturation)
	FLOAT_ARRAY_PROPERTY(ThemeUserInterface, 4, widget_emboss)
	FLOAT_ARRAY_PROPERTY(ThemeUserInterface, 3, editor_outline)
	FLOAT_ARRAY_PROPERTY(ThemeUserInterface, 3, axis_x)
	FLOAT_ARRAY_PROPERTY(ThemeUserInterface, 3, axis_y)
	FLOAT_ARRAY_PROPERTY(ThemeUserInterface, 3, axis_z)
	FLOAT_ARRAY_PROPERTY(ThemeUserInterface, 3, gizmo_hi)
	FLOAT_ARRAY_PROPERTY(ThemeUserInterface, 3, gizmo_primary)
	FLOAT_ARRAY_PROPERTY(ThemeUserInterface, 3, gizmo_secondary)
	FLOAT_ARRAY_PROPERTY(ThemeUserInterface, 3, gizmo_a)
	FLOAT_ARRAY_PROPERTY(ThemeUserInterface, 3, gizmo_b)
	FLOAT_ARRAY_PROPERTY(ThemeUserInterface, 4, icon_collection)
	FLOAT_ARRAY_PROPERTY(ThemeUserInterface, 4, icon_object)
	FLOAT_ARRAY_PROPERTY(ThemeUserInterface, 4, icon_object_data)
	FLOAT_ARRAY_PROPERTY(ThemeUserInterface, 4, icon_modifier)
	FLOAT_ARRAY_PROPERTY(ThemeUserInterface, 4, icon_shading)


	POINTER_PROPERTY(Struct, ThemeSpaceGeneric, rna_type)
	FLOAT_ARRAY_PROPERTY(ThemeSpaceGeneric, 3, back)
	FLOAT_ARRAY_PROPERTY(ThemeSpaceGeneric, 3, title)
	FLOAT_ARRAY_PROPERTY(ThemeSpaceGeneric, 3, text)
	FLOAT_ARRAY_PROPERTY(ThemeSpaceGeneric, 3, text_hi)
	FLOAT_ARRAY_PROPERTY(ThemeSpaceGeneric, 4, header)
	FLOAT_ARRAY_PROPERTY(ThemeSpaceGeneric, 3, header_text)
	FLOAT_ARRAY_PROPERTY(ThemeSpaceGeneric, 3, header_text_hi)
	POINTER_PROPERTY(ThemePanelColors, ThemeSpaceGeneric, panelcolors)
	FLOAT_ARRAY_PROPERTY(ThemeSpaceGeneric, 4, button)
	FLOAT_ARRAY_PROPERTY(ThemeSpaceGeneric, 3, button_title)
	FLOAT_ARRAY_PROPERTY(ThemeSpaceGeneric, 3, button_text)
	FLOAT_ARRAY_PROPERTY(ThemeSpaceGeneric, 3, button_text_hi)
	FLOAT_ARRAY_PROPERTY(ThemeSpaceGeneric, 4, navigation_bar)
	FLOAT_ARRAY_PROPERTY(ThemeSpaceGeneric, 4, execution_buts)
	FLOAT_ARRAY_PROPERTY(ThemeSpaceGeneric, 3, tab_active)
	FLOAT_ARRAY_PROPERTY(ThemeSpaceGeneric, 3, tab_inactive)
	FLOAT_ARRAY_PROPERTY(ThemeSpaceGeneric, 4, tab_back)
	FLOAT_ARRAY_PROPERTY(ThemeSpaceGeneric, 3, tab_outline)


	POINTER_PROPERTY(Struct, ThemeSpaceGradient, rna_type)
	POINTER_PROPERTY(ThemeGradientColors, ThemeSpaceGradient, gradients)
	FLOAT_ARRAY_PROPERTY(ThemeSpaceGradient, 3, title)
	FLOAT_ARRAY_PROPERTY(ThemeSpaceGradient, 3, text)
	FLOAT_ARRAY_PROPERTY(ThemeSpaceGradient, 3, text_hi)
	FLOAT_ARRAY_PROPERTY(ThemeSpaceGradient, 4, header)
	FLOAT_ARRAY_PROPERTY(ThemeSpaceGradient, 3, header_text)
	FLOAT_ARRAY_PROPERTY(ThemeSpaceGradient, 3, header_text_hi)
	POINTER_PROPERTY(ThemePanelColors, ThemeSpaceGradient, panelcolors)
	FLOAT_ARRAY_PROPERTY(ThemeSpaceGradient, 4, button)
	FLOAT_ARRAY_PROPERTY(ThemeSpaceGradient, 3, button_title)
	FLOAT_ARRAY_PROPERTY(ThemeSpaceGradient, 3, button_text)
	FLOAT_ARRAY_PROPERTY(ThemeSpaceGradient, 3, button_text_hi)
	FLOAT_ARRAY_PROPERTY(ThemeSpaceGradient, 4, navigation_bar)
	FLOAT_ARRAY_PROPERTY(ThemeSpaceGradient, 4, execution_buts)
	FLOAT_ARRAY_PROPERTY(ThemeSpaceGradient, 3, tab_active)
	FLOAT_ARRAY_PROPERTY(ThemeSpaceGradient, 3, tab_inactive)
	FLOAT_ARRAY_PROPERTY(ThemeSpaceGradient, 4, tab_back)
	FLOAT_ARRAY_PROPERTY(ThemeSpaceGradient, 3, tab_outline)


	POINTER_PROPERTY(Struct, ThemeSpaceListGeneric, rna_type)
	FLOAT_ARRAY_PROPERTY(ThemeSpaceListGeneric, 3, list)
	FLOAT_ARRAY_PROPERTY(ThemeSpaceListGeneric, 3, list_title)
	FLOAT_ARRAY_PROPERTY(ThemeSpaceListGeneric, 3, list_text)
	FLOAT_ARRAY_PROPERTY(ThemeSpaceListGeneric, 3, list_text_hi)


	POINTER_PROPERTY(Struct, ThemeView3D, rna_type)
	POINTER_PROPERTY(ThemeSpaceGradient, ThemeView3D, space)
	FLOAT_ARRAY_PROPERTY(ThemeView3D, 4, grid)
	FLOAT_ARRAY_PROPERTY(ThemeView3D, 4, clipping_border_3d)
	FLOAT_ARRAY_PROPERTY(ThemeView3D, 3, wire)
	FLOAT_ARRAY_PROPERTY(ThemeView3D, 3, wire_edit)
	FLOAT_ARRAY_PROPERTY(ThemeView3D, 3, gp_vertex)
	FLOAT_ARRAY_PROPERTY(ThemeView3D, 3, gp_vertex_select)
	INT_PROPERTY(ThemeView3D, gp_vertex_size)
	FLOAT_ARRAY_PROPERTY(ThemeView3D, 3, text_grease_pencil)
	FLOAT_ARRAY_PROPERTY(ThemeView3D, 3, object_selected)
	FLOAT_ARRAY_PROPERTY(ThemeView3D, 3, object_active)
	FLOAT_ARRAY_PROPERTY(ThemeView3D, 3, text_keyframe)
	FLOAT_ARRAY_PROPERTY(ThemeView3D, 3, camera)
	FLOAT_ARRAY_PROPERTY(ThemeView3D, 3, empty)
	FLOAT_ARRAY_PROPERTY(ThemeView3D, 4, light)
	FLOAT_ARRAY_PROPERTY(ThemeView3D, 3, speaker)
	FLOAT_ARRAY_PROPERTY(ThemeView3D, 3, vertex)
	FLOAT_ARRAY_PROPERTY(ThemeView3D, 3, vertex_select)
	INT_PROPERTY(ThemeView3D, vertex_size)
	FLOAT_ARRAY_PROPERTY(ThemeView3D, 3, vertex_bevel)
	FLOAT_ARRAY_PROPERTY(ThemeView3D, 3, vertex_unreferenced)
	FLOAT_ARRAY_PROPERTY(ThemeView3D, 3, edge_select)
	FLOAT_ARRAY_PROPERTY(ThemeView3D, 3, edge_seam)
	FLOAT_ARRAY_PROPERTY(ThemeView3D, 3, edge_sharp)
	FLOAT_ARRAY_PROPERTY(ThemeView3D, 3, edge_crease)
	FLOAT_ARRAY_PROPERTY(ThemeView3D, 3, edge_bevel)
	FLOAT_ARRAY_PROPERTY(ThemeView3D, 3, edge_facesel)
	FLOAT_ARRAY_PROPERTY(ThemeView3D, 3, freestyle_edge_mark)
	FLOAT_ARRAY_PROPERTY(ThemeView3D, 4, face)
	FLOAT_ARRAY_PROPERTY(ThemeView3D, 4, face_select)
	FLOAT_ARRAY_PROPERTY(ThemeView3D, 3, face_dot)
	INT_PROPERTY(ThemeView3D, facedot_size)
	FLOAT_ARRAY_PROPERTY(ThemeView3D, 4, freestyle_face_mark)
	FLOAT_ARRAY_PROPERTY(ThemeView3D, 3, nurb_uline)
	FLOAT_ARRAY_PROPERTY(ThemeView3D, 3, nurb_vline)
	FLOAT_ARRAY_PROPERTY(ThemeView3D, 3, nurb_sel_uline)
	FLOAT_ARRAY_PROPERTY(ThemeView3D, 3, nurb_sel_vline)
	FLOAT_ARRAY_PROPERTY(ThemeView3D, 3, act_spline)
	FLOAT_ARRAY_PROPERTY(ThemeView3D, 3, handle_free)
	FLOAT_ARRAY_PROPERTY(ThemeView3D, 3, handle_auto)
	FLOAT_ARRAY_PROPERTY(ThemeView3D, 3, handle_vect)
	FLOAT_ARRAY_PROPERTY(ThemeView3D, 3, handle_sel_vect)
	FLOAT_ARRAY_PROPERTY(ThemeView3D, 3, handle_align)
	FLOAT_ARRAY_PROPERTY(ThemeView3D, 3, handle_sel_free)
	FLOAT_ARRAY_PROPERTY(ThemeView3D, 3, handle_sel_auto)
	FLOAT_ARRAY_PROPERTY(ThemeView3D, 3, handle_sel_align)
	FLOAT_ARRAY_PROPERTY(ThemeView3D, 3, lastsel_point)
	FLOAT_ARRAY_PROPERTY(ThemeView3D, 3, extra_edge_len)
	FLOAT_ARRAY_PROPERTY(ThemeView3D, 3, extra_edge_angle)
	FLOAT_ARRAY_PROPERTY(ThemeView3D, 3, extra_face_angle)
	FLOAT_ARRAY_PROPERTY(ThemeView3D, 3, extra_face_area)
	FLOAT_ARRAY_PROPERTY(ThemeView3D, 4, editmesh_active)
	FLOAT_ARRAY_PROPERTY(ThemeView3D, 3, normal)
	FLOAT_ARRAY_PROPERTY(ThemeView3D, 3, vertex_normal)
	FLOAT_ARRAY_PROPERTY(ThemeView3D, 3, split_normal)
	FLOAT_ARRAY_PROPERTY(ThemeView3D, 3, bone_pose)
	FLOAT_ARRAY_PROPERTY(ThemeView3D, 3, bone_pose_active)
	FLOAT_ARRAY_PROPERTY(ThemeView3D, 3, bone_solid)
	FLOAT_ARRAY_PROPERTY(ThemeView3D, 3, bundle_solid)
	FLOAT_ARRAY_PROPERTY(ThemeView3D, 3, camera_path)
	FLOAT_ARRAY_PROPERTY(ThemeView3D, 3, skin_root)
	FLOAT_ARRAY_PROPERTY(ThemeView3D, 3, view_overlay)
	FLOAT_ARRAY_PROPERTY(ThemeView3D, 3, transform)
	FLOAT_ARRAY_PROPERTY(ThemeView3D, 3, frame_current)
	FLOAT_ARRAY_PROPERTY(ThemeView3D, 4, paint_curve_handle)
	FLOAT_ARRAY_PROPERTY(ThemeView3D, 4, paint_curve_pivot)
	INT_PROPERTY(ThemeView3D, outline_width)


	POINTER_PROPERTY(Struct, ThemeGraphEditor, rna_type)
	POINTER_PROPERTY(ThemeSpaceGeneric, ThemeGraphEditor, space)
	POINTER_PROPERTY(ThemeSpaceListGeneric, ThemeGraphEditor, space_list)
	FLOAT_ARRAY_PROPERTY(ThemeGraphEditor, 3, grid)
	FLOAT_ARRAY_PROPERTY(ThemeGraphEditor, 3, frame_current)
	FLOAT_ARRAY_PROPERTY(ThemeGraphEditor, 3, window_sliders)
	FLOAT_ARRAY_PROPERTY(ThemeGraphEditor, 3, channels_region)
	FLOAT_ARRAY_PROPERTY(ThemeGraphEditor, 3, dopesheet_channel)
	FLOAT_ARRAY_PROPERTY(ThemeGraphEditor, 3, dopesheet_subchannel)
	FLOAT_ARRAY_PROPERTY(ThemeGraphEditor, 3, channel_group)
	FLOAT_ARRAY_PROPERTY(ThemeGraphEditor, 3, active_channels_group)
	FLOAT_ARRAY_PROPERTY(ThemeGraphEditor, 4, preview_range)
	FLOAT_ARRAY_PROPERTY(ThemeGraphEditor, 3, vertex)
	FLOAT_ARRAY_PROPERTY(ThemeGraphEditor, 3, vertex_select)
	INT_PROPERTY(ThemeGraphEditor, vertex_size)
	FLOAT_ARRAY_PROPERTY(ThemeGraphEditor, 3, vertex_bevel)
	FLOAT_ARRAY_PROPERTY(ThemeGraphEditor, 3, vertex_unreferenced)
	FLOAT_ARRAY_PROPERTY(ThemeGraphEditor, 3, handle_free)
	FLOAT_ARRAY_PROPERTY(ThemeGraphEditor, 3, handle_auto)
	FLOAT_ARRAY_PROPERTY(ThemeGraphEditor, 3, handle_vect)
	FLOAT_ARRAY_PROPERTY(ThemeGraphEditor, 3, handle_sel_vect)
	FLOAT_ARRAY_PROPERTY(ThemeGraphEditor, 3, handle_align)
	FLOAT_ARRAY_PROPERTY(ThemeGraphEditor, 3, handle_sel_free)
	FLOAT_ARRAY_PROPERTY(ThemeGraphEditor, 3, handle_sel_auto)
	FLOAT_ARRAY_PROPERTY(ThemeGraphEditor, 3, handle_sel_align)
	FLOAT_ARRAY_PROPERTY(ThemeGraphEditor, 3, handle_auto_clamped)
	FLOAT_ARRAY_PROPERTY(ThemeGraphEditor, 3, handle_sel_auto_clamped)
	FLOAT_ARRAY_PROPERTY(ThemeGraphEditor, 3, lastsel_point)
	FLOAT_ARRAY_PROPERTY(ThemeGraphEditor, 3, handle_vertex)
	FLOAT_ARRAY_PROPERTY(ThemeGraphEditor, 3, handle_vertex_select)
	INT_PROPERTY(ThemeGraphEditor, handle_vertex_size)


	POINTER_PROPERTY(Struct, ThemeFileBrowser, rna_type)
	POINTER_PROPERTY(ThemeSpaceGeneric, ThemeFileBrowser, space)
	FLOAT_ARRAY_PROPERTY(ThemeFileBrowser, 3, selected_file)


	POINTER_PROPERTY(Struct, ThemeNLAEditor, rna_type)
	POINTER_PROPERTY(ThemeSpaceGeneric, ThemeNLAEditor, space)
	POINTER_PROPERTY(ThemeSpaceListGeneric, ThemeNLAEditor, space_list)
	FLOAT_ARRAY_PROPERTY(ThemeNLAEditor, 3, grid)
	FLOAT_ARRAY_PROPERTY(ThemeNLAEditor, 3, view_sliders)
	FLOAT_ARRAY_PROPERTY(ThemeNLAEditor, 4, active_action)
	FLOAT_ARRAY_PROPERTY(ThemeNLAEditor, 4, active_action_unset)
	FLOAT_ARRAY_PROPERTY(ThemeNLAEditor, 4, preview_range)
	FLOAT_ARRAY_PROPERTY(ThemeNLAEditor, 3, strips)
	FLOAT_ARRAY_PROPERTY(ThemeNLAEditor, 3, strips_selected)
	FLOAT_ARRAY_PROPERTY(ThemeNLAEditor, 3, transition_strips)
	FLOAT_ARRAY_PROPERTY(ThemeNLAEditor, 3, transition_strips_selected)
	FLOAT_ARRAY_PROPERTY(ThemeNLAEditor, 3, meta_strips)
	FLOAT_ARRAY_PROPERTY(ThemeNLAEditor, 3, meta_strips_selected)
	FLOAT_ARRAY_PROPERTY(ThemeNLAEditor, 3, sound_strips)
	FLOAT_ARRAY_PROPERTY(ThemeNLAEditor, 3, sound_strips_selected)
	FLOAT_ARRAY_PROPERTY(ThemeNLAEditor, 3, tweak)
	FLOAT_ARRAY_PROPERTY(ThemeNLAEditor, 3, tweak_duplicate)
	FLOAT_ARRAY_PROPERTY(ThemeNLAEditor, 4, keyframe_border)
	FLOAT_ARRAY_PROPERTY(ThemeNLAEditor, 4, keyframe_border_selected)
	FLOAT_ARRAY_PROPERTY(ThemeNLAEditor, 3, frame_current)


	POINTER_PROPERTY(Struct, ThemeDopeSheet, rna_type)
	POINTER_PROPERTY(ThemeSpaceGeneric, ThemeDopeSheet, space)
	POINTER_PROPERTY(ThemeSpaceListGeneric, ThemeDopeSheet, space_list)
	FLOAT_ARRAY_PROPERTY(ThemeDopeSheet, 3, grid)
	FLOAT_ARRAY_PROPERTY(ThemeDopeSheet, 3, frame_current)
	FLOAT_ARRAY_PROPERTY(ThemeDopeSheet, 3, value_sliders)
	FLOAT_ARRAY_PROPERTY(ThemeDopeSheet, 3, view_sliders)
	FLOAT_ARRAY_PROPERTY(ThemeDopeSheet, 4, dopesheet_channel)
	FLOAT_ARRAY_PROPERTY(ThemeDopeSheet, 4, dopesheet_subchannel)
	FLOAT_ARRAY_PROPERTY(ThemeDopeSheet, 4, channels)
	FLOAT_ARRAY_PROPERTY(ThemeDopeSheet, 4, channels_selected)
	FLOAT_ARRAY_PROPERTY(ThemeDopeSheet, 4, channel_group)
	FLOAT_ARRAY_PROPERTY(ThemeDopeSheet, 4, active_channels_group)
	FLOAT_ARRAY_PROPERTY(ThemeDopeSheet, 4, long_key)
	FLOAT_ARRAY_PROPERTY(ThemeDopeSheet, 4, long_key_selected)
	FLOAT_ARRAY_PROPERTY(ThemeDopeSheet, 3, keyframe)
	FLOAT_ARRAY_PROPERTY(ThemeDopeSheet, 3, keyframe_selected)
	FLOAT_ARRAY_PROPERTY(ThemeDopeSheet, 3, keyframe_extreme)
	FLOAT_ARRAY_PROPERTY(ThemeDopeSheet, 3, keyframe_extreme_selected)
	FLOAT_ARRAY_PROPERTY(ThemeDopeSheet, 3, keyframe_breakdown)
	FLOAT_ARRAY_PROPERTY(ThemeDopeSheet, 3, keyframe_breakdown_selected)
	FLOAT_ARRAY_PROPERTY(ThemeDopeSheet, 3, keyframe_jitter)
	FLOAT_ARRAY_PROPERTY(ThemeDopeSheet, 3, keyframe_jitter_selected)
	FLOAT_ARRAY_PROPERTY(ThemeDopeSheet, 3, keyframe_movehold)
	FLOAT_ARRAY_PROPERTY(ThemeDopeSheet, 3, keyframe_movehold_selected)
	FLOAT_ARRAY_PROPERTY(ThemeDopeSheet, 4, keyframe_border)
	FLOAT_ARRAY_PROPERTY(ThemeDopeSheet, 4, keyframe_border_selected)
	FLOAT_PROPERTY(ThemeDopeSheet, keyframe_scale_factor)
	FLOAT_ARRAY_PROPERTY(ThemeDopeSheet, 4, summary)
	FLOAT_ARRAY_PROPERTY(ThemeDopeSheet, 4, preview_range)
	FLOAT_ARRAY_PROPERTY(ThemeDopeSheet, 4, interpolation_line)


	POINTER_PROPERTY(Struct, ThemeImageEditor, rna_type)
	POINTER_PROPERTY(ThemeSpaceGeneric, ThemeImageEditor, space)
	FLOAT_ARRAY_PROPERTY(ThemeImageEditor, 3, gp_vertex)
	FLOAT_ARRAY_PROPERTY(ThemeImageEditor, 3, gp_vertex_select)
	INT_PROPERTY(ThemeImageEditor, gp_vertex_size)
	FLOAT_ARRAY_PROPERTY(ThemeImageEditor, 3, vertex)
	FLOAT_ARRAY_PROPERTY(ThemeImageEditor, 3, vertex_select)
	INT_PROPERTY(ThemeImageEditor, vertex_size)
	FLOAT_ARRAY_PROPERTY(ThemeImageEditor, 3, vertex_bevel)
	FLOAT_ARRAY_PROPERTY(ThemeImageEditor, 3, vertex_unreferenced)
	FLOAT_ARRAY_PROPERTY(ThemeImageEditor, 4, face)
	FLOAT_ARRAY_PROPERTY(ThemeImageEditor, 4, face_select)
	FLOAT_ARRAY_PROPERTY(ThemeImageEditor, 3, face_dot)
	INT_PROPERTY(ThemeImageEditor, facedot_size)
	FLOAT_ARRAY_PROPERTY(ThemeImageEditor, 4, freestyle_face_mark)
	FLOAT_ARRAY_PROPERTY(ThemeImageEditor, 4, editmesh_active)
	FLOAT_ARRAY_PROPERTY(ThemeImageEditor, 3, wire_edit)
	FLOAT_ARRAY_PROPERTY(ThemeImageEditor, 3, edge_select)
	FLOAT_ARRAY_PROPERTY(ThemeImageEditor, 4, scope_back)
	FLOAT_ARRAY_PROPERTY(ThemeImageEditor, 4, preview_stitch_face)
	FLOAT_ARRAY_PROPERTY(ThemeImageEditor, 4, preview_stitch_edge)
	FLOAT_ARRAY_PROPERTY(ThemeImageEditor, 4, preview_stitch_vert)
	FLOAT_ARRAY_PROPERTY(ThemeImageEditor, 4, preview_stitch_stitchable)
	FLOAT_ARRAY_PROPERTY(ThemeImageEditor, 4, preview_stitch_unstitchable)
	FLOAT_ARRAY_PROPERTY(ThemeImageEditor, 4, preview_stitch_active)
	FLOAT_ARRAY_PROPERTY(ThemeImageEditor, 4, uv_shadow)
	FLOAT_ARRAY_PROPERTY(ThemeImageEditor, 4, uv_others)
	FLOAT_ARRAY_PROPERTY(ThemeImageEditor, 3, frame_current)
	FLOAT_ARRAY_PROPERTY(ThemeImageEditor, 3, metadatabg)
	FLOAT_ARRAY_PROPERTY(ThemeImageEditor, 3, metadatatext)
	FLOAT_ARRAY_PROPERTY(ThemeImageEditor, 3, handle_free)
	FLOAT_ARRAY_PROPERTY(ThemeImageEditor, 3, handle_auto)
	FLOAT_ARRAY_PROPERTY(ThemeImageEditor, 3, handle_align)
	FLOAT_ARRAY_PROPERTY(ThemeImageEditor, 3, handle_sel_free)
	FLOAT_ARRAY_PROPERTY(ThemeImageEditor, 3, handle_sel_auto)
	FLOAT_ARRAY_PROPERTY(ThemeImageEditor, 3, handle_sel_align)
	FLOAT_ARRAY_PROPERTY(ThemeImageEditor, 3, handle_auto_clamped)
	FLOAT_ARRAY_PROPERTY(ThemeImageEditor, 3, handle_sel_auto_clamped)
	FLOAT_ARRAY_PROPERTY(ThemeImageEditor, 3, handle_vertex)
	FLOAT_ARRAY_PROPERTY(ThemeImageEditor, 3, handle_vertex_select)
	INT_PROPERTY(ThemeImageEditor, handle_vertex_size)
	FLOAT_ARRAY_PROPERTY(ThemeImageEditor, 4, paint_curve_handle)
	FLOAT_ARRAY_PROPERTY(ThemeImageEditor, 4, paint_curve_pivot)


	POINTER_PROPERTY(Struct, ThemeSequenceEditor, rna_type)
	POINTER_PROPERTY(ThemeSpaceGeneric, ThemeSequenceEditor, space)
	FLOAT_ARRAY_PROPERTY(ThemeSequenceEditor, 3, gp_vertex)
	FLOAT_ARRAY_PROPERTY(ThemeSequenceEditor, 3, gp_vertex_select)
	INT_PROPERTY(ThemeSequenceEditor, gp_vertex_size)
	FLOAT_ARRAY_PROPERTY(ThemeSequenceEditor, 3, grid)
	FLOAT_ARRAY_PROPERTY(ThemeSequenceEditor, 3, window_sliders)
	FLOAT_ARRAY_PROPERTY(ThemeSequenceEditor, 3, movie_strip)
	FLOAT_ARRAY_PROPERTY(ThemeSequenceEditor, 3, movieclip_strip)
	FLOAT_ARRAY_PROPERTY(ThemeSequenceEditor, 3, image_strip)
	FLOAT_ARRAY_PROPERTY(ThemeSequenceEditor, 3, scene_strip)
	FLOAT_ARRAY_PROPERTY(ThemeSequenceEditor, 3, audio_strip)
	FLOAT_ARRAY_PROPERTY(ThemeSequenceEditor, 3, effect_strip)
	FLOAT_ARRAY_PROPERTY(ThemeSequenceEditor, 3, transition_strip)
	FLOAT_ARRAY_PROPERTY(ThemeSequenceEditor, 3, meta_strip)
	FLOAT_ARRAY_PROPERTY(ThemeSequenceEditor, 3, text_strip)
	FLOAT_ARRAY_PROPERTY(ThemeSequenceEditor, 3, frame_current)
	FLOAT_ARRAY_PROPERTY(ThemeSequenceEditor, 3, keyframe)
	FLOAT_ARRAY_PROPERTY(ThemeSequenceEditor, 3, draw_action)
	FLOAT_ARRAY_PROPERTY(ThemeSequenceEditor, 3, preview_back)
	FLOAT_ARRAY_PROPERTY(ThemeSequenceEditor, 3, metadatabg)
	FLOAT_ARRAY_PROPERTY(ThemeSequenceEditor, 3, metadatatext)


	POINTER_PROPERTY(Struct, ThemeProperties, rna_type)
	POINTER_PROPERTY(ThemeSpaceGeneric, ThemeProperties, space)


	POINTER_PROPERTY(Struct, ThemeTextEditor, rna_type)
	POINTER_PROPERTY(ThemeSpaceGeneric, ThemeTextEditor, space)
	FLOAT_ARRAY_PROPERTY(ThemeTextEditor, 3, line_numbers_background)
	FLOAT_ARRAY_PROPERTY(ThemeTextEditor, 3, selected_text)
	FLOAT_ARRAY_PROPERTY(ThemeTextEditor, 3, cursor)
	FLOAT_ARRAY_PROPERTY(ThemeTextEditor, 3, syntax_builtin)
	FLOAT_ARRAY_PROPERTY(ThemeTextEditor, 3, syntax_symbols)
	FLOAT_ARRAY_PROPERTY(ThemeTextEditor, 3, syntax_special)
	FLOAT_ARRAY_PROPERTY(ThemeTextEditor, 3, syntax_preprocessor)
	FLOAT_ARRAY_PROPERTY(ThemeTextEditor, 3, syntax_reserved)
	FLOAT_ARRAY_PROPERTY(ThemeTextEditor, 3, syntax_comment)
	FLOAT_ARRAY_PROPERTY(ThemeTextEditor, 3, syntax_string)
	FLOAT_ARRAY_PROPERTY(ThemeTextEditor, 3, syntax_numbers)


	POINTER_PROPERTY(Struct, ThemeNodeEditor, rna_type)
	POINTER_PROPERTY(ThemeSpaceGeneric, ThemeNodeEditor, space)
	POINTER_PROPERTY(ThemeSpaceListGeneric, ThemeNodeEditor, space_list)
	FLOAT_ARRAY_PROPERTY(ThemeNodeEditor, 3, gp_vertex)
	FLOAT_ARRAY_PROPERTY(ThemeNodeEditor, 3, gp_vertex_select)
	INT_PROPERTY(ThemeNodeEditor, gp_vertex_size)
	FLOAT_ARRAY_PROPERTY(ThemeNodeEditor, 3, node_selected)
	FLOAT_ARRAY_PROPERTY(ThemeNodeEditor, 3, node_active)
	FLOAT_ARRAY_PROPERTY(ThemeNodeEditor, 3, wire)
	FLOAT_ARRAY_PROPERTY(ThemeNodeEditor, 3, wire_inner)
	FLOAT_ARRAY_PROPERTY(ThemeNodeEditor, 3, wire_select)
	FLOAT_ARRAY_PROPERTY(ThemeNodeEditor, 3, selected_text)
	FLOAT_ARRAY_PROPERTY(ThemeNodeEditor, 4, node_backdrop)
	FLOAT_ARRAY_PROPERTY(ThemeNodeEditor, 3, converter_node)
	FLOAT_ARRAY_PROPERTY(ThemeNodeEditor, 3, color_node)
	FLOAT_ARRAY_PROPERTY(ThemeNodeEditor, 4, group_node)
	FLOAT_ARRAY_PROPERTY(ThemeNodeEditor, 3, group_socket_node)
	FLOAT_ARRAY_PROPERTY(ThemeNodeEditor, 4, frame_node)
	FLOAT_ARRAY_PROPERTY(ThemeNodeEditor, 3, matte_node)
	FLOAT_ARRAY_PROPERTY(ThemeNodeEditor, 3, distor_node)
	INT_PROPERTY(ThemeNodeEditor, noodle_curving)
	FLOAT_ARRAY_PROPERTY(ThemeNodeEditor, 3, input_node)
	FLOAT_ARRAY_PROPERTY(ThemeNodeEditor, 3, output_node)
	FLOAT_ARRAY_PROPERTY(ThemeNodeEditor, 3, filter_node)
	FLOAT_ARRAY_PROPERTY(ThemeNodeEditor, 3, vector_node)
	FLOAT_ARRAY_PROPERTY(ThemeNodeEditor, 3, texture_node)
	FLOAT_ARRAY_PROPERTY(ThemeNodeEditor, 3, shader_node)
	FLOAT_ARRAY_PROPERTY(ThemeNodeEditor, 3, script_node)
	FLOAT_ARRAY_PROPERTY(ThemeNodeEditor, 3, pattern_node)
	FLOAT_ARRAY_PROPERTY(ThemeNodeEditor, 3, layout_node)


	POINTER_PROPERTY(Struct, ThemeOutliner, rna_type)
	POINTER_PROPERTY(ThemeSpaceGeneric, ThemeOutliner, space)
	FLOAT_ARRAY_PROPERTY(ThemeOutliner, 3, match)
	FLOAT_ARRAY_PROPERTY(ThemeOutliner, 3, selected_highlight)


	POINTER_PROPERTY(Struct, ThemeInfo, rna_type)
	POINTER_PROPERTY(ThemeSpaceGeneric, ThemeInfo, space)
	FLOAT_ARRAY_PROPERTY(ThemeInfo, 3, info_selected)
	FLOAT_ARRAY_PROPERTY(ThemeInfo, 3, info_selected_text)
	FLOAT_ARRAY_PROPERTY(ThemeInfo, 3, info_error)
	FLOAT_ARRAY_PROPERTY(ThemeInfo, 3, info_error_text)
	FLOAT_ARRAY_PROPERTY(ThemeInfo, 3, info_warning)
	FLOAT_ARRAY_PROPERTY(ThemeInfo, 3, info_warning_text)
	FLOAT_ARRAY_PROPERTY(ThemeInfo, 3, info_info)
	FLOAT_ARRAY_PROPERTY(ThemeInfo, 3, info_info_text)
	FLOAT_ARRAY_PROPERTY(ThemeInfo, 3, info_debug)
	FLOAT_ARRAY_PROPERTY(ThemeInfo, 3, info_debug_text)


	POINTER_PROPERTY(Struct, ThemePreferences, rna_type)
	POINTER_PROPERTY(ThemeSpaceGeneric, ThemePreferences, space)


	POINTER_PROPERTY(Struct, ThemeConsole, rna_type)
	POINTER_PROPERTY(ThemeSpaceGeneric, ThemeConsole, space)
	FLOAT_ARRAY_PROPERTY(ThemeConsole, 3, line_output)
	FLOAT_ARRAY_PROPERTY(ThemeConsole, 3, line_input)
	FLOAT_ARRAY_PROPERTY(ThemeConsole, 3, line_info)
	FLOAT_ARRAY_PROPERTY(ThemeConsole, 3, line_error)
	FLOAT_ARRAY_PROPERTY(ThemeConsole, 3, cursor)
	FLOAT_ARRAY_PROPERTY(ThemeConsole, 4, select)


	POINTER_PROPERTY(Struct, ThemeClipEditor, rna_type)
	POINTER_PROPERTY(ThemeSpaceGeneric, ThemeClipEditor, space)
	POINTER_PROPERTY(ThemeSpaceListGeneric, ThemeClipEditor, space_list)
	FLOAT_ARRAY_PROPERTY(ThemeClipEditor, 3, gp_vertex)
	FLOAT_ARRAY_PROPERTY(ThemeClipEditor, 3, gp_vertex_select)
	INT_PROPERTY(ThemeClipEditor, gp_vertex_size)
	FLOAT_ARRAY_PROPERTY(ThemeClipEditor, 3, marker_outline)
	FLOAT_ARRAY_PROPERTY(ThemeClipEditor, 3, marker)
	FLOAT_ARRAY_PROPERTY(ThemeClipEditor, 3, active_marker)
	FLOAT_ARRAY_PROPERTY(ThemeClipEditor, 3, selected_marker)
	FLOAT_ARRAY_PROPERTY(ThemeClipEditor, 3, disabled_marker)
	FLOAT_ARRAY_PROPERTY(ThemeClipEditor, 3, locked_marker)
	FLOAT_ARRAY_PROPERTY(ThemeClipEditor, 3, path_before)
	FLOAT_ARRAY_PROPERTY(ThemeClipEditor, 3, path_after)
	FLOAT_ARRAY_PROPERTY(ThemeClipEditor, 3, frame_current)
	FLOAT_ARRAY_PROPERTY(ThemeClipEditor, 3, strips)
	FLOAT_ARRAY_PROPERTY(ThemeClipEditor, 3, strips_selected)
	FLOAT_ARRAY_PROPERTY(ThemeClipEditor, 3, metadatabg)
	FLOAT_ARRAY_PROPERTY(ThemeClipEditor, 3, metadatatext)
	FLOAT_ARRAY_PROPERTY(ThemeClipEditor, 3, handle_free)
	FLOAT_ARRAY_PROPERTY(ThemeClipEditor, 3, handle_auto)
	FLOAT_ARRAY_PROPERTY(ThemeClipEditor, 3, handle_align)
	FLOAT_ARRAY_PROPERTY(ThemeClipEditor, 3, handle_sel_free)
	FLOAT_ARRAY_PROPERTY(ThemeClipEditor, 3, handle_sel_auto)
	FLOAT_ARRAY_PROPERTY(ThemeClipEditor, 3, handle_sel_align)
	FLOAT_ARRAY_PROPERTY(ThemeClipEditor, 3, handle_auto_clamped)
	FLOAT_ARRAY_PROPERTY(ThemeClipEditor, 3, handle_sel_auto_clamped)
	FLOAT_ARRAY_PROPERTY(ThemeClipEditor, 3, handle_vertex)
	FLOAT_ARRAY_PROPERTY(ThemeClipEditor, 3, handle_vertex_select)
	INT_PROPERTY(ThemeClipEditor, handle_vertex_size)


	POINTER_PROPERTY(Struct, ThemeTopBar, rna_type)
	POINTER_PROPERTY(ThemeSpaceGeneric, ThemeTopBar, space)


	POINTER_PROPERTY(Struct, ThemeStatusBar, rna_type)
	POINTER_PROPERTY(ThemeSpaceGeneric, ThemeStatusBar, space)


	POINTER_PROPERTY(Struct, ThemeBoneColorSet, rna_type)
	FLOAT_ARRAY_PROPERTY(ThemeBoneColorSet, 3, normal)
	FLOAT_ARRAY_PROPERTY(ThemeBoneColorSet, 3, select)
	FLOAT_ARRAY_PROPERTY(ThemeBoneColorSet, 3, active)
	BOOLEAN_PROPERTY(ThemeBoneColorSet, show_colored_constraints)


	POINTER_PROPERTY(Struct, Theme, rna_type)
	STRING_PROPERTY(Theme, name)
	ENUM_PROPERTY(theme_area_enum, Theme, theme_area)
	POINTER_PROPERTY(ThemeUserInterface, Theme, user_interface)
	POINTER_PROPERTY(ThemeView3D, Theme, view_3d)
	POINTER_PROPERTY(ThemeGraphEditor, Theme, graph_editor)
	POINTER_PROPERTY(ThemeFileBrowser, Theme, file_browser)
	POINTER_PROPERTY(ThemeNLAEditor, Theme, nla_editor)
	POINTER_PROPERTY(ThemeDopeSheet, Theme, dopesheet_editor)
	POINTER_PROPERTY(ThemeImageEditor, Theme, image_editor)
	POINTER_PROPERTY(ThemeSequenceEditor, Theme, sequence_editor)
	POINTER_PROPERTY(ThemeProperties, Theme, properties)
	POINTER_PROPERTY(ThemeTextEditor, Theme, text_editor)
	POINTER_PROPERTY(ThemeNodeEditor, Theme, node_editor)
	POINTER_PROPERTY(ThemeOutliner, Theme, outliner)
	POINTER_PROPERTY(ThemeInfo, Theme, info)
	POINTER_PROPERTY(ThemePreferences, Theme, preferences)
	POINTER_PROPERTY(ThemeConsole, Theme, console)
	POINTER_PROPERTY(ThemeClipEditor, Theme, clip_editor)
	POINTER_PROPERTY(ThemeTopBar, Theme, topbar)
	POINTER_PROPERTY(ThemeStatusBar, Theme, statusbar)



	POINTER_PROPERTY(Struct, UserSolidLight, rna_type)
	BOOLEAN_PROPERTY(UserSolidLight, use)
	FLOAT_PROPERTY(UserSolidLight, smooth)
	FLOAT_ARRAY_PROPERTY(UserSolidLight, 3, direction)
	FLOAT_ARRAY_PROPERTY(UserSolidLight, 3, specular_color)
	FLOAT_ARRAY_PROPERTY(UserSolidLight, 3, diffuse_color)


	POINTER_PROPERTY(Struct, WalkNavigation, rna_type)
	FLOAT_PROPERTY(WalkNavigation, mouse_speed)
	FLOAT_PROPERTY(WalkNavigation, walk_speed)
	FLOAT_PROPERTY(WalkNavigation, walk_speed_factor)
	FLOAT_PROPERTY(WalkNavigation, view_height)
	FLOAT_PROPERTY(WalkNavigation, jump_height)
	FLOAT_PROPERTY(WalkNavigation, teleport_time)
	BOOLEAN_PROPERTY(WalkNavigation, use_gravity)
	BOOLEAN_PROPERTY(WalkNavigation, use_mouse_reverse)


	POINTER_PROPERTY(Struct, Preferences, rna_type)
	ENUM_PROPERTY(active_section_enum, Preferences, active_section)
	STRING_PROPERTY(Preferences, app_template)




	POINTER_PROPERTY(PreferencesView, Preferences, view)
	POINTER_PROPERTY(PreferencesEdit, Preferences, edit)
	POINTER_PROPERTY(PreferencesInput, Preferences, inputs)
	POINTER_PROPERTY(PreferencesKeymap, Preferences, keymap)
	POINTER_PROPERTY(PreferencesFilePaths, Preferences, filepaths)
	POINTER_PROPERTY(PreferencesSystem, Preferences, system)
	INT_ARRAY_PROPERTY(Preferences, 3, version)



	POINTER_PROPERTY(Struct, Addons, rna_type)

	inline Addon Addons::create() {
		PointerRNA result;
		::bAddon *retdata = Addons_new();
		RNA_pointer_create((::ID *) ptr.id.data, &RNA_Addon, retdata, &result);
		return Addon(result);
	}

	inline void Addons::remove(Addon& addon) {
		Addons_remove(NULL, (::PointerRNA *) &addon.ptr);
	}


	POINTER_PROPERTY(Struct, PathCompareCollection, rna_type)

	inline PathCompare PathCompareCollection::create() {
		PointerRNA result;
		::bPathCompare *retdata = PathCompareCollection_new();
		RNA_pointer_create((::ID *) ptr.id.data, &RNA_PathCompare, retdata, &result);
		return PathCompare(result);
	}

	inline void PathCompareCollection::remove(PathCompare& pathcmp) {
		PathCompareCollection_remove(NULL, (::PointerRNA *) &pathcmp.ptr);
	}


	POINTER_PROPERTY(Struct, PreferencesView, rna_type)
	FLOAT_PROPERTY(PreferencesView, ui_scale)
	ENUM_PROPERTY(ui_line_width_enum, PreferencesView, ui_line_width)
	BOOLEAN_PROPERTY(PreferencesView, show_tooltips)
	BOOLEAN_PROPERTY(PreferencesView, show_tooltips_python)
	BOOLEAN_PROPERTY(PreferencesView, show_developer_ui)
	BOOLEAN_PROPERTY(PreferencesView, show_object_info)
	BOOLEAN_PROPERTY(PreferencesView, show_large_cursors)
	BOOLEAN_PROPERTY(PreferencesView, show_view_name)
	BOOLEAN_PROPERTY(PreferencesView, show_splash)
	BOOLEAN_PROPERTY(PreferencesView, show_playback_fps)
	ENUM_PROPERTY(factor_display_type_enum, PreferencesView, factor_display_type)
	BOOLEAN_PROPERTY(PreferencesView, use_weight_color_range)
	POINTER_PROPERTY(ColorRamp, PreferencesView, weight_color_range)
	BOOLEAN_PROPERTY(PreferencesView, show_layout_ui)
	BOOLEAN_PROPERTY(PreferencesView, use_mouse_over_open)
	INT_PROPERTY(PreferencesView, open_toplevel_delay)
	INT_PROPERTY(PreferencesView, open_sublevel_delay)
	ENUM_PROPERTY(color_picker_type_enum, PreferencesView, color_picker_type)
	INT_PROPERTY(PreferencesView, pie_initial_timeout)
	INT_PROPERTY(PreferencesView, pie_tap_timeout)
	INT_PROPERTY(PreferencesView, pie_animation_timeout)
	INT_PROPERTY(PreferencesView, pie_menu_radius)
	INT_PROPERTY(PreferencesView, pie_menu_threshold)
	INT_PROPERTY(PreferencesView, pie_menu_confirm)
	BOOLEAN_PROPERTY(PreferencesView, use_save_prompt)
	BOOLEAN_PROPERTY(PreferencesView, show_column_layout)
	BOOLEAN_PROPERTY(PreferencesView, use_directional_menus)
	ENUM_PROPERTY(header_align_enum, PreferencesView, header_align)
	ENUM_PROPERTY(mini_axis_type_enum, PreferencesView, mini_axis_type)
	INT_PROPERTY(PreferencesView, mini_axis_size)
	INT_PROPERTY(PreferencesView, mini_axis_brightness)
	INT_PROPERTY(PreferencesView, smooth_view)
	FLOAT_PROPERTY(PreferencesView, rotation_angle)
	BOOLEAN_PROPERTY(PreferencesView, show_gizmo)
	INT_PROPERTY(PreferencesView, gizmo_size)
	INT_PROPERTY(PreferencesView, object_origin_size)
	INT_PROPERTY(PreferencesView, view2d_grid_spacing_min)
	ENUM_PROPERTY(timecode_style_enum, PreferencesView, timecode_style)
	ENUM_PROPERTY(view_frame_type_enum, PreferencesView, view_frame_type)
	INT_PROPERTY(PreferencesView, view_frame_keyframes)
	FLOAT_PROPERTY(PreferencesView, view_frame_seconds)
	BOOLEAN_PROPERTY(PreferencesView, use_text_antialiasing)
	ENUM_PROPERTY(text_hinting_enum, PreferencesView, text_hinting)
	STRING_PROPERTY(PreferencesView, font_path_ui)
	STRING_PROPERTY(PreferencesView, font_path_ui_mono)
	BOOLEAN_PROPERTY(PreferencesView, use_international_fonts)
	ENUM_PROPERTY(language_enum, PreferencesView, language)
	BOOLEAN_PROPERTY(PreferencesView, use_translate_tooltips)
	BOOLEAN_PROPERTY(PreferencesView, use_translate_interface)
	BOOLEAN_PROPERTY(PreferencesView, use_translate_new_dataname)


	POINTER_PROPERTY(Struct, PreferencesEdit, rna_type)
	ENUM_PROPERTY(material_link_enum, PreferencesEdit, material_link)
	ENUM_PROPERTY(object_align_enum, PreferencesEdit, object_align)
	BOOLEAN_PROPERTY(PreferencesEdit, use_enter_edit_mode)
	INT_PROPERTY(PreferencesEdit, undo_steps)
	INT_PROPERTY(PreferencesEdit, undo_memory_limit)
	BOOLEAN_PROPERTY(PreferencesEdit, use_global_undo)
	BOOLEAN_PROPERTY(PreferencesEdit, use_auto_keying)
	ENUM_PROPERTY(auto_keying_mode_enum, PreferencesEdit, auto_keying_mode)
	BOOLEAN_PROPERTY(PreferencesEdit, use_keyframe_insert_available)
	BOOLEAN_PROPERTY(PreferencesEdit, use_auto_keying_warning)
	BOOLEAN_PROPERTY(PreferencesEdit, use_keyframe_insert_needed)
	BOOLEAN_PROPERTY(PreferencesEdit, use_visual_keying)
	BOOLEAN_PROPERTY(PreferencesEdit, use_insertkey_xyz_to_rgb)
	ENUM_PROPERTY(keyframe_new_interpolation_type_enum, PreferencesEdit, keyframe_new_interpolation_type)
	ENUM_PROPERTY(keyframe_new_handle_type_enum, PreferencesEdit, keyframe_new_handle_type)
	BOOLEAN_PROPERTY(PreferencesEdit, use_negative_frames)
	FLOAT_PROPERTY(PreferencesEdit, fcurve_unselected_alpha)
	INT_PROPERTY(PreferencesEdit, grease_pencil_manhattan_distance)
	INT_PROPERTY(PreferencesEdit, grease_pencil_euclidean_distance)
	BOOLEAN_PROPERTY(PreferencesEdit, use_grease_pencil_simplify_stroke)
	INT_PROPERTY(PreferencesEdit, grease_pencil_eraser_radius)
	FLOAT_ARRAY_PROPERTY(PreferencesEdit, 4, grease_pencil_default_color)
	FLOAT_ARRAY_PROPERTY(PreferencesEdit, 3, sculpt_paint_overlay_color)
	BOOLEAN_PROPERTY(PreferencesEdit, use_duplicate_mesh)
	BOOLEAN_PROPERTY(PreferencesEdit, use_duplicate_surface)
	BOOLEAN_PROPERTY(PreferencesEdit, use_duplicate_curve)
	BOOLEAN_PROPERTY(PreferencesEdit, use_duplicate_text)
	BOOLEAN_PROPERTY(PreferencesEdit, use_duplicate_metaball)
	BOOLEAN_PROPERTY(PreferencesEdit, use_duplicate_armature)
	BOOLEAN_PROPERTY(PreferencesEdit, use_duplicate_light)
	BOOLEAN_PROPERTY(PreferencesEdit, use_duplicate_material)
	BOOLEAN_PROPERTY(PreferencesEdit, use_duplicate_texture)
	BOOLEAN_PROPERTY(PreferencesEdit, use_duplicate_fcurve)
	BOOLEAN_PROPERTY(PreferencesEdit, use_duplicate_action)
	BOOLEAN_PROPERTY(PreferencesEdit, use_duplicate_particle)
	INT_PROPERTY(PreferencesEdit, node_margin)
	BOOLEAN_PROPERTY(PreferencesEdit, use_cursor_lock_adjust)
	BOOLEAN_PROPERTY(PreferencesEdit, use_mouse_depth_cursor)


	POINTER_PROPERTY(Struct, PreferencesInput, rna_type)
	ENUM_PROPERTY(view_zoom_method_enum, PreferencesInput, view_zoom_method)
	ENUM_PROPERTY(view_zoom_axis_enum, PreferencesInput, view_zoom_axis)
	BOOLEAN_PROPERTY(PreferencesInput, invert_mouse_zoom)
	BOOLEAN_PROPERTY(PreferencesInput, use_mouse_depth_navigate)
	BOOLEAN_PROPERTY(PreferencesInput, use_camera_lock_parent)
	BOOLEAN_PROPERTY(PreferencesInput, use_zoom_to_mouse)
	BOOLEAN_PROPERTY(PreferencesInput, use_auto_perspective)
	BOOLEAN_PROPERTY(PreferencesInput, use_rotate_around_active)
	ENUM_PROPERTY(view_rotate_method_enum, PreferencesInput, view_rotate_method)
	BOOLEAN_PROPERTY(PreferencesInput, use_mouse_continuous)
	BOOLEAN_PROPERTY(PreferencesInput, use_drag_immediately)
	BOOLEAN_PROPERTY(PreferencesInput, use_numeric_input_advanced)
	ENUM_PROPERTY(navigation_mode_enum, PreferencesInput, navigation_mode)
	POINTER_PROPERTY(WalkNavigation, PreferencesInput, walk_navigation)
	INT_PROPERTY(PreferencesInput, drag_threshold)
	INT_PROPERTY(PreferencesInput, move_threshold)
	FLOAT_PROPERTY(PreferencesInput, pressure_threshold_max)
	FLOAT_PROPERTY(PreferencesInput, pressure_softness)
	ENUM_PROPERTY(tablet_api_enum, PreferencesInput, tablet_api)
	FLOAT_PROPERTY(PreferencesInput, ndof_sensitivity)
	FLOAT_PROPERTY(PreferencesInput, ndof_orbit_sensitivity)
	FLOAT_PROPERTY(PreferencesInput, ndof_deadzone)
	BOOLEAN_PROPERTY(PreferencesInput, ndof_pan_yz_swap_axis)
	BOOLEAN_PROPERTY(PreferencesInput, ndof_zoom_invert)
	BOOLEAN_PROPERTY(PreferencesInput, ndof_show_guide)
	ENUM_PROPERTY(ndof_view_navigate_method_enum, PreferencesInput, ndof_view_navigate_method)
	ENUM_PROPERTY(ndof_view_rotate_method_enum, PreferencesInput, ndof_view_rotate_method)
	BOOLEAN_PROPERTY(PreferencesInput, ndof_rotx_invert_axis)
	BOOLEAN_PROPERTY(PreferencesInput, ndof_roty_invert_axis)
	BOOLEAN_PROPERTY(PreferencesInput, ndof_rotz_invert_axis)
	BOOLEAN_PROPERTY(PreferencesInput, ndof_panx_invert_axis)
	BOOLEAN_PROPERTY(PreferencesInput, ndof_pany_invert_axis)
	BOOLEAN_PROPERTY(PreferencesInput, ndof_panz_invert_axis)
	BOOLEAN_PROPERTY(PreferencesInput, ndof_lock_horizon)
	BOOLEAN_PROPERTY(PreferencesInput, ndof_fly_helicopter)
	INT_PROPERTY(PreferencesInput, mouse_double_click_time)
	BOOLEAN_PROPERTY(PreferencesInput, use_mouse_emulate_3_button)
	BOOLEAN_PROPERTY(PreferencesInput, use_emulate_numpad)
	BOOLEAN_PROPERTY(PreferencesInput, invert_zoom_wheel)
	INT_PROPERTY(PreferencesInput, wheel_scroll_lines)
	BOOLEAN_PROPERTY(PreferencesInput, use_trackpad_natural)


	POINTER_PROPERTY(Struct, PreferencesKeymap, rna_type)
	BOOLEAN_PROPERTY(PreferencesKeymap, show_ui_keyconfig)
	STRING_PROPERTY(PreferencesKeymap, active_keyconfig)


	POINTER_PROPERTY(Struct, PreferencesFilePaths, rna_type)
	BOOLEAN_PROPERTY(PreferencesFilePaths, show_hidden_files_datablocks)
	BOOLEAN_PROPERTY(PreferencesFilePaths, use_filter_files)
	BOOLEAN_PROPERTY(PreferencesFilePaths, hide_recent_locations)
	BOOLEAN_PROPERTY(PreferencesFilePaths, hide_system_bookmarks)
	BOOLEAN_PROPERTY(PreferencesFilePaths, show_thumbnails)
	BOOLEAN_PROPERTY(PreferencesFilePaths, use_relative_paths)
	BOOLEAN_PROPERTY(PreferencesFilePaths, use_file_compression)
	BOOLEAN_PROPERTY(PreferencesFilePaths, use_load_ui)
	BOOLEAN_PROPERTY(PreferencesFilePaths, use_scripts_auto_execute)
	BOOLEAN_PROPERTY(PreferencesFilePaths, use_tabs_as_spaces)
	STRING_PROPERTY(PreferencesFilePaths, font_directory)
	STRING_PROPERTY(PreferencesFilePaths, texture_directory)
	STRING_PROPERTY(PreferencesFilePaths, render_output_directory)
	STRING_PROPERTY(PreferencesFilePaths, script_directory)
	STRING_PROPERTY(PreferencesFilePaths, i18n_branches_directory)
	STRING_PROPERTY(PreferencesFilePaths, sound_directory)
	STRING_PROPERTY(PreferencesFilePaths, temporary_directory)
	STRING_PROPERTY(PreferencesFilePaths, render_cache_directory)
	STRING_PROPERTY(PreferencesFilePaths, image_editor)
	STRING_PROPERTY(PreferencesFilePaths, animation_player)
	ENUM_PROPERTY(animation_player_preset_enum, PreferencesFilePaths, animation_player_preset)
	INT_PROPERTY(PreferencesFilePaths, save_version)
	BOOLEAN_PROPERTY(PreferencesFilePaths, use_auto_save_temporary_files)
	INT_PROPERTY(PreferencesFilePaths, auto_save_time)
	INT_PROPERTY(PreferencesFilePaths, recent_files)
	BOOLEAN_PROPERTY(PreferencesFilePaths, use_save_preview_images)


	POINTER_PROPERTY(Struct, PreferencesSystem, rna_type)
	FLOAT_PROPERTY(PreferencesSystem, ui_scale)
	FLOAT_PROPERTY(PreferencesSystem, ui_line_width)
	INT_PROPERTY(PreferencesSystem, dpi)
	FLOAT_PROPERTY(PreferencesSystem, pixel_size)
	INT_PROPERTY(PreferencesSystem, prefetch_frames)
	INT_PROPERTY(PreferencesSystem, memory_cache_limit)
	INT_PROPERTY(PreferencesSystem, scrollback)
	ENUM_PROPERTY(multi_sample_enum, PreferencesSystem, multi_sample)
	BOOLEAN_PROPERTY(PreferencesSystem, use_edit_mode_smooth_wire)
	ENUM_PROPERTY(gpencil_multi_sample_enum, PreferencesSystem, gpencil_multi_sample)
	BOOLEAN_PROPERTY(PreferencesSystem, use_region_overlap)
	FLOAT_PROPERTY(PreferencesSystem, gpu_viewport_quality)

	FLOAT_ARRAY_PROPERTY(PreferencesSystem, 3, light_ambient)
	BOOLEAN_PROPERTY(PreferencesSystem, use_studio_light_edit)
	FLOAT_PROPERTY(PreferencesSystem, gl_clip_alpha)
	ENUM_PROPERTY(image_draw_method_enum, PreferencesSystem, image_draw_method)
	ENUM_PROPERTY(anisotropic_filter_enum, PreferencesSystem, anisotropic_filter)
	ENUM_PROPERTY(gl_texture_limit_enum, PreferencesSystem, gl_texture_limit)
	INT_PROPERTY(PreferencesSystem, texture_time_out)
	INT_PROPERTY(PreferencesSystem, texture_collection_rate)
	BOOLEAN_PROPERTY(PreferencesSystem, use_select_pick_depth)
	ENUM_PROPERTY(audio_mixing_buffer_enum, PreferencesSystem, audio_mixing_buffer)
	ENUM_PROPERTY(audio_device_enum, PreferencesSystem, audio_device)
	ENUM_PROPERTY(audio_sample_rate_enum, PreferencesSystem, audio_sample_rate)
	ENUM_PROPERTY(audio_sample_format_enum, PreferencesSystem, audio_sample_format)
	ENUM_PROPERTY(audio_channels_enum, PreferencesSystem, audio_channels)
	ENUM_PROPERTY(opensubdiv_compute_type_enum, PreferencesSystem, opensubdiv_compute_type)
	INT_PROPERTY(PreferencesSystem, legacy_compute_device_type)


	POINTER_PROPERTY(Struct, Addon, rna_type)
	STRING_PROPERTY(Addon, module)
	POINTER_PROPERTY(AddonPreferences, Addon, preferences)


	POINTER_PROPERTY(Struct, AddonPreferences, rna_type)
	STRING_PROPERTY(AddonPreferences, bl_idname)


	POINTER_PROPERTY(Struct, StudioLights, rna_type)

	inline StudioLight StudioLights::load(const char * path, int type) {
		PointerRNA result;
		::StudioLight *retdata = StudioLights_load((::UserDef *) this->ptr.data, path, type);
		RNA_pointer_create((::ID *) ptr.id.data, &RNA_StudioLight, retdata, &result);
		return StudioLight(result);
	}

	inline StudioLight StudioLights::create(const char * path) {
		PointerRNA result;
		::StudioLight *retdata = StudioLights_new((::UserDef *) this->ptr.data, path);
		RNA_pointer_create((::ID *) ptr.id.data, &RNA_StudioLight, retdata, &result);
		return StudioLight(result);
	}

	inline void StudioLights::remove(StudioLight& studio_light) {
		StudioLights_remove((::UserDef *) this->ptr.data, (::StudioLight *) studio_light.ptr.data);
	}

	inline void StudioLights::refresh() {
		StudioLights_refresh((::UserDef *) this->ptr.data);
	}


	POINTER_PROPERTY(Struct, StudioLight, rna_type)
	INT_PROPERTY(StudioLight, index)
	BOOLEAN_PROPERTY(StudioLight, is_user_defined)
	ENUM_PROPERTY(type_enum, StudioLight, type)
	STRING_PROPERTY(StudioLight, name)
	STRING_PROPERTY(StudioLight, path)

	FLOAT_ARRAY_PROPERTY(StudioLight, 3, light_ambient)
	STRING_PROPERTY(StudioLight, path_irr_cache)
	STRING_PROPERTY(StudioLight, path_sh_cache)
	FLOAT_ARRAY_PROPERTY(StudioLight, 12, spherical_harmonics_coefficients)


	POINTER_PROPERTY(Struct, PathCompare, rna_type)
	STRING_PROPERTY(PathCompare, path)
	BOOLEAN_PROPERTY(PathCompare, use_glob)


	STRING_PROPERTY(VectorFont, filepath)
	POINTER_PROPERTY(PackedFile, VectorFont, packed_file)

	inline void VectorFont::pack(void *main) {
		VectorFont_pack((::VFont *) this->ptr.data, (::Main *) main, NULL);
	}

	inline void VectorFont::unpack(void *main, int method) {
		VectorFont_unpack((::VFont *) this->ptr.data, (::Main *) main, NULL, method);
	}


	POINTER_PROPERTY(Struct, Operator, rna_type)
	STRING_PROPERTY(Operator, name)
	POINTER_PROPERTY(OperatorProperties, Operator, properties)
	BOOLEAN_PROPERTY(Operator, has_reports)
	POINTER_PROPERTY(UILayout, Operator, layout)
	POINTER_PROPERTY(OperatorOptions, Operator, options)
	STRING_PROPERTY(Operator, bl_idname)
	STRING_PROPERTY(Operator, bl_label)
	STRING_PROPERTY(Operator, bl_translation_context)
	STRING_PROPERTY(Operator, bl_description)
	STRING_PROPERTY(Operator, bl_undo_group)
	ENUM_PROPERTY(bl_options_enum, Operator, bl_options)


	inline void Operator::report(int type, const char * message) {
		Operator_report((::wmOperator *) this->ptr.data, type, message);
	}

	inline bool Operator::is_repeat(Context C) {
		return Operator_is_repeat((::wmOperator *) this->ptr.data, (::bContext *) C.ptr.data);
	}


	POINTER_PROPERTY(Struct, OperatorProperties, rna_type)


	POINTER_PROPERTY(Struct, OperatorOptions, rna_type)
	BOOLEAN_PROPERTY(OperatorOptions, is_grab_cursor)
	BOOLEAN_PROPERTY(OperatorOptions, is_invoke)
	BOOLEAN_PROPERTY(OperatorOptions, is_repeat)
	BOOLEAN_PROPERTY(OperatorOptions, use_cursor_region)






	POINTER_PROPERTY(Struct, Macro, rna_type)
	STRING_PROPERTY(Macro, name)
	POINTER_PROPERTY(OperatorProperties, Macro, properties)
	STRING_PROPERTY(Macro, bl_idname)
	STRING_PROPERTY(Macro, bl_label)
	STRING_PROPERTY(Macro, bl_translation_context)
	STRING_PROPERTY(Macro, bl_description)
	STRING_PROPERTY(Macro, bl_undo_group)
	ENUM_PROPERTY(bl_options_enum, Macro, bl_options)

	inline void Macro::report(int type, const char * message) {
		Macro_report((::wmOperator *) this->ptr.data, type, message);
	}


	POINTER_PROPERTY(Struct, OperatorMacro, rna_type)
	POINTER_PROPERTY(OperatorProperties, OperatorMacro, properties)


	POINTER_PROPERTY(Struct, Event, rna_type)
	STRING_PROPERTY(Event, ascii)
	STRING_PROPERTY(Event, unicode)
	ENUM_PROPERTY(value_enum, Event, value)
	ENUM_PROPERTY(type_enum, Event, type)
	INT_PROPERTY(Event, mouse_x)
	INT_PROPERTY(Event, mouse_y)
	INT_PROPERTY(Event, mouse_region_x)
	INT_PROPERTY(Event, mouse_region_y)
	INT_PROPERTY(Event, mouse_prev_x)
	INT_PROPERTY(Event, mouse_prev_y)
	FLOAT_PROPERTY(Event, pressure)
	FLOAT_ARRAY_PROPERTY(Event, 2, tilt)
	BOOLEAN_PROPERTY(Event, is_tablet)
	BOOLEAN_PROPERTY(Event, is_mouse_absolute)
	BOOLEAN_PROPERTY(Event, shift)
	BOOLEAN_PROPERTY(Event, ctrl)
	BOOLEAN_PROPERTY(Event, alt)
	BOOLEAN_PROPERTY(Event, oskey)


	POINTER_PROPERTY(Struct, Timer, rna_type)
	FLOAT_PROPERTY(Timer, time_step)
	FLOAT_PROPERTY(Timer, time_delta)
	FLOAT_PROPERTY(Timer, time_duration)


	POINTER_PROPERTY(Struct, UIPopupMenu, rna_type)
	POINTER_PROPERTY(UILayout, UIPopupMenu, layout)


	POINTER_PROPERTY(Struct, UIPopover, rna_type)
	POINTER_PROPERTY(UILayout, UIPopover, layout)


	POINTER_PROPERTY(Struct, UIPieMenu, rna_type)
	POINTER_PROPERTY(UILayout, UIPieMenu, layout)


	POINTER_PROPERTY(Struct, Window, rna_type)
	POINTER_PROPERTY(Window, Window, parent)
	POINTER_PROPERTY(Scene, Window, scene)
	POINTER_PROPERTY(WorkSpace, Window, workspace)
	POINTER_PROPERTY(Screen, Window, screen)
	POINTER_PROPERTY(ViewLayer, Window, view_layer)
	INT_PROPERTY(Window, x)
	INT_PROPERTY(Window, y)
	INT_PROPERTY(Window, width)
	INT_PROPERTY(Window, height)
	POINTER_PROPERTY(Stereo3dDisplay, Window, stereo_3d_display)

	inline void Window::cursor_warp(int x, int y) {
		Window_cursor_warp((::wmWindow *) this->ptr.data, x, y);
	}

	inline void Window::cursor_set(int cursor) {
		Window_cursor_set((::wmWindow *) this->ptr.data, cursor);
	}

	inline void Window::cursor_modal_set(int cursor) {
		Window_cursor_modal_set((::wmWindow *) this->ptr.data, cursor);
	}

	inline void Window::cursor_modal_restore() {
		Window_cursor_modal_restore((::wmWindow *) this->ptr.data);
	}

	inline Event Window::event_simulate(int type, int value, const char * unicode, int x, int y, bool shift, bool ctrl, bool alt, bool oskey) {
		PointerRNA result;
		::wmEvent *retdata = Window_event_simulate((::wmWindow *) this->ptr.data, NULL, type, value, unicode, x, y, shift, ctrl, alt, oskey);
		RNA_pointer_create((::ID *) ptr.id.data, &RNA_Event, retdata, &result);
		return Event(result);
	}


	POINTER_PROPERTY(Struct, Stereo3dDisplay, rna_type)
	ENUM_PROPERTY(display_mode_enum, Stereo3dDisplay, display_mode)
	ENUM_PROPERTY(anaglyph_type_enum, Stereo3dDisplay, anaglyph_type)
	ENUM_PROPERTY(interlace_type_enum, Stereo3dDisplay, interlace_type)
	BOOLEAN_PROPERTY(Stereo3dDisplay, use_interlace_swap)
	BOOLEAN_PROPERTY(Stereo3dDisplay, use_sidebyside_crosseyed)





	STRING_PROPERTY(WindowManager, clipboard)

	inline void WindowManager::fileselect_add(Context C, Operator& operator_value) {
		WindowManager_fileselect_add((::bContext *) C.ptr.data, (::wmOperator *) operator_value.ptr.data);
	}

	inline bool WindowManager::modal_handler_add(Context C, Operator& operator_value) {
		return WindowManager_modal_handler_add((::bContext *) C.ptr.data, (::wmOperator *) operator_value.ptr.data);
	}

	inline Timer WindowManager::event_timer_add(float time_step, Window& window) {
		PointerRNA result;
		::wmTimer *retdata = WindowManager_event_timer_add((::wmWindowManager *) this->ptr.data, time_step, (::wmWindow *) window.ptr.data);
		RNA_pointer_create((::ID *) ptr.id.data, &RNA_Timer, retdata, &result);
		return Timer(result);
	}

	inline void WindowManager::event_timer_remove(Timer& timer) {
		WindowManager_event_timer_remove((::wmWindowManager *) this->ptr.data, (::wmTimer *) timer.ptr.data);
	}

	inline void WindowManager::gizmo_group_type_ensure(const char * identifier) {
		WindowManager_gizmo_group_type_ensure(NULL, identifier);
	}

	inline void WindowManager::gizmo_group_type_unlink_delayed(const char * identifier) {
		WindowManager_gizmo_group_type_unlink_delayed(NULL, identifier);
	}

	inline void WindowManager::progress_begin(float min, float max) {
		WindowManager_progress_begin((::wmWindowManager *) this->ptr.data, min, max);
	}

	inline void WindowManager::progress_update(float value) {
		WindowManager_progress_update((::wmWindowManager *) this->ptr.data, value);
	}

	inline void WindowManager::progress_end() {
		WindowManager_progress_end((::wmWindowManager *) this->ptr.data);
	}

	inline int WindowManager::invoke_props_popup(Context C, Operator& operator_value, Event& event) {
		return WindowManager_invoke_props_popup((::bContext *) C.ptr.data, (::wmOperator *) operator_value.ptr.data, (::wmEvent *) event.ptr.data);
	}

	inline int WindowManager::invoke_props_dialog(Context C, Operator& operator_value, int width, int height) {
		return WindowManager_invoke_props_dialog((::bContext *) C.ptr.data, (::wmOperator *) operator_value.ptr.data, width, height);
	}

	inline void WindowManager::invoke_search_popup(Context C, Operator& operator_value) {
		WindowManager_invoke_search_popup((::bContext *) C.ptr.data, (::wmOperator *) operator_value.ptr.data);
	}

	inline int WindowManager::invoke_popup(Context C, Operator& operator_value, int width, int height) {
		return WindowManager_invoke_popup((::bContext *) C.ptr.data, (::wmOperator *) operator_value.ptr.data, width, height);
	}

	inline int WindowManager::invoke_confirm(Context C, Operator& operator_value, Event& event) {
		return WindowManager_invoke_confirm((::bContext *) C.ptr.data, (::wmOperator *) operator_value.ptr.data, (::wmEvent *) event.ptr.data);
	}

	inline UIPopupMenu WindowManager::popmenu_begin__internal(Context C, const char * title, int icon) {
		PointerRNA result;
		result = WindowManager_popmenu_begin__internal((::bContext *) C.ptr.data, title, icon);
		return UIPopupMenu(result);
	}

	inline void WindowManager::popmenu_end__internal(Context C, UIPopupMenu& menu) {
		WindowManager_popmenu_end__internal((::bContext *) C.ptr.data, (::PointerRNA *) menu.ptr.data);
	}

	inline UIPopover WindowManager::popover_begin__internal(Context C, int ui_units_x) {
		PointerRNA result;
		result = WindowManager_popover_begin__internal((::bContext *) C.ptr.data, ui_units_x);
		return UIPopover(result);
	}

	inline void WindowManager::popover_end__internal(Context C, UIPopover& menu, KeyMap& keymap) {
		WindowManager_popover_end__internal((::bContext *) C.ptr.data, (::PointerRNA *) menu.ptr.data, (::wmKeyMap *) keymap.ptr.data);
	}

	inline UIPieMenu WindowManager::piemenu_begin__internal(Context C, const char * title, int icon, Event& event) {
		PointerRNA result;
		result = WindowManager_piemenu_begin__internal((::bContext *) C.ptr.data, title, icon, (::PointerRNA *) event.ptr.data);
		return UIPieMenu(result);
	}

	inline void WindowManager::piemenu_end__internal(Context C, UIPieMenu& menu) {
		WindowManager_piemenu_end__internal((::bContext *) C.ptr.data, (::PointerRNA *) menu.ptr.data);
	}

	inline OperatorProperties WindowManager::operator_properties_last(const char * operator_value) {
		PointerRNA result;
		result = WindowManager_operator_properties_last(operator_value);
		return OperatorProperties(result);
	}

	inline void WindowManager::print_undo_steps() {
		WindowManager_print_undo_steps((::wmWindowManager *) this->ptr.data);
	}


	POINTER_PROPERTY(Struct, KeyConfigurations, rna_type)
	POINTER_PROPERTY(KeyConfig, KeyConfigurations, active)
	POINTER_PROPERTY(KeyConfig, KeyConfigurations, default_value)
	POINTER_PROPERTY(KeyConfig, KeyConfigurations, addon)
	POINTER_PROPERTY(KeyConfig, KeyConfigurations, user)

	inline KeyConfig KeyConfigurations::create(const char * name) {
		PointerRNA result;
		::wmKeyConfig *retdata = KeyConfigurations_new((::wmWindowManager *) this->ptr.data, name);
		RNA_pointer_create((::ID *) ptr.id.data, &RNA_KeyConfig, retdata, &result);
		return KeyConfig(result);
	}

	inline void KeyConfigurations::remove(KeyConfig& keyconfig) {
		KeyConfigurations_remove((::wmWindowManager *) this->ptr.data, NULL, (::PointerRNA *) &keyconfig.ptr);
	}

	inline KeyMapItem KeyConfigurations::find_item_from_operator(Context C, const char * idname, int context, OperatorProperties& properties, int include, int exclude, KeyMap *keymap) {
		PointerRNA result;
		result = KeyConfigurations_find_item_from_operator((::wmWindowManager *) this->ptr.data, (::bContext *) C.ptr.data, idname, context, (::PointerRNA *) properties.ptr.data, include, exclude, &keymap->ptr);
		return KeyMapItem(result);
	}

	inline void KeyConfigurations::update() {
		KeyConfigurations_update((::wmWindowManager *) this->ptr.data);
	}


	POINTER_PROPERTY(Struct, KeyConfigPreferences, rna_type)
	STRING_PROPERTY(KeyConfigPreferences, bl_idname)


	POINTER_PROPERTY(Struct, KeyConfig, rna_type)
	STRING_PROPERTY(KeyConfig, name)

	BOOLEAN_PROPERTY(KeyConfig, is_user_defined)
	POINTER_PROPERTY(KeyConfigPreferences, KeyConfig, preferences)


	POINTER_PROPERTY(Struct, KeyMaps, rna_type)

	inline KeyMap KeyMaps::create(const char * name, int space_type, int region_type, bool modal, bool tool) {
		PointerRNA result;
		::wmKeyMap *retdata = KeyMaps_new((::wmKeyConfig *) this->ptr.data, name, space_type, region_type, modal, tool);
		RNA_pointer_create((::ID *) ptr.id.data, &RNA_KeyMap, retdata, &result);
		return KeyMap(result);
	}

	inline void KeyMaps::remove(KeyMap& keymap) {
		KeyMaps_remove((::wmKeyConfig *) this->ptr.data, NULL, (::PointerRNA *) &keymap.ptr);
	}

	inline KeyMap KeyMaps::find(const char * name, int space_type, int region_type) {
		PointerRNA result;
		::wmKeyMap *retdata = KeyMaps_find((::wmKeyConfig *) this->ptr.data, name, space_type, region_type);
		RNA_pointer_create((::ID *) ptr.id.data, &RNA_KeyMap, retdata, &result);
		return KeyMap(result);
	}

	inline KeyMap KeyMaps::find_modal(const char * name) {
		PointerRNA result;
		::wmKeyMap *retdata = KeyMaps_find_modal((::wmKeyConfig *) this->ptr.data, name);
		RNA_pointer_create((::ID *) ptr.id.data, &RNA_KeyMap, retdata, &result);
		return KeyMap(result);
	}


	POINTER_PROPERTY(Struct, KeyMap, rna_type)
	STRING_PROPERTY(KeyMap, name)
	STRING_PROPERTY(KeyMap, bl_owner_id)
	ENUM_PROPERTY(space_type_enum, KeyMap, space_type)
	ENUM_PROPERTY(region_type_enum, KeyMap, region_type)

	BOOLEAN_PROPERTY(KeyMap, is_user_modified)
	BOOLEAN_PROPERTY(KeyMap, is_modal)
	BOOLEAN_PROPERTY(KeyMap, show_expanded_items)
	BOOLEAN_PROPERTY(KeyMap, show_expanded_children)

	inline KeyMap KeyMap::active(Context C) {
		PointerRNA result;
		::wmKeyMap *retdata = KeyMap_active((::wmKeyMap *) this->ptr.data, (::bContext *) C.ptr.data);
		RNA_pointer_create((::ID *) ptr.id.data, &RNA_KeyMap, retdata, &result);
		return KeyMap(result);
	}

	inline void KeyMap::restore_to_default(Context C) {
		KeyMap_restore_to_default((::wmKeyMap *) this->ptr.data, (::bContext *) C.ptr.data);
	}

	inline void KeyMap::restore_item_to_default(Context C, KeyMapItem& item) {
		KeyMap_restore_item_to_default((::wmKeyMap *) this->ptr.data, (::bContext *) C.ptr.data, (::wmKeyMapItem *) item.ptr.data);
	}


	POINTER_PROPERTY(Struct, KeyMapItems, rna_type)

	inline KeyMapItem KeyMapItems::create(const char * idname, int type, int value, bool any, bool shift, bool ctrl, bool alt, bool oskey, int key_modifier, bool head) {
		PointerRNA result;
		::wmKeyMapItem *retdata = KeyMapItems_new((::wmKeyMap *) this->ptr.data, NULL, idname, type, value, any, shift, ctrl, alt, oskey, key_modifier, head);
		RNA_pointer_create((::ID *) ptr.id.data, &RNA_KeyMapItem, retdata, &result);
		return KeyMapItem(result);
	}

	inline KeyMapItem KeyMapItems::new_modal(const char * propvalue, int type, int value, bool any, bool shift, bool ctrl, bool alt, bool oskey, int key_modifier) {
		PointerRNA result;
		::wmKeyMapItem *retdata = KeyMapItems_new_modal((::wmKeyMap *) this->ptr.data, NULL, propvalue, type, value, any, shift, ctrl, alt, oskey, key_modifier);
		RNA_pointer_create((::ID *) ptr.id.data, &RNA_KeyMapItem, retdata, &result);
		return KeyMapItem(result);
	}

	inline KeyMapItem KeyMapItems::new_from_item(KeyMapItem& item, bool head) {
		PointerRNA result;
		::wmKeyMapItem *retdata = KeyMapItems_new_from_item((::wmKeyMap *) this->ptr.data, NULL, (::wmKeyMapItem *) item.ptr.data, head);
		RNA_pointer_create((::ID *) ptr.id.data, &RNA_KeyMapItem, retdata, &result);
		return KeyMapItem(result);
	}

	inline void KeyMapItems::remove(KeyMapItem& item) {
		KeyMapItems_remove((::wmKeyMap *) this->ptr.data, NULL, (::PointerRNA *) &item.ptr);
	}

	inline KeyMapItem KeyMapItems::from_id(int id) {
		PointerRNA result;
		::wmKeyMapItem *retdata = KeyMapItems_from_id((::wmKeyMap *) this->ptr.data, id);
		RNA_pointer_create((::ID *) ptr.id.data, &RNA_KeyMapItem, retdata, &result);
		return KeyMapItem(result);
	}

	inline KeyMapItem KeyMapItems::find_from_operator(const char * idname, OperatorProperties& properties, int include, int exclude) {
		PointerRNA result;
		result = KeyMapItems_find_from_operator((::ID *) ptr.id.data, (::wmKeyMap *) this->ptr.data, idname, (::PointerRNA *) properties.ptr.data, include, exclude);
		return KeyMapItem(result);
	}


	POINTER_PROPERTY(Struct, KeyMapItem, rna_type)
	STRING_PROPERTY(KeyMapItem, idname)
	STRING_PROPERTY(KeyMapItem, name)
	POINTER_PROPERTY(OperatorProperties, KeyMapItem, properties)
	ENUM_PROPERTY(map_type_enum, KeyMapItem, map_type)
	ENUM_PROPERTY(type_enum, KeyMapItem, type)
	ENUM_PROPERTY(value_enum, KeyMapItem, value)
	INT_PROPERTY(KeyMapItem, id)
	BOOLEAN_PROPERTY(KeyMapItem, any)
	BOOLEAN_PROPERTY(KeyMapItem, shift)
	BOOLEAN_PROPERTY(KeyMapItem, ctrl)
	BOOLEAN_PROPERTY(KeyMapItem, alt)
	BOOLEAN_PROPERTY(KeyMapItem, oskey)
	ENUM_PROPERTY(key_modifier_enum, KeyMapItem, key_modifier)
	BOOLEAN_PROPERTY(KeyMapItem, show_expanded)
	ENUM_PROPERTY(propvalue_enum, KeyMapItem, propvalue)
	BOOLEAN_PROPERTY(KeyMapItem, active)
	BOOLEAN_PROPERTY(KeyMapItem, is_user_modified)
	BOOLEAN_PROPERTY(KeyMapItem, is_user_defined)

	inline bool KeyMapItem::compare(KeyMapItem& item) {
		return KeyMapItem_compare((::wmKeyMapItem *) this->ptr.data, (::wmKeyMapItem *) item.ptr.data);
	}

	inline void KeyMapItem::to_string(bool compact, char * result) {
		KeyMapItem_to_string((::wmKeyMapItem *) this->ptr.data, compact, result);
	}


	POINTER_PROPERTY(Struct, GizmoGroup, rna_type)
	STRING_PROPERTY(GizmoGroup, bl_idname)
	STRING_PROPERTY(GizmoGroup, bl_label)
	ENUM_PROPERTY(bl_space_type_enum, GizmoGroup, bl_space_type)
	ENUM_PROPERTY(bl_region_type_enum, GizmoGroup, bl_region_type)
	STRING_PROPERTY(GizmoGroup, bl_owner_id)
	ENUM_PROPERTY(bl_options_enum, GizmoGroup, bl_options)
	STRING_PROPERTY(GizmoGroup, name)
	BOOLEAN_PROPERTY(GizmoGroup, has_reports)



	POINTER_PROPERTY(Struct, Gizmo, rna_type)
	POINTER_PROPERTY(GizmoProperties, Gizmo, properties)
	STRING_PROPERTY(Gizmo, bl_idname)
	POINTER_PROPERTY(GizmoGroup, Gizmo, group)
	FLOAT_ARRAY_PROPERTY(Gizmo, 3, color)
	FLOAT_PROPERTY(Gizmo, alpha)
	FLOAT_ARRAY_PROPERTY(Gizmo, 3, color_highlight)
	FLOAT_PROPERTY(Gizmo, alpha_highlight)
	FLOAT_ARRAY_PROPERTY(Gizmo, 16, matrix_space)
	FLOAT_ARRAY_PROPERTY(Gizmo, 16, matrix_basis)
	FLOAT_ARRAY_PROPERTY(Gizmo, 16, matrix_offset)
	FLOAT_ARRAY_PROPERTY(Gizmo, 16, matrix_world)
	FLOAT_PROPERTY(Gizmo, scale_basis)
	FLOAT_PROPERTY(Gizmo, line_width)
	BOOLEAN_PROPERTY(Gizmo, hide)
	BOOLEAN_PROPERTY(Gizmo, hide_select)
	BOOLEAN_PROPERTY(Gizmo, use_grab_cursor)
	BOOLEAN_PROPERTY(Gizmo, use_draw_hover)
	BOOLEAN_PROPERTY(Gizmo, use_draw_modal)
	BOOLEAN_PROPERTY(Gizmo, use_draw_value)
	BOOLEAN_PROPERTY(Gizmo, use_draw_offset_scale)
	BOOLEAN_PROPERTY(Gizmo, use_draw_scale)
	BOOLEAN_PROPERTY(Gizmo, use_select_background)
	BOOLEAN_PROPERTY(Gizmo, use_operator_tool_properties)
	BOOLEAN_PROPERTY(Gizmo, is_highlight)
	BOOLEAN_PROPERTY(Gizmo, is_modal)
	BOOLEAN_PROPERTY(Gizmo, select)

	inline void Gizmo::draw_preset_box(float matrix[16], int select_id) {
		Gizmo_draw_preset_box((::wmGizmo *) this->ptr.data, matrix, select_id);
	}

	inline void Gizmo::draw_preset_arrow(float matrix[16], int axis, int select_id) {
		Gizmo_draw_preset_arrow((::wmGizmo *) this->ptr.data, matrix, axis, select_id);
	}

	inline void Gizmo::draw_preset_circle(float matrix[16], int axis, int select_id) {
		Gizmo_draw_preset_circle((::wmGizmo *) this->ptr.data, matrix, axis, select_id);
	}

	inline void Gizmo::draw_preset_facemap(Context C, Object& object, int face_map, int select_id) {
		Gizmo_draw_preset_facemap((::wmGizmo *) this->ptr.data, (::bContext *) C.ptr.data, (::Object *) object.ptr.data, face_map, select_id);
	}

	inline void Gizmo::target_set_prop(const char * target, AnyType& data, const char * property, int index) {
		Gizmo_target_set_prop((::wmGizmo *) this->ptr.data, NULL, target, (::PointerRNA *) data.ptr.data, property, index);
	}

	inline OperatorProperties Gizmo::target_set_operator(const char * operator_value, int index) {
		PointerRNA result;
		result = Gizmo_target_set_operator((::wmGizmo *) this->ptr.data, NULL, operator_value, index);
		return OperatorProperties(result);
	}

	inline bool Gizmo::target_is_valid(const char * property) {
		return Gizmo_target_is_valid((::wmGizmo *) this->ptr.data, NULL, property);
	}


	POINTER_PROPERTY(Struct, GizmoProperties, rna_type)


	POINTER_PROPERTY(Struct, Gizmos, rna_type)

	inline Gizmo Gizmos::create(const char * type) {
		PointerRNA result;
		::wmGizmo *retdata = Gizmos_new((::wmGizmoGroup *) this->ptr.data, NULL, type);
		RNA_pointer_create((::ID *) ptr.id.data, &RNA_Gizmo, retdata, &result);
		return Gizmo(result);
	}

	inline void Gizmos::remove(Context C, Gizmo& gizmo) {
		Gizmos_remove((::wmGizmoGroup *) this->ptr.data, (::bContext *) C.ptr.data, (::wmGizmo *) gizmo.ptr.data);
	}

	inline void Gizmos::clear(Context C) {
		Gizmos_clear((::wmGizmoGroup *) this->ptr.data, (::bContext *) C.ptr.data);
	}


	POINTER_PROPERTY(Struct, GizmoGroupProperties, rna_type)


	POINTER_PROPERTY(Struct, wmOwnerID, rna_type)
	STRING_PROPERTY(wmOwnerID, name)


	POINTER_PROPERTY(Struct, WorkSpaceTool, rna_type)
	STRING_PROPERTY(WorkSpaceTool, idname)
	INT_PROPERTY(WorkSpaceTool, index)
	ENUM_PROPERTY(space_type_enum, WorkSpaceTool, space_type)
	ENUM_PROPERTY(mode_enum, WorkSpaceTool, mode)
	BOOLEAN_PROPERTY(WorkSpaceTool, has_datablock)
	STRING_PROPERTY(WorkSpaceTool, widget)

	inline void WorkSpaceTool::setup(Context C, const char * idname, int cursor, const char * keymap, const char * gizmo_group, const char * data_block, const char * operator_value, int index) {
		WorkSpaceTool_setup((::ID *) ptr.id.data, (::bToolRef *) this->ptr.data, (::bContext *) C.ptr.data, idname, cursor, keymap, gizmo_group, data_block, operator_value, index);
	}

	inline OperatorProperties WorkSpaceTool::operator_properties(const char * operator_value) {
		PointerRNA result;
		result = WorkSpaceTool_operator_properties((::bToolRef *) this->ptr.data, NULL, operator_value);
		return OperatorProperties(result);
	}

	inline GizmoGroupProperties WorkSpaceTool::gizmo_group_properties(const char * group) {
		PointerRNA result;
		result = WorkSpaceTool_gizmo_group_properties((::bToolRef *) this->ptr.data, NULL, group);
		return GizmoGroupProperties(result);
	}

	inline void WorkSpaceTool::refresh_from_context(void *main) {
		WorkSpaceTool_refresh_from_context((::ID *) ptr.id.data, (::bToolRef *) this->ptr.data, (::Main *) main);
	}





	ENUM_PROPERTY(tools_space_type_enum, WorkSpace, tools_space_type)
	ENUM_PROPERTY(tools_mode_enum, WorkSpace, tools_mode)
	ENUM_PROPERTY(object_mode_enum, WorkSpace, object_mode)
	BOOLEAN_PROPERTY(WorkSpace, use_filter_by_owner)

	inline void WorkSpace::status_text_set(Context C, const char * text) {
		WorkSpace_status_text_set((::bContext *) C.ptr.data, text);
	}


	POINTER_PROPERTY(Struct, wmOwnerIDs, rna_type)

	inline wmOwnerID wmOwnerIDs::create(const char * name) {
		PointerRNA result;
		::wmOwnerID *retdata = wmOwnerIDs_new((::WorkSpace *) this->ptr.data, name);
		RNA_pointer_create((::ID *) ptr.id.data, &RNA_wmOwnerID, retdata, &result);
		return wmOwnerID(result);
	}

	inline void wmOwnerIDs::remove(wmOwnerID& owner_id) {
		wmOwnerIDs_remove((::WorkSpace *) this->ptr.data, NULL, (::PointerRNA *) &owner_id.ptr);
	}

	inline void wmOwnerIDs::clear() {
		wmOwnerIDs_clear((::WorkSpace *) this->ptr.data);
	}


	POINTER_PROPERTY(Struct, wmTools, rna_type)

	inline WorkSpaceTool wmTools::from_space_view3d_mode(int mode, bool create) {
		PointerRNA result;
		::bToolRef *retdata = wmTools_from_space_view3d_mode((::WorkSpace *) this->ptr.data, mode, create);
		RNA_pointer_create((::ID *) ptr.id.data, &RNA_WorkSpaceTool, retdata, &result);
		return WorkSpaceTool(result);
	}

	inline WorkSpaceTool wmTools::from_space_image_mode(int mode, bool create) {
		PointerRNA result;
		::bToolRef *retdata = wmTools_from_space_image_mode((::WorkSpace *) this->ptr.data, mode, create);
		RNA_pointer_create((::ID *) ptr.id.data, &RNA_WorkSpaceTool, retdata, &result);
		return WorkSpaceTool(result);
	}

	inline WorkSpaceTool wmTools::from_space_node(bool create) {
		PointerRNA result;
		::bToolRef *retdata = wmTools_from_space_node((::WorkSpace *) this->ptr.data, create);
		RNA_pointer_create((::ID *) ptr.id.data, &RNA_WorkSpaceTool, retdata, &result);
		return WorkSpaceTool(result);
	}


	POINTER_PROPERTY(AnimData, World, animation_data)
	FLOAT_ARRAY_PROPERTY(World, 3, color)
	POINTER_PROPERTY(WorldLighting, World, light_settings)
	POINTER_PROPERTY(WorldMistSettings, World, mist_settings)
	POINTER_PROPERTY(NodeTree, World, node_tree)
	BOOLEAN_PROPERTY(World, use_nodes)


	POINTER_PROPERTY(Struct, WorldLighting, rna_type)
	BOOLEAN_PROPERTY(WorldLighting, use_ambient_occlusion)
	FLOAT_PROPERTY(WorldLighting, ao_factor)
	FLOAT_PROPERTY(WorldLighting, distance)


	POINTER_PROPERTY(Struct, WorldMistSettings, rna_type)
	BOOLEAN_PROPERTY(WorldMistSettings, use_mist)
	FLOAT_PROPERTY(WorldMistSettings, intensity)
	FLOAT_PROPERTY(WorldMistSettings, start)
	FLOAT_PROPERTY(WorldMistSettings, depth)
	FLOAT_PROPERTY(WorldMistSettings, height)
	ENUM_PROPERTY(falloff_enum, WorldMistSettings, falloff)


	STRING_PROPERTY(MovieClip, filepath)
	POINTER_PROPERTY(MovieTracking, MovieClip, tracking)
	POINTER_PROPERTY(MovieClipProxy, MovieClip, proxy)
	BOOLEAN_PROPERTY(MovieClip, use_proxy)
	INT_ARRAY_PROPERTY(MovieClip, 2, size)
	FLOAT_ARRAY_PROPERTY(MovieClip, 2, display_aspect)
	ENUM_PROPERTY(source_enum, MovieClip, source)
	BOOLEAN_PROPERTY(MovieClip, use_proxy_custom_directory)
	POINTER_PROPERTY(GreasePencil, MovieClip, grease_pencil)
	INT_PROPERTY(MovieClip, frame_start)
	INT_PROPERTY(MovieClip, frame_offset)
	INT_PROPERTY(MovieClip, frame_duration)
	FLOAT_PROPERTY(MovieClip, fps)
	POINTER_PROPERTY(ColorManagedInputColorspaceSettings, MovieClip, colorspace_settings)
	POINTER_PROPERTY(AnimData, MovieClip, animation_data)

	inline IDPropertyWrapPtr MovieClip::metadata() {
		PointerRNA result;
		result = MovieClip_metadata((::MovieClip *) this->ptr.data);
		return IDPropertyWrapPtr(result);
	}


	POINTER_PROPERTY(Struct, MovieClipProxy, rna_type)
	BOOLEAN_PROPERTY(MovieClipProxy, build_25)
	BOOLEAN_PROPERTY(MovieClipProxy, build_50)
	BOOLEAN_PROPERTY(MovieClipProxy, build_75)
	BOOLEAN_PROPERTY(MovieClipProxy, build_100)
	BOOLEAN_PROPERTY(MovieClipProxy, build_undistorted_25)
	BOOLEAN_PROPERTY(MovieClipProxy, build_undistorted_50)
	BOOLEAN_PROPERTY(MovieClipProxy, build_undistorted_75)
	BOOLEAN_PROPERTY(MovieClipProxy, build_undistorted_100)
	BOOLEAN_PROPERTY(MovieClipProxy, build_record_run)
	BOOLEAN_PROPERTY(MovieClipProxy, build_free_run)
	BOOLEAN_PROPERTY(MovieClipProxy, build_free_run_rec_date)
	INT_PROPERTY(MovieClipProxy, quality)
	ENUM_PROPERTY(timecode_enum, MovieClipProxy, timecode)
	STRING_PROPERTY(MovieClipProxy, directory)


	POINTER_PROPERTY(Struct, MovieClipUser, rna_type)
	INT_PROPERTY(MovieClipUser, frame_current)
	ENUM_PROPERTY(proxy_render_size_enum, MovieClipUser, proxy_render_size)
	BOOLEAN_PROPERTY(MovieClipUser, use_render_undistorted)


	POINTER_PROPERTY(Struct, MovieClipScopes, rna_type)


	POINTER_PROPERTY(Struct, MovieTrackingSettings, rna_type)
	ENUM_PROPERTY(speed_enum, MovieTrackingSettings, speed)
	BOOLEAN_PROPERTY(MovieTrackingSettings, use_keyframe_selection)
	ENUM_PROPERTY(refine_intrinsics_enum, MovieTrackingSettings, refine_intrinsics)
	FLOAT_PROPERTY(MovieTrackingSettings, distance)
	INT_PROPERTY(MovieTrackingSettings, clean_frames)
	FLOAT_PROPERTY(MovieTrackingSettings, clean_error)
	ENUM_PROPERTY(clean_action_enum, MovieTrackingSettings, clean_action)
	BOOLEAN_PROPERTY(MovieTrackingSettings, show_default_expanded)
	BOOLEAN_PROPERTY(MovieTrackingSettings, show_extra_expanded)
	BOOLEAN_PROPERTY(MovieTrackingSettings, use_tripod_solver)
	INT_PROPERTY(MovieTrackingSettings, default_frames_limit)
	ENUM_PROPERTY(default_pattern_match_enum, MovieTrackingSettings, default_pattern_match)
	INT_PROPERTY(MovieTrackingSettings, default_margin)
	ENUM_PROPERTY(default_motion_model_enum, MovieTrackingSettings, default_motion_model)
	BOOLEAN_PROPERTY(MovieTrackingSettings, use_default_brute)
	BOOLEAN_PROPERTY(MovieTrackingSettings, use_default_mask)
	BOOLEAN_PROPERTY(MovieTrackingSettings, use_default_normalization)
	FLOAT_PROPERTY(MovieTrackingSettings, default_correlation_min)
	INT_PROPERTY(MovieTrackingSettings, default_pattern_size)
	INT_PROPERTY(MovieTrackingSettings, default_search_size)
	BOOLEAN_PROPERTY(MovieTrackingSettings, use_default_red_channel)
	BOOLEAN_PROPERTY(MovieTrackingSettings, use_default_green_channel)
	BOOLEAN_PROPERTY(MovieTrackingSettings, use_default_blue_channel)
	FLOAT_PROPERTY(MovieTrackingSettings, default_weight)
	FLOAT_PROPERTY(MovieTrackingSettings, object_distance)


	POINTER_PROPERTY(Struct, MovieTrackingCamera, rna_type)
	ENUM_PROPERTY(distortion_model_enum, MovieTrackingCamera, distortion_model)
	FLOAT_PROPERTY(MovieTrackingCamera, sensor_width)
	FLOAT_PROPERTY(MovieTrackingCamera, focal_length)
	FLOAT_PROPERTY(MovieTrackingCamera, focal_length_pixels)
	ENUM_PROPERTY(units_enum, MovieTrackingCamera, units)
	FLOAT_ARRAY_PROPERTY(MovieTrackingCamera, 2, principal)
	FLOAT_PROPERTY(MovieTrackingCamera, k1)
	FLOAT_PROPERTY(MovieTrackingCamera, k2)
	FLOAT_PROPERTY(MovieTrackingCamera, k3)
	FLOAT_PROPERTY(MovieTrackingCamera, division_k1)
	FLOAT_PROPERTY(MovieTrackingCamera, division_k2)
	FLOAT_PROPERTY(MovieTrackingCamera, pixel_aspect)


	POINTER_PROPERTY(Struct, MovieTrackingMarker, rna_type)
	FLOAT_ARRAY_PROPERTY(MovieTrackingMarker, 2, co)
	INT_PROPERTY(MovieTrackingMarker, frame)
	BOOLEAN_PROPERTY(MovieTrackingMarker, mute)
	FLOAT_ARRAY_PROPERTY(MovieTrackingMarker, 8, pattern_corners)
	FLOAT_ARRAY_PROPERTY(MovieTrackingMarker, 4, pattern_bound_box)
	FLOAT_ARRAY_PROPERTY(MovieTrackingMarker, 2, search_min)
	FLOAT_ARRAY_PROPERTY(MovieTrackingMarker, 2, search_max)
	BOOLEAN_PROPERTY(MovieTrackingMarker, is_keyed)


	POINTER_PROPERTY(Struct, MovieTrackingTrack, rna_type)
	STRING_PROPERTY(MovieTrackingTrack, name)
	INT_PROPERTY(MovieTrackingTrack, frames_limit)
	ENUM_PROPERTY(pattern_match_enum, MovieTrackingTrack, pattern_match)
	INT_PROPERTY(MovieTrackingTrack, margin)
	ENUM_PROPERTY(motion_model_enum, MovieTrackingTrack, motion_model)
	FLOAT_PROPERTY(MovieTrackingTrack, correlation_min)
	BOOLEAN_PROPERTY(MovieTrackingTrack, use_brute)
	BOOLEAN_PROPERTY(MovieTrackingTrack, use_mask)
	BOOLEAN_PROPERTY(MovieTrackingTrack, use_normalization)

	BOOLEAN_PROPERTY(MovieTrackingTrack, use_red_channel)
	BOOLEAN_PROPERTY(MovieTrackingTrack, use_green_channel)
	BOOLEAN_PROPERTY(MovieTrackingTrack, use_blue_channel)
	BOOLEAN_PROPERTY(MovieTrackingTrack, use_grayscale_preview)
	BOOLEAN_PROPERTY(MovieTrackingTrack, use_alpha_preview)
	BOOLEAN_PROPERTY(MovieTrackingTrack, has_bundle)
	FLOAT_ARRAY_PROPERTY(MovieTrackingTrack, 3, bundle)
	BOOLEAN_PROPERTY(MovieTrackingTrack, hide)
	BOOLEAN_PROPERTY(MovieTrackingTrack, select)
	BOOLEAN_PROPERTY(MovieTrackingTrack, select_anchor)
	BOOLEAN_PROPERTY(MovieTrackingTrack, select_pattern)
	BOOLEAN_PROPERTY(MovieTrackingTrack, select_search)
	BOOLEAN_PROPERTY(MovieTrackingTrack, lock)
	BOOLEAN_PROPERTY(MovieTrackingTrack, use_custom_color)
	FLOAT_ARRAY_PROPERTY(MovieTrackingTrack, 3, color)
	FLOAT_PROPERTY(MovieTrackingTrack, average_error)
	POINTER_PROPERTY(GreasePencil, MovieTrackingTrack, grease_pencil)
	FLOAT_PROPERTY(MovieTrackingTrack, weight)
	FLOAT_PROPERTY(MovieTrackingTrack, weight_stab)
	FLOAT_ARRAY_PROPERTY(MovieTrackingTrack, 2, offset)


	POINTER_PROPERTY(Struct, MovieTrackingMarkers, rna_type)

	inline MovieTrackingMarker MovieTrackingMarkers::find_frame(int frame, bool exact) {
		PointerRNA result;
		::MovieTrackingMarker *retdata = MovieTrackingMarkers_find_frame((::MovieTrackingTrack *) this->ptr.data, frame, exact);
		RNA_pointer_create((::ID *) ptr.id.data, &RNA_MovieTrackingMarker, retdata, &result);
		return MovieTrackingMarker(result);
	}

	inline MovieTrackingMarker MovieTrackingMarkers::insert_frame(int frame, float co[2]) {
		PointerRNA result;
		::MovieTrackingMarker *retdata = MovieTrackingMarkers_insert_frame((::MovieTrackingTrack *) this->ptr.data, frame, co);
		RNA_pointer_create((::ID *) ptr.id.data, &RNA_MovieTrackingMarker, retdata, &result);
		return MovieTrackingMarker(result);
	}

	inline void MovieTrackingMarkers::delete_frame(int frame) {
		MovieTrackingMarkers_delete_frame((::MovieTrackingTrack *) this->ptr.data, frame);
	}


	POINTER_PROPERTY(Struct, MovieTrackingPlaneMarker, rna_type)
	INT_PROPERTY(MovieTrackingPlaneMarker, frame)
	FLOAT_ARRAY_PROPERTY(MovieTrackingPlaneMarker, 8, corners)
	BOOLEAN_PROPERTY(MovieTrackingPlaneMarker, mute)


	POINTER_PROPERTY(Struct, MovieTrackingPlaneTrack, rna_type)
	STRING_PROPERTY(MovieTrackingPlaneTrack, name)

	BOOLEAN_PROPERTY(MovieTrackingPlaneTrack, select)
	BOOLEAN_PROPERTY(MovieTrackingPlaneTrack, use_auto_keying)
	POINTER_PROPERTY(Image, MovieTrackingPlaneTrack, image)
	FLOAT_PROPERTY(MovieTrackingPlaneTrack, image_opacity)


	POINTER_PROPERTY(Struct, MovieTrackingPlaneMarkers, rna_type)

	inline MovieTrackingPlaneMarker MovieTrackingPlaneMarkers::find_frame(int frame, bool exact) {
		PointerRNA result;
		::MovieTrackingPlaneMarker *retdata = MovieTrackingPlaneMarkers_find_frame((::MovieTrackingPlaneTrack *) this->ptr.data, frame, exact);
		RNA_pointer_create((::ID *) ptr.id.data, &RNA_MovieTrackingPlaneMarker, retdata, &result);
		return MovieTrackingPlaneMarker(result);
	}

	inline MovieTrackingPlaneMarker MovieTrackingPlaneMarkers::insert_frame(int frame) {
		PointerRNA result;
		::MovieTrackingPlaneMarker *retdata = MovieTrackingPlaneMarkers_insert_frame((::MovieTrackingPlaneTrack *) this->ptr.data, frame);
		RNA_pointer_create((::ID *) ptr.id.data, &RNA_MovieTrackingPlaneMarker, retdata, &result);
		return MovieTrackingPlaneMarker(result);
	}

	inline void MovieTrackingPlaneMarkers::delete_frame(int frame) {
		MovieTrackingPlaneMarkers_delete_frame((::MovieTrackingPlaneTrack *) this->ptr.data, frame);
	}


	POINTER_PROPERTY(Struct, MovieTrackingTracks, rna_type)
	POINTER_PROPERTY(MovieTrackingTrack, MovieTrackingTracks, active)

	inline MovieTrackingTrack MovieTrackingTracks::create(const char * name, int frame) {
		PointerRNA result;
		::MovieTrackingTrack *retdata = MovieTrackingTracks_new((::ID *) ptr.id.data, (::MovieTracking *) this->ptr.data, name, frame);
		RNA_pointer_create((::ID *) ptr.id.data, &RNA_MovieTrackingTrack, retdata, &result);
		return MovieTrackingTrack(result);
	}


	POINTER_PROPERTY(Struct, MovieTrackingPlaneTracks, rna_type)
	POINTER_PROPERTY(MovieTrackingPlaneTrack, MovieTrackingPlaneTracks, active)


	POINTER_PROPERTY(Struct, MovieTrackingObjectTracks, rna_type)
	POINTER_PROPERTY(MovieTrackingTrack, MovieTrackingObjectTracks, active)

	inline MovieTrackingTrack MovieTrackingObjectTracks::create(const char * name, int frame) {
		PointerRNA result;
		::MovieTrackingTrack *retdata = MovieTrackingObjectTracks_new((::ID *) ptr.id.data, (::MovieTrackingObject *) this->ptr.data, name, frame);
		RNA_pointer_create((::ID *) ptr.id.data, &RNA_MovieTrackingTrack, retdata, &result);
		return MovieTrackingTrack(result);
	}


	POINTER_PROPERTY(Struct, MovieTrackingObjectPlaneTracks, rna_type)
	POINTER_PROPERTY(MovieTrackingTrack, MovieTrackingObjectPlaneTracks, active)


	POINTER_PROPERTY(Struct, MovieTrackingStabilization, rna_type)
	BOOLEAN_PROPERTY(MovieTrackingStabilization, use_2d_stabilization)
	BOOLEAN_PROPERTY(MovieTrackingStabilization, use_stabilize_rotation)
	BOOLEAN_PROPERTY(MovieTrackingStabilization, use_stabilize_scale)

	INT_PROPERTY(MovieTrackingStabilization, active_track_index)

	INT_PROPERTY(MovieTrackingStabilization, active_rotation_track_index)
	INT_PROPERTY(MovieTrackingStabilization, anchor_frame)
	FLOAT_ARRAY_PROPERTY(MovieTrackingStabilization, 2, target_position)
	FLOAT_PROPERTY(MovieTrackingStabilization, target_rotation)
	FLOAT_PROPERTY(MovieTrackingStabilization, target_scale)
	BOOLEAN_PROPERTY(MovieTrackingStabilization, use_autoscale)
	FLOAT_PROPERTY(MovieTrackingStabilization, scale_max)
	FLOAT_PROPERTY(MovieTrackingStabilization, influence_location)
	FLOAT_PROPERTY(MovieTrackingStabilization, influence_scale)
	FLOAT_PROPERTY(MovieTrackingStabilization, influence_rotation)
	ENUM_PROPERTY(filter_type_enum, MovieTrackingStabilization, filter_type)
	BOOLEAN_PROPERTY(MovieTrackingStabilization, show_tracks_expanded)


	POINTER_PROPERTY(Struct, MovieTrackingReconstructedCameras, rna_type)

	inline MovieReconstructedCamera MovieTrackingReconstructedCameras::find_frame(int frame) {
		PointerRNA result;
		::MovieReconstructedCamera *retdata = MovieTrackingReconstructedCameras_find_frame((::ID *) ptr.id.data, (::MovieTrackingReconstruction *) this->ptr.data, frame);
		RNA_pointer_create((::ID *) ptr.id.data, &RNA_MovieReconstructedCamera, retdata, &result);
		return MovieReconstructedCamera(result);
	}

	inline void MovieTrackingReconstructedCameras::matrix_from_frame(int frame, float matrix[16]) {
		MovieTrackingReconstructedCameras_matrix_from_frame((::ID *) ptr.id.data, (::MovieTrackingReconstruction *) this->ptr.data, frame, matrix);
	}


	POINTER_PROPERTY(Struct, MovieReconstructedCamera, rna_type)
	INT_PROPERTY(MovieReconstructedCamera, frame)
	FLOAT_ARRAY_PROPERTY(MovieReconstructedCamera, 16, matrix)
	FLOAT_PROPERTY(MovieReconstructedCamera, average_error)


	POINTER_PROPERTY(Struct, MovieTrackingReconstruction, rna_type)
	BOOLEAN_PROPERTY(MovieTrackingReconstruction, is_valid)
	FLOAT_PROPERTY(MovieTrackingReconstruction, average_error)



	POINTER_PROPERTY(Struct, MovieTrackingObject, rna_type)
	STRING_PROPERTY(MovieTrackingObject, name)
	BOOLEAN_PROPERTY(MovieTrackingObject, is_camera)


	POINTER_PROPERTY(MovieTrackingReconstruction, MovieTrackingObject, reconstruction)
	FLOAT_PROPERTY(MovieTrackingObject, scale)
	INT_PROPERTY(MovieTrackingObject, keyframe_a)
	INT_PROPERTY(MovieTrackingObject, keyframe_b)


	POINTER_PROPERTY(Struct, MovieTrackingDopesheet, rna_type)
	ENUM_PROPERTY(sort_method_enum, MovieTrackingDopesheet, sort_method)
	BOOLEAN_PROPERTY(MovieTrackingDopesheet, use_invert_sort)
	BOOLEAN_PROPERTY(MovieTrackingDopesheet, show_only_selected)
	BOOLEAN_PROPERTY(MovieTrackingDopesheet, show_hidden)


	POINTER_PROPERTY(Struct, MovieTracking, rna_type)
	POINTER_PROPERTY(MovieTrackingSettings, MovieTracking, settings)
	POINTER_PROPERTY(MovieTrackingCamera, MovieTracking, camera)


	POINTER_PROPERTY(MovieTrackingStabilization, MovieTracking, stabilization)
	POINTER_PROPERTY(MovieTrackingReconstruction, MovieTracking, reconstruction)

	INT_PROPERTY(MovieTracking, active_object_index)
	POINTER_PROPERTY(MovieTrackingDopesheet, MovieTracking, dopesheet)


	POINTER_PROPERTY(Struct, MovieTrackingObjects, rna_type)
	POINTER_PROPERTY(MovieTrackingObject, MovieTrackingObjects, active)

	inline MovieTrackingObject MovieTrackingObjects::create(const char * name) {
		PointerRNA result;
		::MovieTrackingObject *retdata = MovieTrackingObjects_new((::MovieTracking *) this->ptr.data, name);
		RNA_pointer_create((::ID *) ptr.id.data, &RNA_MovieTrackingObject, retdata, &result);
		return MovieTrackingObject(result);
	}

	inline void MovieTrackingObjects::remove(MovieTrackingObject& object) {
		MovieTrackingObjects_remove((::MovieTracking *) this->ptr.data, NULL, (::PointerRNA *) &object.ptr);
	}


	POINTER_PROPERTY(Struct, MaskParent, rna_type)
	POINTER_PROPERTY(ID, MaskParent, id)
	ENUM_PROPERTY(id_type_enum, MaskParent, id_type)
	ENUM_PROPERTY(type_enum, MaskParent, type)
	STRING_PROPERTY(MaskParent, parent)
	STRING_PROPERTY(MaskParent, sub_parent)


	POINTER_PROPERTY(Struct, MaskSplinePointUW, rna_type)
	FLOAT_PROPERTY(MaskSplinePointUW, u)
	FLOAT_PROPERTY(MaskSplinePointUW, weight)
	BOOLEAN_PROPERTY(MaskSplinePointUW, select)


	POINTER_PROPERTY(Struct, MaskSplinePoint, rna_type)
	FLOAT_ARRAY_PROPERTY(MaskSplinePoint, 2, handle_left)
	FLOAT_ARRAY_PROPERTY(MaskSplinePoint, 2, co)
	FLOAT_ARRAY_PROPERTY(MaskSplinePoint, 2, handle_right)
	ENUM_PROPERTY(handle_type_enum, MaskSplinePoint, handle_type)
	ENUM_PROPERTY(handle_left_type_enum, MaskSplinePoint, handle_left_type)
	ENUM_PROPERTY(handle_right_type_enum, MaskSplinePoint, handle_right_type)
	FLOAT_PROPERTY(MaskSplinePoint, weight)
	BOOLEAN_PROPERTY(MaskSplinePoint, select)
	POINTER_PROPERTY(MaskParent, MaskSplinePoint, parent)



	POINTER_PROPERTY(Struct, MaskSpline, rna_type)
	ENUM_PROPERTY(offset_mode_enum, MaskSpline, offset_mode)
	ENUM_PROPERTY(weight_interpolation_enum, MaskSpline, weight_interpolation)
	BOOLEAN_PROPERTY(MaskSpline, use_cyclic)
	BOOLEAN_PROPERTY(MaskSpline, use_fill)
	BOOLEAN_PROPERTY(MaskSpline, use_self_intersection_check)



	POINTER_PROPERTY(Struct, MaskSplines, rna_type)
	POINTER_PROPERTY(MaskSpline, MaskSplines, active)
	POINTER_PROPERTY(MaskSplinePoint, MaskSplines, active_point)

	inline MaskSpline MaskSplines::create() {
		PointerRNA result;
		::MaskSpline *retdata = MaskSplines_new((::ID *) ptr.id.data, (::MaskLayer *) this->ptr.data);
		RNA_pointer_create((::ID *) ptr.id.data, &RNA_MaskSpline, retdata, &result);
		return MaskSpline(result);
	}

	inline void MaskSplines::remove(MaskSpline& spline) {
		MaskSplines_remove((::ID *) ptr.id.data, (::MaskLayer *) this->ptr.data, NULL, (::PointerRNA *) &spline.ptr);
	}


	POINTER_PROPERTY(Struct, MaskSplinePoints, rna_type)

	inline void MaskSplinePoints::add(int count) {
		MaskSplinePoints_add((::ID *) ptr.id.data, (::MaskSpline *) this->ptr.data, count);
	}

	inline void MaskSplinePoints::remove(MaskSplinePoint& point) {
		MaskSplinePoints_remove((::ID *) ptr.id.data, (::MaskSpline *) this->ptr.data, NULL, (::PointerRNA *) &point.ptr);
	}


	POINTER_PROPERTY(Struct, MaskLayer, rna_type)
	STRING_PROPERTY(MaskLayer, name)

	BOOLEAN_PROPERTY(MaskLayer, hide)
	BOOLEAN_PROPERTY(MaskLayer, hide_select)
	BOOLEAN_PROPERTY(MaskLayer, hide_render)
	BOOLEAN_PROPERTY(MaskLayer, select)
	FLOAT_PROPERTY(MaskLayer, alpha)
	ENUM_PROPERTY(blend_enum, MaskLayer, blend)
	BOOLEAN_PROPERTY(MaskLayer, invert)
	ENUM_PROPERTY(falloff_enum, MaskLayer, falloff)
	BOOLEAN_PROPERTY(MaskLayer, use_fill_holes)
	BOOLEAN_PROPERTY(MaskLayer, use_fill_overlap)



	INT_PROPERTY(Mask, active_layer_index)
	INT_PROPERTY(Mask, frame_start)
	INT_PROPERTY(Mask, frame_end)
	POINTER_PROPERTY(AnimData, Mask, animation_data)


	POINTER_PROPERTY(Struct, MaskLayers, rna_type)
	POINTER_PROPERTY(MaskLayer, MaskLayers, active)

	inline MaskLayer MaskLayers::create(const char * name) {
		PointerRNA result;
		::MaskLayer *retdata = MaskLayers_new((::Mask *) this->ptr.data, name);
		RNA_pointer_create((::ID *) ptr.id.data, &RNA_MaskLayer, retdata, &result);
		return MaskLayer(result);
	}

	inline void MaskLayers::remove(MaskLayer& layer) {
		MaskLayers_remove((::Mask *) this->ptr.data, NULL, (::PointerRNA *) &layer.ptr);
	}

	inline void MaskLayers::clear() {
		MaskLayers_clear((::Mask *) this->ptr.data);
	}


}

#endif /* __RNA_BLENDER_CPP_H__ */

